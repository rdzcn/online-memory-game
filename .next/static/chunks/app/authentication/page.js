/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/authentication/page"],{

/***/ "(app-client)/./node_modules/ably/build/ably-commonjs.js":
/*!**************************************************!*\
  !*** ./node_modules/ably/build/ably-commonjs.js ***!
  \**************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/* provided dependency */ var Buffer = __webpack_require__(/*! buffer */ \"(app-client)/./node_modules/next/dist/compiled/buffer/index.js\")[\"Buffer\"];\n/*!\n * @license Copyright 2015-2022 Ably Real-time Ltd (ably.com)\n * \n * Ably JavaScript Library v1.2.49\n * https://github.com/ably/ably-js\n * \n * Released under the Apache Licence v2.0\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(window, function() {\nreturn /******/ (function(modules) { // webpackBootstrap\n/******/ \t// The module cache\n/******/ \tvar installedModules = {};\n/******/\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_723__(moduleId) {\n/******/\n/******/ \t\t// Check if module is in cache\n/******/ \t\tif(installedModules[moduleId]) {\n/******/ \t\t\treturn installedModules[moduleId].exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = installedModules[moduleId] = {\n/******/ \t\t\ti: moduleId,\n/******/ \t\t\tl: false,\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/\n/******/ \t\t// Execute the module function\n/******/ \t\tmodules[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_723__);\n/******/\n/******/ \t\t// Flag the module as loaded\n/******/ \t\tmodule.l = true;\n/******/\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/\n/******/\n/******/ \t// expose the modules object (__webpack_modules__)\n/******/ \t__nested_webpack_require_723__.m = modules;\n/******/\n/******/ \t// expose the module cache\n/******/ \t__nested_webpack_require_723__.c = installedModules;\n/******/\n/******/ \t// define getter function for harmony exports\n/******/ \t__nested_webpack_require_723__.d = function(exports, name, getter) {\n/******/ \t\tif(!__nested_webpack_require_723__.o(exports, name)) {\n/******/ \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n/******/ \t\t}\n/******/ \t};\n/******/\n/******/ \t// define __esModule on exports\n/******/ \t__nested_webpack_require_723__.r = function(exports) {\n/******/ \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t}\n/******/ \t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t};\n/******/\n/******/ \t// create a fake namespace object\n/******/ \t// mode & 1: value is a module id, require it\n/******/ \t// mode & 2: merge all properties of value into the ns\n/******/ \t// mode & 4: return value when already ns object\n/******/ \t// mode & 8|1: behave like require\n/******/ \t__nested_webpack_require_723__.t = function(value, mode) {\n/******/ \t\tif(mode & 1) value = __nested_webpack_require_723__(value);\n/******/ \t\tif(mode & 8) return value;\n/******/ \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n/******/ \t\tvar ns = Object.create(null);\n/******/ \t\t__nested_webpack_require_723__.r(ns);\n/******/ \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n/******/ \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __nested_webpack_require_723__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n/******/ \t\treturn ns;\n/******/ \t};\n/******/\n/******/ \t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t__nested_webpack_require_723__.n = function(module) {\n/******/ \t\tvar getter = module && module.__esModule ?\n/******/ \t\t\tfunction getDefault() { return module['default']; } :\n/******/ \t\t\tfunction getModuleExports() { return module; };\n/******/ \t\t__nested_webpack_require_723__.d(getter, 'a', getter);\n/******/ \t\treturn getter;\n/******/ \t};\n/******/\n/******/ \t// Object.prototype.hasOwnProperty.call\n/******/ \t__nested_webpack_require_723__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n/******/\n/******/ \t// __webpack_public_path__\n/******/ \t__nested_webpack_require_723__.p = \"\";\n/******/\n/******/\n/******/ \t// Load entry module and return exports\n/******/ \treturn __nested_webpack_require_723__(__nested_webpack_require_723__.s = 42);\n/******/ })\n/************************************************************************/\n/******/ ([\n/* 0 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_4200__) {\n\n\"use strict\";\n__nested_webpack_require_4200__.r(__webpack_exports__);\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__extends\", function() { return __extends; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__assign\", function() { return __assign; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__rest\", function() { return __rest; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__decorate\", function() { return __decorate; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__param\", function() { return __param; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__metadata\", function() { return __metadata; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__awaiter\", function() { return __awaiter; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__generator\", function() { return __generator; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__createBinding\", function() { return __createBinding; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__exportStar\", function() { return __exportStar; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__values\", function() { return __values; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__read\", function() { return __read; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__spread\", function() { return __spread; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__spreadArrays\", function() { return __spreadArrays; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__spreadArray\", function() { return __spreadArray; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__await\", function() { return __await; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__asyncGenerator\", function() { return __asyncGenerator; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__asyncDelegator\", function() { return __asyncDelegator; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__asyncValues\", function() { return __asyncValues; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__makeTemplateObject\", function() { return __makeTemplateObject; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__importStar\", function() { return __importStar; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__importDefault\", function() { return __importDefault; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__classPrivateFieldGet\", function() { return __classPrivateFieldGet; });\n/* harmony export (binding) */ __nested_webpack_require_4200__.d(__webpack_exports__, \"__classPrivateFieldSet\", function() { return __classPrivateFieldSet; });\n/*! *****************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    }\r\n    return __assign.apply(this, arguments);\r\n}\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __decorate(decorators, target, key, desc) {\r\n    var c = arguments.length, r = c < 3 ? target : desc === null ? desc = Object.getOwnPropertyDescriptor(target, key) : desc, d;\r\n    if (typeof Reflect === \"object\" && typeof Reflect.decorate === \"function\") r = Reflect.decorate(decorators, target, key, desc);\r\n    else for (var i = decorators.length - 1; i >= 0; i--) if (d = decorators[i]) r = (c < 3 ? d(r) : c > 3 ? d(target, key, r) : d(target, key)) || r;\r\n    return c > 3 && r && Object.defineProperty(target, key, r), r;\r\n}\r\n\r\nfunction __param(paramIndex, decorator) {\r\n    return function (target, key) { decorator(target, key, paramIndex); }\r\n}\r\n\r\nfunction __metadata(metadataKey, metadataValue) {\r\n    if (typeof Reflect === \"object\" && typeof Reflect.metadata === \"function\") return Reflect.metadata(metadataKey, metadataValue);\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nvar __createBinding = Object.create ? (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\r\n}) : (function(o, m, k, k2) {\r\n    if (k2 === undefined) k2 = k;\r\n    o[k2] = m[k];\r\n});\r\n\r\nfunction __exportStar(m, o) {\r\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(o, p)) __createBinding(o, m, p);\r\n}\r\n\r\nfunction __values(o) {\r\n    var s = typeof Symbol === \"function\" && Symbol.iterator, m = s && o[s], i = 0;\r\n    if (m) return m.call(o);\r\n    if (o && typeof o.length === \"number\") return {\r\n        next: function () {\r\n            if (o && i >= o.length) o = void 0;\r\n            return { value: o && o[i++], done: !o };\r\n        }\r\n    };\r\n    throw new TypeError(s ? \"Object is not iterable.\" : \"Symbol.iterator is not defined.\");\r\n}\r\n\r\nfunction __read(o, n) {\r\n    var m = typeof Symbol === \"function\" && o[Symbol.iterator];\r\n    if (!m) return o;\r\n    var i = m.call(o), r, ar = [], e;\r\n    try {\r\n        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);\r\n    }\r\n    catch (error) { e = { error: error }; }\r\n    finally {\r\n        try {\r\n            if (r && !r.done && (m = i[\"return\"])) m.call(i);\r\n        }\r\n        finally { if (e) throw e.error; }\r\n    }\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spread() {\r\n    for (var ar = [], i = 0; i < arguments.length; i++)\r\n        ar = ar.concat(__read(arguments[i]));\r\n    return ar;\r\n}\r\n\r\n/** @deprecated */\r\nfunction __spreadArrays() {\r\n    for (var s = 0, i = 0, il = arguments.length; i < il; i++) s += arguments[i].length;\r\n    for (var r = Array(s), k = 0, i = 0; i < il; i++)\r\n        for (var a = arguments[i], j = 0, jl = a.length; j < jl; j++, k++)\r\n            r[k] = a[j];\r\n    return r;\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\r\n\r\nfunction __await(v) {\r\n    return this instanceof __await ? (this.v = v, this) : new __await(v);\r\n}\r\n\r\nfunction __asyncGenerator(thisArg, _arguments, generator) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var g = generator.apply(thisArg, _arguments || []), i, q = [];\r\n    return i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i;\r\n    function verb(n) { if (g[n]) i[n] = function (v) { return new Promise(function (a, b) { q.push([n, v, a, b]) > 1 || resume(n, v); }); }; }\r\n    function resume(n, v) { try { step(g[n](v)); } catch (e) { settle(q[0][3], e); } }\r\n    function step(r) { r.value instanceof __await ? Promise.resolve(r.value.v).then(fulfill, reject) : settle(q[0][2], r); }\r\n    function fulfill(value) { resume(\"next\", value); }\r\n    function reject(value) { resume(\"throw\", value); }\r\n    function settle(f, v) { if (f(v), q.shift(), q.length) resume(q[0][0], q[0][1]); }\r\n}\r\n\r\nfunction __asyncDelegator(o) {\r\n    var i, p;\r\n    return i = {}, verb(\"next\"), verb(\"throw\", function (e) { throw e; }), verb(\"return\"), i[Symbol.iterator] = function () { return this; }, i;\r\n    function verb(n, f) { i[n] = o[n] ? function (v) { return (p = !p) ? { value: __await(o[n](v)), done: n === \"return\" } : f ? f(v) : v; } : f; }\r\n}\r\n\r\nfunction __asyncValues(o) {\r\n    if (!Symbol.asyncIterator) throw new TypeError(\"Symbol.asyncIterator is not defined.\");\r\n    var m = o[Symbol.asyncIterator], i;\r\n    return m ? m.call(o) : (o = typeof __values === \"function\" ? __values(o) : o[Symbol.iterator](), i = {}, verb(\"next\"), verb(\"throw\"), verb(\"return\"), i[Symbol.asyncIterator] = function () { return this; }, i);\r\n    function verb(n) { i[n] = o[n] && function (v) { return new Promise(function (resolve, reject) { v = o[n](v), settle(resolve, reject, v.done, v.value); }); }; }\r\n    function settle(resolve, reject, d, v) { Promise.resolve(v).then(function(v) { resolve({ value: v, done: d }); }, reject); }\r\n}\r\n\r\nfunction __makeTemplateObject(cooked, raw) {\r\n    if (Object.defineProperty) { Object.defineProperty(cooked, \"raw\", { value: raw }); } else { cooked.raw = raw; }\r\n    return cooked;\r\n};\r\n\r\nvar __setModuleDefault = Object.create ? (function(o, v) {\r\n    Object.defineProperty(o, \"default\", { enumerable: true, value: v });\r\n}) : function(o, v) {\r\n    o[\"default\"] = v;\r\n};\r\n\r\nfunction __importStar(mod) {\r\n    if (mod && mod.__esModule) return mod;\r\n    var result = {};\r\n    if (mod != null) for (var k in mod) if (k !== \"default\" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);\r\n    __setModuleDefault(result, mod);\r\n    return result;\r\n}\r\n\r\nfunction __importDefault(mod) {\r\n    return (mod && mod.__esModule) ? mod : { default: mod };\r\n}\r\n\r\nfunction __classPrivateFieldGet(receiver, state, kind, f) {\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a getter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot read private member from an object whose class did not declare it\");\r\n    return kind === \"m\" ? f : kind === \"a\" ? f.call(receiver) : f ? f.value : state.get(receiver);\r\n}\r\n\r\nfunction __classPrivateFieldSet(receiver, state, value, kind, f) {\r\n    if (kind === \"m\") throw new TypeError(\"Private method is not writable\");\r\n    if (kind === \"a\" && !f) throw new TypeError(\"Private accessor was defined without a setter\");\r\n    if (typeof state === \"function\" ? receiver !== state || !f : !state.has(receiver)) throw new TypeError(\"Cannot write private member to an object whose class did not declare it\");\r\n    return (kind === \"a\" ? f.call(receiver, value) : f ? f.value = value : state.set(receiver, value)), value;\r\n}\r\n\n\n/***/ }),\n/* 1 */\n/***/ (function(module, exports, __nested_webpack_require_19043__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.allToUpperCase = exports.allToLowerCase = exports.encodeBody = exports.decodeBody = exports.Format = exports.promisify = exports.trim = exports.arrChooseN = exports.randomHexString = exports.randomString = exports.cheapRandStr = exports.dataSizeBytes = exports.inspectBody = exports.inspectError = exports.isErrorInfoOrPartialErrorInfo = exports.now = exports.parseQueryString = exports.toQueryString = exports.arrPopRandomElement = exports.defaultPostHeaders = exports.defaultGetHeaders = exports.allSame = exports.arrEvery = exports.arrFilter = exports.arrMap = exports.safeArrForEach = exports.arrForEach = exports.forInOwnNonNullProperties = exports.valuesArray = exports.keysArray = exports.arrWithoutValue = exports.arrDeleteValue = exports.arrIn = exports.arrIndexOf = exports.arrSubtract = exports.arrIntersectOb = exports.arrIntersect = exports.intersect = exports.containsValue = exports.inherits = exports.prototypicalClone = exports.shallowClone = exports.isEmptyArg = exports.isOnlyPropIn = exports.isEmpty = exports.isObject = exports.ensureArray = exports.isArray = exports.copy = exports.mixin = void 0;\nexports.arrEquals = exports.toBase64 = exports.matchDerivedChannel = exports.shallowEquals = exports.getGlobalObject = exports.getRetryTime = exports.getJitterCoefficient = exports.getBackoffCoefficient = void 0;\nvar tslib_1 = __nested_webpack_require_19043__(0);\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_19043__(3));\nvar defaults_1 = tslib_1.__importStar(__nested_webpack_require_19043__(8));\nvar errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_19043__(4));\nvar enc_base64_1 = __nested_webpack_require_19043__(11);\nvar enc_utf8_1 = __nested_webpack_require_19043__(31);\nfunction randomPosn(arrOrStr) {\n    return Math.floor(Math.random() * arrOrStr.length);\n}\n/*\n * Add a set of properties to a target object\n * target: the target object\n * props:  an object whose enumerable properties are\n *         added, by reference only\n */\nfunction mixin(target) {\n    var args = [];\n    for (var _i = 1; _i < arguments.length; _i++) {\n        args[_i - 1] = arguments[_i];\n    }\n    for (var i = 0; i < args.length; i++) {\n        var source = args[i];\n        if (!source) {\n            break;\n        }\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        for (var key in source) {\n            if (!hasOwnProperty || hasOwnProperty.call(source, key)) {\n                target[key] = source[key];\n            }\n        }\n    }\n    return target;\n}\nexports.mixin = mixin;\n/*\n * Add a set of properties to a target object\n * target: the target object\n * props:  an object whose enumerable properties are\n *         added, by reference only\n */\nfunction copy(src) {\n    return mixin({}, src);\n}\nexports.copy = copy;\n/*\n * Determine whether or not a given object is\n * an array.\n */\nexports.isArray = Array.isArray ||\n    function (value) {\n        return Object.prototype.toString.call(value) == '[object Array]';\n    };\n/*\n * Ensures that an Array object is always returned\n * returning the original Array of obj is an Array\n * else wrapping the obj in a single element Array\n */\nfunction ensureArray(obj) {\n    if (isEmptyArg(obj)) {\n        return [];\n    }\n    if ((0, exports.isArray)(obj)) {\n        return obj;\n    }\n    return [obj];\n}\nexports.ensureArray = ensureArray;\nfunction isObject(ob) {\n    return Object.prototype.toString.call(ob) == '[object Object]';\n}\nexports.isObject = isObject;\n/*\n * Determine whether or not an object contains\n * any enumerable properties.\n * ob: the object\n */\nfunction isEmpty(ob) {\n    for (var prop in ob)\n        return false;\n    return true;\n}\nexports.isEmpty = isEmpty;\nfunction isOnlyPropIn(ob, property) {\n    for (var prop in ob) {\n        if (prop !== property) {\n            return false;\n        }\n    }\n    return true;\n}\nexports.isOnlyPropIn = isOnlyPropIn;\n/*\n * Determine whether or not an argument to an overloaded function is\n * undefined (missing) or null.\n * This method is useful when constructing functions such as (WebIDL terminology):\n *   off([TreatUndefinedAs=Null] DOMString? event)\n * as you can then confirm the argument using:\n *   Utils.isEmptyArg(event)\n */\nfunction isEmptyArg(arg) {\n    return arg === null || arg === undefined;\n}\nexports.isEmptyArg = isEmptyArg;\n/*\n * Perform a simple shallow clone of an object.\n * Result is an object irrespective of whether\n * the input is an object or array. All\n * enumerable properties are copied.\n * ob: the object\n */\nfunction shallowClone(ob) {\n    var result = new Object();\n    for (var prop in ob)\n        result[prop] = ob[prop];\n    return result;\n}\nexports.shallowClone = shallowClone;\n/*\n * Clone an object by creating a new object with the\n * given object as its prototype. Optionally\n * a set of additional own properties can be\n * supplied to be added to the newly created clone.\n * ob:            the object to be cloned\n * ownProperties: optional object with additional\n *                properties to add\n */\nfunction prototypicalClone(ob, ownProperties) {\n    var F = /** @class */ (function () {\n        function F() {\n        }\n        return F;\n    }());\n    F.prototype = ob;\n    var result = new F();\n    if (ownProperties)\n        mixin(result, ownProperties);\n    return result;\n}\nexports.prototypicalClone = prototypicalClone;\n/*\n * Declare a constructor to represent a subclass\n * of another constructor\n * If platform has a built-in version we use that from Platform, else we\n * define here (so can make use of other Utils fns)\n * See node.js util.inherits\n */\nvar inherits = function (ctor, superCtor) {\n    if (platform_1.default.Config.inherits) {\n        platform_1.default.Config.inherits(ctor, superCtor);\n        return;\n    }\n    ctor.super_ = superCtor;\n    ctor.prototype = prototypicalClone(superCtor.prototype, { constructor: ctor });\n};\nexports.inherits = inherits;\n/*\n * Determine whether or not an object has an enumerable\n * property whose value equals a given value.\n * ob:  the object\n * val: the value to find\n */\nfunction containsValue(ob, val) {\n    for (var i in ob) {\n        if (ob[i] == val)\n            return true;\n    }\n    return false;\n}\nexports.containsValue = containsValue;\nfunction intersect(arr, ob) {\n    return (0, exports.isArray)(ob) ? arrIntersect(arr, ob) : arrIntersectOb(arr, ob);\n}\nexports.intersect = intersect;\nfunction arrIntersect(arr1, arr2) {\n    var result = [];\n    for (var i = 0; i < arr1.length; i++) {\n        var member = arr1[i];\n        if ((0, exports.arrIndexOf)(arr2, member) != -1)\n            result.push(member);\n    }\n    return result;\n}\nexports.arrIntersect = arrIntersect;\nfunction arrIntersectOb(arr, ob) {\n    var result = [];\n    for (var i = 0; i < arr.length; i++) {\n        var member = arr[i];\n        if (member in ob)\n            result.push(member);\n    }\n    return result;\n}\nexports.arrIntersectOb = arrIntersectOb;\nfunction arrSubtract(arr1, arr2) {\n    var result = [];\n    for (var i = 0; i < arr1.length; i++) {\n        var element = arr1[i];\n        if ((0, exports.arrIndexOf)(arr2, element) == -1)\n            result.push(element);\n    }\n    return result;\n}\nexports.arrSubtract = arrSubtract;\nexports.arrIndexOf = Array.prototype.indexOf\n    ? function (arr, elem, fromIndex) {\n        return arr.indexOf(elem, fromIndex);\n    }\n    : function (arr, elem, fromIndex) {\n        fromIndex = fromIndex || 0;\n        var len = arr.length;\n        for (; fromIndex < len; fromIndex++) {\n            if (arr[fromIndex] === elem) {\n                return fromIndex;\n            }\n        }\n        return -1;\n    };\nfunction arrIn(arr, val) {\n    return (0, exports.arrIndexOf)(arr, val) !== -1;\n}\nexports.arrIn = arrIn;\nfunction arrDeleteValue(arr, val) {\n    var idx = (0, exports.arrIndexOf)(arr, val);\n    var res = idx != -1;\n    if (res)\n        arr.splice(idx, 1);\n    return res;\n}\nexports.arrDeleteValue = arrDeleteValue;\nfunction arrWithoutValue(arr, val) {\n    var newArr = arr.slice();\n    arrDeleteValue(newArr, val);\n    return newArr;\n}\nexports.arrWithoutValue = arrWithoutValue;\n/*\n * Construct an array of the keys of the enumerable\n * properties of a given object, optionally limited\n * to only the own properties.\n * ob:      the object\n * ownOnly: boolean, get own properties only\n */\nfunction keysArray(ob, ownOnly) {\n    var result = [];\n    for (var prop in ob) {\n        if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))\n            continue;\n        result.push(prop);\n    }\n    return result;\n}\nexports.keysArray = keysArray;\n/*\n * Construct an array of the values of the enumerable\n * properties of a given object, optionally limited\n * to only the own properties.\n * ob:      the object\n * ownOnly: boolean, get own properties only\n */\nfunction valuesArray(ob, ownOnly) {\n    var result = [];\n    for (var prop in ob) {\n        if (ownOnly && !Object.prototype.hasOwnProperty.call(ob, prop))\n            continue;\n        result.push(ob[prop]);\n    }\n    return result;\n}\nexports.valuesArray = valuesArray;\nfunction forInOwnNonNullProperties(ob, fn) {\n    for (var prop in ob) {\n        if (Object.prototype.hasOwnProperty.call(ob, prop) && ob[prop]) {\n            fn(prop);\n        }\n    }\n}\nexports.forInOwnNonNullProperties = forInOwnNonNullProperties;\nexports.arrForEach = Array.prototype.forEach\n    ? function (arr, fn) {\n        arr.forEach(fn);\n    }\n    : function (arr, fn) {\n        var len = arr.length;\n        for (var i = 0; i < len; i++) {\n            fn(arr[i], i, arr);\n        }\n    };\n/* Useful when the function may mutate the array */\nfunction safeArrForEach(arr, fn) {\n    return (0, exports.arrForEach)(arr.slice(), fn);\n}\nexports.safeArrForEach = safeArrForEach;\nexports.arrMap = Array.prototype.map\n    ? function (arr, fn) {\n        return arr.map(fn);\n    }\n    : function (arr, fn) {\n        var result = [];\n        var len = arr.length;\n        for (var i = 0; i < len; i++) {\n            result.push(fn(arr[i], i, arr));\n        }\n        return result;\n    };\nexports.arrFilter = Array.prototype.filter\n    ? function (arr, fn) {\n        return arr.filter(fn);\n    }\n    : function (arr, fn) {\n        var result = [], len = arr.length;\n        for (var i = 0; i < len; i++) {\n            if (fn(arr[i])) {\n                result.push(arr[i]);\n            }\n        }\n        return result;\n    };\nexports.arrEvery = Array.prototype.every\n    ? function (arr, fn) {\n        return arr.every(fn);\n    }\n    : function (arr, fn) {\n        var len = arr.length;\n        for (var i = 0; i < len; i++) {\n            if (!fn(arr[i], i, arr)) {\n                return false;\n            }\n        }\n        return true;\n    };\nfunction allSame(arr, prop) {\n    if (arr.length === 0) {\n        return true;\n    }\n    var first = arr[0][prop];\n    return (0, exports.arrEvery)(arr, function (item) {\n        return item[prop] === first;\n    });\n}\nexports.allSame = allSame;\nvar contentTypes = {\n    json: 'application/json',\n    jsonp: 'application/javascript',\n    xml: 'application/xml',\n    html: 'text/html',\n    msgpack: 'application/x-msgpack',\n};\nfunction defaultGetHeaders(options, format) {\n    var accept = contentTypes[format || Format.json];\n    return {\n        accept: accept,\n        'X-Ably-Version': defaults_1.default.protocolVersion.toString(),\n        'Ably-Agent': (0, defaults_1.getAgentString)(options),\n    };\n}\nexports.defaultGetHeaders = defaultGetHeaders;\nfunction defaultPostHeaders(options, format) {\n    var contentType;\n    var accept = (contentType = contentTypes[format || Format.json]);\n    return {\n        accept: accept,\n        'content-type': contentType,\n        'X-Ably-Version': defaults_1.default.protocolVersion.toString(),\n        'Ably-Agent': (0, defaults_1.getAgentString)(options),\n    };\n}\nexports.defaultPostHeaders = defaultPostHeaders;\nfunction arrPopRandomElement(arr) {\n    return arr.splice(randomPosn(arr), 1)[0];\n}\nexports.arrPopRandomElement = arrPopRandomElement;\nfunction toQueryString(params) {\n    var parts = [];\n    if (params) {\n        for (var key in params)\n            parts.push(encodeURIComponent(key) + '=' + encodeURIComponent(params[key]));\n    }\n    return parts.length ? '?' + parts.join('&') : '';\n}\nexports.toQueryString = toQueryString;\nfunction parseQueryString(query) {\n    var match;\n    var search = /([^?&=]+)=?([^&]*)/g;\n    var result = {};\n    while ((match = search.exec(query)))\n        result[decodeURIComponent(match[1])] = decodeURIComponent(match[2]);\n    return result;\n}\nexports.parseQueryString = parseQueryString;\nexports.now = Date.now ||\n    function () {\n        /* IE 8 */\n        return new Date().getTime();\n    };\nfunction isErrorInfoOrPartialErrorInfo(err) {\n    return (typeof err == 'object' &&\n        err !== null &&\n        (err.constructor.name == 'ErrorInfo' || err.constructor.name == 'PartialErrorInfo'));\n}\nexports.isErrorInfoOrPartialErrorInfo = isErrorInfoOrPartialErrorInfo;\nfunction inspectError(err) {\n    var _a, _b;\n    if (err instanceof Error ||\n        ((_a = err === null || err === void 0 ? void 0 : err.constructor) === null || _a === void 0 ? void 0 : _a.name) === 'ErrorInfo' ||\n        ((_b = err === null || err === void 0 ? void 0 : err.constructor) === null || _b === void 0 ? void 0 : _b.name) === 'PartialErrorInfo')\n        return err.toString();\n    return platform_1.default.Config.inspect(err);\n}\nexports.inspectError = inspectError;\nfunction inspectBody(body) {\n    if (platform_1.default.BufferUtils.isBuffer(body)) {\n        return body.toString();\n    }\n    else if (typeof body === 'string') {\n        return body;\n    }\n    else {\n        return platform_1.default.Config.inspect(body);\n    }\n}\nexports.inspectBody = inspectBody;\n/* Data is assumed to be either a string or a buffer. */\nfunction dataSizeBytes(data) {\n    if (platform_1.default.BufferUtils.isBuffer(data)) {\n        return platform_1.default.BufferUtils.byteLength(data);\n    }\n    if (typeof data === 'string') {\n        return platform_1.default.Config.stringByteSize(data);\n    }\n    throw new Error('Expected input of Utils.dataSizeBytes to be a buffer or string, but was: ' + typeof data);\n}\nexports.dataSizeBytes = dataSizeBytes;\nfunction cheapRandStr() {\n    return String(Math.random()).substr(2);\n}\nexports.cheapRandStr = cheapRandStr;\n/* Takes param the minimum number of bytes of entropy the string must\n * include, not the length of the string. String length produced is not\n * guaranteed. */\nvar randomString = function (numBytes) {\n    if (platform_1.default.Config.getRandomValues && typeof Uint8Array !== 'undefined') {\n        var uIntArr = new Uint8Array(numBytes);\n        platform_1.default.Config.getRandomValues(uIntArr);\n        return platform_1.default.BufferUtils.base64Encode(uIntArr);\n    }\n    /* Old browser; fall back to Math.random. Could just use a\n     * CryptoJS version of the above, but want this to still work in nocrypto\n     * versions of the library */\n    var charset = platform_1.default.BufferUtils.base64CharSet;\n    /* base64 has 33% overhead; round length up */\n    var length = Math.round((numBytes * 4) / 3);\n    var result = '';\n    for (var i = 0; i < length; i++) {\n        result += charset[randomPosn(charset)];\n    }\n    return result;\n};\nexports.randomString = randomString;\nvar randomHexString = function (numBytes) {\n    if (platform_1.default.Config.getRandomValues && typeof Uint8Array !== 'undefined') {\n        var uIntArr = new Uint8Array(numBytes);\n        platform_1.default.Config.getRandomValues(uIntArr);\n        return platform_1.default.BufferUtils.hexEncode(uIntArr);\n    }\n    var charset = platform_1.default.BufferUtils.hexCharSet;\n    var length = numBytes * 2;\n    var result = '';\n    for (var i = 0; i < length; i++) {\n        result += charset[randomPosn(charset)];\n    }\n    return result;\n};\nexports.randomHexString = randomHexString;\n/* Pick n elements at random without replacement from an array */\nfunction arrChooseN(arr, n) {\n    var numItems = Math.min(n, arr.length), mutableArr = arr.slice(), result = [];\n    for (var i = 0; i < numItems; i++) {\n        result.push(arrPopRandomElement(mutableArr));\n    }\n    return result;\n}\nexports.arrChooseN = arrChooseN;\nexports.trim = String.prototype.trim\n    ? function (str) {\n        return str.trim();\n    }\n    : function (str) {\n        return str.replace(/^[\\s\\uFEFF\\xA0]+|[\\s\\uFEFF\\xA0]+$/g, '');\n    };\nfunction promisify(ob, fnName, args) {\n    return new Promise(function (resolve, reject) {\n        ob[fnName].apply(ob, tslib_1.__spreadArray(tslib_1.__spreadArray([], args, false), [function (err, res) {\n                err ? reject(err) : resolve(res);\n            }], false));\n    });\n}\nexports.promisify = promisify;\nvar Format;\n(function (Format) {\n    Format[\"msgpack\"] = \"msgpack\";\n    Format[\"json\"] = \"json\";\n})(Format = exports.Format || (exports.Format = {}));\nfunction decodeBody(body, format) {\n    return format == 'msgpack' ? platform_1.default.Config.msgpack.decode(body) : JSON.parse(String(body));\n}\nexports.decodeBody = decodeBody;\nfunction encodeBody(body, format) {\n    return format == 'msgpack' ? platform_1.default.Config.msgpack.encode(body, true) : JSON.stringify(body);\n}\nexports.encodeBody = encodeBody;\nfunction allToLowerCase(arr) {\n    return arr.map(function (element) {\n        return element && element.toLowerCase();\n    });\n}\nexports.allToLowerCase = allToLowerCase;\nfunction allToUpperCase(arr) {\n    return arr.map(function (element) {\n        return element && element.toUpperCase();\n    });\n}\nexports.allToUpperCase = allToUpperCase;\nfunction getBackoffCoefficient(count) {\n    return Math.min((count + 2) / 3, 2);\n}\nexports.getBackoffCoefficient = getBackoffCoefficient;\nfunction getJitterCoefficient() {\n    return 1 - Math.random() * 0.2;\n}\nexports.getJitterCoefficient = getJitterCoefficient;\n/**\n *\n * @param initialTimeout initial timeout value\n * @param retryAttempt integer indicating retryAttempt\n * @returns RetryTimeout value for given timeout and retryAttempt.\n * If x is the value generated then,\n * Upper bound = min((retryAttempt + 2) / 3, 2) * initialTimeout,\n * Lower bound = 0.8 * Upper bound,\n * Lower bound < x < Upper bound\n */\nfunction getRetryTime(initialTimeout, retryAttempt) {\n    return initialTimeout * getBackoffCoefficient(retryAttempt) * getJitterCoefficient();\n}\nexports.getRetryTime = getRetryTime;\nfunction getGlobalObject() {\n    if (global) {\n        return global;\n    }\n    if (typeof window !== 'undefined') {\n        return window;\n    }\n    return self;\n}\nexports.getGlobalObject = getGlobalObject;\nfunction shallowEquals(source, target) {\n    return (Object.keys(source).every(function (key) { return source[key] === target[key]; }) &&\n        Object.keys(target).every(function (key) { return target[key] === source[key]; }));\n}\nexports.shallowEquals = shallowEquals;\nfunction matchDerivedChannel(name) {\n    /**\n     * This regex check is to retain existing channel params if any e.g [?rewind=1]foo to\n     * [filter=xyz?rewind=1]foo. This is to keep channel compatibility around use of\n     * channel params that work with derived channels.\n     *\n     * This eslint unsafe regex warning is triggered because the RegExp uses nested quantifiers,\n     * but it does not create any situation where the regex engine has to\n     * explore a large number of possible matches so itâ€™s safe to ignore\n     */\n    var regex = /^(\\[([^?]*)(?:(.*))\\])?(.+)$/; // eslint-disable-line\n    var match = name.match(regex);\n    if (!match || !match.length || match.length < 5) {\n        throw new errorinfo_1.default('regex match failed', 400, 40010);\n    }\n    // Fail if there is already a channel qualifier, eg [meta]foo should fail instead of just overriding with [filter=xyz]foo\n    if (match[2]) {\n        throw new errorinfo_1.default(\"cannot use a derived option with a \".concat(match[2], \" channel\"), 400, 40010);\n    }\n    // Return match values to be added to derive channel quantifier.\n    return {\n        qualifierParam: match[3] || '',\n        channelName: match[4],\n    };\n}\nexports.matchDerivedChannel = matchDerivedChannel;\nfunction toBase64(str) {\n    if (platform_1.default.Config.createHmac) {\n        return Buffer.from(str, 'ascii').toString('base64');\n    }\n    return (0, enc_base64_1.stringify)((0, enc_utf8_1.parse)(str));\n}\nexports.toBase64 = toBase64;\nfunction arrEquals(a, b) {\n    return (a.length === b.length &&\n        (0, exports.arrEvery)(a, function (val, i) {\n            return val === b[i];\n        }));\n}\nexports.arrEquals = arrEquals;\n\n/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_19043__(13)))\n\n/***/ }),\n/* 2 */\n/***/ (function(module, exports, __nested_webpack_require_39803__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_39803__(0);\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_39803__(3));\n// Workaround for salesforce lightning locker compatibility\n// This is a shorthand version of Utils.getGlobalObject (which we can't use here without creating a circular import)\nvar globalObject = global || (typeof window !== 'undefined' ? window : self);\nvar LogLevels;\n(function (LogLevels) {\n    LogLevels[LogLevels[\"None\"] = 0] = \"None\";\n    LogLevels[LogLevels[\"Error\"] = 1] = \"Error\";\n    LogLevels[LogLevels[\"Major\"] = 2] = \"Major\";\n    LogLevels[LogLevels[\"Minor\"] = 3] = \"Minor\";\n    LogLevels[LogLevels[\"Micro\"] = 4] = \"Micro\";\n})(LogLevels || (LogLevels = {}));\nfunction pad(timeSegment, three) {\n    return \"\".concat(timeSegment).padStart(three ? 3 : 2, '0');\n}\nfunction getHandler(logger) {\n    return platform_1.default.Config.logTimestamps\n        ? function (msg) {\n            var time = new Date();\n            logger(pad(time.getHours()) +\n                ':' +\n                pad(time.getMinutes()) +\n                ':' +\n                pad(time.getSeconds()) +\n                '.' +\n                pad(time.getMilliseconds(), 1) +\n                ' ' +\n                msg);\n        }\n        : logger;\n}\nvar getDefaultLoggers = function () {\n    var _a, _b;\n    var consoleLogger;\n    var errorLogger;\n    /* Can't just check for console && console.log; fails in IE <=9 */\n    if ((typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') /* node */ ||\n        typeof ((_b = (_a = globalObject === null || globalObject === void 0 ? void 0 : globalObject.console) === null || _a === void 0 ? void 0 : _a.log) === null || _b === void 0 ? void 0 : _b.apply) === 'function' /* sensible browsers */) {\n        consoleLogger = function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            console.log.apply(console, args);\n        };\n        errorLogger = console.warn\n            ? function () {\n                var args = [];\n                for (var _i = 0; _i < arguments.length; _i++) {\n                    args[_i] = arguments[_i];\n                }\n                console.warn.apply(console, args);\n            }\n            : consoleLogger;\n    }\n    else if (globalObject === null || globalObject === void 0 ? void 0 : globalObject.console.log) {\n        /* IE <= 9 with the console open -- console.log does not\n         * inherit from Function, so has no apply method */\n        consoleLogger = errorLogger = function () {\n            Function.prototype.apply.call(console.log, console, arguments);\n        };\n    }\n    else {\n        /* IE <= 9 when dev tools are closed - window.console not even defined */\n        consoleLogger = errorLogger = function () { };\n    }\n    return [consoleLogger, errorLogger].map(getHandler);\n};\nvar Logger = /** @class */ (function () {\n    function Logger() {\n        Logger.logLevel = Logger.LOG_DEFAULT;\n    }\n    Logger.initLogHandlers = function () {\n        var _a = getDefaultLoggers(), logHandler = _a[0], logErrorHandler = _a[1];\n        this.logHandler = logHandler;\n        this.logErrorHandler = logErrorHandler;\n    };\n    Logger.logLevel = LogLevels.Error; // default logLevel\n    // public constants\n    Logger.LOG_NONE = LogLevels.None;\n    Logger.LOG_ERROR = LogLevels.Error;\n    Logger.LOG_MAJOR = LogLevels.Major;\n    Logger.LOG_MINOR = LogLevels.Minor;\n    Logger.LOG_MICRO = LogLevels.Micro;\n    // aliases\n    Logger.LOG_DEFAULT = LogLevels.Error;\n    Logger.LOG_DEBUG = LogLevels.Micro;\n    /* public static functions */\n    Logger.logAction = function (level, action, message) {\n        if (Logger.shouldLog(level)) {\n            (level === LogLevels.Error ? Logger.logErrorHandler : Logger.logHandler)('Ably: ' + action + ': ' + message);\n        }\n    };\n    Logger.deprecated = function (original, replacement) {\n        Logger.deprecatedWithMsg(original, \"Please use '\" + replacement + \"' instead.\");\n    };\n    Logger.deprecatedWithMsg = function (funcName, msg) {\n        if (Logger.shouldLog(LogLevels.Error)) {\n            Logger.logErrorHandler(\"Ably: Deprecation warning - '\" + funcName + \"' is deprecated and will be removed from a future version. \" + msg);\n        }\n    };\n    /* Where a logging operation is expensive, such as serialisation of data, use shouldLog will prevent\n         the object being serialised if the log level will not output the message */\n    Logger.shouldLog = function (level) {\n        return level <= Logger.logLevel;\n    };\n    Logger.setLog = function (level, handler) {\n        if (level !== undefined)\n            Logger.logLevel = level;\n        if (handler !== undefined)\n            Logger.logHandler = Logger.logErrorHandler = handler;\n    };\n    return Logger;\n}());\nexports.default = Logger;\n\n/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_39803__(13)))\n\n/***/ }),\n/* 3 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar Platform = /** @class */ (function () {\n    function Platform() {\n    }\n    return Platform;\n}());\nexports.default = Platform;\n\n\n/***/ }),\n/* 4 */\n/***/ (function(module, exports, __nested_webpack_require_45217__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PartialErrorInfo = void 0;\nvar tslib_1 = __nested_webpack_require_45217__(0);\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_45217__(3));\nvar Utils = tslib_1.__importStar(__nested_webpack_require_45217__(1));\nfunction toString(err) {\n    var result = '[' + err.constructor.name;\n    if (err.message)\n        result += ': ' + err.message;\n    if (err.statusCode)\n        result += '; statusCode=' + err.statusCode;\n    if (err.code)\n        result += '; code=' + err.code;\n    if (err.cause)\n        result += '; cause=' + Utils.inspectError(err.cause);\n    if (err.href && !(err.message && err.message.indexOf('help.ably.io') > -1))\n        result += '; see ' + err.href + ' ';\n    result += ']';\n    return result;\n}\nvar ErrorInfo = /** @class */ (function (_super) {\n    tslib_1.__extends(ErrorInfo, _super);\n    function ErrorInfo(message, code, statusCode, cause) {\n        var _this = _super.call(this, message) || this;\n        if (typeof Object.setPrototypeOf !== 'undefined') {\n            Object.setPrototypeOf(_this, ErrorInfo.prototype);\n        }\n        _this.code = code;\n        _this.statusCode = statusCode;\n        _this.cause = cause;\n        return _this;\n    }\n    ErrorInfo.prototype.toString = function () {\n        return toString(this);\n    };\n    ErrorInfo.fromValues = function (values) {\n        var _a = values, message = _a.message, code = _a.code, statusCode = _a.statusCode;\n        if (typeof message !== 'string' || typeof code !== 'number' || typeof statusCode !== 'number') {\n            throw new Error('ErrorInfo.fromValues(): invalid values: ' + platform_1.default.Config.inspect(values));\n        }\n        var result = Object.assign(new ErrorInfo(message, code, statusCode), values);\n        if (result.code && !result.href) {\n            result.href = 'https://help.ably.io/error/' + result.code;\n        }\n        return result;\n    };\n    return ErrorInfo;\n}(Error));\nexports.default = ErrorInfo;\nvar PartialErrorInfo = /** @class */ (function (_super) {\n    tslib_1.__extends(PartialErrorInfo, _super);\n    function PartialErrorInfo(message, code, statusCode, cause) {\n        var _this = _super.call(this, message) || this;\n        if (typeof Object.setPrototypeOf !== 'undefined') {\n            Object.setPrototypeOf(_this, PartialErrorInfo.prototype);\n        }\n        _this.code = code;\n        _this.statusCode = statusCode;\n        _this.cause = cause;\n        return _this;\n    }\n    PartialErrorInfo.prototype.toString = function () {\n        return toString(this);\n    };\n    return PartialErrorInfo;\n}(Error));\nexports.PartialErrorInfo = PartialErrorInfo;\n\n\n/***/ }),\n/* 5 */\n/***/ (function(module, exports, __nested_webpack_require_47972__) {\n\n;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__nested_webpack_require_47972__(6));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Check if typed arrays are supported\n\t    if (typeof ArrayBuffer != 'function') {\n\t        return;\n\t    }\n\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\n\t    // Reference original init\n\t    var superInit = WordArray.init;\n\n\t    // Augment WordArray.init to handle typed arrays\n\t    var subInit = WordArray.init = function (typedArray) {\n\t        // Convert buffers to uint8\n\t        if (typedArray instanceof ArrayBuffer) {\n\t            typedArray = new Uint8Array(typedArray);\n\t        }\n\n\t        // Convert other array views to uint8\n\t        if (\n\t            typedArray instanceof Int8Array ||\n\t            (typeof Uint8ClampedArray !== \"undefined\" && typedArray instanceof Uint8ClampedArray) ||\n\t            typedArray instanceof Int16Array ||\n\t            typedArray instanceof Uint16Array ||\n\t            typedArray instanceof Int32Array ||\n\t            typedArray instanceof Uint32Array ||\n\t            typedArray instanceof Float32Array ||\n\t            typedArray instanceof Float64Array\n\t        ) {\n\t            typedArray = new Uint8Array(typedArray.buffer, typedArray.byteOffset, typedArray.byteLength);\n\t        }\n\n\t        // Handle Uint8Array\n\t        if (typedArray instanceof Uint8Array) {\n\t            // Shortcut\n\t            var typedArrayByteLength = typedArray.byteLength;\n\n\t            // Extract bytes\n\t            var words = [];\n\t            for (var i = 0; i < typedArrayByteLength; i++) {\n\t                words[i >>> 2] |= typedArray[i] << (24 - (i % 4) * 8);\n\t            }\n\n\t            // Initialize this word array\n\t            superInit.call(this, words, typedArrayByteLength);\n\t        } else {\n\t            // Else call normal init\n\t            superInit.apply(this, arguments);\n\t        }\n\t    };\n\n\t    subInit.prototype = WordArray;\n\t}());\n\n\n\treturn CryptoJS.lib.WordArray;\n\n}));\n\n/***/ }),\n/* 6 */\n/***/ (function(module, exports, __nested_webpack_require_50110__) {\n\n/* WEBPACK VAR INJECTION */(function(global) {;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory();\n\t}\n\telse {}\n}(this, function () {\n\n\t/*globals window, global, require*/\n\n\t/**\n\t * CryptoJS core components.\n\t */\n\tvar CryptoJS = CryptoJS || (function (Math, undefined) {\n\n\t    var crypto;\n\n\t    // Native crypto from window (Browser)\n\t    if (typeof window !== 'undefined' && window.crypto) {\n\t        crypto = window.crypto;\n\t    }\n\n\t    // Native (experimental IE 11) crypto from window (Browser)\n\t    if (!crypto && typeof window !== 'undefined' && window.msCrypto) {\n\t        crypto = window.msCrypto;\n\t    }\n\n\t    // Native crypto from global (NodeJS)\n\t    if (!crypto && typeof global !== 'undefined' && global.crypto) {\n\t        crypto = global.crypto;\n\t    }\n\n\t    // Native crypto import via require (NodeJS)\n\t    if (!crypto && \"function\" === 'function') {\n\t        try {\n\t            crypto = __nested_webpack_require_50110__(44);\n\t        } catch (err) {}\n\t    }\n\n\t    /*\n\t     * Cryptographically secure pseudorandom number generator\n\t     *\n\t     * As Math.random() is cryptographically not safe to use\n\t     */\n\t    var cryptoSecureRandomInt = function () {\n\t        if (crypto) {\n\t            // Use getRandomValues method (Browser)\n\t            if (typeof crypto.getRandomValues === 'function') {\n\t                try {\n\t                    return crypto.getRandomValues(new Uint32Array(1))[0];\n\t                } catch (err) {}\n\t            }\n\n\t            // Use randomBytes method (NodeJS)\n\t            if (typeof crypto.randomBytes === 'function') {\n\t                try {\n\t                    return crypto.randomBytes(4).readInt32LE();\n\t                } catch (err) {}\n\t            }\n\t        }\n\n\t        throw new Error('Native crypto module could not be used to get secure random number.');\n\t    };\n\n\t    /*\n\t     * Local polyfill of Object.create\n\n\t     */\n\t    var create = Object.create || (function () {\n\t        function F() {}\n\n\t        return function (obj) {\n\t            var subtype;\n\n\t            F.prototype = obj;\n\n\t            subtype = new F();\n\n\t            F.prototype = null;\n\n\t            return subtype;\n\t        };\n\t    }())\n\n\t    /**\n\t     * CryptoJS namespace.\n\t     */\n\t    var C = {};\n\n\t    /**\n\t     * Library namespace.\n\t     */\n\t    var C_lib = C.lib = {};\n\n\t    /**\n\t     * Base object for prototypal inheritance.\n\t     */\n\t    var Base = C_lib.Base = (function () {\n\n\n\t        return {\n\t            /**\n\t             * Creates a new object that inherits from this object.\n\t             *\n\t             * @param {Object} overrides Properties to copy into the new object.\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         field: 'value',\n\t             *\n\t             *         method: function () {\n\t             *         }\n\t             *     });\n\t             */\n\t            extend: function (overrides) {\n\t                // Spawn\n\t                var subtype = create(this);\n\n\t                // Augment\n\t                if (overrides) {\n\t                    subtype.mixIn(overrides);\n\t                }\n\n\t                // Create default initializer\n\t                if (!subtype.hasOwnProperty('init') || this.init === subtype.init) {\n\t                    subtype.init = function () {\n\t                        subtype.$super.init.apply(this, arguments);\n\t                    };\n\t                }\n\n\t                // Initializer's prototype is the subtype object\n\t                subtype.init.prototype = subtype;\n\n\t                // Reference supertype\n\t                subtype.$super = this;\n\n\t                return subtype;\n\t            },\n\n\t            /**\n\t             * Extends this object and runs the init method.\n\t             * Arguments to create() will be passed to init().\n\t             *\n\t             * @return {Object} The new object.\n\t             *\n\t             * @static\n\t             *\n\t             * @example\n\t             *\n\t             *     var instance = MyType.create();\n\t             */\n\t            create: function () {\n\t                var instance = this.extend();\n\t                instance.init.apply(instance, arguments);\n\n\t                return instance;\n\t            },\n\n\t            /**\n\t             * Initializes a newly created object.\n\t             * Override this method to add some logic when your objects are created.\n\t             *\n\t             * @example\n\t             *\n\t             *     var MyType = CryptoJS.lib.Base.extend({\n\t             *         init: function () {\n\t             *             // ...\n\t             *         }\n\t             *     });\n\t             */\n\t            init: function () {\n\t            },\n\n\t            /**\n\t             * Copies properties into this object.\n\t             *\n\t             * @param {Object} properties The properties to mix in.\n\t             *\n\t             * @example\n\t             *\n\t             *     MyType.mixIn({\n\t             *         field: 'value'\n\t             *     });\n\t             */\n\t            mixIn: function (properties) {\n\t                for (var propertyName in properties) {\n\t                    if (properties.hasOwnProperty(propertyName)) {\n\t                        this[propertyName] = properties[propertyName];\n\t                    }\n\t                }\n\n\t                // IE won't copy toString using the loop above\n\t                if (properties.hasOwnProperty('toString')) {\n\t                    this.toString = properties.toString;\n\t                }\n\t            },\n\n\t            /**\n\t             * Creates a copy of this object.\n\t             *\n\t             * @return {Object} The clone.\n\t             *\n\t             * @example\n\t             *\n\t             *     var clone = instance.clone();\n\t             */\n\t            clone: function () {\n\t                return this.init.prototype.extend(this);\n\t            }\n\t        };\n\t    }());\n\n\t    /**\n\t     * An array of 32-bit words.\n\t     *\n\t     * @property {Array} words The array of 32-bit words.\n\t     * @property {number} sigBytes The number of significant bytes in this word array.\n\t     */\n\t    var WordArray = C_lib.WordArray = Base.extend({\n\t        /**\n\t         * Initializes a newly created word array.\n\t         *\n\t         * @param {Array} words (Optional) An array of 32-bit words.\n\t         * @param {number} sigBytes (Optional) The number of significant bytes in the words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.create();\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607]);\n\t         *     var wordArray = CryptoJS.lib.WordArray.create([0x00010203, 0x04050607], 6);\n\t         */\n\t        init: function (words, sigBytes) {\n\t            words = this.words = words || [];\n\n\t            if (sigBytes != undefined) {\n\t                this.sigBytes = sigBytes;\n\t            } else {\n\t                this.sigBytes = words.length * 4;\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts this word array to a string.\n\t         *\n\t         * @param {Encoder} encoder (Optional) The encoding strategy to use. Default: CryptoJS.enc.Hex\n\t         *\n\t         * @return {string} The stringified word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = wordArray + '';\n\t         *     var string = wordArray.toString();\n\t         *     var string = wordArray.toString(CryptoJS.enc.Utf8);\n\t         */\n\t        toString: function (encoder) {\n\t            return (encoder || Hex).stringify(this);\n\t        },\n\n\t        /**\n\t         * Concatenates a word array to this word array.\n\t         *\n\t         * @param {WordArray} wordArray The word array to append.\n\t         *\n\t         * @return {WordArray} This word array.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray1.concat(wordArray2);\n\t         */\n\t        concat: function (wordArray) {\n\t            // Shortcuts\n\t            var thisWords = this.words;\n\t            var thatWords = wordArray.words;\n\t            var thisSigBytes = this.sigBytes;\n\t            var thatSigBytes = wordArray.sigBytes;\n\n\t            // Clamp excess bits\n\t            this.clamp();\n\n\t            // Concat\n\t            if (thisSigBytes % 4) {\n\t                // Copy one byte at a time\n\t                for (var i = 0; i < thatSigBytes; i++) {\n\t                    var thatByte = (thatWords[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                    thisWords[(thisSigBytes + i) >>> 2] |= thatByte << (24 - ((thisSigBytes + i) % 4) * 8);\n\t                }\n\t            } else {\n\t                // Copy one word at a time\n\t                for (var i = 0; i < thatSigBytes; i += 4) {\n\t                    thisWords[(thisSigBytes + i) >>> 2] = thatWords[i >>> 2];\n\t                }\n\t            }\n\t            this.sigBytes += thatSigBytes;\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Removes insignificant bits.\n\t         *\n\t         * @example\n\t         *\n\t         *     wordArray.clamp();\n\t         */\n\t        clamp: function () {\n\t            // Shortcuts\n\t            var words = this.words;\n\t            var sigBytes = this.sigBytes;\n\n\t            // Clamp\n\t            words[sigBytes >>> 2] &= 0xffffffff << (32 - (sigBytes % 4) * 8);\n\t            words.length = Math.ceil(sigBytes / 4);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this word array.\n\t         *\n\t         * @return {WordArray} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = wordArray.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone.words = this.words.slice(0);\n\n\t            return clone;\n\t        },\n\n\t        /**\n\t         * Creates a word array filled with random bytes.\n\t         *\n\t         * @param {number} nBytes The number of random bytes to generate.\n\t         *\n\t         * @return {WordArray} The random word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.lib.WordArray.random(16);\n\t         */\n\t        random: function (nBytes) {\n\t            var words = [];\n\n\t            for (var i = 0; i < nBytes; i += 4) {\n\t                words.push(cryptoSecureRandomInt());\n\t            }\n\n\t            return new WordArray.init(words, nBytes);\n\t        }\n\t    });\n\n\t    /**\n\t     * Encoder namespace.\n\t     */\n\t    var C_enc = C.enc = {};\n\n\t    /**\n\t     * Hex encoding strategy.\n\t     */\n\t    var Hex = C_enc.Hex = {\n\t        /**\n\t         * Converts a word array to a hex string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The hex string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.enc.Hex.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var hexChars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                hexChars.push((bite >>> 4).toString(16));\n\t                hexChars.push((bite & 0x0f).toString(16));\n\t            }\n\n\t            return hexChars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a hex string to a word array.\n\t         *\n\t         * @param {string} hexStr The hex string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Hex.parse(hexString);\n\t         */\n\t        parse: function (hexStr) {\n\t            // Shortcut\n\t            var hexStrLength = hexStr.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < hexStrLength; i += 2) {\n\t                words[i >>> 3] |= parseInt(hexStr.substr(i, 2), 16) << (24 - (i % 8) * 4);\n\t            }\n\n\t            return new WordArray.init(words, hexStrLength / 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * Latin1 encoding strategy.\n\t     */\n\t    var Latin1 = C_enc.Latin1 = {\n\t        /**\n\t         * Converts a word array to a Latin1 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Latin1 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var latin1String = CryptoJS.enc.Latin1.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var latin1Chars = [];\n\t            for (var i = 0; i < sigBytes; i++) {\n\t                var bite = (words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n\t                latin1Chars.push(String.fromCharCode(bite));\n\t            }\n\n\t            return latin1Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Latin1 string to a word array.\n\t         *\n\t         * @param {string} latin1Str The Latin1 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Latin1.parse(latin1String);\n\t         */\n\t        parse: function (latin1Str) {\n\t            // Shortcut\n\t            var latin1StrLength = latin1Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < latin1StrLength; i++) {\n\t                words[i >>> 2] |= (latin1Str.charCodeAt(i) & 0xff) << (24 - (i % 4) * 8);\n\t            }\n\n\t            return new WordArray.init(words, latin1StrLength);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-8 encoding strategy.\n\t     */\n\t    var Utf8 = C_enc.Utf8 = {\n\t        /**\n\t         * Converts a word array to a UTF-8 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-8 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf8String = CryptoJS.enc.Utf8.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            try {\n\t                return decodeURIComponent(escape(Latin1.stringify(wordArray)));\n\t            } catch (e) {\n\t                throw new Error('Malformed UTF-8 data');\n\t            }\n\t        },\n\n\t        /**\n\t         * Converts a UTF-8 string to a word array.\n\t         *\n\t         * @param {string} utf8Str The UTF-8 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf8.parse(utf8String);\n\t         */\n\t        parse: function (utf8Str) {\n\t            return Latin1.parse(unescape(encodeURIComponent(utf8Str)));\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract buffered block algorithm template.\n\t     *\n\t     * The property blockSize must be implemented in a concrete subtype.\n\t     *\n\t     * @property {number} _minBufferSize The number of blocks that should be kept unprocessed in the buffer. Default: 0\n\t     */\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm = Base.extend({\n\t        /**\n\t         * Resets this block algorithm's data buffer to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm.reset();\n\t         */\n\t        reset: function () {\n\t            // Initial values\n\t            this._data = new WordArray.init();\n\t            this._nDataBytes = 0;\n\t        },\n\n\t        /**\n\t         * Adds new data to this block algorithm's buffer.\n\t         *\n\t         * @param {WordArray|string} data The data to append. Strings are converted to a WordArray using UTF-8.\n\t         *\n\t         * @example\n\t         *\n\t         *     bufferedBlockAlgorithm._append('data');\n\t         *     bufferedBlockAlgorithm._append(wordArray);\n\t         */\n\t        _append: function (data) {\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof data == 'string') {\n\t                data = Utf8.parse(data);\n\t            }\n\n\t            // Append\n\t            this._data.concat(data);\n\t            this._nDataBytes += data.sigBytes;\n\t        },\n\n\t        /**\n\t         * Processes available data blocks.\n\t         *\n\t         * This method invokes _doProcessBlock(offset), which must be implemented by a concrete subtype.\n\t         *\n\t         * @param {boolean} doFlush Whether all blocks and partial blocks should be processed.\n\t         *\n\t         * @return {WordArray} The processed data.\n\t         *\n\t         * @example\n\t         *\n\t         *     var processedData = bufferedBlockAlgorithm._process();\n\t         *     var processedData = bufferedBlockAlgorithm._process(!!'flush');\n\t         */\n\t        _process: function (doFlush) {\n\t            var processedWords;\n\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\t            var dataSigBytes = data.sigBytes;\n\t            var blockSize = this.blockSize;\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count blocks ready\n\t            var nBlocksReady = dataSigBytes / blockSizeBytes;\n\t            if (doFlush) {\n\t                // Round up to include partial blocks\n\t                nBlocksReady = Math.ceil(nBlocksReady);\n\t            } else {\n\t                // Round down to include only full blocks,\n\t                // less the number of blocks that must remain in the buffer\n\t                nBlocksReady = Math.max((nBlocksReady | 0) - this._minBufferSize, 0);\n\t            }\n\n\t            // Count words ready\n\t            var nWordsReady = nBlocksReady * blockSize;\n\n\t            // Count bytes ready\n\t            var nBytesReady = Math.min(nWordsReady * 4, dataSigBytes);\n\n\t            // Process blocks\n\t            if (nWordsReady) {\n\t                for (var offset = 0; offset < nWordsReady; offset += blockSize) {\n\t                    // Perform concrete-algorithm logic\n\t                    this._doProcessBlock(dataWords, offset);\n\t                }\n\n\t                // Remove processed words\n\t                processedWords = dataWords.splice(0, nWordsReady);\n\t                data.sigBytes -= nBytesReady;\n\t            }\n\n\t            // Return processed words\n\t            return new WordArray.init(processedWords, nBytesReady);\n\t        },\n\n\t        /**\n\t         * Creates a copy of this object.\n\t         *\n\t         * @return {Object} The clone.\n\t         *\n\t         * @example\n\t         *\n\t         *     var clone = bufferedBlockAlgorithm.clone();\n\t         */\n\t        clone: function () {\n\t            var clone = Base.clone.call(this);\n\t            clone._data = this._data.clone();\n\n\t            return clone;\n\t        },\n\n\t        _minBufferSize: 0\n\t    });\n\n\t    /**\n\t     * Abstract hasher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this hasher operates on. Default: 16 (512 bits)\n\t     */\n\t    var Hasher = C_lib.Hasher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Initializes a newly created hasher.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for this hash computation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hasher = CryptoJS.algo.SHA256.create();\n\t         */\n\t        init: function (cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this hasher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-hasher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Updates this hasher with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {Hasher} This hasher.\n\t         *\n\t         * @example\n\t         *\n\t         *     hasher.update('message');\n\t         *     hasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            // Append\n\t            this._append(messageUpdate);\n\n\t            // Update the hash\n\t            this._process();\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the hash computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The hash.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hash = hasher.finalize();\n\t         *     var hash = hasher.finalize('message');\n\t         *     var hash = hasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Final message update\n\t            if (messageUpdate) {\n\t                this._append(messageUpdate);\n\t            }\n\n\t            // Perform concrete-hasher logic\n\t            var hash = this._doFinalize();\n\n\t            return hash;\n\t        },\n\n\t        blockSize: 512/32,\n\n\t        /**\n\t         * Creates a shortcut function to a hasher's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to create a helper for.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var SHA256 = CryptoJS.lib.Hasher._createHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHelper: function (hasher) {\n\t            return function (message, cfg) {\n\t                return new hasher.init(cfg).finalize(message);\n\t            };\n\t        },\n\n\t        /**\n\t         * Creates a shortcut function to the HMAC's object interface.\n\t         *\n\t         * @param {Hasher} hasher The hasher to use in this HMAC helper.\n\t         *\n\t         * @return {Function} The shortcut function.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var HmacSHA256 = CryptoJS.lib.Hasher._createHmacHelper(CryptoJS.algo.SHA256);\n\t         */\n\t        _createHmacHelper: function (hasher) {\n\t            return function (message, key) {\n\t                return new C_algo.HMAC.init(hasher, key).finalize(message);\n\t            };\n\t        }\n\t    });\n\n\t    /**\n\t     * Algorithm namespace.\n\t     */\n\t    var C_algo = C.algo = {};\n\n\t    return C;\n\t}(Math));\n\n\n\treturn CryptoJS;\n\n}));\n/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_50110__(13)))\n\n/***/ }),\n/* 7 */\n/***/ (function(module, exports, __nested_webpack_require_73476__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_73476__(0);\nvar Utils = tslib_1.__importStar(__nested_webpack_require_73476__(1));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_73476__(2));\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_73476__(3));\n/* Call the listener, catch any exceptions and log, but continue operation*/\nfunction callListener(eventThis, listener, args) {\n    try {\n        listener.apply(eventThis, args);\n    }\n    catch (e) {\n        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'EventEmitter.emit()', 'Unexpected listener exception: ' + e + '; stack = ' + (e && e.stack));\n    }\n}\n/**\n * Remove listeners that match listener\n * @param targetListeners is an array of listener arrays or event objects with arrays of listeners\n * @param listener the listener callback to remove\n * @param eventFilter (optional) event name instructing the function to only remove listeners for the specified event\n */\nfunction removeListener(targetListeners, listener, eventFilter) {\n    var listeners;\n    var index;\n    var eventName;\n    for (var targetListenersIndex = 0; targetListenersIndex < targetListeners.length; targetListenersIndex++) {\n        listeners = targetListeners[targetListenersIndex];\n        if (eventFilter) {\n            listeners = listeners[eventFilter];\n        }\n        if (Utils.isArray(listeners)) {\n            while ((index = Utils.arrIndexOf(listeners, listener)) !== -1) {\n                listeners.splice(index, 1);\n            }\n            /* If events object has an event name key with no listeners then\n                          remove the key to stop the list growing indefinitely */\n            if (eventFilter && listeners.length === 0) {\n                delete targetListeners[targetListenersIndex][eventFilter];\n            }\n        }\n        else if (Utils.isObject(listeners)) {\n            /* events */\n            for (eventName in listeners) {\n                if (Object.prototype.hasOwnProperty.call(listeners, eventName) && Utils.isArray(listeners[eventName])) {\n                    removeListener([listeners], listener, eventName);\n                }\n            }\n        }\n    }\n}\nvar EventEmitter = /** @class */ (function () {\n    function EventEmitter() {\n        this.any = [];\n        this.events = Object.create(null);\n        this.anyOnce = [];\n        this.eventsOnce = Object.create(null);\n    }\n    EventEmitter.prototype.on = function () {\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length === 1) {\n            var listener = args[0];\n            if (typeof listener === 'function') {\n                this.any.push(listener);\n            }\n            else {\n                throw new Error('EventListener.on(): Invalid arguments: ' + platform_1.default.Config.inspect(args));\n            }\n        }\n        if (args.length === 2) {\n            var event_1 = args[0], listener_1 = args[1];\n            if (typeof listener_1 !== 'function') {\n                throw new Error('EventListener.on(): Invalid arguments: ' + platform_1.default.Config.inspect(args));\n            }\n            if (Utils.isEmptyArg(event_1)) {\n                this.any.push(listener_1);\n            }\n            else if (Utils.isArray(event_1)) {\n                event_1.forEach(function (eventName) {\n                    _this.on(eventName, listener_1);\n                });\n            }\n            else {\n                if (typeof event_1 !== 'string') {\n                    throw new Error('EventListener.on(): Invalid arguments: ' + platform_1.default.Config.inspect(args));\n                }\n                var listeners = this.events[event_1] || (this.events[event_1] = []);\n                listeners.push(listener_1);\n            }\n        }\n    };\n    EventEmitter.prototype.off = function () {\n        var _a;\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        if (args.length == 0 || (Utils.isEmptyArg(args[0]) && Utils.isEmptyArg(args[1]))) {\n            this.any = [];\n            this.events = Object.create(null);\n            this.anyOnce = [];\n            this.eventsOnce = Object.create(null);\n            return;\n        }\n        var firstArg = args[0], secondArg = args[1];\n        var listener = null;\n        var event = null;\n        if (args.length === 1 || !secondArg) {\n            if (typeof firstArg === 'function') {\n                /* we take this to be the listener and treat the event as \"any\" .. */\n                listener = firstArg;\n            }\n            else {\n                event = firstArg;\n            }\n            /* ... or we take event to be the actual event name and listener to be all */\n        }\n        else {\n            if (typeof secondArg !== 'function') {\n                throw new Error('EventEmitter.off(): invalid arguments:' + platform_1.default.Config.inspect(args));\n            }\n            _a = [firstArg, secondArg], event = _a[0], listener = _a[1];\n        }\n        if (listener && Utils.isEmptyArg(event)) {\n            removeListener([this.any, this.events, this.anyOnce, this.eventsOnce], listener);\n            return;\n        }\n        if (Utils.isArray(event)) {\n            event.forEach(function (eventName) {\n                _this.off(eventName, listener);\n            });\n            return;\n        }\n        /* \"normal\" case where event is an actual event */\n        if (typeof event !== 'string') {\n            throw new Error('EventEmitter.off(): invalid arguments:' + platform_1.default.Config.inspect(args));\n        }\n        if (listener) {\n            removeListener([this.events, this.eventsOnce], listener, event);\n        }\n        else {\n            delete this.events[event];\n            delete this.eventsOnce[event];\n        }\n    };\n    /**\n     * Get the array of listeners for a given event; excludes once events\n     * @param event (optional) the name of the event, or none for 'any'\n     * @return array of events, or null if none\n     */\n    EventEmitter.prototype.listeners = function (event) {\n        if (event) {\n            var listeners = this.events[event] || [];\n            if (this.eventsOnce[event])\n                Array.prototype.push.apply(listeners, this.eventsOnce[event]);\n            return listeners.length ? listeners : null;\n        }\n        return this.any.length ? this.any : null;\n    };\n    /**\n     * Emit an event\n     * @param event the event name\n     * @param args the arguments to pass to the listener\n     */\n    EventEmitter.prototype.emit = function (event) {\n        var args = []; /* , args... */\n        for (var _i = 1 /* , args... */; _i < arguments.length /* , args... */; _i++ /* , args... */) {\n            args[_i - 1] = arguments[_i]; /* , args... */\n        }\n        var eventThis = { event: event };\n        var listeners = [];\n        if (this.anyOnce.length) {\n            Array.prototype.push.apply(listeners, this.anyOnce);\n            this.anyOnce = [];\n        }\n        if (this.any.length) {\n            Array.prototype.push.apply(listeners, this.any);\n        }\n        var eventsOnceListeners = this.eventsOnce[event];\n        if (eventsOnceListeners) {\n            Array.prototype.push.apply(listeners, eventsOnceListeners);\n            delete this.eventsOnce[event];\n        }\n        var eventsListeners = this.events[event];\n        if (eventsListeners) {\n            Array.prototype.push.apply(listeners, eventsListeners);\n        }\n        Utils.arrForEach(listeners, function (listener) {\n            callListener(eventThis, listener, args);\n        });\n    };\n    EventEmitter.prototype.once = function () {\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var argCount = args.length;\n        if ((argCount === 0 || (argCount === 1 && typeof args[0] !== 'function')) && platform_1.default.Config.Promise) {\n            var event_2 = args[0];\n            return new platform_1.default.Config.Promise(function (resolve) {\n                _this.once(event_2, resolve);\n            });\n        }\n        var firstArg = args[0], secondArg = args[1];\n        if (args.length === 1 && typeof firstArg === 'function') {\n            this.anyOnce.push(firstArg);\n        }\n        else if (Utils.isEmptyArg(firstArg)) {\n            if (typeof secondArg !== 'function') {\n                throw new Error('EventEmitter.once(): Invalid arguments:' + platform_1.default.Config.inspect(args));\n            }\n            this.anyOnce.push(secondArg);\n        }\n        else if (Utils.isArray(firstArg)) {\n            var self_1 = this;\n            var listenerWrapper_1 = function () {\n                var innerArgs = Array.prototype.slice.call(arguments);\n                Utils.arrForEach(firstArg, function (eventName) {\n                    self_1.off(eventName, listenerWrapper_1);\n                });\n                if (typeof secondArg !== 'function') {\n                    throw new Error('EventEmitter.once(): Invalid arguments:' + platform_1.default.Config.inspect(args));\n                }\n                secondArg.apply(this, innerArgs);\n            };\n            Utils.arrForEach(firstArg, function (eventName) {\n                self_1.on(eventName, listenerWrapper_1);\n            });\n        }\n        else {\n            if (typeof firstArg !== 'string') {\n                throw new Error('EventEmitter.once(): Invalid arguments:' + platform_1.default.Config.inspect(args));\n            }\n            var listeners = this.eventsOnce[firstArg] || (this.eventsOnce[firstArg] = []);\n            if (secondArg) {\n                if (typeof secondArg !== 'function') {\n                    throw new Error('EventEmitter.once(): Invalid arguments:' + platform_1.default.Config.inspect(args));\n                }\n                listeners.push(secondArg);\n            }\n        }\n    };\n    /**\n     * Private API\n     *\n     * Listen for a single occurrence of a state event and fire immediately if currentState matches targetState\n     * @param targetState the name of the state event to listen to\n     * @param currentState the name of the current state of this object\n     * @param listener the listener to be called\n     * @param listenerArgs\n     */\n    EventEmitter.prototype.whenState = function (targetState, currentState, listener) {\n        var _this = this;\n        var listenerArgs = [];\n        for (var _i = 3; _i < arguments.length; _i++) {\n            listenerArgs[_i - 3] = arguments[_i];\n        }\n        var eventThis = { event: targetState };\n        if (typeof targetState !== 'string' || typeof currentState !== 'string') {\n            throw 'whenState requires a valid event String argument';\n        }\n        if (typeof listener !== 'function' && platform_1.default.Config.Promise) {\n            return new platform_1.default.Config.Promise(function (resolve) {\n                EventEmitter.prototype.whenState.apply(_this, [targetState, currentState, resolve].concat(listenerArgs));\n            });\n        }\n        if (targetState === currentState) {\n            callListener(eventThis, listener, listenerArgs);\n        }\n        else {\n            this.once(targetState, listener);\n        }\n    };\n    return EventEmitter;\n}());\nexports.default = EventEmitter;\n\n\n/***/ }),\n/* 8 */\n/***/ (function(module, exports, __nested_webpack_require_85072__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.getDefaults = exports.normaliseOptions = exports.objectifyOptions = exports.getAgentString = exports.getHosts = exports.getFallbackHosts = exports.environmentFallbackHosts = exports.getHttpScheme = exports.getPort = exports.getHost = void 0;\nvar tslib_1 = __nested_webpack_require_85072__(0);\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_85072__(3));\nvar Utils = tslib_1.__importStar(__nested_webpack_require_85072__(1));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_85072__(2));\nvar errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_85072__(4));\nvar package_json_1 = __nested_webpack_require_85072__(43);\nvar agent = 'ably-js/' + package_json_1.version;\nvar Defaults = {\n    ENVIRONMENT: '',\n    REST_HOST: 'rest.ably.io',\n    REALTIME_HOST: 'realtime.ably.io',\n    FALLBACK_HOSTS: [\n        'A.ably-realtime.com',\n        'B.ably-realtime.com',\n        'C.ably-realtime.com',\n        'D.ably-realtime.com',\n        'E.ably-realtime.com',\n    ],\n    PORT: 80,\n    TLS_PORT: 443,\n    TIMEOUTS: {\n        /* Documented as options params: */\n        disconnectedRetryTimeout: 15000,\n        suspendedRetryTimeout: 30000,\n        /* Undocumented, but part of the api and can be used by customers: */\n        httpRequestTimeout: 15000,\n        channelRetryTimeout: 15000,\n        fallbackRetryTimeout: 600000,\n        /* For internal / test use only: */\n        connectionStateTtl: 120000,\n        realtimeRequestTimeout: 10000,\n        recvTimeout: 90000,\n        preferenceConnectTimeout: 6000,\n        parallelUpgradeDelay: 6000,\n    },\n    httpMaxRetryCount: 3,\n    maxMessageSize: 65536,\n    version: package_json_1.version,\n    protocolVersion: 2,\n    agent: agent,\n    getHost: getHost,\n    getPort: getPort,\n    getHttpScheme: getHttpScheme,\n    environmentFallbackHosts: environmentFallbackHosts,\n    getFallbackHosts: getFallbackHosts,\n    getHosts: getHosts,\n    checkHost: checkHost,\n    objectifyOptions: objectifyOptions,\n    normaliseOptions: normaliseOptions,\n};\nfunction getHost(options, host, ws) {\n    if (ws)\n        host = (host == options.restHost && options.realtimeHost) || host || options.realtimeHost;\n    else\n        host = host || options.restHost;\n    return host;\n}\nexports.getHost = getHost;\nfunction getPort(options, tls) {\n    return tls || options.tls ? options.tlsPort : options.port;\n}\nexports.getPort = getPort;\nfunction getHttpScheme(options) {\n    return options.tls ? 'https://' : 'http://';\n}\nexports.getHttpScheme = getHttpScheme;\n// construct environment fallback hosts as per RSC15i\nfunction environmentFallbackHosts(environment) {\n    return [\n        environment + '-a-fallback.ably-realtime.com',\n        environment + '-b-fallback.ably-realtime.com',\n        environment + '-c-fallback.ably-realtime.com',\n        environment + '-d-fallback.ably-realtime.com',\n        environment + '-e-fallback.ably-realtime.com',\n    ];\n}\nexports.environmentFallbackHosts = environmentFallbackHosts;\nfunction getFallbackHosts(options) {\n    var fallbackHosts = options.fallbackHosts, httpMaxRetryCount = typeof options.httpMaxRetryCount !== 'undefined' ? options.httpMaxRetryCount : Defaults.httpMaxRetryCount;\n    return fallbackHosts ? Utils.arrChooseN(fallbackHosts, httpMaxRetryCount) : [];\n}\nexports.getFallbackHosts = getFallbackHosts;\nfunction getHosts(options) {\n    return [options.restHost].concat(getFallbackHosts(options));\n}\nexports.getHosts = getHosts;\nfunction checkHost(host) {\n    if (typeof host !== 'string') {\n        throw new errorinfo_1.default('host must be a string; was a ' + typeof host, 40000, 400);\n    }\n    if (!host.length) {\n        throw new errorinfo_1.default('host must not be zero-length', 40000, 400);\n    }\n}\nfunction getRealtimeHost(options, production, environment) {\n    if (options.realtimeHost)\n        return options.realtimeHost;\n    /* prefer setting realtimeHost to restHost as a custom restHost typically indicates\n     * a development environment is being used that can't be inferred by the library */\n    if (options.restHost) {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Defaults.normaliseOptions', 'restHost is set to \"' +\n            options.restHost +\n            '\" but realtimeHost is not set, so setting realtimeHost to \"' +\n            options.restHost +\n            '\" too. If this is not what you want, please set realtimeHost explicitly.');\n        return options.restHost;\n    }\n    return production ? Defaults.REALTIME_HOST : environment + '-' + Defaults.REALTIME_HOST;\n}\nfunction getTimeouts(options) {\n    /* Allow values passed in options to override default timeouts */\n    var timeouts = {};\n    for (var prop in Defaults.TIMEOUTS) {\n        timeouts[prop] = options[prop] || Defaults.TIMEOUTS[prop];\n    }\n    return timeouts;\n}\nfunction getAgentString(options) {\n    var agentStr = Defaults.agent;\n    if (options.agents) {\n        for (var agent in options.agents) {\n            agentStr += ' ' + agent + '/' + options.agents[agent];\n        }\n    }\n    return agentStr;\n}\nexports.getAgentString = getAgentString;\nfunction objectifyOptions(options) {\n    if (typeof options == 'string') {\n        return options.indexOf(':') == -1 ? { token: options } : { key: options };\n    }\n    return options;\n}\nexports.objectifyOptions = objectifyOptions;\nfunction normaliseOptions(options) {\n    /* Deprecated options */\n    if (options.host) {\n        logger_1.default.deprecated('host', 'restHost');\n        options.restHost = options.host;\n    }\n    if (options.wsHost) {\n        logger_1.default.deprecated('wsHost', 'realtimeHost');\n        options.realtimeHost = options.wsHost;\n    }\n    if (options.queueEvents) {\n        logger_1.default.deprecated('queueEvents', 'queueMessages');\n        options.queueMessages = options.queueEvents;\n    }\n    if (options.fallbackHostsUseDefault) {\n        /* fallbackHostsUseDefault and fallbackHosts are mutually exclusive as per TO3k7 */\n        if (options.fallbackHosts) {\n            var msg = 'fallbackHosts and fallbackHostsUseDefault cannot both be set';\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Defaults.normaliseOptions', msg);\n            throw new errorinfo_1.default(msg, 40000, 400);\n        }\n        /* default fallbacks can't be used with custom ports */\n        if (options.port || options.tlsPort) {\n            var msg = 'fallbackHostsUseDefault cannot be set when port or tlsPort are set';\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Defaults.normaliseOptions', msg);\n            throw new errorinfo_1.default(msg, 40000, 400);\n        }\n        /* emit an appropriate deprecation warning */\n        if (options.environment) {\n            logger_1.default.deprecatedWithMsg('fallbackHostsUseDefault', 'There is no longer a need to set this when the environment option is also set since the library will now generate the correct fallback hosts using the environment option.');\n        }\n        else {\n            logger_1.default.deprecated('fallbackHostsUseDefault', 'fallbackHosts: Ably.Defaults.FALLBACK_HOSTS');\n        }\n        /* use the default fallback hosts as requested */\n        options.fallbackHosts = Defaults.FALLBACK_HOSTS;\n    }\n    /* options.recover as a boolean is deprecated, and therefore is not part of the public typing */\n    if (options.recover === true) {\n        logger_1.default.deprecated('{recover: true}', '{recover: function(lastConnectionDetails, cb) { cb(true); }}');\n        options.recover = function (lastConnectionDetails, cb) {\n            cb(true);\n        };\n    }\n    if (typeof options.recover === 'function' && options.closeOnUnload === true) {\n        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Defaults.normaliseOptions', 'closeOnUnload was true and a session recovery function was set - these are mutually exclusive, so unsetting the latter');\n        options.recover = undefined;\n    }\n    if (!('closeOnUnload' in options)) {\n        /* Have closeOnUnload default to true unless we have any indication that\n         * the user may want to recover the connection */\n        options.closeOnUnload = !options.recover;\n    }\n    if (options.transports && Utils.arrIn(options.transports, 'xhr')) {\n        logger_1.default.deprecated('transports: [\"xhr\"]', 'transports: [\"xhr_streaming\"]');\n        Utils.arrDeleteValue(options.transports, 'xhr');\n        options.transports.push('xhr_streaming');\n    }\n    if (!('queueMessages' in options))\n        options.queueMessages = true;\n    /* infer hosts and fallbacks based on the configured environment */\n    var environment = (options.environment && String(options.environment).toLowerCase()) || Defaults.ENVIRONMENT;\n    var production = !environment || environment === 'production';\n    if (!options.fallbackHosts && !options.restHost && !options.realtimeHost && !options.port && !options.tlsPort) {\n        options.fallbackHosts = production ? Defaults.FALLBACK_HOSTS : environmentFallbackHosts(environment);\n    }\n    var restHost = options.restHost || (production ? Defaults.REST_HOST : environment + '-' + Defaults.REST_HOST);\n    var realtimeHost = getRealtimeHost(options, production, environment);\n    Utils.arrForEach((options.fallbackHosts || []).concat(restHost, realtimeHost), checkHost);\n    options.port = options.port || Defaults.PORT;\n    options.tlsPort = options.tlsPort || Defaults.TLS_PORT;\n    if (!('tls' in options))\n        options.tls = true;\n    var timeouts = getTimeouts(options);\n    if ('useBinaryProtocol' in options) {\n        options.useBinaryProtocol = platform_1.default.Config.supportsBinary && options.useBinaryProtocol;\n    }\n    else {\n        options.useBinaryProtocol = platform_1.default.Config.preferBinary;\n    }\n    if (options.clientId) {\n        var headers = (options.headers = options.headers || {});\n        headers['X-Ably-ClientId'] = platform_1.default.BufferUtils.base64Encode(platform_1.default.BufferUtils.utf8Encode(options.clientId));\n    }\n    if (!('idempotentRestPublishing' in options)) {\n        options.idempotentRestPublishing = true;\n    }\n    if (options.promises && !platform_1.default.Config.Promise) {\n        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Defaults.normaliseOptions', '{promises: true} was specified, but no Promise constructor found; disabling promises');\n        options.promises = false;\n    }\n    var connectivityCheckParams = null;\n    var connectivityCheckUrl = options.connectivityCheckUrl;\n    if (options.connectivityCheckUrl) {\n        var _a = options.connectivityCheckUrl.split('?'), uri = _a[0], qs = _a[1];\n        connectivityCheckParams = qs ? Utils.parseQueryString(qs) : {};\n        if (uri.indexOf('://') === -1) {\n            uri = 'https://' + uri;\n        }\n        connectivityCheckUrl = uri;\n    }\n    return tslib_1.__assign(tslib_1.__assign({}, options), { useBinaryProtocol: 'useBinaryProtocol' in options\n            ? platform_1.default.Config.supportsBinary && options.useBinaryProtocol\n            : platform_1.default.Config.preferBinary, realtimeHost: realtimeHost, restHost: restHost, maxMessageSize: options.maxMessageSize || Defaults.maxMessageSize, timeouts: timeouts, connectivityCheckParams: connectivityCheckParams, connectivityCheckUrl: connectivityCheckUrl });\n}\nexports.normaliseOptions = normaliseOptions;\nexports.default = Defaults;\nfunction getDefaults(platformDefaults) {\n    return Object.assign(Defaults, platformDefaults);\n}\nexports.getDefaults = getDefaults;\n\n\n/***/ }),\n/* 9 */\n/***/ (function(module, exports, __nested_webpack_require_96658__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_96658__(0);\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_96658__(3));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_96658__(2));\nvar errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_96658__(4));\nvar Utils = tslib_1.__importStar(__nested_webpack_require_96658__(1));\nfunction normaliseContext(context) {\n    if (!context || !context.channelOptions) {\n        return {\n            channelOptions: context,\n            plugins: {},\n            baseEncodedPreviousPayload: undefined,\n        };\n    }\n    return context;\n}\nfunction normalizeCipherOptions(options) {\n    if (options && options.cipher) {\n        if (!platform_1.default.Crypto)\n            throw new Error('Encryption not enabled; use ably.encryption.js instead');\n        var cipher = platform_1.default.Crypto.getCipher(options.cipher);\n        return {\n            cipher: cipher.cipherParams,\n            channelCipher: cipher.cipher,\n        };\n    }\n    return options !== null && options !== void 0 ? options : {};\n}\nfunction getMessageSize(msg) {\n    var size = 0;\n    if (msg.name) {\n        size += msg.name.length;\n    }\n    if (msg.clientId) {\n        size += msg.clientId.length;\n    }\n    if (msg.extras) {\n        size += JSON.stringify(msg.extras).length;\n    }\n    if (msg.data) {\n        size += Utils.dataSizeBytes(msg.data);\n    }\n    return size;\n}\nvar Message = /** @class */ (function () {\n    function Message() {\n    }\n    /**\n     * Overload toJSON() to intercept JSON.stringify()\n     * @return {*}\n     */\n    Message.prototype.toJSON = function () {\n        /* encode data to base64 if present and we're returning real JSON;\n         * although msgpack calls toJSON(), we know it is a stringify()\n         * call if it has a non-empty arguments list */\n        var encoding = this.encoding;\n        var data = this.data;\n        if (data && platform_1.default.BufferUtils.isBuffer(data)) {\n            if (arguments.length > 0) {\n                /* stringify call */\n                encoding = encoding ? encoding + '/base64' : 'base64';\n                data = platform_1.default.BufferUtils.base64Encode(data);\n            }\n            else {\n                /* Called by msgpack. toBuffer returns a datatype understandable by\n                 * that platform's msgpack implementation (Buffer in node, Uint8Array\n                 * in browsers) */\n                data = platform_1.default.BufferUtils.toBuffer(data);\n            }\n        }\n        return {\n            name: this.name,\n            id: this.id,\n            clientId: this.clientId,\n            connectionId: this.connectionId,\n            connectionKey: this.connectionKey,\n            extras: this.extras,\n            encoding: encoding,\n            data: data,\n        };\n    };\n    Message.prototype.toString = function () {\n        var result = '[Message';\n        if (this.name)\n            result += '; name=' + this.name;\n        if (this.id)\n            result += '; id=' + this.id;\n        if (this.timestamp)\n            result += '; timestamp=' + this.timestamp;\n        if (this.clientId)\n            result += '; clientId=' + this.clientId;\n        if (this.connectionId)\n            result += '; connectionId=' + this.connectionId;\n        if (this.encoding)\n            result += '; encoding=' + this.encoding;\n        if (this.extras)\n            result += '; extras =' + JSON.stringify(this.extras);\n        if (this.data) {\n            if (typeof this.data == 'string')\n                result += '; data=' + this.data;\n            else if (platform_1.default.BufferUtils.isBuffer(this.data))\n                result += '; data (buffer)=' + platform_1.default.BufferUtils.base64Encode(this.data);\n            else\n                result += '; data (json)=' + JSON.stringify(this.data);\n        }\n        if (this.extras)\n            result += '; extras=' + JSON.stringify(this.extras);\n        result += ']';\n        return result;\n    };\n    Message.encrypt = function (msg, options, callback) {\n        var data = msg.data, encoding = msg.encoding, cipher = options.channelCipher;\n        encoding = encoding ? encoding + '/' : '';\n        if (!platform_1.default.BufferUtils.isBuffer(data)) {\n            data = platform_1.default.BufferUtils.utf8Encode(String(data));\n            encoding = encoding + 'utf-8/';\n        }\n        cipher.encrypt(data, function (err, data) {\n            if (err) {\n                callback(err);\n                return;\n            }\n            msg.data = data;\n            msg.encoding = encoding + 'cipher+' + cipher.algorithm;\n            callback(null, msg);\n        });\n    };\n    Message.encode = function (msg, options, callback) {\n        var data = msg.data;\n        var nativeDataType = typeof data == 'string' || platform_1.default.BufferUtils.isBuffer(data) || data === null || data === undefined;\n        if (!nativeDataType) {\n            if (Utils.isObject(data) || Utils.isArray(data)) {\n                msg.data = JSON.stringify(data);\n                msg.encoding = msg.encoding ? msg.encoding + '/json' : 'json';\n            }\n            else {\n                throw new errorinfo_1.default('Data type is unsupported', 40013, 400);\n            }\n        }\n        if (options != null && options.cipher) {\n            Message.encrypt(msg, options, callback);\n        }\n        else {\n            callback(null, msg);\n        }\n    };\n    Message.encodeArray = function (messages, options, callback) {\n        var processed = 0;\n        for (var i = 0; i < messages.length; i++) {\n            Message.encode(messages[i], options, function (err) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n                processed++;\n                if (processed == messages.length) {\n                    callback(null, messages);\n                }\n            });\n        }\n    };\n    Message.decode = function (message, inputContext) {\n        var context = normaliseContext(inputContext);\n        var lastPayload = message.data;\n        var encoding = message.encoding;\n        if (encoding) {\n            var xforms = encoding.split('/');\n            var lastProcessedEncodingIndex = void 0, encodingsToProcess = xforms.length, data = message.data;\n            var xform = '';\n            try {\n                while ((lastProcessedEncodingIndex = encodingsToProcess) > 0) {\n                    // eslint-disable-next-line security/detect-unsafe-regex\n                    var match = xforms[--encodingsToProcess].match(/([-\\w]+)(\\+([\\w-]+))?/);\n                    if (!match)\n                        break;\n                    xform = match[1];\n                    switch (xform) {\n                        case 'base64':\n                            data = platform_1.default.BufferUtils.base64Decode(String(data));\n                            if (lastProcessedEncodingIndex == xforms.length) {\n                                lastPayload = data;\n                            }\n                            continue;\n                        case 'utf-8':\n                            data = platform_1.default.BufferUtils.utf8Decode(data);\n                            continue;\n                        case 'json':\n                            data = JSON.parse(data);\n                            continue;\n                        case 'cipher':\n                            if (context.channelOptions != null &&\n                                context.channelOptions.cipher &&\n                                context.channelOptions.channelCipher) {\n                                var xformAlgorithm = match[3], cipher = context.channelOptions.channelCipher;\n                                /* don't attempt to decrypt unless the cipher params are compatible */\n                                if (xformAlgorithm != cipher.algorithm) {\n                                    throw new Error('Unable to decrypt message with given cipher; incompatible cipher params');\n                                }\n                                data = cipher.decrypt(data);\n                                continue;\n                            }\n                            else {\n                                throw new Error('Unable to decrypt message; not an encrypted channel');\n                            }\n                        case 'vcdiff':\n                            if (!context.plugins || !context.plugins.vcdiff) {\n                                throw new errorinfo_1.default('Missing Vcdiff decoder (https://github.com/ably-forks/vcdiff-decoder)', 40019, 400);\n                            }\n                            if (typeof Uint8Array === 'undefined') {\n                                throw new errorinfo_1.default('Delta decoding not supported on this browser (need ArrayBuffer & Uint8Array)', 40020, 400);\n                            }\n                            try {\n                                var deltaBase = context.baseEncodedPreviousPayload;\n                                if (typeof deltaBase === 'string') {\n                                    deltaBase = platform_1.default.BufferUtils.utf8Encode(deltaBase);\n                                }\n                                /* vcdiff expects Uint8Arrays, can't copy with ArrayBuffers. (also, if we\n                                 * don't have a TextDecoder, deltaBase might be a WordArray here, so need\n                                 * to process it into a buffer anyway) */\n                                deltaBase = platform_1.default.BufferUtils.toBuffer(deltaBase);\n                                data = platform_1.default.BufferUtils.toBuffer(data);\n                                data = platform_1.default.BufferUtils.typedArrayToBuffer(context.plugins.vcdiff.decode(data, deltaBase));\n                                lastPayload = data;\n                            }\n                            catch (e) {\n                                throw new errorinfo_1.default('Vcdiff delta decode failed with ' + e, 40018, 400);\n                            }\n                            continue;\n                        default:\n                            throw new Error('Unknown encoding');\n                    }\n                }\n            }\n            catch (e) {\n                var err = e;\n                throw new errorinfo_1.default('Error processing the ' + xform + ' encoding, decoder returned â€˜' + err.message + 'â€™', err.code || 40013, 400);\n            }\n            finally {\n                message.encoding =\n                    lastProcessedEncodingIndex <= 0 ? null : xforms.slice(0, lastProcessedEncodingIndex).join('/');\n                message.data = data;\n            }\n        }\n        context.baseEncodedPreviousPayload = lastPayload;\n    };\n    Message.fromResponseBody = function (body, options, format) {\n        if (format) {\n            body = Utils.decodeBody(body, format);\n        }\n        for (var i = 0; i < body.length; i++) {\n            var msg = (body[i] = Message.fromValues(body[i]));\n            try {\n                Message.decode(msg, options);\n            }\n            catch (e) {\n                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Message.fromResponseBody()', e.toString());\n            }\n        }\n        return body;\n    };\n    Message.fromValues = function (values) {\n        return Object.assign(new Message(), values);\n    };\n    Message.fromValuesArray = function (values) {\n        var count = values.length, result = new Array(count);\n        for (var i = 0; i < count; i++)\n            result[i] = Message.fromValues(values[i]);\n        return result;\n    };\n    Message.fromEncoded = function (encoded, inputOptions) {\n        var msg = Message.fromValues(encoded);\n        var options = normalizeCipherOptions(inputOptions !== null && inputOptions !== void 0 ? inputOptions : null);\n        /* if decoding fails at any point, catch and return the message decoded to\n         * the fullest extent possible */\n        try {\n            Message.decode(msg, options);\n        }\n        catch (e) {\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Message.fromEncoded()', e.toString());\n        }\n        return msg;\n    };\n    Message.fromEncodedArray = function (encodedArray, options) {\n        return encodedArray.map(function (encoded) {\n            return Message.fromEncoded(encoded, options);\n        });\n    };\n    /* This should be called on encode()d (and encrypt()d) Messages (as it\n     * assumes the data is a string or buffer) */\n    Message.getMessagesSize = function (messages) {\n        var msg, total = 0;\n        for (var i = 0; i < messages.length; i++) {\n            msg = messages[i];\n            total += msg.size || (msg.size = getMessageSize(msg));\n        }\n        return total;\n    };\n    Message.serialize = Utils.encodeBody;\n    return Message;\n}());\nexports.default = Message;\n\n\n/***/ }),\n/* 10 */\n/***/ (function(module, exports, __nested_webpack_require_109721__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_109721__(0);\nvar Utils = tslib_1.__importStar(__nested_webpack_require_109721__(1));\nvar errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_109721__(4));\nvar message_1 = tslib_1.__importDefault(__nested_webpack_require_109721__(9));\nvar presencemessage_1 = tslib_1.__importDefault(__nested_webpack_require_109721__(15));\nvar actions = {\n    HEARTBEAT: 0,\n    ACK: 1,\n    NACK: 2,\n    CONNECT: 3,\n    CONNECTED: 4,\n    DISCONNECT: 5,\n    DISCONNECTED: 6,\n    CLOSE: 7,\n    CLOSED: 8,\n    ERROR: 9,\n    ATTACH: 10,\n    ATTACHED: 11,\n    DETACH: 12,\n    DETACHED: 13,\n    PRESENCE: 14,\n    MESSAGE: 15,\n    SYNC: 16,\n    AUTH: 17,\n    ACTIVATE: 18,\n};\nvar ActionName = [];\nObject.keys(actions).forEach(function (name) {\n    ActionName[actions[name]] = name;\n});\nvar flags = {\n    /* Channel attach state flags */\n    HAS_PRESENCE: 1 << 0,\n    HAS_BACKLOG: 1 << 1,\n    RESUMED: 1 << 2,\n    TRANSIENT: 1 << 4,\n    ATTACH_RESUME: 1 << 5,\n    /* Channel mode flags */\n    PRESENCE: 1 << 16,\n    PUBLISH: 1 << 17,\n    SUBSCRIBE: 1 << 18,\n    PRESENCE_SUBSCRIBE: 1 << 19,\n};\nvar flagNames = Object.keys(flags);\nflags.MODE_ALL = flags.PRESENCE | flags.PUBLISH | flags.SUBSCRIBE | flags.PRESENCE_SUBSCRIBE;\nfunction toStringArray(array) {\n    var result = [];\n    if (array) {\n        for (var i = 0; i < array.length; i++) {\n            result.push(array[i].toString());\n        }\n    }\n    return '[ ' + result.join(', ') + ' ]';\n}\nvar simpleAttributes = 'id channel channelSerial connectionId count msgSerial timestamp'.split(' ');\nvar ProtocolMessage = /** @class */ (function () {\n    function ProtocolMessage() {\n        var _this = this;\n        this.hasFlag = function (flag) {\n            return (_this.flags & flags[flag]) > 0;\n        };\n    }\n    ProtocolMessage.prototype.setFlag = function (flag) {\n        return (this.flags = this.flags | flags[flag]);\n    };\n    ProtocolMessage.prototype.getMode = function () {\n        return this.flags && this.flags & flags.MODE_ALL;\n    };\n    ProtocolMessage.prototype.encodeModesToFlags = function (modes) {\n        var _this = this;\n        modes.forEach(function (mode) { return _this.setFlag(mode); });\n    };\n    ProtocolMessage.prototype.decodeModesFromFlags = function () {\n        var _this = this;\n        var modes = [];\n        ProtocolMessage.channelModes.forEach(function (mode) {\n            if (_this.hasFlag(mode)) {\n                modes.push(mode);\n            }\n        });\n        return modes.length > 0 ? modes : undefined;\n    };\n    ProtocolMessage.fromValues = function (values) {\n        return Object.assign(new ProtocolMessage(), values);\n    };\n    ProtocolMessage.Action = actions;\n    ProtocolMessage.channelModes = ['PRESENCE', 'PUBLISH', 'SUBSCRIBE', 'PRESENCE_SUBSCRIBE'];\n    ProtocolMessage.ActionName = ActionName;\n    ProtocolMessage.serialize = Utils.encodeBody;\n    ProtocolMessage.deserialize = function (serialized, format) {\n        var deserialized = Utils.decodeBody(serialized, format);\n        return ProtocolMessage.fromDeserialized(deserialized);\n    };\n    ProtocolMessage.fromDeserialized = function (deserialized) {\n        var error = deserialized.error;\n        if (error)\n            deserialized.error = errorinfo_1.default.fromValues(error);\n        var messages = deserialized.messages;\n        if (messages)\n            for (var i = 0; i < messages.length; i++)\n                messages[i] = message_1.default.fromValues(messages[i]);\n        var presence = deserialized.presence;\n        if (presence)\n            for (var i = 0; i < presence.length; i++)\n                presence[i] = presencemessage_1.default.fromValues(presence[i], true);\n        return Object.assign(new ProtocolMessage(), deserialized);\n    };\n    ProtocolMessage.stringify = function (msg) {\n        var result = '[ProtocolMessage';\n        if (msg.action !== undefined)\n            result += '; action=' + ProtocolMessage.ActionName[msg.action] || 0;\n        var attribute;\n        for (var attribIndex = 0; attribIndex < simpleAttributes.length; attribIndex++) {\n            attribute = simpleAttributes[attribIndex];\n            if (msg[attribute] !== undefined)\n                result += '; ' + attribute + '=' + msg[attribute];\n        }\n        if (msg.messages)\n            result += '; messages=' + toStringArray(message_1.default.fromValuesArray(msg.messages));\n        if (msg.presence)\n            result += '; presence=' + toStringArray(presencemessage_1.default.fromValuesArray(msg.presence));\n        if (msg.error)\n            result += '; error=' + errorinfo_1.default.fromValues(msg.error).toString();\n        if (msg.auth && msg.auth.accessToken)\n            result += '; token=' + msg.auth.accessToken;\n        if (msg.flags)\n            result += '; flags=' + flagNames.filter(msg.hasFlag).join(',');\n        if (msg.params) {\n            var stringifiedParams_1 = '';\n            Utils.forInOwnNonNullProperties(msg.params, function (prop) {\n                if (stringifiedParams_1.length > 0) {\n                    stringifiedParams_1 += '; ';\n                }\n                stringifiedParams_1 += prop + '=' + msg.params[prop];\n            });\n            if (stringifiedParams_1.length > 0) {\n                result += '; params=[' + stringifiedParams_1 + ']';\n            }\n        }\n        result += ']';\n        return result;\n    };\n    return ProtocolMessage;\n}());\nexports.default = ProtocolMessage;\n\n\n/***/ }),\n/* 11 */\n/***/ (function(module, exports, __nested_webpack_require_115275__) {\n\n;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__nested_webpack_require_115275__(6));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_enc = C.enc;\n\n\t    /**\n\t     * Base64 encoding strategy.\n\t     */\n\t    var Base64 = C_enc.Base64 = {\n\t        /**\n\t         * Converts a word array to a Base64 string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The Base64 string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var base64String = CryptoJS.enc.Base64.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\t            var map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\n\t            // Clamp excess bits\n\t            wordArray.clamp();\n\n\t            // Convert\n\t            var base64Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 3) {\n\t                var byte1 = (words[i >>> 2]       >>> (24 - (i % 4) * 8))       & 0xff;\n\t                var byte2 = (words[(i + 1) >>> 2] >>> (24 - ((i + 1) % 4) * 8)) & 0xff;\n\t                var byte3 = (words[(i + 2) >>> 2] >>> (24 - ((i + 2) % 4) * 8)) & 0xff;\n\n\t                var triplet = (byte1 << 16) | (byte2 << 8) | byte3;\n\n\t                for (var j = 0; (j < 4) && (i + j * 0.75 < sigBytes); j++) {\n\t                    base64Chars.push(map.charAt((triplet >>> (6 * (3 - j))) & 0x3f));\n\t                }\n\t            }\n\n\t            // Add padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                while (base64Chars.length % 4) {\n\t                    base64Chars.push(paddingChar);\n\t                }\n\t            }\n\n\t            return base64Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a Base64 string to a word array.\n\t         *\n\t         * @param {string} base64Str The Base64 string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Base64.parse(base64String);\n\t         */\n\t        parse: function (base64Str) {\n\t            // Shortcuts\n\t            var base64StrLength = base64Str.length;\n\t            var map = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';\n\t            var reverseMap = this._reverseMap;\n\n\t            if (!reverseMap) {\n\t                    reverseMap = this._reverseMap = [];\n\t                    for (var j = 0; j < map.length; j++) {\n\t                        reverseMap[map.charCodeAt(j)] = j;\n\t                    }\n\t            }\n\n\t            // Ignore padding\n\t            var paddingChar = map.charAt(64);\n\t            if (paddingChar) {\n\t                var paddingIndex = base64Str.indexOf(paddingChar);\n\t                if (paddingIndex !== -1) {\n\t                    base64StrLength = paddingIndex;\n\t                }\n\t            }\n\n\t            // Convert\n\t            return parseLoop(base64Str, base64StrLength, reverseMap);\n\n\t        }\n\t    };\n\n\t    function parseLoop(base64Str, base64StrLength, reverseMap) {\n\t      var words = [];\n\t      var nBytes = 0;\n\t      for (var i = 0; i < base64StrLength; i++) {\n\t          if (i % 4) {\n\t              var bits1 = reverseMap[base64Str.charCodeAt(i - 1)] << ((i % 4) * 2);\n\t              var bits2 = reverseMap[base64Str.charCodeAt(i)] >>> (6 - (i % 4) * 2);\n\t              var bitsCombined = bits1 | bits2;\n\t              words[nBytes >>> 2] |= bitsCombined << (24 - (nBytes % 4) * 8);\n\t              nBytes++;\n\t          }\n\t      }\n\t      return WordArray.create(words, nBytes);\n\t    }\n\t}());\n\n\n\treturn CryptoJS.enc.Base64;\n\n}));\n\n/***/ }),\n/* 12 */\n/***/ (function(module, exports, __nested_webpack_require_119298__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_119298__(0);\nvar Utils = tslib_1.__importStar(__nested_webpack_require_119298__(1));\nvar protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_119298__(10));\nvar transport_1 = tslib_1.__importDefault(__nested_webpack_require_119298__(26));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_119298__(2));\nvar defaults_1 = tslib_1.__importDefault(__nested_webpack_require_119298__(8));\nvar connectionerrors_1 = tslib_1.__importDefault(__nested_webpack_require_119298__(20));\nvar auth_1 = tslib_1.__importDefault(__nested_webpack_require_119298__(17));\nvar errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_119298__(4));\nvar XHRStates_1 = tslib_1.__importDefault(__nested_webpack_require_119298__(21));\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_119298__(3));\n/* TODO: can remove once realtime sends protocol message responses for comet errors */\nfunction shouldBeErrorAction(err) {\n    var UNRESOLVABLE_ERROR_CODES = [80015, 80017, 80030];\n    if (err.code) {\n        if (auth_1.default.isTokenErr(err))\n            return false;\n        if (Utils.arrIn(UNRESOLVABLE_ERROR_CODES, err.code))\n            return true;\n        return err.code >= 40000 && err.code < 50000;\n    }\n    else {\n        /* Likely a network or transport error of some kind. Certainly not fatal to the connection */\n        return false;\n    }\n}\nfunction protocolMessageFromRawError(err) {\n    /* err will be either a legacy (non-protocolmessage) comet error response\n     * (which will have an err.code), or a xhr/network error (which won't). */\n    if (shouldBeErrorAction(err)) {\n        return [protocolmessage_1.default.fromValues({ action: protocolmessage_1.default.Action.ERROR, error: err })];\n    }\n    else {\n        return [protocolmessage_1.default.fromValues({ action: protocolmessage_1.default.Action.DISCONNECTED, error: err })];\n    }\n}\n/*\n * A base comet transport class\n */\nvar CometTransport = /** @class */ (function (_super) {\n    tslib_1.__extends(CometTransport, _super);\n    function CometTransport(connectionManager, auth, params) {\n        var _this = _super.call(this, connectionManager, auth, params, /* binary not supported for comet so force JSON protocol */ true) || this;\n        /* For comet, we could do the auth update by aborting the current recv and\n         * starting a new one with the new token, that'd be sufficient for realtime.\n         * Problem is JSONP - you can't cancel truly abort a recv once started. So\n         * we need to send an AUTH for jsonp. In which case it's simpler to keep all\n         * comet transports the same and do it for all of them. So we send the AUTH\n         * instead, and don't need to abort the recv */\n        _this.onAuthUpdated = function (tokenDetails) {\n            _this.authParams = { access_token: tokenDetails.token };\n        };\n        _this.stream = 'stream' in params ? params.stream : true;\n        _this.sendRequest = null;\n        _this.recvRequest = null;\n        _this.pendingCallback = null;\n        _this.pendingItems = null;\n        return _this;\n    }\n    CometTransport.prototype.connect = function () {\n        var _this = this;\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.connect()', 'starting');\n        transport_1.default.prototype.connect.call(this);\n        var params = this.params;\n        var options = params.options;\n        var host = defaults_1.default.getHost(options, params.host);\n        var port = defaults_1.default.getPort(options);\n        var cometScheme = options.tls ? 'https://' : 'http://';\n        this.baseUri = cometScheme + host + ':' + port + '/comet/';\n        var connectUri = this.baseUri + 'connect';\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.connect()', 'uri: ' + connectUri);\n        this.auth.getAuthParams(function (err, authParams) {\n            if (err) {\n                _this.disconnect(err);\n                return;\n            }\n            if (_this.isDisposed) {\n                return;\n            }\n            _this.authParams = authParams;\n            var connectParams = _this.params.getConnectParams(authParams);\n            if ('stream' in connectParams)\n                _this.stream = connectParams.stream;\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.connect()', 'connectParams:' + Utils.toQueryString(connectParams));\n            /* this will be the 'recvRequest' so this connection can stream messages */\n            var preconnected = false;\n            var connectRequest = (_this.recvRequest = _this.createRequest(connectUri, null, connectParams, null, _this.stream ? XHRStates_1.default.REQ_RECV_STREAM : XHRStates_1.default.REQ_RECV));\n            connectRequest.on('data', function (data) {\n                if (!_this.recvRequest) {\n                    /* the transport was disposed before we connected */\n                    return;\n                }\n                if (!preconnected) {\n                    preconnected = true;\n                    _this.emit('preconnect');\n                }\n                _this.onData(data);\n            });\n            connectRequest.on('complete', function (err) {\n                if (!_this.recvRequest) {\n                    /* the transport was disposed before we connected */\n                    err = err || new errorinfo_1.default('Request cancelled', 80003, 400);\n                }\n                _this.recvRequest = null;\n                /* Connect request may complete without a emitting 'data' event since that is not\n                 * emitted for e.g. a non-streamed error response. Still implies preconnect. */\n                if (!preconnected && !err) {\n                    preconnected = true;\n                    _this.emit('preconnect');\n                }\n                _this.onActivity();\n                if (err) {\n                    if (err.code) {\n                        /* A protocol error received from realtime. TODO: once realtime\n                         * consistendly sends errors wrapped in protocol messages, should be\n                         * able to remove this */\n                        _this.onData(protocolMessageFromRawError(err));\n                    }\n                    else {\n                        /* A network/xhr error. Don't bother wrapping in a protocol message,\n                         * just disconnect the transport */\n                        _this.disconnect(err);\n                    }\n                    return;\n                }\n                platform_1.default.Config.nextTick(function () {\n                    _this.recv();\n                });\n            });\n            connectRequest.exec();\n        });\n    };\n    CometTransport.prototype.requestClose = function () {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.requestClose()');\n        this._requestCloseOrDisconnect(true);\n    };\n    CometTransport.prototype.requestDisconnect = function () {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.requestDisconnect()');\n        this._requestCloseOrDisconnect(false);\n    };\n    CometTransport.prototype._requestCloseOrDisconnect = function (closing) {\n        var _this = this;\n        var closeOrDisconnectUri = closing ? this.closeUri : this.disconnectUri;\n        if (closeOrDisconnectUri) {\n            var request = this.createRequest(closeOrDisconnectUri, null, this.authParams, null, XHRStates_1.default.REQ_SEND);\n            request.on('complete', function (err) {\n                if (err) {\n                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'CometTransport.request' + (closing ? 'Close()' : 'Disconnect()'), 'request returned err = ' + Utils.inspectError(err));\n                    _this.finish('disconnected', err);\n                }\n            });\n            request.exec();\n        }\n    };\n    CometTransport.prototype.dispose = function () {\n        var _this = this;\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.dispose()', '');\n        if (!this.isDisposed) {\n            this.isDisposed = true;\n            if (this.recvRequest) {\n                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'CometTransport.dispose()', 'aborting recv request');\n                this.recvRequest.abort();\n                this.recvRequest = null;\n            }\n            /* In almost all cases the transport will be finished before it's\n             * disposed. Finish here just to make sure. */\n            this.finish('disconnected', connectionerrors_1.default.disconnected());\n            platform_1.default.Config.nextTick(function () {\n                _this.emit('disposed');\n            });\n        }\n    };\n    CometTransport.prototype.onConnect = function (message) {\n        var _a;\n        /* if this transport has been disposed whilst awaiting connection, do nothing */\n        if (this.isDisposed) {\n            return;\n        }\n        /* the connectionKey in a comet connected response is really\n         * <instId>-<connectionKey> */\n        var connectionStr = (_a = message.connectionDetails) === null || _a === void 0 ? void 0 : _a.connectionKey;\n        transport_1.default.prototype.onConnect.call(this, message);\n        var baseConnectionUri = this.baseUri + connectionStr;\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'CometTransport.onConnect()', 'baseUri = ' + baseConnectionUri);\n        this.sendUri = baseConnectionUri + '/send';\n        this.recvUri = baseConnectionUri + '/recv';\n        this.closeUri = baseConnectionUri + '/close';\n        this.disconnectUri = baseConnectionUri + '/disconnect';\n    };\n    CometTransport.prototype.send = function (message) {\n        if (this.sendRequest) {\n            /* there is a pending send, so queue this message */\n            this.pendingItems = this.pendingItems || [];\n            this.pendingItems.push(message);\n            return;\n        }\n        /* send this, plus any pending, now */\n        var pendingItems = this.pendingItems || [];\n        pendingItems.push(message);\n        this.pendingItems = null;\n        this.sendItems(pendingItems);\n    };\n    CometTransport.prototype.sendAnyPending = function () {\n        var pendingItems = this.pendingItems;\n        if (!pendingItems) {\n            return;\n        }\n        this.pendingItems = null;\n        this.sendItems(pendingItems);\n    };\n    CometTransport.prototype.sendItems = function (items) {\n        var _this = this;\n        var sendRequest = (this.sendRequest = this.createRequest(this.sendUri, null, this.authParams, this.encodeRequest(items), XHRStates_1.default.REQ_SEND));\n        sendRequest.on('complete', function (err, data) {\n            if (err)\n                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'CometTransport.sendItems()', 'on complete: err = ' + Utils.inspectError(err));\n            _this.sendRequest = null;\n            /* the result of the request, even if a nack, is usually a protocol response\n             * contained in the data. An err is anomolous, and indicates some issue with the\n             * network,transport, or connection */\n            if (err) {\n                if (err.code) {\n                    /* A protocol error received from realtime. TODO: once realtime\n                     * consistendly sends errors wrapped in protocol messages, should be\n                     * able to remove this */\n                    _this.onData(protocolMessageFromRawError(err));\n                }\n                else {\n                    /* A network/xhr error. Don't bother wrapping in a protocol message,\n                     * just disconnect the transport */\n                    _this.disconnect(err);\n                }\n                return;\n            }\n            if (data) {\n                _this.onData(data);\n            }\n            if (_this.pendingItems) {\n                platform_1.default.Config.nextTick(function () {\n                    /* If there's a new send request by now, any pending items will have\n                     * been picked up by that; any new ones added since then will be\n                     * picked up after that one completes */\n                    if (!_this.sendRequest) {\n                        _this.sendAnyPending();\n                    }\n                });\n            }\n        });\n        sendRequest.exec();\n    };\n    CometTransport.prototype.recv = function () {\n        var _this = this;\n        /* do nothing if there is an active request, which might be streaming */\n        if (this.recvRequest)\n            return;\n        /* If we're no longer connected, do nothing */\n        if (!this.isConnected)\n            return;\n        var recvRequest = (this.recvRequest = this.createRequest(this.recvUri, null, this.authParams, null, this.stream ? XHRStates_1.default.REQ_RECV_STREAM : XHRStates_1.default.REQ_RECV_POLL));\n        recvRequest.on('data', function (data) {\n            _this.onData(data);\n        });\n        recvRequest.on('complete', function (err) {\n            _this.recvRequest = null;\n            /* A request completing must be considered activity, as realtime sends\n             * heartbeats every 15s since a request began, not every 15s absolutely */\n            _this.onActivity();\n            if (err) {\n                if (err.code) {\n                    /* A protocol error received from realtime. TODO: once realtime\n                     * consistently sends errors wrapped in protocol messages, should be\n                     * able to remove this */\n                    _this.onData(protocolMessageFromRawError(err));\n                }\n                else {\n                    /* A network/xhr error. Don't bother wrapping in a protocol message,\n                     * just disconnect the transport */\n                    _this.disconnect(err);\n                }\n                return;\n            }\n            platform_1.default.Config.nextTick(function () {\n                _this.recv();\n            });\n        });\n        recvRequest.exec();\n    };\n    CometTransport.prototype.onData = function (responseData) {\n        try {\n            var items = this.decodeResponse(responseData);\n            if (items && items.length)\n                for (var i = 0; i < items.length; i++)\n                    this.onProtocolMessage(protocolmessage_1.default.fromDeserialized(items[i]));\n        }\n        catch (e) {\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'CometTransport.onData()', 'Unexpected exception handing channel event: ' + e.stack);\n        }\n    };\n    CometTransport.prototype.encodeRequest = function (requestItems) {\n        return JSON.stringify(requestItems);\n    };\n    CometTransport.prototype.decodeResponse = function (responseData) {\n        if (typeof responseData == 'string')\n            return JSON.parse(responseData);\n        return responseData;\n    };\n    return CometTransport;\n}(transport_1.default));\nexports.default = CometTransport;\n\n\n/***/ }),\n/* 13 */\n/***/ (function(module, exports) {\n\nvar g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n\n\n/***/ }),\n/* 14 */\n/***/ (function(module, exports, __nested_webpack_require_134922__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_134922__(0);\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_134922__(3));\nvar Utils = tslib_1.__importStar(__nested_webpack_require_134922__(1));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_134922__(2));\nvar auth_1 = tslib_1.__importDefault(__nested_webpack_require_134922__(17));\nvar HttpMethods_1 = tslib_1.__importDefault(__nested_webpack_require_134922__(18));\nvar errorinfo_1 = __nested_webpack_require_134922__(4);\nfunction withAuthDetails(rest, headers, params, errCallback, opCallback) {\n    if (rest.http.supportsAuthHeaders) {\n        rest.auth.getAuthHeaders(function (err, authHeaders) {\n            if (err)\n                errCallback(err);\n            else\n                opCallback(Utils.mixin(authHeaders, headers), params);\n        });\n    }\n    else {\n        rest.auth.getAuthParams(function (err, authParams) {\n            if (err)\n                errCallback(err);\n            else\n                opCallback(headers, Utils.mixin(authParams, params));\n        });\n    }\n}\nfunction unenvelope(callback, format) {\n    return function (err, body, outerHeaders, unpacked, outerStatusCode) {\n        if (err && !body) {\n            callback(err);\n            return;\n        }\n        if (!unpacked) {\n            try {\n                body = Utils.decodeBody(body, format);\n            }\n            catch (e) {\n                if (Utils.isErrorInfoOrPartialErrorInfo(e)) {\n                    callback(e);\n                }\n                else {\n                    callback(new errorinfo_1.PartialErrorInfo(Utils.inspectError(e), null));\n                }\n                return;\n            }\n        }\n        if (!body) {\n            callback(new errorinfo_1.PartialErrorInfo('unenvelope(): Response body is missing', null));\n            return;\n        }\n        var _a = body, wrappedStatusCode = _a.statusCode, response = _a.response, wrappedHeaders = _a.headers;\n        if (wrappedStatusCode === undefined) {\n            /* Envelope already unwrapped by the transport */\n            callback(err, body, outerHeaders, true, outerStatusCode);\n            return;\n        }\n        if (wrappedStatusCode < 200 || wrappedStatusCode >= 300) {\n            /* handle wrapped errors */\n            var wrappedErr = (response && response.error) || err;\n            if (!wrappedErr) {\n                wrappedErr = new Error('Error in unenveloping ' + body);\n                wrappedErr.statusCode = wrappedStatusCode;\n            }\n            callback(wrappedErr, response, wrappedHeaders, true, wrappedStatusCode);\n            return;\n        }\n        callback(err, response, wrappedHeaders, true, wrappedStatusCode);\n    };\n}\nfunction paramString(params) {\n    var paramPairs = [];\n    if (params) {\n        for (var needle in params) {\n            paramPairs.push(needle + '=' + params[needle]);\n        }\n    }\n    return paramPairs.join('&');\n}\nfunction urlFromPathAndParams(path, params) {\n    return path + (params ? '?' : '') + paramString(params);\n}\nfunction logResponseHandler(callback, method, path, params) {\n    return function (err, body, headers, unpacked, statusCode) {\n        if (err) {\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Resource.' + method + '()', 'Received Error; ' + urlFromPathAndParams(path, params) + '; Error: ' + Utils.inspectError(err));\n        }\n        else {\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Resource.' + method + '()', 'Received; ' +\n                urlFromPathAndParams(path, params) +\n                '; Headers: ' +\n                paramString(headers) +\n                '; StatusCode: ' +\n                statusCode +\n                '; Body: ' +\n                (platform_1.default.BufferUtils.isBuffer(body) ? body.toString() : body));\n        }\n        if (callback) {\n            callback(err, body, headers, unpacked, statusCode);\n        }\n    };\n}\nvar Resource = /** @class */ (function () {\n    function Resource() {\n    }\n    Resource.get = function (rest, path, headers, params, envelope, callback) {\n        Resource.do(HttpMethods_1.default.Get, rest, path, null, headers, params, envelope, callback);\n    };\n    Resource.delete = function (rest, path, headers, params, envelope, callback) {\n        Resource.do(HttpMethods_1.default.Delete, rest, path, null, headers, params, envelope, callback);\n    };\n    Resource.post = function (rest, path, body, headers, params, envelope, callback) {\n        Resource.do(HttpMethods_1.default.Post, rest, path, body, headers, params, envelope, callback);\n    };\n    Resource.patch = function (rest, path, body, headers, params, envelope, callback) {\n        Resource.do(HttpMethods_1.default.Patch, rest, path, body, headers, params, envelope, callback);\n    };\n    Resource.put = function (rest, path, body, headers, params, envelope, callback) {\n        Resource.do(HttpMethods_1.default.Put, rest, path, body, headers, params, envelope, callback);\n    };\n    Resource.do = function (method, rest, path, body, headers, params, envelope, callback) {\n        if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {\n            callback = logResponseHandler(callback, method, path, params);\n        }\n        if (envelope) {\n            callback = callback && unenvelope(callback, envelope);\n            (params = params || {})['envelope'] = envelope;\n        }\n        function doRequest(headers, params) {\n            var _a;\n            if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {\n                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Resource.' + method + '()', 'Sending; ' + urlFromPathAndParams(path, params));\n            }\n            if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {\n                var decodedBody = body;\n                if (((_a = headers['content-type']) === null || _a === void 0 ? void 0 : _a.indexOf('msgpack')) > 0) {\n                    try {\n                        decodedBody = platform_1.default.Config.msgpack.decode(body);\n                    }\n                    catch (decodeErr) {\n                        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Resource.' + method + '()', 'Sending MsgPack Decoding Error: ' + Utils.inspectError(decodeErr));\n                    }\n                }\n                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Resource.' + method + '()', 'Sending; ' + urlFromPathAndParams(path, params) + '; Body: ' + decodedBody);\n            }\n            rest.http.do(method, rest, path, headers, body, params, function (err, res, resHeaders, unpacked, statusCode) {\n                if (err && auth_1.default.isTokenErr(err)) {\n                    /* token has expired, so get a new one */\n                    rest.auth.authorize(null, null, function (err) {\n                        if (err) {\n                            callback(err);\n                            return;\n                        }\n                        /* retry ... */\n                        withAuthDetails(rest, headers, params, callback, doRequest);\n                    });\n                    return;\n                }\n                callback(err, res, resHeaders, unpacked, statusCode);\n            });\n        }\n        withAuthDetails(rest, headers, params, callback, doRequest);\n    };\n    return Resource;\n}());\nexports.default = Resource;\n\n\n/***/ }),\n/* 15 */\n/***/ (function(module, exports, __nested_webpack_require_142403__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_142403__(0);\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_142403__(2));\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_142403__(3));\nvar message_1 = tslib_1.__importDefault(__nested_webpack_require_142403__(9));\nvar Utils = tslib_1.__importStar(__nested_webpack_require_142403__(1));\nfunction toActionValue(actionString) {\n    return PresenceMessage.Actions.indexOf(actionString);\n}\nvar PresenceMessage = /** @class */ (function () {\n    function PresenceMessage() {\n    }\n    /* Returns whether this presenceMessage is synthesized, i.e. was not actually\n     * sent by the connection (usually means a leave event sent 15s after a\n     * disconnection). This is useful because synthesized messages cannot be\n     * compared for newness by id lexicographically - RTP2b1\n     */\n    PresenceMessage.prototype.isSynthesized = function () {\n        if (!this.id || !this.connectionId) {\n            return true;\n        }\n        return this.id.substring(this.connectionId.length, 0) !== this.connectionId;\n    };\n    /* RTP2b2 */\n    PresenceMessage.prototype.parseId = function () {\n        if (!this.id)\n            throw new Error('parseId(): Presence message does not contain an id');\n        var parts = this.id.split(':');\n        return {\n            connectionId: parts[0],\n            msgSerial: parseInt(parts[1], 10),\n            index: parseInt(parts[2], 10),\n        };\n    };\n    /**\n     * Overload toJSON() to intercept JSON.stringify()\n     * @return {*}\n     */\n    PresenceMessage.prototype.toJSON = function () {\n        /* encode data to base64 if present and we're returning real JSON;\n         * although msgpack calls toJSON(), we know it is a stringify()\n         * call if it has a non-empty arguments list */\n        var data = this.data;\n        var encoding = this.encoding;\n        if (data && platform_1.default.BufferUtils.isBuffer(data)) {\n            if (arguments.length > 0) {\n                /* stringify call */\n                encoding = encoding ? encoding + '/base64' : 'base64';\n                data = platform_1.default.BufferUtils.base64Encode(data);\n            }\n            else {\n                /* Called by msgpack. toBuffer returns a datatype understandable by\n                 * that platform's msgpack implementation (Buffer in node, Uint8Array\n                 * in browsers) */\n                data = platform_1.default.BufferUtils.toBuffer(data);\n            }\n        }\n        return {\n            id: this.id,\n            clientId: this.clientId,\n            /* Convert presence action back to an int for sending to Ably */\n            action: toActionValue(this.action),\n            data: data,\n            encoding: encoding,\n            extras: this.extras,\n        };\n    };\n    PresenceMessage.prototype.toString = function () {\n        var result = '[PresenceMessage';\n        result += '; action=' + this.action;\n        if (this.id)\n            result += '; id=' + this.id;\n        if (this.timestamp)\n            result += '; timestamp=' + this.timestamp;\n        if (this.clientId)\n            result += '; clientId=' + this.clientId;\n        if (this.connectionId)\n            result += '; connectionId=' + this.connectionId;\n        if (this.encoding)\n            result += '; encoding=' + this.encoding;\n        if (this.data) {\n            if (typeof this.data == 'string')\n                result += '; data=' + this.data;\n            else if (platform_1.default.BufferUtils.isBuffer(this.data))\n                result += '; data (buffer)=' + platform_1.default.BufferUtils.base64Encode(this.data);\n            else\n                result += '; data (json)=' + JSON.stringify(this.data);\n        }\n        if (this.extras) {\n            result += '; extras=' + JSON.stringify(this.extras);\n        }\n        result += ']';\n        return result;\n    };\n    PresenceMessage.fromResponseBody = function (body, options, format) {\n        var messages = [];\n        if (format) {\n            body = Utils.decodeBody(body, format);\n        }\n        for (var i = 0; i < body.length; i++) {\n            var msg = (messages[i] = PresenceMessage.fromValues(body[i], true));\n            try {\n                PresenceMessage.decode(msg, options);\n            }\n            catch (e) {\n                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'PresenceMessage.fromResponseBody()', e.toString());\n            }\n        }\n        return messages;\n    };\n    PresenceMessage.fromValues = function (values, stringifyAction) {\n        if (stringifyAction) {\n            values.action = PresenceMessage.Actions[values.action];\n        }\n        return Object.assign(new PresenceMessage(), values);\n    };\n    PresenceMessage.fromValuesArray = function (values) {\n        var count = values.length, result = new Array(count);\n        for (var i = 0; i < count; i++)\n            result[i] = PresenceMessage.fromValues(values[i]);\n        return result;\n    };\n    PresenceMessage.fromEncoded = function (encoded, options) {\n        var msg = PresenceMessage.fromValues(encoded, true);\n        /* if decoding fails at any point, catch and return the message decoded to\n         * the fullest extent possible */\n        try {\n            PresenceMessage.decode(msg, options !== null && options !== void 0 ? options : {});\n        }\n        catch (e) {\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'PresenceMessage.fromEncoded()', e.toString());\n        }\n        return msg;\n    };\n    PresenceMessage.fromEncodedArray = function (encodedArray, options) {\n        return encodedArray.map(function (encoded) {\n            return PresenceMessage.fromEncoded(encoded, options);\n        });\n    };\n    PresenceMessage.fromData = function (data) {\n        if (data instanceof PresenceMessage) {\n            return data;\n        }\n        return PresenceMessage.fromValues({\n            data: data,\n        });\n    };\n    PresenceMessage.Actions = ['absent', 'present', 'enter', 'leave', 'update'];\n    PresenceMessage.encode = message_1.default.encode;\n    PresenceMessage.decode = message_1.default.decode;\n    PresenceMessage.getMessagesSize = message_1.default.getMessagesSize;\n    return PresenceMessage;\n}());\nexports.default = PresenceMessage;\n\n\n/***/ }),\n/* 16 */\n/***/ (function(module, exports, __nested_webpack_require_148797__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_148797__(0);\nvar Utils = tslib_1.__importStar(__nested_webpack_require_148797__(1));\nvar eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_148797__(7));\nvar errorinfo_1 = tslib_1.__importStar(__nested_webpack_require_148797__(4));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_148797__(2));\nvar defaults_1 = tslib_1.__importDefault(__nested_webpack_require_148797__(8));\nvar XHRStates_1 = tslib_1.__importDefault(__nested_webpack_require_148797__(21));\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_148797__(3));\nfunction isAblyError(responseBody, headers) {\n    return Utils.arrIn(Utils.allToLowerCase(Utils.keysArray(headers)), 'x-ably-errorcode');\n}\nfunction getAblyError(responseBody, headers) {\n    if (isAblyError(responseBody, headers)) {\n        return responseBody.error && errorinfo_1.default.fromValues(responseBody.error);\n    }\n}\nvar noop = function () { };\nvar idCounter = 0;\nvar pendingRequests = {};\nvar isIE = typeof global !== 'undefined' && global.XDomainRequest;\nfunction ieVersion() {\n    var match = navigator.userAgent.toString().match(/MSIE\\s([\\d.]+)/);\n    return match && Number(match[1]);\n}\nfunction needJsonEnvelope() {\n    /* IE 10 xhr bug: http://stackoverflow.com/a/16320339 */\n    var version;\n    return isIE && (version = ieVersion()) && version === 10;\n}\nfunction getHeader(xhr, header) {\n    return xhr.getResponseHeader && xhr.getResponseHeader(header);\n}\n/* Safari mysteriously returns 'Identity' for transfer-encoding when in fact\n * it is 'chunked'. So instead, decide that it is chunked when\n * transfer-encoding is present or content-length is absent.  ('or' because\n * when using http2 streaming, there's no transfer-encoding header, but can\n * still deduce streaming from lack of content-length) */\nfunction isEncodingChunked(xhr) {\n    return (xhr.getResponseHeader && (xhr.getResponseHeader('transfer-encoding') || !xhr.getResponseHeader('content-length')));\n}\nfunction getHeadersAsObject(xhr) {\n    var headerPairs = Utils.trim(xhr.getAllResponseHeaders()).split('\\r\\n');\n    var headers = {};\n    for (var i = 0; i < headerPairs.length; i++) {\n        var parts = headerPairs[i].split(':').map(Utils.trim);\n        headers[parts[0].toLowerCase()] = parts[1];\n    }\n    return headers;\n}\nvar XHRRequest = /** @class */ (function (_super) {\n    tslib_1.__extends(XHRRequest, _super);\n    function XHRRequest(uri, headers, params, body, requestMode, timeouts, method) {\n        var _this = _super.call(this) || this;\n        params = params || {};\n        params.rnd = Utils.cheapRandStr();\n        if (needJsonEnvelope() && !params.envelope)\n            params.envelope = 'json';\n        _this.uri = uri + Utils.toQueryString(params);\n        _this.headers = headers || {};\n        _this.body = body;\n        _this.method = method ? method.toUpperCase() : Utils.isEmptyArg(body) ? 'GET' : 'POST';\n        _this.requestMode = requestMode;\n        _this.timeouts = timeouts;\n        _this.timedOut = false;\n        _this.requestComplete = false;\n        _this.id = String(++idCounter);\n        pendingRequests[_this.id] = _this;\n        return _this;\n    }\n    XHRRequest.createRequest = function (uri, headers, params, body, requestMode, timeouts, method) {\n        /* XHR requests are used either with the context being a realtime\n         * transport, or with timeouts passed in (for when used by a rest client),\n         * or completely standalone.  Use the appropriate timeouts in each case */\n        var _timeouts = timeouts || defaults_1.default.TIMEOUTS;\n        return new XHRRequest(uri, headers, Utils.copy(params), body, requestMode, _timeouts, method);\n    };\n    XHRRequest.prototype.complete = function (err, body, headers, unpacked, statusCode) {\n        if (!this.requestComplete) {\n            this.requestComplete = true;\n            if (!err && body) {\n                this.emit('data', body);\n            }\n            this.emit('complete', err, body, headers, unpacked, statusCode);\n            this.dispose();\n        }\n    };\n    XHRRequest.prototype.abort = function () {\n        this.dispose();\n    };\n    XHRRequest.prototype.exec = function () {\n        var _this = this;\n        var headers = this.headers;\n        var timeout = this.requestMode == XHRStates_1.default.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout, timer = (this.timer = setTimeout(function () {\n            _this.timedOut = true;\n            xhr.abort();\n        }, timeout)), method = this.method, xhr = (this.xhr = new XMLHttpRequest()), accept = headers['accept'];\n        var body = this.body;\n        var responseType = 'text';\n        if (!accept) {\n            // Default to JSON\n            headers['accept'] = 'application/json';\n        }\n        else if (accept.indexOf('application/x-msgpack') === 0) {\n            // Msgpack responses will be typed as ArrayBuffer\n            responseType = 'arraybuffer';\n        }\n        if (body) {\n            var contentType = headers['content-type'] || (headers['content-type'] = 'application/json');\n            if (contentType.indexOf('application/json') > -1 && typeof body != 'string')\n                body = JSON.stringify(body);\n        }\n        // Can probably remove this directive if https://github.com/nodesecurity/eslint-plugin-security/issues/26 is resolved\n        // eslint-disable-next-line security/detect-non-literal-fs-filename\n        xhr.open(method, this.uri, true);\n        xhr.responseType = responseType;\n        if ('authorization' in headers) {\n            xhr.withCredentials = true;\n        }\n        for (var h in headers)\n            xhr.setRequestHeader(h, headers[h]);\n        var errorHandler = function (errorEvent, message, code, statusCode) {\n            var _a;\n            var errorMessage = message + ' (event type: ' + errorEvent.type + ')';\n            if ((_a = _this === null || _this === void 0 ? void 0 : _this.xhr) === null || _a === void 0 ? void 0 : _a.statusText)\n                errorMessage += ', current statusText is ' + _this.xhr.statusText;\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Request.on' + errorEvent.type + '()', errorMessage);\n            _this.complete(new errorinfo_1.PartialErrorInfo(errorMessage, code, statusCode));\n        };\n        xhr.onerror = function (errorEvent) {\n            errorHandler(errorEvent, 'XHR error occurred', null, 400);\n        };\n        xhr.onabort = function (errorEvent) {\n            if (_this.timedOut) {\n                errorHandler(errorEvent, 'Request aborted due to request timeout expiring', null, 408);\n            }\n            else {\n                errorHandler(errorEvent, 'Request cancelled', null, 400);\n            }\n        };\n        xhr.ontimeout = function (errorEvent) {\n            errorHandler(errorEvent, 'Request timed out', null, 408);\n        };\n        var streaming;\n        var statusCode;\n        var successResponse;\n        var streamPos = 0;\n        var unpacked = false;\n        var onResponse = function () {\n            clearTimeout(timer);\n            successResponse = statusCode < 400;\n            if (statusCode == 204) {\n                _this.complete(null, null, null, null, statusCode);\n                return;\n            }\n            streaming = _this.requestMode == XHRStates_1.default.REQ_RECV_STREAM && successResponse && isEncodingChunked(xhr);\n        };\n        var onEnd = function () {\n            var parsedResponse;\n            try {\n                var contentType = getHeader(xhr, 'content-type');\n                /* Be liberal in what we accept; buggy auth servers may respond\n                 * without the correct contenttype, but assume they're still\n                 * responding with json */\n                var json = contentType ? contentType.indexOf('application/json') >= 0 : xhr.responseType == 'text';\n                if (json) {\n                    /* If we requested msgpack but server responded with json, then since\n                     * we set the responseType expecting msgpack, the response will be\n                     * an ArrayBuffer containing json */\n                    var jsonResponseBody = xhr.responseType === 'arraybuffer'\n                        ? platform_1.default.BufferUtils.utf8Decode(xhr.response)\n                        : String(xhr.responseText);\n                    if (jsonResponseBody.length) {\n                        parsedResponse = JSON.parse(jsonResponseBody);\n                    }\n                    else {\n                        parsedResponse = jsonResponseBody;\n                    }\n                    unpacked = true;\n                }\n                else {\n                    parsedResponse = xhr.response;\n                }\n                if (parsedResponse.response !== undefined) {\n                    /* unwrap JSON envelope */\n                    statusCode = parsedResponse.statusCode;\n                    successResponse = statusCode < 400;\n                    headers = parsedResponse.headers;\n                    parsedResponse = parsedResponse.response;\n                }\n                else {\n                    headers = getHeadersAsObject(xhr);\n                }\n            }\n            catch (e) {\n                _this.complete(new errorinfo_1.PartialErrorInfo('Malformed response body from server: ' + e.message, null, 400));\n                return;\n            }\n            /* If response is an array, it's an array of protocol messages -- even if\n             * is contains an error action (hence the nonsuccess statuscode), we can\n             * consider the request to have succeeded, just pass it on to\n             * onProtocolMessage to decide what to do */\n            if (successResponse || Utils.isArray(parsedResponse)) {\n                _this.complete(null, parsedResponse, headers, unpacked, statusCode);\n                return;\n            }\n            var err = getAblyError(parsedResponse, headers);\n            if (!err) {\n                err = new errorinfo_1.PartialErrorInfo('Error response received from server: ' +\n                    statusCode +\n                    ' body was: ' +\n                    platform_1.default.Config.inspect(parsedResponse), null, statusCode);\n            }\n            _this.complete(err, parsedResponse, headers, unpacked, statusCode);\n        };\n        function onProgress() {\n            var responseText = xhr.responseText;\n            var bodyEnd = responseText.length - 1;\n            var idx, chunk;\n            while (streamPos < bodyEnd && (idx = responseText.indexOf('\\n', streamPos)) > -1) {\n                chunk = responseText.slice(streamPos, idx);\n                streamPos = idx + 1;\n                onChunk(chunk);\n            }\n        }\n        var onChunk = function (chunk) {\n            try {\n                chunk = JSON.parse(chunk);\n            }\n            catch (e) {\n                _this.complete(new errorinfo_1.PartialErrorInfo('Malformed response body from server: ' + e.message, null, 400));\n                return;\n            }\n            _this.emit('data', chunk);\n        };\n        var onStreamEnd = function () {\n            onProgress();\n            _this.streamComplete = true;\n            platform_1.default.Config.nextTick(function () {\n                _this.complete();\n            });\n        };\n        xhr.onreadystatechange = function () {\n            var readyState = xhr.readyState;\n            if (readyState < 3)\n                return;\n            if (xhr.status !== 0) {\n                if (statusCode === undefined) {\n                    statusCode = xhr.status;\n                    /* IE returns 1223 for 204: http://bugs.jquery.com/ticket/1450 */\n                    if (statusCode === 1223)\n                        statusCode = 204;\n                    onResponse();\n                }\n                if (readyState == 3 && streaming) {\n                    onProgress();\n                }\n                else if (readyState == 4) {\n                    if (streaming)\n                        onStreamEnd();\n                    else\n                        onEnd();\n                }\n            }\n        };\n        xhr.send(body);\n    };\n    XHRRequest.prototype.dispose = function () {\n        var xhr = this.xhr;\n        if (xhr) {\n            xhr.onreadystatechange = xhr.onerror = xhr.onabort = xhr.ontimeout = noop;\n            this.xhr = null;\n            var timer = this.timer;\n            if (timer) {\n                clearTimeout(timer);\n                this.timer = null;\n            }\n            if (!this.requestComplete)\n                xhr.abort();\n        }\n        delete pendingRequests[this.id];\n    };\n    return XHRRequest;\n}(eventemitter_1.default));\nexports.default = XHRRequest;\n\n/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_148797__(13)))\n\n/***/ }),\n/* 17 */\n/***/ (function(module, exports, __nested_webpack_require_161753__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_161753__(0);\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_161753__(2));\nvar Utils = tslib_1.__importStar(__nested_webpack_require_161753__(1));\nvar multicaster_1 = tslib_1.__importDefault(__nested_webpack_require_161753__(23));\nvar errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_161753__(4));\nvar hmac_sha256_1 = tslib_1.__importDefault(__nested_webpack_require_161753__(45));\nvar enc_base64_1 = __nested_webpack_require_161753__(11);\nvar HttpMethods_1 = tslib_1.__importDefault(__nested_webpack_require_161753__(18));\nvar HttpStatusCodes_1 = tslib_1.__importDefault(__nested_webpack_require_161753__(25));\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_161753__(3));\nvar resource_1 = tslib_1.__importDefault(__nested_webpack_require_161753__(14));\nvar MAX_TOKEN_LENGTH = Math.pow(2, 17);\nfunction noop() { }\nfunction random() {\n    return ('000000' + Math.floor(Math.random() * 1e16)).slice(-16);\n}\nfunction isRealtime(client) {\n    return !!client.connection;\n}\n/* A client auth callback may give errors in any number of formats; normalise to an ErrorInfo or PartialErrorInfo */\nfunction normaliseAuthcallbackError(err) {\n    if (!Utils.isErrorInfoOrPartialErrorInfo(err)) {\n        return new errorinfo_1.default(Utils.inspectError(err), err.code || 40170, err.statusCode || 401);\n    }\n    /* network errors will not have an inherent error code */\n    if (!err.code) {\n        if (err.statusCode === 403) {\n            err.code = 40300;\n        }\n        else {\n            err.code = 40170;\n            /* normalise statusCode to 401 per RSA4e */\n            err.statusCode = 401;\n        }\n    }\n    return err;\n}\nvar hmac = function (text, key) {\n    if (platform_1.default.Config.createHmac) {\n        var inst = platform_1.default.Config.createHmac('SHA256', key);\n        inst.update(text);\n        return inst.digest('base64');\n    }\n    return (0, enc_base64_1.stringify)((0, hmac_sha256_1.default)(text, key));\n};\nfunction c14n(capability) {\n    if (!capability)\n        return '';\n    if (typeof capability == 'string')\n        capability = JSON.parse(capability);\n    var c14nCapability = Object.create(null);\n    var keys = Utils.keysArray(capability, true);\n    if (!keys)\n        return '';\n    keys.sort();\n    for (var i = 0; i < keys.length; i++) {\n        c14nCapability[keys[i]] = capability[keys[i]].sort();\n    }\n    return JSON.stringify(c14nCapability);\n}\nfunction logAndValidateTokenAuthMethod(authOptions) {\n    if (authOptions.authCallback) {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth()', 'using token auth with authCallback');\n    }\n    else if (authOptions.authUrl) {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth()', 'using token auth with authUrl');\n    }\n    else if (authOptions.key) {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth()', 'using token auth with client-side signing');\n    }\n    else if (authOptions.tokenDetails) {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth()', 'using token auth with supplied token only');\n    }\n    else {\n        var msg = 'authOptions must include valid authentication parameters';\n        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth()', msg);\n        throw new Error(msg);\n    }\n}\nfunction basicAuthForced(options) {\n    return 'useTokenAuth' in options && !options.useTokenAuth;\n}\n/* RSA4 */\nfunction useTokenAuth(options) {\n    return (options.useTokenAuth ||\n        (!basicAuthForced(options) && (options.authCallback || options.authUrl || options.token || options.tokenDetails)));\n}\n/* RSA4a */\nfunction noWayToRenew(options) {\n    return !options.key && !options.authCallback && !options.authUrl;\n}\nvar trId = 0;\nfunction getTokenRequestId() {\n    return trId++;\n}\nvar Auth = /** @class */ (function () {\n    function Auth(client, options) {\n        // This initialization is always overwritten and only used to prevent a TypeScript compiler error\n        this.authOptions = {};\n        this.client = client;\n        this.tokenParams = options.defaultTokenParams || {};\n        /* The id of the current token request if one is in progress, else null */\n        this.currentTokenRequestId = null;\n        this.waitingForTokenRequest = null;\n        if (useTokenAuth(options)) {\n            /* Token auth */\n            if (options.key && !hmac) {\n                var msg = 'client-side token request signing not supported';\n                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth()', msg);\n                throw new Error(msg);\n            }\n            if (noWayToRenew(options)) {\n                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth()', 'Warning: library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help');\n            }\n            this._saveTokenOptions(options.defaultTokenParams, options);\n            logAndValidateTokenAuthMethod(this.authOptions);\n        }\n        else {\n            /* Basic auth */\n            if (!options.key) {\n                var msg = 'No authentication options provided; need one of: key, authUrl, or authCallback (or for testing only, token or tokenDetails)';\n                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth()', msg);\n                throw new errorinfo_1.default(msg, 40160, 401);\n            }\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth()', 'anonymous, using basic auth');\n            this._saveBasicOptions(options);\n        }\n    }\n    Auth.prototype.authorize = function (tokenParams, authOptions, callback) {\n        var _this = this;\n        var _authOptions;\n        /* shuffle and normalise arguments as necessary */\n        if (typeof tokenParams == 'function' && !callback) {\n            callback = tokenParams;\n            _authOptions = tokenParams = null;\n        }\n        else if (typeof authOptions == 'function' && !callback) {\n            callback = authOptions;\n            _authOptions = null;\n        }\n        else {\n            _authOptions = authOptions;\n        }\n        if (!callback) {\n            if (this.client.options.promises) {\n                return Utils.promisify(this, 'authorize', arguments);\n            }\n        }\n        /* RSA10a: authorize() call implies token auth. If a key is passed it, we\n         * just check if it doesn't clash and assume we're generating a token from it */\n        if (_authOptions && _authOptions.key && this.authOptions.key !== _authOptions.key) {\n            throw new errorinfo_1.default('Unable to update auth options with incompatible key', 40102, 401);\n        }\n        if (_authOptions && 'force' in _authOptions) {\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.authorize', 'Deprecation warning: specifying {force: true} in authOptions is no longer necessary, authorize() now always gets a new token. Please remove this, as in version 1.0 and later, having a non-null authOptions will overwrite stored library authOptions, which may not be what you want');\n            /* Emulate the old behaviour: if 'force' was the only member of authOptions,\n             * set it to null so it doesn't overwrite stored. TODO: remove in version 1.0 */\n            if (Utils.isOnlyPropIn(_authOptions, 'force')) {\n                _authOptions = null;\n            }\n        }\n        this._forceNewToken(tokenParams, _authOptions, function (err, tokenDetails) {\n            if (err) {\n                if (_this.client.connection && err.statusCode === HttpStatusCodes_1.default.Forbidden) {\n                    /* Per RSA4d & RSA4d1, if the auth server explicitly repudiates our right to\n                     * stay connecticed by returning a 403, we actively disconnect the connection\n                     * even though we may well still have time left in the old token. */\n                    _this.client.connection.connectionManager.actOnErrorFromAuthorize(err);\n                }\n                callback === null || callback === void 0 ? void 0 : callback(err);\n                return;\n            }\n            /* RTC8\n             * - When authorize called by an end user and have a realtime connection,\n             * don't call back till new token has taken effect.\n             * - Use this.client.connection as a proxy for (this.client instanceof Realtime),\n             * which doesn't work in node as Realtime isn't part of the vm context for Rest clients */\n            if (isRealtime(_this.client)) {\n                _this.client.connection.connectionManager.onAuthUpdated(tokenDetails, callback || noop);\n            }\n            else {\n                callback === null || callback === void 0 ? void 0 : callback(null, tokenDetails);\n            }\n        });\n    };\n    Auth.prototype.authorise = function (tokenParams, authOptions, callback) {\n        logger_1.default.deprecated('Auth.authorise', 'Auth.authorize');\n        this.authorize(tokenParams, authOptions, callback);\n    };\n    /* For internal use, eg by connectionManager - useful when want to call back\n     * as soon as we have the new token, rather than waiting for it to take\n     * effect on the connection as #authorize does */\n    Auth.prototype._forceNewToken = function (tokenParams, authOptions, callback) {\n        var _this = this;\n        /* get rid of current token even if still valid */\n        this.tokenDetails = null;\n        /* _save normalises the tokenParams and authOptions and updates the auth\n         * object. All subsequent operations should use the values on `this`,\n         * not the passed in ones. */\n        this._saveTokenOptions(tokenParams, authOptions);\n        logAndValidateTokenAuthMethod(this.authOptions);\n        this._ensureValidAuthCredentials(true, function (err, tokenDetails) {\n            /* RSA10g */\n            delete _this.tokenParams.timestamp;\n            delete _this.authOptions.queryTime;\n            callback(err, tokenDetails);\n        });\n    };\n    Auth.prototype.requestToken = function (tokenParams, authOptions, callback) {\n        var _this = this;\n        /* shuffle and normalise arguments as necessary */\n        if (typeof tokenParams == 'function' && !callback) {\n            callback = tokenParams;\n            authOptions = tokenParams = null;\n        }\n        else if (typeof authOptions == 'function' && !callback) {\n            callback = authOptions;\n            authOptions = null;\n        }\n        if (!callback && this.client.options.promises) {\n            return Utils.promisify(this, 'requestToken', arguments);\n        }\n        /* RSA8e: if authOptions passed in, they're used instead of stored, don't merge them */\n        authOptions = authOptions || this.authOptions;\n        tokenParams = tokenParams || Utils.copy(this.tokenParams);\n        var _callback = callback || noop;\n        /* first set up whatever callback will be used to get signed\n         * token requests */\n        var tokenRequestCallback, client = this.client;\n        if (authOptions.authCallback) {\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authCallback');\n            tokenRequestCallback = authOptions.authCallback;\n        }\n        else if (authOptions.authUrl) {\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.requestToken()', 'using token auth with authUrl');\n            tokenRequestCallback = function (params, cb) {\n                var authHeaders = Utils.mixin({ accept: 'application/json, text/plain' }, authOptions.authHeaders);\n                var usePost = authOptions.authMethod && authOptions.authMethod.toLowerCase() === 'post';\n                var providedQsParams;\n                /* Combine authParams with any qs params given in the authUrl */\n                var queryIdx = authOptions.authUrl.indexOf('?');\n                if (queryIdx > -1) {\n                    providedQsParams = Utils.parseQueryString(authOptions.authUrl.slice(queryIdx));\n                    authOptions.authUrl = authOptions.authUrl.slice(0, queryIdx);\n                    if (!usePost) {\n                        /* In case of conflict, authParams take precedence over qs params in the authUrl */\n                        authOptions.authParams = Utils.mixin(providedQsParams, authOptions.authParams);\n                    }\n                }\n                /* RSA8c2 */\n                var authParams = Utils.mixin({}, authOptions.authParams || {}, params);\n                var authUrlRequestCallback = function (err, body, headers, unpacked) {\n                    var contentType;\n                    if (err) {\n                        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Received Error: ' + Utils.inspectError(err));\n                    }\n                    else {\n                        contentType = headers['content-type'];\n                        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Received; content-type: ' + contentType + '; body: ' + Utils.inspectBody(body));\n                    }\n                    if (err || unpacked)\n                        return cb(err, body);\n                    if (platform_1.default.BufferUtils.isBuffer(body))\n                        body = body.toString();\n                    if (!contentType) {\n                        cb(new errorinfo_1.default('authUrl response is missing a content-type header', 40170, 401));\n                        return;\n                    }\n                    var json = contentType.indexOf('application/json') > -1, text = contentType.indexOf('text/plain') > -1 || contentType.indexOf('application/jwt') > -1;\n                    if (!json && !text) {\n                        cb(new errorinfo_1.default('authUrl responded with unacceptable content-type ' +\n                            contentType +\n                            ', should be either text/plain, application/jwt or application/json', 40170, 401));\n                        return;\n                    }\n                    if (json) {\n                        if (body.length > MAX_TOKEN_LENGTH) {\n                            cb(new errorinfo_1.default('authUrl response exceeded max permitted length', 40170, 401));\n                            return;\n                        }\n                        try {\n                            body = JSON.parse(body);\n                        }\n                        catch (e) {\n                            cb(new errorinfo_1.default('Unexpected error processing authURL response; err = ' + e.message, 40170, 401));\n                            return;\n                        }\n                    }\n                    cb(null, body, contentType);\n                };\n                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Auth.requestToken().tokenRequestCallback', 'Requesting token from ' +\n                    authOptions.authUrl +\n                    '; Params: ' +\n                    JSON.stringify(authParams) +\n                    '; method: ' +\n                    (usePost ? 'POST' : 'GET'));\n                if (usePost) {\n                    /* send body form-encoded */\n                    var headers = authHeaders || {};\n                    headers['content-type'] = 'application/x-www-form-urlencoded';\n                    var body = Utils.toQueryString(authParams).slice(1); /* slice is to remove the initial '?' */\n                    _this.client.http.doUri(HttpMethods_1.default.Post, client, authOptions.authUrl, headers, body, providedQsParams, authUrlRequestCallback);\n                }\n                else {\n                    _this.client.http.doUri(HttpMethods_1.default.Get, client, authOptions.authUrl, authHeaders || {}, null, authParams, authUrlRequestCallback);\n                }\n            };\n        }\n        else if (authOptions.key) {\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.requestToken()', 'using token auth with client-side signing');\n            tokenRequestCallback = function (params, cb) {\n                _this.createTokenRequest(params, authOptions, cb);\n            };\n        }\n        else {\n            var msg = 'Need a new token, but authOptions does not include any way to request one (no authUrl, authCallback, or key)';\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth()', 'library initialized with a token literal without any way to renew the token when it expires (no authUrl, authCallback, or key). See https://help.ably.io/error/40171 for help');\n            _callback(new errorinfo_1.default(msg, 40171, 403));\n            return;\n        }\n        /* normalise token params */\n        if ('capability' in tokenParams)\n            tokenParams.capability = c14n(tokenParams.capability);\n        var tokenRequest = function (signedTokenParams, tokenCb) {\n            var keyName = signedTokenParams.keyName, path = '/keys/' + keyName + '/requestToken', tokenUri = function (host) {\n                return client.baseUri(host) + path;\n            };\n            var requestHeaders = Utils.defaultPostHeaders(_this.client.options);\n            if (authOptions.requestHeaders)\n                Utils.mixin(requestHeaders, authOptions.requestHeaders);\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Auth.requestToken().requestToken', 'Sending POST to ' + path + '; Token params: ' + JSON.stringify(signedTokenParams));\n            _this.client.http.do(HttpMethods_1.default.Post, client, tokenUri, requestHeaders, JSON.stringify(signedTokenParams), null, tokenCb);\n        };\n        var tokenRequestCallbackTimeoutExpired = false, timeoutLength = this.client.options.timeouts.realtimeRequestTimeout, tokenRequestCallbackTimeout = setTimeout(function () {\n            tokenRequestCallbackTimeoutExpired = true;\n            var msg = 'Token request callback timed out after ' + timeoutLength / 1000 + ' seconds';\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.requestToken()', msg);\n            _callback(new errorinfo_1.default(msg, 40170, 401));\n        }, timeoutLength);\n        tokenRequestCallback(tokenParams, function (err, tokenRequestOrDetails, contentType) {\n            if (tokenRequestCallbackTimeoutExpired)\n                return;\n            clearTimeout(tokenRequestCallbackTimeout);\n            if (err) {\n                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.requestToken()', 'token request signing call returned error; err = ' + Utils.inspectError(err));\n                _callback(normaliseAuthcallbackError(err));\n                return;\n            }\n            /* the response from the callback might be a token string, a signed request or a token details */\n            if (typeof tokenRequestOrDetails === 'string') {\n                if (tokenRequestOrDetails.length === 0) {\n                    _callback(new errorinfo_1.default('Token string is empty', 40170, 401));\n                }\n                else if (tokenRequestOrDetails.length > MAX_TOKEN_LENGTH) {\n                    _callback(new errorinfo_1.default('Token string exceeded max permitted length (was ' + tokenRequestOrDetails.length + ' bytes)', 40170, 401));\n                }\n                else if (tokenRequestOrDetails === 'undefined' || tokenRequestOrDetails === 'null') {\n                    /* common failure mode with poorly-implemented authCallbacks */\n                    _callback(new errorinfo_1.default('Token string was literal null/undefined', 40170, 401));\n                }\n                else if (tokenRequestOrDetails[0] === '{' && !(contentType && contentType.indexOf('application/jwt') > -1)) {\n                    _callback(new errorinfo_1.default(\"Token was double-encoded; make sure you're not JSON-encoding an already encoded token request or details\", 40170, 401));\n                }\n                else {\n                    _callback(null, { token: tokenRequestOrDetails });\n                }\n                return;\n            }\n            if (typeof tokenRequestOrDetails !== 'object') {\n                var msg = 'Expected token request callback to call back with a token string or token request/details object, but got a ' +\n                    typeof tokenRequestOrDetails;\n                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.requestToken()', msg);\n                _callback(new errorinfo_1.default(msg, 40170, 401));\n                return;\n            }\n            var objectSize = JSON.stringify(tokenRequestOrDetails).length;\n            if (objectSize > MAX_TOKEN_LENGTH && !authOptions.suppressMaxLengthCheck) {\n                _callback(new errorinfo_1.default('Token request/details object exceeded max permitted stringified size (was ' + objectSize + ' bytes)', 40170, 401));\n                return;\n            }\n            if ('issued' in tokenRequestOrDetails) {\n                /* a tokenDetails object */\n                _callback(null, tokenRequestOrDetails);\n                return;\n            }\n            if (!('keyName' in tokenRequestOrDetails)) {\n                var msg = 'Expected token request callback to call back with a token string, token request object, or token details object';\n                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.requestToken()', msg);\n                _callback(new errorinfo_1.default(msg, 40170, 401));\n                return;\n            }\n            /* it's a token request, so make the request */\n            tokenRequest(tokenRequestOrDetails, function (err, tokenResponse, headers, unpacked) {\n                if (err) {\n                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth.requestToken()', 'token request API call returned error; err = ' + Utils.inspectError(err));\n                    _callback(normaliseAuthcallbackError(err));\n                    return;\n                }\n                if (!unpacked)\n                    tokenResponse = JSON.parse(tokenResponse);\n                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.getToken()', 'token received');\n                _callback(null, tokenResponse);\n            });\n        });\n    };\n    /**\n     * Create and sign a token request based on the given options.\n     * NOTE this can only be used when the key value is available locally.\n     * Otherwise, signed token requests must be obtained from the key\n     * owner (either using the token request callback or url).\n     *\n     * @param authOptions\n     * an object containing the request options:\n     * - key:           the key to use. If not specified, a key passed in constructing\n     *                  the Rest interface will be used\n     *\n     * - queryTime      (optional) boolean indicating that the ably system should be\n     *                  queried for the current time when none is specified explicitly\n     *\n     * - requestHeaders (optional, unsupported, for testing only) extra headers to add to the\n     *                  requestToken request\n     *\n     * @param tokenParams\n     * an object containing the parameters for the requested token:\n     * - ttl:       (optional) the requested life of the token in ms. If none is specified\n     *                  a default of 1 hour is provided. The maximum lifetime is 24hours; any request\n     *                  exceeding that lifetime will be rejected with an error.\n     *\n     * - capability:    (optional) the capability to associate with the access token.\n     *                  If none is specified, a token will be requested with all of the\n     *                  capabilities of the specified key.\n     *\n     * - clientId:      (optional) a client ID to associate with the token; if not\n     *                  specified, a clientId passed in constructing the Rest interface will be used\n     *\n     * - timestamp:     (optional) the time in ms since the epoch. If none is specified,\n     *                  the system will be queried for a time value to use.\n     *\n     * @param callback\n     */\n    Auth.prototype.createTokenRequest = function (tokenParams, authOptions, callback) {\n        var _this = this;\n        /* shuffle and normalise arguments as necessary */\n        if (typeof tokenParams == 'function' && !callback) {\n            callback = tokenParams;\n            authOptions = tokenParams = null;\n        }\n        else if (typeof authOptions == 'function' && !callback) {\n            callback = authOptions;\n            authOptions = null;\n        }\n        if (!callback && this.client.options.promises) {\n            return Utils.promisify(this, 'createTokenRequest', arguments);\n        }\n        /* RSA9h: if authOptions passed in, they're used instead of stored, don't merge them */\n        authOptions = authOptions || this.authOptions;\n        tokenParams = tokenParams || Utils.copy(this.tokenParams);\n        var key = authOptions.key;\n        if (!key) {\n            callback(new errorinfo_1.default('No key specified', 40101, 403));\n            return;\n        }\n        var keyParts = key.split(':'), keyName = keyParts[0], keySecret = keyParts[1];\n        if (!keySecret) {\n            callback(new errorinfo_1.default('Invalid key specified', 40101, 403));\n            return;\n        }\n        if (tokenParams.clientId === '') {\n            callback(new errorinfo_1.default('clientId canâ€™t be an empty string', 40012, 400));\n            return;\n        }\n        if ('capability' in tokenParams) {\n            tokenParams.capability = c14n(tokenParams.capability);\n        }\n        var request = Utils.mixin({ keyName: keyName }, tokenParams), clientId = tokenParams.clientId || '', ttl = tokenParams.ttl || '', capability = tokenParams.capability || '';\n        (function (authoriseCb) {\n            if (request.timestamp) {\n                authoriseCb();\n                return;\n            }\n            _this.getTimestamp(authOptions && authOptions.queryTime, function (err, time) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n                request.timestamp = time;\n                authoriseCb();\n            });\n        })(function () {\n            /* nonce */\n            /* NOTE: there is no expectation that the client\n             * specifies the nonce; this is done by the library\n             * However, this can be overridden by the client\n             * simply for testing purposes. */\n            var nonce = request.nonce || (request.nonce = random()), timestamp = request.timestamp;\n            var signText = request.keyName + '\\n' + ttl + '\\n' + capability + '\\n' + clientId + '\\n' + timestamp + '\\n' + nonce + '\\n';\n            /* mac */\n            /* NOTE: there is no expectation that the client\n             * specifies the mac; this is done by the library\n             * However, this can be overridden by the client\n             * simply for testing purposes. */\n            request.mac = request.mac || hmac(signText, keySecret);\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.getTokenRequest()', 'generated signed request');\n            callback(null, request);\n        });\n    };\n    /**\n     * Get the auth query params to use for a websocket connection,\n     * based on the current auth parameters\n     */\n    Auth.prototype.getAuthParams = function (callback) {\n        if (this.method == 'basic')\n            callback(null, { key: this.key });\n        else\n            this._ensureValidAuthCredentials(false, function (err, tokenDetails) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n                if (!tokenDetails) {\n                    throw new Error('Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails');\n                }\n                callback(null, { access_token: tokenDetails.token });\n            });\n    };\n    /**\n     * Get the authorization header to use for a REST or comet request,\n     * based on the current auth parameters\n     */\n    Auth.prototype.getAuthHeaders = function (callback) {\n        if (this.method == 'basic') {\n            callback(null, { authorization: 'Basic ' + this.basicKey });\n        }\n        else {\n            this._ensureValidAuthCredentials(false, function (err, tokenDetails) {\n                if (err) {\n                    callback(err);\n                    return;\n                }\n                if (!tokenDetails) {\n                    throw new Error('Auth.getAuthParams(): _ensureValidAuthCredentials returned no error or tokenDetails');\n                }\n                callback(null, { authorization: 'Bearer ' + Utils.toBase64(tokenDetails.token) });\n            });\n        }\n    };\n    /**\n     * Get the current time based on the local clock,\n     * or if the option queryTime is true, return the server time.\n     * The server time offset from the local time is stored so that\n     * only one request to the server to get the time is ever needed\n     */\n    Auth.prototype.getTimestamp = function (queryTime, callback) {\n        if (!this.isTimeOffsetSet() && (queryTime || this.authOptions.queryTime)) {\n            this.client.time(callback);\n        }\n        else {\n            callback(null, this.getTimestampUsingOffset());\n        }\n    };\n    Auth.prototype.getTimestampUsingOffset = function () {\n        return Utils.now() + (this.client.serverTimeOffset || 0);\n    };\n    Auth.prototype.isTimeOffsetSet = function () {\n        return this.client.serverTimeOffset !== null;\n    };\n    Auth.prototype._saveBasicOptions = function (authOptions) {\n        this.method = 'basic';\n        this.key = authOptions.key;\n        this.basicKey = Utils.toBase64(authOptions.key);\n        this.authOptions = authOptions || {};\n        if ('clientId' in authOptions) {\n            this._userSetClientId(authOptions.clientId);\n        }\n    };\n    Auth.prototype._saveTokenOptions = function (tokenParams, authOptions) {\n        this.method = 'token';\n        if (tokenParams) {\n            /* We temporarily persist tokenParams.timestamp in case a new token needs\n             * to be requested, then null it out in the callback of\n             * _ensureValidAuthCredentials for RSA10g compliance */\n            this.tokenParams = tokenParams;\n        }\n        if (authOptions) {\n            /* normalise */\n            if (authOptions.token) {\n                /* options.token may contain a token string or, for convenience, a TokenDetails */\n                authOptions.tokenDetails =\n                    typeof authOptions.token === 'string'\n                        ? { token: authOptions.token }\n                        : authOptions.token;\n            }\n            if (authOptions.tokenDetails) {\n                this.tokenDetails = authOptions.tokenDetails;\n            }\n            if ('clientId' in authOptions) {\n                this._userSetClientId(authOptions.clientId);\n            }\n            this.authOptions = authOptions;\n        }\n    };\n    /* @param forceSupersede: force a new token request even if there's one in\n     * progress, making all pending callbacks wait for the new one */\n    Auth.prototype._ensureValidAuthCredentials = function (forceSupersede, callback) {\n        var _this = this;\n        var token = this.tokenDetails;\n        if (token) {\n            if (this._tokenClientIdMismatch(token.clientId)) {\n                /* 403 to trigger a permanently failed client - RSA15c */\n                callback(new errorinfo_1.default('Mismatch between clientId in token (' + token.clientId + ') and current clientId (' + this.clientId + ')', 40102, 403));\n                return;\n            }\n            /* RSA4b1 -- if we have a server time offset set already, we can\n             * automatically remove expired tokens. Else just use the cached token. If it is\n             * expired Ably will tell us and we'll discard it then. */\n            if (!this.isTimeOffsetSet() || !token.expires || token.expires >= this.getTimestampUsingOffset()) {\n                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.getToken()', 'using cached token; expires = ' + token.expires);\n                callback(null, token);\n                return;\n            }\n            /* expired, so remove and fallthrough to getting a new one */\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth.getToken()', 'deleting expired token');\n            this.tokenDetails = null;\n        }\n        (this.waitingForTokenRequest || (this.waitingForTokenRequest = multicaster_1.default.create())).push(callback);\n        if (this.currentTokenRequestId !== null && !forceSupersede) {\n            return;\n        }\n        /* Request a new token */\n        var tokenRequestId = (this.currentTokenRequestId = getTokenRequestId());\n        this.requestToken(this.tokenParams, this.authOptions, function (err, tokenResponse) {\n            if (_this.currentTokenRequestId > tokenRequestId) {\n                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Auth._ensureValidAuthCredentials()', 'Discarding token request response; overtaken by newer one');\n                return;\n            }\n            _this.currentTokenRequestId = null;\n            var callbacks = _this.waitingForTokenRequest || noop;\n            _this.waitingForTokenRequest = null;\n            if (err) {\n                callbacks(err);\n                return;\n            }\n            callbacks(null, (_this.tokenDetails = tokenResponse));\n        });\n    };\n    /* User-set: check types, '*' is disallowed, throw any errors */\n    Auth.prototype._userSetClientId = function (clientId) {\n        if (!(typeof clientId === 'string' || clientId === null)) {\n            throw new errorinfo_1.default('clientId must be either a string or null', 40012, 400);\n        }\n        else if (clientId === '*') {\n            throw new errorinfo_1.default('Canâ€™t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, instantiate the library with {defaultTokenParams: {clientId: \"*\"}}), or if calling authorize(), pass it in as a tokenParam: authorize({clientId: \"*\"}, authOptions)', 40012, 400);\n        }\n        else {\n            var err = this._uncheckedSetClientId(clientId);\n            if (err)\n                throw err;\n        }\n    };\n    /* Ably-set: no typechecking, '*' is allowed but not set on this.clientId), return errors to the caller */\n    Auth.prototype._uncheckedSetClientId = function (clientId) {\n        if (this._tokenClientIdMismatch(clientId)) {\n            /* Should never happen in normal circumstances as realtime should\n             * recognise mismatch and return an error */\n            var msg = 'Unexpected clientId mismatch: client has ' + this.clientId + ', requested ' + clientId;\n            var err = new errorinfo_1.default(msg, 40102, 401);\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Auth._uncheckedSetClientId()', msg);\n            return err;\n        }\n        else {\n            /* RSA7a4: if options.clientId is provided and is not\n             * null, it overrides defaultTokenParams.clientId */\n            this.clientId = this.tokenParams.clientId = clientId;\n            return null;\n        }\n    };\n    Auth.prototype._tokenClientIdMismatch = function (tokenClientId) {\n        return !!(this.clientId &&\n            this.clientId !== '*' &&\n            tokenClientId &&\n            tokenClientId !== '*' &&\n            this.clientId !== tokenClientId);\n    };\n    Auth.isTokenErr = function (error) {\n        return error.code && error.code >= 40140 && error.code < 40150;\n    };\n    Auth.prototype.revokeTokens = function (specifiers, optionsOrCallbackArg, callbackArg) {\n        if (useTokenAuth(this.client.options)) {\n            throw new errorinfo_1.default('Cannot revoke tokens when using token auth', 40162, 401);\n        }\n        var keyName = this.client.options.keyName;\n        var resolvedOptions;\n        if (typeof optionsOrCallbackArg === 'function') {\n            callbackArg = optionsOrCallbackArg;\n            resolvedOptions = {};\n        }\n        else {\n            resolvedOptions = optionsOrCallbackArg !== null && optionsOrCallbackArg !== void 0 ? optionsOrCallbackArg : {};\n        }\n        if (callbackArg === undefined) {\n            if (this.client.options.promises) {\n                return Utils.promisify(this, 'revokeTokens', [specifiers, resolvedOptions]);\n            }\n            callbackArg = noop;\n        }\n        var callback = callbackArg;\n        var requestBodyDTO = tslib_1.__assign({ targets: specifiers.map(function (specifier) { return \"\".concat(specifier.type, \":\").concat(specifier.value); }) }, resolvedOptions);\n        var format = this.client.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(this.client.options, format);\n        if (this.client.options.headers)\n            Utils.mixin(headers, this.client.options.headers);\n        var requestBody = Utils.encodeBody(requestBodyDTO, format);\n        resource_1.default.post(this.client, \"/keys/\".concat(keyName, \"/revokeTokens\"), requestBody, headers, { newBatchResponse: 'true' }, null, function (err, body, headers, unpacked) {\n            if (err) {\n                // TODO remove this type assertion after fixing https://github.com/ably/ably-js/issues/1405\n                callback(err);\n                return;\n            }\n            var batchResult = (unpacked ? body : Utils.decodeBody(body, format));\n            callback(null, batchResult);\n        });\n    };\n    return Auth;\n}());\nexports.default = Auth;\n\n\n/***/ }),\n/* 18 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar HttpMethods;\n(function (HttpMethods) {\n    HttpMethods[\"Get\"] = \"get\";\n    HttpMethods[\"Delete\"] = \"delete\";\n    HttpMethods[\"Post\"] = \"post\";\n    HttpMethods[\"Put\"] = \"put\";\n    HttpMethods[\"Patch\"] = \"patch\";\n})(HttpMethods || (HttpMethods = {}));\nexports.default = HttpMethods;\n\n\n/***/ }),\n/* 19 */\n/***/ (function(module, exports, __nested_webpack_require_200124__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.HttpPaginatedResponse = exports.PaginatedResult = void 0;\nvar tslib_1 = __nested_webpack_require_200124__(0);\nvar Utils = tslib_1.__importStar(__nested_webpack_require_200124__(1));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_200124__(2));\nvar resource_1 = tslib_1.__importDefault(__nested_webpack_require_200124__(14));\nfunction getRelParams(linkUrl) {\n    var urlMatch = linkUrl.match(/^\\.\\/(\\w+)\\?(.*)$/);\n    return urlMatch && urlMatch[2] && Utils.parseQueryString(urlMatch[2]);\n}\nfunction parseRelLinks(linkHeader) {\n    if (typeof linkHeader == 'string')\n        linkHeader = linkHeader.split(',');\n    var relParams = {};\n    for (var i = 0; i < linkHeader.length; i++) {\n        var linkMatch = linkHeader[i].match(/^\\s*<(.+)>;\\s*rel=\"(\\w+)\"$/);\n        if (linkMatch) {\n            var params = getRelParams(linkMatch[1]);\n            if (params)\n                relParams[linkMatch[2]] = params;\n        }\n    }\n    return relParams;\n}\nfunction returnErrOnly(err, body, useHPR) {\n    /* If using httpPaginatedResponse, errors from Ably are returned as part of\n     * the HPR, only do callback(err) for network errors etc. which don't\n     * return a body and/or have no ably-originated error code (non-numeric\n     * error codes originate from node) */\n    return !(useHPR && (body || typeof err.code === 'number'));\n}\nvar PaginatedResource = /** @class */ (function () {\n    function PaginatedResource(rest, path, headers, envelope, bodyHandler, useHttpPaginatedResponse) {\n        this.rest = rest;\n        this.path = path;\n        this.headers = headers;\n        this.envelope = envelope !== null && envelope !== void 0 ? envelope : null;\n        this.bodyHandler = bodyHandler;\n        this.useHttpPaginatedResponse = useHttpPaginatedResponse || false;\n    }\n    PaginatedResource.prototype.get = function (params, callback) {\n        var _this = this;\n        resource_1.default.get(this.rest, this.path, this.headers, params, this.envelope, function (err, body, headers, unpacked, statusCode) {\n            _this.handlePage(err, body, headers, unpacked, statusCode, callback);\n        });\n    };\n    PaginatedResource.prototype.delete = function (params, callback) {\n        var _this = this;\n        resource_1.default.delete(this.rest, this.path, this.headers, params, this.envelope, function (err, body, headers, unpacked, statusCode) {\n            _this.handlePage(err, body, headers, unpacked, statusCode, callback);\n        });\n    };\n    PaginatedResource.prototype.post = function (params, body, callback) {\n        var _this = this;\n        resource_1.default.post(this.rest, this.path, body, this.headers, params, this.envelope, function (err, responseBody, headers, unpacked, statusCode) {\n            if (callback) {\n                _this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);\n            }\n        });\n    };\n    PaginatedResource.prototype.put = function (params, body, callback) {\n        var _this = this;\n        resource_1.default.put(this.rest, this.path, body, this.headers, params, this.envelope, function (err, responseBody, headers, unpacked, statusCode) {\n            if (callback) {\n                _this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);\n            }\n        });\n    };\n    PaginatedResource.prototype.patch = function (params, body, callback) {\n        var _this = this;\n        resource_1.default.patch(this.rest, this.path, body, this.headers, params, this.envelope, function (err, responseBody, headers, unpacked, statusCode) {\n            if (callback) {\n                _this.handlePage(err, responseBody, headers, unpacked, statusCode, callback);\n            }\n        });\n    };\n    PaginatedResource.prototype.handlePage = function (err, body, headers, unpacked, statusCode, callback) {\n        if (err && returnErrOnly(err, body, this.useHttpPaginatedResponse)) {\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'PaginatedResource.handlePage()', 'Unexpected error getting resource: err = ' + Utils.inspectError(err));\n            callback === null || callback === void 0 ? void 0 : callback(err);\n            return;\n        }\n        var items, linkHeader, relParams;\n        try {\n            items = this.bodyHandler(body, headers || {}, unpacked);\n        }\n        catch (e) {\n            /* If we got an error, the failure to parse the body is almost certainly\n             * due to that, so callback with that in preference over the parse error */\n            callback === null || callback === void 0 ? void 0 : callback(err || e);\n            return;\n        }\n        if (headers && (linkHeader = headers['Link'] || headers['link'])) {\n            relParams = parseRelLinks(linkHeader);\n        }\n        if (this.useHttpPaginatedResponse) {\n            callback(null, new HttpPaginatedResponse(this, items, headers || {}, statusCode, relParams, err));\n        }\n        else {\n            callback(null, new PaginatedResult(this, items, relParams));\n        }\n    };\n    return PaginatedResource;\n}());\nvar PaginatedResult = /** @class */ (function () {\n    function PaginatedResult(resource, items, relParams) {\n        var _this = this;\n        this.resource = resource;\n        this.items = items;\n        var self = this;\n        if (relParams) {\n            if ('first' in relParams) {\n                this.first = function (callback) {\n                    if (!callback && self.resource.rest.options.promises) {\n                        return Utils.promisify(self, 'first', []);\n                    }\n                    self.get(relParams.first, callback);\n                };\n            }\n            if ('current' in relParams) {\n                this.current = function (callback) {\n                    if (!callback && self.resource.rest.options.promises) {\n                        return Utils.promisify(self, 'current', []);\n                    }\n                    self.get(relParams.current, callback);\n                };\n            }\n            this.next = function (callback) {\n                if (!callback && self.resource.rest.options.promises) {\n                    return Utils.promisify(self, 'next', []);\n                }\n                if ('next' in relParams) {\n                    self.get(relParams.next, callback);\n                }\n                else {\n                    callback(null, null);\n                }\n            };\n            this.hasNext = function () {\n                return 'next' in relParams;\n            };\n            this.isLast = function () {\n                var _a;\n                return !((_a = _this.hasNext) === null || _a === void 0 ? void 0 : _a.call(_this));\n            };\n        }\n    }\n    /* We assume that only the initial request can be a POST, and that accessing\n     * the rest of a multipage set of results can always be done with GET */\n    PaginatedResult.prototype.get = function (params, callback) {\n        var res = this.resource;\n        resource_1.default.get(res.rest, res.path, res.headers, params, res.envelope, function (err, body, headers, unpacked, statusCode) {\n            res.handlePage(err, body, headers, unpacked, statusCode, callback);\n        });\n    };\n    return PaginatedResult;\n}());\nexports.PaginatedResult = PaginatedResult;\nvar HttpPaginatedResponse = /** @class */ (function (_super) {\n    tslib_1.__extends(HttpPaginatedResponse, _super);\n    function HttpPaginatedResponse(resource, items, headers, statusCode, relParams, err) {\n        var _this = _super.call(this, resource, items, relParams) || this;\n        _this.statusCode = statusCode;\n        _this.success = statusCode < 300 && statusCode >= 200;\n        _this.headers = headers;\n        _this.errorCode = err && err.code;\n        _this.errorMessage = err && err.message;\n        return _this;\n    }\n    HttpPaginatedResponse.prototype.toJSON = function () {\n        return {\n            items: this.items,\n            statusCode: this.statusCode,\n            success: this.success,\n            headers: this.headers,\n            errorCode: this.errorCode,\n            errorMessage: this.errorMessage,\n        };\n    };\n    return HttpPaginatedResponse;\n}(PaginatedResult));\nexports.HttpPaginatedResponse = HttpPaginatedResponse;\nexports.default = PaginatedResource;\n\n\n/***/ }),\n/* 20 */\n/***/ (function(module, exports, __nested_webpack_require_208545__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isRetriable = void 0;\nvar tslib_1 = __nested_webpack_require_208545__(0);\nvar errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_208545__(4));\nvar ConnectionErrorCodes = {\n    DISCONNECTED: 80003,\n    SUSPENDED: 80002,\n    FAILED: 80000,\n    CLOSING: 80017,\n    CLOSED: 80017,\n    UNKNOWN_CONNECTION_ERR: 50002,\n    UNKNOWN_CHANNEL_ERR: 50001,\n};\nvar ConnectionErrors = {\n    disconnected: function () {\n        return errorinfo_1.default.fromValues({\n            statusCode: 400,\n            code: ConnectionErrorCodes.DISCONNECTED,\n            message: 'Connection to server temporarily unavailable',\n        });\n    },\n    suspended: function () {\n        return errorinfo_1.default.fromValues({\n            statusCode: 400,\n            code: ConnectionErrorCodes.SUSPENDED,\n            message: 'Connection to server unavailable',\n        });\n    },\n    failed: function () {\n        return errorinfo_1.default.fromValues({\n            statusCode: 400,\n            code: ConnectionErrorCodes.FAILED,\n            message: 'Connection failed or disconnected by server',\n        });\n    },\n    closing: function () {\n        return errorinfo_1.default.fromValues({\n            statusCode: 400,\n            code: ConnectionErrorCodes.CLOSING,\n            message: 'Connection closing',\n        });\n    },\n    closed: function () {\n        return errorinfo_1.default.fromValues({\n            statusCode: 400,\n            code: ConnectionErrorCodes.CLOSED,\n            message: 'Connection closed',\n        });\n    },\n    unknownConnectionErr: function () {\n        return errorinfo_1.default.fromValues({\n            statusCode: 500,\n            code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n            message: 'Internal connection error',\n        });\n    },\n    unknownChannelErr: function () {\n        return errorinfo_1.default.fromValues({\n            statusCode: 500,\n            code: ConnectionErrorCodes.UNKNOWN_CONNECTION_ERR,\n            message: 'Internal channel error',\n        });\n    },\n};\nfunction isRetriable(err) {\n    if (!err.statusCode || !err.code || err.statusCode >= 500) {\n        return true;\n    }\n    return Object.values(ConnectionErrorCodes).includes(err.code);\n}\nexports.isRetriable = isRetriable;\nexports.default = ConnectionErrors;\n\n\n/***/ }),\n/* 21 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar XHRStates;\n(function (XHRStates) {\n    XHRStates[XHRStates[\"REQ_SEND\"] = 0] = \"REQ_SEND\";\n    XHRStates[XHRStates[\"REQ_RECV\"] = 1] = \"REQ_RECV\";\n    XHRStates[XHRStates[\"REQ_RECV_POLL\"] = 2] = \"REQ_RECV_POLL\";\n    XHRStates[XHRStates[\"REQ_RECV_STREAM\"] = 3] = \"REQ_RECV_STREAM\";\n})(XHRStates || (XHRStates = {}));\nexports.default = XHRStates;\n\n\n/***/ }),\n/* 22 */\n/***/ (function(module, exports, __nested_webpack_require_211467__) {\n\n;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__nested_webpack_require_211467__(6), __nested_webpack_require_211467__(5), __nested_webpack_require_211467__(58), __nested_webpack_require_211467__(11), __nested_webpack_require_211467__(40), __nested_webpack_require_211467__(32), __nested_webpack_require_211467__(24), __nested_webpack_require_211467__(27), __nested_webpack_require_211467__(28), __nested_webpack_require_211467__(59), __nested_webpack_require_211467__(60));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\treturn CryptoJS;\n\n}));\n\n/***/ }),\n/* 23 */\n/***/ (function(module, exports, __nested_webpack_require_211978__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_211978__(0);\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_211978__(2));\nvar Multicaster = /** @class */ (function () {\n    // Private constructor; use static Multicaster.create instead\n    function Multicaster(members) {\n        this.members = members || [];\n    }\n    Multicaster.prototype.call = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        for (var _a = 0, _b = this.members; _a < _b.length; _a++) {\n            var member = _b[_a];\n            if (member) {\n                try {\n                    member.apply(void 0, args);\n                }\n                catch (e) {\n                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Multicaster multiple callback handler', 'Unexpected exception: ' + e + '; stack = ' + e.stack);\n                }\n            }\n        }\n    };\n    Multicaster.prototype.push = function () {\n        var _a;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        (_a = this.members).push.apply(_a, args);\n    };\n    Multicaster.create = function (members) {\n        var instance = new Multicaster(members);\n        return Object.assign(function () {\n            var args = [];\n            for (var _i = 0; _i < arguments.length; _i++) {\n                args[_i] = arguments[_i];\n            }\n            return instance.call.apply(instance, args);\n        }, {\n            push: function (fn) { return instance.push(fn); },\n        });\n    };\n    return Multicaster;\n}());\nexports.default = Multicaster;\n\n\n/***/ }),\n/* 24 */\n/***/ (function(module, exports, __nested_webpack_require_213807__) {\n\n;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__nested_webpack_require_213807__(6));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var C_enc = C.enc;\n\t    var Utf8 = C_enc.Utf8;\n\t    var C_algo = C.algo;\n\n\t    /**\n\t     * HMAC algorithm.\n\t     */\n\t    var HMAC = C_algo.HMAC = Base.extend({\n\t        /**\n\t         * Initializes a newly created HMAC.\n\t         *\n\t         * @param {Hasher} hasher The hash algorithm to use.\n\t         * @param {WordArray|string} key The secret key.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hmacHasher = CryptoJS.algo.HMAC.create(CryptoJS.algo.SHA256, key);\n\t         */\n\t        init: function (hasher, key) {\n\t            // Init hasher\n\t            hasher = this._hasher = new hasher.init();\n\n\t            // Convert string to WordArray, else assume WordArray already\n\t            if (typeof key == 'string') {\n\t                key = Utf8.parse(key);\n\t            }\n\n\t            // Shortcuts\n\t            var hasherBlockSize = hasher.blockSize;\n\t            var hasherBlockSizeBytes = hasherBlockSize * 4;\n\n\t            // Allow arbitrary length keys\n\t            if (key.sigBytes > hasherBlockSizeBytes) {\n\t                key = hasher.finalize(key);\n\t            }\n\n\t            // Clamp excess bits\n\t            key.clamp();\n\n\t            // Clone key for inner and outer pads\n\t            var oKey = this._oKey = key.clone();\n\t            var iKey = this._iKey = key.clone();\n\n\t            // Shortcuts\n\t            var oKeyWords = oKey.words;\n\t            var iKeyWords = iKey.words;\n\n\t            // XOR keys with pad constants\n\t            for (var i = 0; i < hasherBlockSize; i++) {\n\t                oKeyWords[i] ^= 0x5c5c5c5c;\n\t                iKeyWords[i] ^= 0x36363636;\n\t            }\n\t            oKey.sigBytes = iKey.sigBytes = hasherBlockSizeBytes;\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this HMAC to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     hmacHasher.reset();\n\t         */\n\t        reset: function () {\n\t            // Shortcut\n\t            var hasher = this._hasher;\n\n\t            // Reset\n\t            hasher.reset();\n\t            hasher.update(this._iKey);\n\t        },\n\n\t        /**\n\t         * Updates this HMAC with a message.\n\t         *\n\t         * @param {WordArray|string} messageUpdate The message to append.\n\t         *\n\t         * @return {HMAC} This HMAC instance.\n\t         *\n\t         * @example\n\t         *\n\t         *     hmacHasher.update('message');\n\t         *     hmacHasher.update(wordArray);\n\t         */\n\t        update: function (messageUpdate) {\n\t            this._hasher.update(messageUpdate);\n\n\t            // Chainable\n\t            return this;\n\t        },\n\n\t        /**\n\t         * Finalizes the HMAC computation.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} messageUpdate (Optional) A final message update.\n\t         *\n\t         * @return {WordArray} The HMAC.\n\t         *\n\t         * @example\n\t         *\n\t         *     var hmac = hmacHasher.finalize();\n\t         *     var hmac = hmacHasher.finalize('message');\n\t         *     var hmac = hmacHasher.finalize(wordArray);\n\t         */\n\t        finalize: function (messageUpdate) {\n\t            // Shortcut\n\t            var hasher = this._hasher;\n\n\t            // Compute HMAC\n\t            var innerHash = hasher.finalize(messageUpdate);\n\t            hasher.reset();\n\t            var hmac = hasher.finalize(this._oKey.clone().concat(innerHash));\n\n\t            return hmac;\n\t        }\n\t    });\n\t}());\n\n\n}));\n\n/***/ }),\n/* 25 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.isSuccessCode = void 0;\nvar HttpStatusCodes;\n(function (HttpStatusCodes) {\n    HttpStatusCodes[HttpStatusCodes[\"Success\"] = 200] = \"Success\";\n    HttpStatusCodes[HttpStatusCodes[\"NoContent\"] = 204] = \"NoContent\";\n    HttpStatusCodes[HttpStatusCodes[\"BadRequest\"] = 400] = \"BadRequest\";\n    HttpStatusCodes[HttpStatusCodes[\"Unauthorized\"] = 401] = \"Unauthorized\";\n    HttpStatusCodes[HttpStatusCodes[\"Forbidden\"] = 403] = \"Forbidden\";\n    HttpStatusCodes[HttpStatusCodes[\"RequestTimeout\"] = 408] = \"RequestTimeout\";\n    HttpStatusCodes[HttpStatusCodes[\"InternalServerError\"] = 500] = \"InternalServerError\";\n})(HttpStatusCodes || (HttpStatusCodes = {}));\nfunction isSuccessCode(statusCode) {\n    return statusCode >= HttpStatusCodes.Success && statusCode < HttpStatusCodes.BadRequest;\n}\nexports.isSuccessCode = isSuccessCode;\nexports.default = HttpStatusCodes;\n\n\n/***/ }),\n/* 26 */\n/***/ (function(module, exports, __nested_webpack_require_218725__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_218725__(0);\nvar protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_218725__(10));\nvar Utils = tslib_1.__importStar(__nested_webpack_require_218725__(1));\nvar eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_218725__(7));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_218725__(2));\nvar connectionerrors_1 = tslib_1.__importDefault(__nested_webpack_require_218725__(20));\nvar errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_218725__(4));\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_218725__(3));\nvar actions = protocolmessage_1.default.Action;\nvar closeMessage = protocolmessage_1.default.fromValues({ action: actions.CLOSE });\nvar disconnectMessage = protocolmessage_1.default.fromValues({ action: actions.DISCONNECT });\n/*\n * Transport instances inherit from EventEmitter and emit the following events:\n *\n * event name       data\n * closed           error\n * failed           error\n * disposed\n * connected        null error, connectionSerial, connectionId, connectionDetails\n * event            channel message object\n */\nvar Transport = /** @class */ (function (_super) {\n    tslib_1.__extends(Transport, _super);\n    function Transport(connectionManager, auth, params, forceJsonProtocol) {\n        var _this = _super.call(this) || this;\n        if (forceJsonProtocol) {\n            params.format = undefined;\n            params.heartbeats = true;\n        }\n        _this.connectionManager = connectionManager;\n        connectionManager.registerProposedTransport(_this);\n        _this.auth = auth;\n        _this.params = params;\n        _this.timeouts = params.options.timeouts;\n        _this.format = params.format;\n        _this.isConnected = false;\n        _this.isFinished = false;\n        _this.isDisposed = false;\n        _this.maxIdleInterval = null;\n        _this.idleTimer = null;\n        _this.lastActivity = null;\n        return _this;\n    }\n    Transport.prototype.connect = function () { };\n    Transport.prototype.close = function () {\n        if (this.isConnected) {\n            this.requestClose();\n        }\n        this.finish('closed', connectionerrors_1.default.closed());\n    };\n    Transport.prototype.disconnect = function (err) {\n        /* Used for network/transport issues that need to result in the transport\n         * being disconnected, but should not transition the connection to 'failed' */\n        if (this.isConnected) {\n            this.requestDisconnect();\n        }\n        this.finish('disconnected', err || connectionerrors_1.default.disconnected());\n    };\n    Transport.prototype.fail = function (err) {\n        /* Used for client-side-detected fatal connection issues */\n        if (this.isConnected) {\n            this.requestDisconnect();\n        }\n        this.finish('failed', err || connectionerrors_1.default.failed());\n    };\n    Transport.prototype.finish = function (event, err) {\n        var _a;\n        if (this.isFinished) {\n            return;\n        }\n        this.isFinished = true;\n        this.isConnected = false;\n        this.maxIdleInterval = null;\n        clearTimeout((_a = this.idleTimer) !== null && _a !== void 0 ? _a : undefined);\n        this.idleTimer = null;\n        this.emit(event, err);\n        this.dispose();\n    };\n    Transport.prototype.onProtocolMessage = function (message) {\n        if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Transport.onProtocolMessage()', 'received on ' +\n                this.shortName +\n                ': ' +\n                protocolmessage_1.default.stringify(message) +\n                '; connectionId = ' +\n                this.connectionManager.connectionId);\n        }\n        this.onActivity();\n        switch (message.action) {\n            case actions.HEARTBEAT:\n                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Transport.onProtocolMessage()', this.shortName + ' heartbeat; connectionId = ' + this.connectionManager.connectionId);\n                this.emit('heartbeat', message.id);\n                break;\n            case actions.CONNECTED:\n                this.onConnect(message);\n                this.emit('connected', message.error, message.connectionId, message.connectionDetails, message);\n                break;\n            case actions.CLOSED:\n                this.onClose(message);\n                break;\n            case actions.DISCONNECTED:\n                this.onDisconnect(message);\n                break;\n            case actions.ACK:\n                this.emit('ack', message.msgSerial, message.count);\n                break;\n            case actions.NACK:\n                this.emit('nack', message.msgSerial, message.count, message.error);\n                break;\n            case actions.SYNC:\n                this.connectionManager.onChannelMessage(message, this);\n                break;\n            case actions.ACTIVATE:\n                // Ignored.\n                break;\n            case actions.AUTH:\n                this.auth.authorize(function (err) {\n                    if (err) {\n                        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Transport.onProtocolMessage()', 'Ably requested re-authentication, but unable to obtain a new token: ' + Utils.inspectError(err));\n                    }\n                });\n                break;\n            case actions.ERROR:\n                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.onProtocolMessage()', 'received error action; connectionId = ' +\n                    this.connectionManager.connectionId +\n                    '; err = ' +\n                    platform_1.default.Config.inspect(message.error) +\n                    (message.channel ? ', channel: ' + message.channel : ''));\n                if (message.channel === undefined) {\n                    this.onFatalError(message);\n                    break;\n                }\n                /* otherwise it's a channel-specific error, so handle it in the channel */\n                this.connectionManager.onChannelMessage(message, this);\n                break;\n            default:\n                /* all other actions are channel-specific */\n                this.connectionManager.onChannelMessage(message, this);\n        }\n    };\n    Transport.prototype.onConnect = function (message) {\n        this.isConnected = true;\n        if (!message.connectionDetails) {\n            throw new Error('Transport.onConnect(): Connect message recieved without connectionDetails');\n        }\n        var maxPromisedIdle = message.connectionDetails.maxIdleInterval;\n        if (maxPromisedIdle) {\n            this.maxIdleInterval = maxPromisedIdle + this.timeouts.realtimeRequestTimeout;\n            this.onActivity();\n        }\n        /* else Realtime declines to guarantee any maximum idle interval - CD2h */\n    };\n    Transport.prototype.onDisconnect = function (message) {\n        /* Used for when the server has disconnected the client (usually with a\n         * DISCONNECTED action) */\n        var err = message && message.error;\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.onDisconnect()', 'err = ' + Utils.inspectError(err));\n        this.finish('disconnected', err);\n    };\n    Transport.prototype.onFatalError = function (message) {\n        /* On receipt of a fatal connection error, we can assume that the server\n         * will close the connection and the transport, and do not need to request\n         * a disconnection - RTN15i */\n        var err = message && message.error;\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.onFatalError()', 'err = ' + Utils.inspectError(err));\n        this.finish('failed', err);\n    };\n    Transport.prototype.onClose = function (message) {\n        var err = message && message.error;\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.onClose()', 'err = ' + Utils.inspectError(err));\n        this.finish('closed', err);\n    };\n    Transport.prototype.requestClose = function () {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.requestClose()', '');\n        this.send(closeMessage);\n    };\n    Transport.prototype.requestDisconnect = function () {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.requestDisconnect()', '');\n        this.send(disconnectMessage);\n    };\n    Transport.prototype.ping = function (id) {\n        var msg = { action: protocolmessage_1.default.Action.HEARTBEAT };\n        if (id)\n            msg.id = id;\n        this.send(protocolmessage_1.default.fromValues(msg));\n    };\n    Transport.prototype.dispose = function () {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.dispose()', '');\n        this.isDisposed = true;\n        this.off();\n    };\n    Transport.prototype.onActivity = function () {\n        if (!this.maxIdleInterval) {\n            return;\n        }\n        this.lastActivity = this.connectionManager.lastActivity = Utils.now();\n        this.setIdleTimer(this.maxIdleInterval + 100);\n    };\n    Transport.prototype.setIdleTimer = function (timeout) {\n        var _this = this;\n        if (!this.idleTimer) {\n            this.idleTimer = setTimeout(function () {\n                _this.onIdleTimerExpire();\n            }, timeout);\n        }\n    };\n    Transport.prototype.onIdleTimerExpire = function () {\n        if (!this.lastActivity || !this.maxIdleInterval) {\n            throw new Error('Transport.onIdleTimerExpire(): lastActivity/maxIdleInterval not set');\n        }\n        this.idleTimer = null;\n        var sinceLast = Utils.now() - this.lastActivity;\n        var timeRemaining = this.maxIdleInterval - sinceLast;\n        if (timeRemaining <= 0) {\n            var msg = 'No activity seen from realtime in ' + sinceLast + 'ms; assuming connection has dropped';\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Transport.onIdleTimerExpire()', msg);\n            this.disconnect(new errorinfo_1.default(msg, 80003, 408));\n        }\n        else {\n            this.setIdleTimer(timeRemaining + 100);\n        }\n    };\n    Transport.tryConnect = function (transportCtor, connectionManager, auth, transportParams, callback) {\n        var transport = new transportCtor(connectionManager, auth, transportParams);\n        var transportAttemptTimer;\n        var errorCb = function (err) {\n            clearTimeout(transportAttemptTimer);\n            callback({ event: this.event, error: err });\n        };\n        var realtimeRequestTimeout = connectionManager.options.timeouts.realtimeRequestTimeout;\n        transportAttemptTimer = setTimeout(function () {\n            transport.off(['preconnect', 'disconnected', 'failed']);\n            transport.dispose();\n            errorCb.call({ event: 'disconnected' }, new errorinfo_1.default('Timeout waiting for transport to indicate itself viable', 50000, 500));\n        }, realtimeRequestTimeout);\n        transport.on(['failed', 'disconnected'], errorCb);\n        transport.on('preconnect', function () {\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Transport.tryConnect()', 'viable transport ' + transport);\n            clearTimeout(transportAttemptTimer);\n            transport.off(['failed', 'disconnected'], errorCb);\n            callback(null, transport);\n        });\n        transport.connect();\n    };\n    return Transport;\n}(eventemitter_1.default));\nexports.default = Transport;\n\n\n/***/ }),\n/* 27 */\n/***/ (function(module, exports, __nested_webpack_require_230310__) {\n\n;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__nested_webpack_require_230310__(6), __nested_webpack_require_230310__(40), __nested_webpack_require_230310__(24));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_algo = C.algo;\n\t    var MD5 = C_algo.MD5;\n\n\t    /**\n\t     * This key derivation function is meant to conform with EVP_BytesToKey.\n\t     * www.openssl.org/docs/crypto/EVP_BytesToKey.html\n\t     */\n\t    var EvpKDF = C_algo.EvpKDF = Base.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {number} keySize The key size in words to generate. Default: 4 (128 bits)\n\t         * @property {Hasher} hasher The hash algorithm to use. Default: MD5\n\t         * @property {number} iterations The number of iterations to perform. Default: 1\n\t         */\n\t        cfg: Base.extend({\n\t            keySize: 128/32,\n\t            hasher: MD5,\n\t            iterations: 1\n\t        }),\n\n\t        /**\n\t         * Initializes a newly created key derivation function.\n\t         *\n\t         * @param {Object} cfg (Optional) The configuration options to use for the derivation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var kdf = CryptoJS.algo.EvpKDF.create();\n\t         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8 });\n\t         *     var kdf = CryptoJS.algo.EvpKDF.create({ keySize: 8, iterations: 1000 });\n\t         */\n\t        init: function (cfg) {\n\t            this.cfg = this.cfg.extend(cfg);\n\t        },\n\n\t        /**\n\t         * Derives a key from a password.\n\t         *\n\t         * @param {WordArray|string} password The password.\n\t         * @param {WordArray|string} salt A salt.\n\t         *\n\t         * @return {WordArray} The derived key.\n\t         *\n\t         * @example\n\t         *\n\t         *     var key = kdf.compute(password, salt);\n\t         */\n\t        compute: function (password, salt) {\n\t            var block;\n\n\t            // Shortcut\n\t            var cfg = this.cfg;\n\n\t            // Init hasher\n\t            var hasher = cfg.hasher.create();\n\n\t            // Initial values\n\t            var derivedKey = WordArray.create();\n\n\t            // Shortcuts\n\t            var derivedKeyWords = derivedKey.words;\n\t            var keySize = cfg.keySize;\n\t            var iterations = cfg.iterations;\n\n\t            // Generate key\n\t            while (derivedKeyWords.length < keySize) {\n\t                if (block) {\n\t                    hasher.update(block);\n\t                }\n\t                block = hasher.update(password).finalize(salt);\n\t                hasher.reset();\n\n\t                // Iterations\n\t                for (var i = 1; i < iterations; i++) {\n\t                    block = hasher.finalize(block);\n\t                    hasher.reset();\n\t                }\n\n\t                derivedKey.concat(block);\n\t            }\n\t            derivedKey.sigBytes = keySize * 4;\n\n\t            return derivedKey;\n\t        }\n\t    });\n\n\t    /**\n\t     * Derives a key from a password.\n\t     *\n\t     * @param {WordArray|string} password The password.\n\t     * @param {WordArray|string} salt A salt.\n\t     * @param {Object} cfg (Optional) The configuration options to use for this computation.\n\t     *\n\t     * @return {WordArray} The derived key.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var key = CryptoJS.EvpKDF(password, salt);\n\t     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8 });\n\t     *     var key = CryptoJS.EvpKDF(password, salt, { keySize: 8, iterations: 1000 });\n\t     */\n\t    C.EvpKDF = function (password, salt, cfg) {\n\t        return EvpKDF.create(cfg).compute(password, salt);\n\t    };\n\t}());\n\n\n\treturn CryptoJS.EvpKDF;\n\n}));\n\n/***/ }),\n/* 28 */\n/***/ (function(module, exports, __nested_webpack_require_234199__) {\n\n;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__nested_webpack_require_234199__(6), __nested_webpack_require_234199__(27));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t/**\n\t * Cipher core components.\n\t */\n\tCryptoJS.lib.Cipher || (function (undefined) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var Base = C_lib.Base;\n\t    var WordArray = C_lib.WordArray;\n\t    var BufferedBlockAlgorithm = C_lib.BufferedBlockAlgorithm;\n\t    var C_enc = C.enc;\n\t    var Utf8 = C_enc.Utf8;\n\t    var Base64 = C_enc.Base64;\n\t    var C_algo = C.algo;\n\t    var EvpKDF = C_algo.EvpKDF;\n\n\t    /**\n\t     * Abstract base cipher template.\n\t     *\n\t     * @property {number} keySize This cipher's key size. Default: 4 (128 bits)\n\t     * @property {number} ivSize This cipher's IV size. Default: 4 (128 bits)\n\t     * @property {number} _ENC_XFORM_MODE A constant representing encryption mode.\n\t     * @property {number} _DEC_XFORM_MODE A constant representing decryption mode.\n\t     */\n\t    var Cipher = C_lib.Cipher = BufferedBlockAlgorithm.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {WordArray} iv The IV to use for this operation.\n\t         */\n\t        cfg: Base.extend(),\n\n\t        /**\n\t         * Creates this cipher in encryption mode.\n\t         *\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {Cipher} A cipher instance.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.createEncryptor(keyWordArray, { iv: ivWordArray });\n\t         */\n\t        createEncryptor: function (key, cfg) {\n\t            return this.create(this._ENC_XFORM_MODE, key, cfg);\n\t        },\n\n\t        /**\n\t         * Creates this cipher in decryption mode.\n\t         *\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {Cipher} A cipher instance.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.createDecryptor(keyWordArray, { iv: ivWordArray });\n\t         */\n\t        createDecryptor: function (key, cfg) {\n\t            return this.create(this._DEC_XFORM_MODE, key, cfg);\n\t        },\n\n\t        /**\n\t         * Initializes a newly created cipher.\n\t         *\n\t         * @param {number} xformMode Either the encryption or decryption transormation mode constant.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipher = CryptoJS.algo.AES.create(CryptoJS.algo.AES._ENC_XFORM_MODE, keyWordArray, { iv: ivWordArray });\n\t         */\n\t        init: function (xformMode, key, cfg) {\n\t            // Apply config defaults\n\t            this.cfg = this.cfg.extend(cfg);\n\n\t            // Store transform mode and key\n\t            this._xformMode = xformMode;\n\t            this._key = key;\n\n\t            // Set initial values\n\t            this.reset();\n\t        },\n\n\t        /**\n\t         * Resets this cipher to its initial state.\n\t         *\n\t         * @example\n\t         *\n\t         *     cipher.reset();\n\t         */\n\t        reset: function () {\n\t            // Reset data buffer\n\t            BufferedBlockAlgorithm.reset.call(this);\n\n\t            // Perform concrete-cipher logic\n\t            this._doReset();\n\t        },\n\n\t        /**\n\t         * Adds data to be encrypted or decrypted.\n\t         *\n\t         * @param {WordArray|string} dataUpdate The data to encrypt or decrypt.\n\t         *\n\t         * @return {WordArray} The data after processing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var encrypted = cipher.process('data');\n\t         *     var encrypted = cipher.process(wordArray);\n\t         */\n\t        process: function (dataUpdate) {\n\t            // Append\n\t            this._append(dataUpdate);\n\n\t            // Process available blocks\n\t            return this._process();\n\t        },\n\n\t        /**\n\t         * Finalizes the encryption or decryption process.\n\t         * Note that the finalize operation is effectively a destructive, read-once operation.\n\t         *\n\t         * @param {WordArray|string} dataUpdate The final data to encrypt or decrypt.\n\t         *\n\t         * @return {WordArray} The data after final processing.\n\t         *\n\t         * @example\n\t         *\n\t         *     var encrypted = cipher.finalize();\n\t         *     var encrypted = cipher.finalize('data');\n\t         *     var encrypted = cipher.finalize(wordArray);\n\t         */\n\t        finalize: function (dataUpdate) {\n\t            // Final data update\n\t            if (dataUpdate) {\n\t                this._append(dataUpdate);\n\t            }\n\n\t            // Perform concrete-cipher logic\n\t            var finalProcessedData = this._doFinalize();\n\n\t            return finalProcessedData;\n\t        },\n\n\t        keySize: 128/32,\n\n\t        ivSize: 128/32,\n\n\t        _ENC_XFORM_MODE: 1,\n\n\t        _DEC_XFORM_MODE: 2,\n\n\t        /**\n\t         * Creates shortcut functions to a cipher's object interface.\n\t         *\n\t         * @param {Cipher} cipher The cipher to create a helper for.\n\t         *\n\t         * @return {Object} An object with encrypt and decrypt shortcut functions.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var AES = CryptoJS.lib.Cipher._createHelper(CryptoJS.algo.AES);\n\t         */\n\t        _createHelper: (function () {\n\t            function selectCipherStrategy(key) {\n\t                if (typeof key == 'string') {\n\t                    return PasswordBasedCipher;\n\t                } else {\n\t                    return SerializableCipher;\n\t                }\n\t            }\n\n\t            return function (cipher) {\n\t                return {\n\t                    encrypt: function (message, key, cfg) {\n\t                        return selectCipherStrategy(key).encrypt(cipher, message, key, cfg);\n\t                    },\n\n\t                    decrypt: function (ciphertext, key, cfg) {\n\t                        return selectCipherStrategy(key).decrypt(cipher, ciphertext, key, cfg);\n\t                    }\n\t                };\n\t            };\n\t        }())\n\t    });\n\n\t    /**\n\t     * Abstract base stream cipher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 1 (32 bits)\n\t     */\n\t    var StreamCipher = C_lib.StreamCipher = Cipher.extend({\n\t        _doFinalize: function () {\n\t            // Process partial blocks\n\t            var finalProcessedBlocks = this._process(!!'flush');\n\n\t            return finalProcessedBlocks;\n\t        },\n\n\t        blockSize: 1\n\t    });\n\n\t    /**\n\t     * Mode namespace.\n\t     */\n\t    var C_mode = C.mode = {};\n\n\t    /**\n\t     * Abstract base block cipher mode template.\n\t     */\n\t    var BlockCipherMode = C_lib.BlockCipherMode = Base.extend({\n\t        /**\n\t         * Creates this mode for encryption.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.createEncryptor(cipher, iv.words);\n\t         */\n\t        createEncryptor: function (cipher, iv) {\n\t            return this.Encryptor.create(cipher, iv);\n\t        },\n\n\t        /**\n\t         * Creates this mode for decryption.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.createDecryptor(cipher, iv.words);\n\t         */\n\t        createDecryptor: function (cipher, iv) {\n\t            return this.Decryptor.create(cipher, iv);\n\t        },\n\n\t        /**\n\t         * Initializes a newly created mode.\n\t         *\n\t         * @param {Cipher} cipher A block cipher instance.\n\t         * @param {Array} iv The IV words.\n\t         *\n\t         * @example\n\t         *\n\t         *     var mode = CryptoJS.mode.CBC.Encryptor.create(cipher, iv.words);\n\t         */\n\t        init: function (cipher, iv) {\n\t            this._cipher = cipher;\n\t            this._iv = iv;\n\t        }\n\t    });\n\n\t    /**\n\t     * Cipher Block Chaining mode.\n\t     */\n\t    var CBC = C_mode.CBC = (function () {\n\t        /**\n\t         * Abstract base CBC mode.\n\t         */\n\t        var CBC = BlockCipherMode.extend();\n\n\t        /**\n\t         * CBC encryptor.\n\t         */\n\t        CBC.Encryptor = CBC.extend({\n\t            /**\n\t             * Processes the data block at offset.\n\t             *\n\t             * @param {Array} words The data words to operate on.\n\t             * @param {number} offset The offset where the block starts.\n\t             *\n\t             * @example\n\t             *\n\t             *     mode.processBlock(data.words, offset);\n\t             */\n\t            processBlock: function (words, offset) {\n\t                // Shortcuts\n\t                var cipher = this._cipher;\n\t                var blockSize = cipher.blockSize;\n\n\t                // XOR and encrypt\n\t                xorBlock.call(this, words, offset, blockSize);\n\t                cipher.encryptBlock(words, offset);\n\n\t                // Remember this block to use with next block\n\t                this._prevBlock = words.slice(offset, offset + blockSize);\n\t            }\n\t        });\n\n\t        /**\n\t         * CBC decryptor.\n\t         */\n\t        CBC.Decryptor = CBC.extend({\n\t            /**\n\t             * Processes the data block at offset.\n\t             *\n\t             * @param {Array} words The data words to operate on.\n\t             * @param {number} offset The offset where the block starts.\n\t             *\n\t             * @example\n\t             *\n\t             *     mode.processBlock(data.words, offset);\n\t             */\n\t            processBlock: function (words, offset) {\n\t                // Shortcuts\n\t                var cipher = this._cipher;\n\t                var blockSize = cipher.blockSize;\n\n\t                // Remember this block to use with next block\n\t                var thisBlock = words.slice(offset, offset + blockSize);\n\n\t                // Decrypt and XOR\n\t                cipher.decryptBlock(words, offset);\n\t                xorBlock.call(this, words, offset, blockSize);\n\n\t                // This block becomes the previous block\n\t                this._prevBlock = thisBlock;\n\t            }\n\t        });\n\n\t        function xorBlock(words, offset, blockSize) {\n\t            var block;\n\n\t            // Shortcut\n\t            var iv = this._iv;\n\n\t            // Choose mixing block\n\t            if (iv) {\n\t                block = iv;\n\n\t                // Remove IV for subsequent blocks\n\t                this._iv = undefined;\n\t            } else {\n\t                block = this._prevBlock;\n\t            }\n\n\t            // XOR blocks\n\t            for (var i = 0; i < blockSize; i++) {\n\t                words[offset + i] ^= block[i];\n\t            }\n\t        }\n\n\t        return CBC;\n\t    }());\n\n\t    /**\n\t     * Padding namespace.\n\t     */\n\t    var C_pad = C.pad = {};\n\n\t    /**\n\t     * PKCS #5/7 padding strategy.\n\t     */\n\t    var Pkcs7 = C_pad.Pkcs7 = {\n\t        /**\n\t         * Pads data using the algorithm defined in PKCS #5/7.\n\t         *\n\t         * @param {WordArray} data The data to pad.\n\t         * @param {number} blockSize The multiple that the data should be padded to.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     CryptoJS.pad.Pkcs7.pad(wordArray, 4);\n\t         */\n\t        pad: function (data, blockSize) {\n\t            // Shortcut\n\t            var blockSizeBytes = blockSize * 4;\n\n\t            // Count padding bytes\n\t            var nPaddingBytes = blockSizeBytes - data.sigBytes % blockSizeBytes;\n\n\t            // Create padding word\n\t            var paddingWord = (nPaddingBytes << 24) | (nPaddingBytes << 16) | (nPaddingBytes << 8) | nPaddingBytes;\n\n\t            // Create padding\n\t            var paddingWords = [];\n\t            for (var i = 0; i < nPaddingBytes; i += 4) {\n\t                paddingWords.push(paddingWord);\n\t            }\n\t            var padding = WordArray.create(paddingWords, nPaddingBytes);\n\n\t            // Add padding\n\t            data.concat(padding);\n\t        },\n\n\t        /**\n\t         * Unpads data that had been padded using the algorithm defined in PKCS #5/7.\n\t         *\n\t         * @param {WordArray} data The data to unpad.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     CryptoJS.pad.Pkcs7.unpad(wordArray);\n\t         */\n\t        unpad: function (data) {\n\t            // Get number of padding bytes from last byte\n\t            var nPaddingBytes = data.words[(data.sigBytes - 1) >>> 2] & 0xff;\n\n\t            // Remove padding\n\t            data.sigBytes -= nPaddingBytes;\n\t        }\n\t    };\n\n\t    /**\n\t     * Abstract base block cipher template.\n\t     *\n\t     * @property {number} blockSize The number of 32-bit words this cipher operates on. Default: 4 (128 bits)\n\t     */\n\t    var BlockCipher = C_lib.BlockCipher = Cipher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {Mode} mode The block mode to use. Default: CBC\n\t         * @property {Padding} padding The padding strategy to use. Default: Pkcs7\n\t         */\n\t        cfg: Cipher.cfg.extend({\n\t            mode: CBC,\n\t            padding: Pkcs7\n\t        }),\n\n\t        reset: function () {\n\t            var modeCreator;\n\n\t            // Reset cipher\n\t            Cipher.reset.call(this);\n\n\t            // Shortcuts\n\t            var cfg = this.cfg;\n\t            var iv = cfg.iv;\n\t            var mode = cfg.mode;\n\n\t            // Reset block mode\n\t            if (this._xformMode == this._ENC_XFORM_MODE) {\n\t                modeCreator = mode.createEncryptor;\n\t            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n\t                modeCreator = mode.createDecryptor;\n\t                // Keep at least one block in the buffer for unpadding\n\t                this._minBufferSize = 1;\n\t            }\n\n\t            if (this._mode && this._mode.__creator == modeCreator) {\n\t                this._mode.init(this, iv && iv.words);\n\t            } else {\n\t                this._mode = modeCreator.call(mode, this, iv && iv.words);\n\t                this._mode.__creator = modeCreator;\n\t            }\n\t        },\n\n\t        _doProcessBlock: function (words, offset) {\n\t            this._mode.processBlock(words, offset);\n\t        },\n\n\t        _doFinalize: function () {\n\t            var finalProcessedBlocks;\n\n\t            // Shortcut\n\t            var padding = this.cfg.padding;\n\n\t            // Finalize\n\t            if (this._xformMode == this._ENC_XFORM_MODE) {\n\t                // Pad data\n\t                padding.pad(this._data, this.blockSize);\n\n\t                // Process final blocks\n\t                finalProcessedBlocks = this._process(!!'flush');\n\t            } else /* if (this._xformMode == this._DEC_XFORM_MODE) */ {\n\t                // Process final blocks\n\t                finalProcessedBlocks = this._process(!!'flush');\n\n\t                // Unpad data\n\t                padding.unpad(finalProcessedBlocks);\n\t            }\n\n\t            return finalProcessedBlocks;\n\t        },\n\n\t        blockSize: 128/32\n\t    });\n\n\t    /**\n\t     * A collection of cipher parameters.\n\t     *\n\t     * @property {WordArray} ciphertext The raw ciphertext.\n\t     * @property {WordArray} key The key to this ciphertext.\n\t     * @property {WordArray} iv The IV used in the ciphering operation.\n\t     * @property {WordArray} salt The salt used with a key derivation function.\n\t     * @property {Cipher} algorithm The cipher algorithm.\n\t     * @property {Mode} mode The block mode used in the ciphering operation.\n\t     * @property {Padding} padding The padding scheme used in the ciphering operation.\n\t     * @property {number} blockSize The block size of the cipher.\n\t     * @property {Format} formatter The default formatting strategy to convert this cipher params object to a string.\n\t     */\n\t    var CipherParams = C_lib.CipherParams = Base.extend({\n\t        /**\n\t         * Initializes a newly created cipher params object.\n\t         *\n\t         * @param {Object} cipherParams An object with any of the possible cipher parameters.\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.lib.CipherParams.create({\n\t         *         ciphertext: ciphertextWordArray,\n\t         *         key: keyWordArray,\n\t         *         iv: ivWordArray,\n\t         *         salt: saltWordArray,\n\t         *         algorithm: CryptoJS.algo.AES,\n\t         *         mode: CryptoJS.mode.CBC,\n\t         *         padding: CryptoJS.pad.PKCS7,\n\t         *         blockSize: 4,\n\t         *         formatter: CryptoJS.format.OpenSSL\n\t         *     });\n\t         */\n\t        init: function (cipherParams) {\n\t            this.mixIn(cipherParams);\n\t        },\n\n\t        /**\n\t         * Converts this cipher params object to a string.\n\t         *\n\t         * @param {Format} formatter (Optional) The formatting strategy to use.\n\t         *\n\t         * @return {string} The stringified cipher params.\n\t         *\n\t         * @throws Error If neither the formatter nor the default formatter is set.\n\t         *\n\t         * @example\n\t         *\n\t         *     var string = cipherParams + '';\n\t         *     var string = cipherParams.toString();\n\t         *     var string = cipherParams.toString(CryptoJS.format.OpenSSL);\n\t         */\n\t        toString: function (formatter) {\n\t            return (formatter || this.formatter).stringify(this);\n\t        }\n\t    });\n\n\t    /**\n\t     * Format namespace.\n\t     */\n\t    var C_format = C.format = {};\n\n\t    /**\n\t     * OpenSSL formatting strategy.\n\t     */\n\t    var OpenSSLFormatter = C_format.OpenSSL = {\n\t        /**\n\t         * Converts a cipher params object to an OpenSSL-compatible string.\n\t         *\n\t         * @param {CipherParams} cipherParams The cipher params object.\n\t         *\n\t         * @return {string} The OpenSSL-compatible string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var openSSLString = CryptoJS.format.OpenSSL.stringify(cipherParams);\n\t         */\n\t        stringify: function (cipherParams) {\n\t            var wordArray;\n\n\t            // Shortcuts\n\t            var ciphertext = cipherParams.ciphertext;\n\t            var salt = cipherParams.salt;\n\n\t            // Format\n\t            if (salt) {\n\t                wordArray = WordArray.create([0x53616c74, 0x65645f5f]).concat(salt).concat(ciphertext);\n\t            } else {\n\t                wordArray = ciphertext;\n\t            }\n\n\t            return wordArray.toString(Base64);\n\t        },\n\n\t        /**\n\t         * Converts an OpenSSL-compatible string to a cipher params object.\n\t         *\n\t         * @param {string} openSSLStr The OpenSSL-compatible string.\n\t         *\n\t         * @return {CipherParams} The cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.format.OpenSSL.parse(openSSLString);\n\t         */\n\t        parse: function (openSSLStr) {\n\t            var salt;\n\n\t            // Parse base64\n\t            var ciphertext = Base64.parse(openSSLStr);\n\n\t            // Shortcut\n\t            var ciphertextWords = ciphertext.words;\n\n\t            // Test for salt\n\t            if (ciphertextWords[0] == 0x53616c74 && ciphertextWords[1] == 0x65645f5f) {\n\t                // Extract salt\n\t                salt = WordArray.create(ciphertextWords.slice(2, 4));\n\n\t                // Remove salt from ciphertext\n\t                ciphertextWords.splice(0, 4);\n\t                ciphertext.sigBytes -= 16;\n\t            }\n\n\t            return CipherParams.create({ ciphertext: ciphertext, salt: salt });\n\t        }\n\t    };\n\n\t    /**\n\t     * A cipher wrapper that returns ciphertext as a serializable cipher params object.\n\t     */\n\t    var SerializableCipher = C_lib.SerializableCipher = Base.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {Formatter} format The formatting strategy to convert cipher param objects to and from a string. Default: OpenSSL\n\t         */\n\t        cfg: Base.extend({\n\t            format: OpenSSLFormatter\n\t        }),\n\n\t        /**\n\t         * Encrypts a message.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {WordArray|string} message The message to encrypt.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {CipherParams} A cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key);\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv });\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher.encrypt(CryptoJS.algo.AES, message, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         */\n\t        encrypt: function (cipher, message, key, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Encrypt\n\t            var encryptor = cipher.createEncryptor(key, cfg);\n\t            var ciphertext = encryptor.finalize(message);\n\n\t            // Shortcut\n\t            var cipherCfg = encryptor.cfg;\n\n\t            // Create and return serializable cipher params\n\t            return CipherParams.create({\n\t                ciphertext: ciphertext,\n\t                key: key,\n\t                iv: cipherCfg.iv,\n\t                algorithm: cipher,\n\t                mode: cipherCfg.mode,\n\t                padding: cipherCfg.padding,\n\t                blockSize: cipher.blockSize,\n\t                formatter: cfg.format\n\t            });\n\t        },\n\n\t        /**\n\t         * Decrypts serialized ciphertext.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n\t         * @param {WordArray} key The key.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {WordArray} The plaintext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         *     var plaintext = CryptoJS.lib.SerializableCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, key, { iv: iv, format: CryptoJS.format.OpenSSL });\n\t         */\n\t        decrypt: function (cipher, ciphertext, key, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Convert string to CipherParams\n\t            ciphertext = this._parse(ciphertext, cfg.format);\n\n\t            // Decrypt\n\t            var plaintext = cipher.createDecryptor(key, cfg).finalize(ciphertext.ciphertext);\n\n\t            return plaintext;\n\t        },\n\n\t        /**\n\t         * Converts serialized ciphertext to CipherParams,\n\t         * else assumed CipherParams already and returns ciphertext unchanged.\n\t         *\n\t         * @param {CipherParams|string} ciphertext The ciphertext.\n\t         * @param {Formatter} format The formatting strategy to use to parse serialized ciphertext.\n\t         *\n\t         * @return {CipherParams} The unserialized ciphertext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.SerializableCipher._parse(ciphertextStringOrParams, format);\n\t         */\n\t        _parse: function (ciphertext, format) {\n\t            if (typeof ciphertext == 'string') {\n\t                return format.parse(ciphertext, this);\n\t            } else {\n\t                return ciphertext;\n\t            }\n\t        }\n\t    });\n\n\t    /**\n\t     * Key derivation function namespace.\n\t     */\n\t    var C_kdf = C.kdf = {};\n\n\t    /**\n\t     * OpenSSL key derivation function.\n\t     */\n\t    var OpenSSLKdf = C_kdf.OpenSSL = {\n\t        /**\n\t         * Derives a key and IV from a password.\n\t         *\n\t         * @param {string} password The password to derive from.\n\t         * @param {number} keySize The size in words of the key to generate.\n\t         * @param {number} ivSize The size in words of the IV to generate.\n\t         * @param {WordArray|string} salt (Optional) A 64-bit salt to use. If omitted, a salt will be generated randomly.\n\t         *\n\t         * @return {CipherParams} A cipher params object with the key, IV, and salt.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32);\n\t         *     var derivedParams = CryptoJS.kdf.OpenSSL.execute('Password', 256/32, 128/32, 'saltsalt');\n\t         */\n\t        execute: function (password, keySize, ivSize, salt) {\n\t            // Generate random salt\n\t            if (!salt) {\n\t                salt = WordArray.random(64/8);\n\t            }\n\n\t            // Derive key and IV\n\t            var key = EvpKDF.create({ keySize: keySize + ivSize }).compute(password, salt);\n\n\t            // Separate key and IV\n\t            var iv = WordArray.create(key.words.slice(keySize), ivSize * 4);\n\t            key.sigBytes = keySize * 4;\n\n\t            // Return params\n\t            return CipherParams.create({ key: key, iv: iv, salt: salt });\n\t        }\n\t    };\n\n\t    /**\n\t     * A serializable cipher wrapper that derives the key from a password,\n\t     * and returns ciphertext as a serializable cipher params object.\n\t     */\n\t    var PasswordBasedCipher = C_lib.PasswordBasedCipher = SerializableCipher.extend({\n\t        /**\n\t         * Configuration options.\n\t         *\n\t         * @property {KDF} kdf The key derivation function to use to generate a key and IV from a password. Default: OpenSSL\n\t         */\n\t        cfg: SerializableCipher.cfg.extend({\n\t            kdf: OpenSSLKdf\n\t        }),\n\n\t        /**\n\t         * Encrypts a message using a password.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {WordArray|string} message The message to encrypt.\n\t         * @param {string} password The password.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {CipherParams} A cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password');\n\t         *     var ciphertextParams = CryptoJS.lib.PasswordBasedCipher.encrypt(CryptoJS.algo.AES, message, 'password', { format: CryptoJS.format.OpenSSL });\n\t         */\n\t        encrypt: function (cipher, message, password, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Derive key and other params\n\t            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize);\n\n\t            // Add IV to config\n\t            cfg.iv = derivedParams.iv;\n\n\t            // Encrypt\n\t            var ciphertext = SerializableCipher.encrypt.call(this, cipher, message, derivedParams.key, cfg);\n\n\t            // Mix in derived params\n\t            ciphertext.mixIn(derivedParams);\n\n\t            return ciphertext;\n\t        },\n\n\t        /**\n\t         * Decrypts serialized ciphertext using a password.\n\t         *\n\t         * @param {Cipher} cipher The cipher algorithm to use.\n\t         * @param {CipherParams|string} ciphertext The ciphertext to decrypt.\n\t         * @param {string} password The password.\n\t         * @param {Object} cfg (Optional) The configuration options to use for this operation.\n\t         *\n\t         * @return {WordArray} The plaintext.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, formattedCiphertext, 'password', { format: CryptoJS.format.OpenSSL });\n\t         *     var plaintext = CryptoJS.lib.PasswordBasedCipher.decrypt(CryptoJS.algo.AES, ciphertextParams, 'password', { format: CryptoJS.format.OpenSSL });\n\t         */\n\t        decrypt: function (cipher, ciphertext, password, cfg) {\n\t            // Apply config defaults\n\t            cfg = this.cfg.extend(cfg);\n\n\t            // Convert string to CipherParams\n\t            ciphertext = this._parse(ciphertext, cfg.format);\n\n\t            // Derive key and other params\n\t            var derivedParams = cfg.kdf.execute(password, cipher.keySize, cipher.ivSize, ciphertext.salt);\n\n\t            // Add IV to config\n\t            cfg.iv = derivedParams.iv;\n\n\t            // Decrypt\n\t            var plaintext = SerializableCipher.decrypt.call(this, cipher, ciphertext, derivedParams.key, cfg);\n\n\t            return plaintext;\n\t        }\n\t    });\n\t}());\n\n\n}));\n\n/***/ }),\n/* 29 */\n/***/ (function(module, exports, __nested_webpack_require_263745__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Request = exports.createRequest = void 0;\nvar tslib_1 = __nested_webpack_require_263745__(0);\nvar Utils = tslib_1.__importStar(__nested_webpack_require_263745__(1));\nvar comettransport_1 = tslib_1.__importDefault(__nested_webpack_require_263745__(12));\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_263745__(3));\nvar eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_263745__(7));\nvar errorinfo_1 = __nested_webpack_require_263745__(4);\nvar defaults_1 = tslib_1.__importDefault(__nested_webpack_require_263745__(8));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_263745__(2));\nvar XHRStates_1 = tslib_1.__importDefault(__nested_webpack_require_263745__(21));\n// Workaround for salesforce lightning locker compatibility\nvar globalObject = Utils.getGlobalObject();\nvar noop = function () { };\n/* Can't just use window.Ably, as that won't exist if using the commonjs version. */\nvar _ = (globalObject._ablyjs_jsonp = {});\n/* express strips out parantheses from the callback!\n * Kludge to still alow its responses to work, while not keeping the\n * function form for normal use and not cluttering window.Ably\n * https://github.com/expressjs/express/blob/5b4d4b4ab1324743534fbcd4709f4e75bb4b4e9d/lib/response.js#L305\n */\n_._ = function (id) {\n    return _['_' + id] || noop;\n};\nvar idCounter = 1;\nvar shortName = 'jsonp';\nfunction createRequest(uri, headers, params, body, requestMode, timeouts, method) {\n    /* JSONP requests are used either with the context being a realtime\n     * transport, or with timeouts passed in (for when used by a rest client),\n     * or completely standalone.  Use the appropriate timeouts in each case */\n    timeouts = timeouts || defaults_1.default.TIMEOUTS;\n    return new Request(undefined, uri, headers, Utils.copy(params), body, requestMode, timeouts, method);\n}\nexports.createRequest = createRequest;\nvar JSONPTransport = /** @class */ (function (_super) {\n    tslib_1.__extends(JSONPTransport, _super);\n    function JSONPTransport(connectionManager, auth, params) {\n        var _this = _super.call(this, connectionManager, auth, params) || this;\n        _this.shortName = shortName;\n        params.stream = false;\n        return _this;\n    }\n    JSONPTransport.isAvailable = function () {\n        return platform_1.default.Config.jsonpSupported && platform_1.default.Config.allowComet;\n    };\n    JSONPTransport.prototype.toString = function () {\n        return 'JSONPTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;\n    };\n    JSONPTransport.prototype.createRequest = function (uri, headers, params, body, requestMode, timeouts, method) {\n        /* JSONP requests are used either with the context being a realtime\n         * transport, or with timeouts passed in (for when used by a rest client),\n         * or completely standalone.  Use the appropriate timeouts in each case */\n        timeouts = (this === null || this === void 0 ? void 0 : this.timeouts) || timeouts || defaults_1.default.TIMEOUTS;\n        return createRequest(uri, headers, params, body, requestMode, timeouts, method);\n    };\n    return JSONPTransport;\n}(comettransport_1.default));\nvar Request = /** @class */ (function (_super) {\n    tslib_1.__extends(Request, _super);\n    function Request(id, uri, headers, params, body, requestMode, timeouts, method) {\n        var _this = _super.call(this) || this;\n        if (id === undefined)\n            id = idCounter++;\n        _this.id = id;\n        _this.uri = uri;\n        _this.params = params || {};\n        _this.params.rnd = Utils.cheapRandStr();\n        if (headers) {\n            /* JSONP doesn't allow headers. Cherry-pick a couple to turn into qs params */\n            if (headers['X-Ably-Version'])\n                _this.params.v = headers['X-Ably-Version'];\n            if (headers['X-Ably-Lib'])\n                _this.params.lib = headers['X-Ably-Lib'];\n        }\n        _this.body = body;\n        _this.method = method;\n        _this.requestMode = requestMode;\n        _this.timeouts = timeouts;\n        _this.requestComplete = false;\n        return _this;\n    }\n    Request.prototype.exec = function () {\n        var _this = this;\n        var id = this.id, body = this.body, method = this.method, uri = this.uri, params = this.params;\n        params.callback = '_ablyjs_jsonp._(' + id + ')';\n        params.envelope = 'jsonp';\n        if (body) {\n            params.body = body;\n        }\n        if (method && method !== 'get') {\n            params.method = method;\n        }\n        var script = (this.script = document.createElement('script'));\n        var src = uri + Utils.toQueryString(params);\n        script.src = src;\n        if (script.src.split('/').slice(-1)[0] !== src.split('/').slice(-1)[0]) {\n            /* The src has been truncated. Can't abort, but can at least emit an\n             * error so the user knows what's gone wrong. (Can't compare strings\n             * directly as src may have a port, script.src won't) */\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'JSONP Request.exec()', 'Warning: the browser appears to have truncated the script URI. This will likely result in the request failing due to an unparseable body param');\n        }\n        script.async = true;\n        script.type = 'text/javascript';\n        script.charset = 'UTF-8';\n        script.onerror = function (err) {\n            _this.complete(new errorinfo_1.PartialErrorInfo('JSONP script error (event: ' + platform_1.default.Config.inspect(err) + ')', null, 400));\n        };\n        _['_' + id] = function (message) {\n            if (message.statusCode) {\n                /* Handle as enveloped jsonp, as all jsonp transport uses should be */\n                var response = message.response;\n                if (message.statusCode == 204) {\n                    _this.complete(null, null, null, message.statusCode);\n                }\n                else if (!response) {\n                    _this.complete(new errorinfo_1.PartialErrorInfo('Invalid server response: no envelope detected', null, 500));\n                }\n                else if (message.statusCode < 400 || Utils.isArray(response)) {\n                    /* If response is an array, it's an array of protocol messages -- even if\n                     * it contains an error action (hence the nonsuccess statuscode), we can\n                     * consider the request to have succeeded, just pass it on to\n                     * onProtocolMessage to decide what to do */\n                    _this.complete(null, response, message.headers, message.statusCode);\n                }\n                else {\n                    var err = response.error || new errorinfo_1.PartialErrorInfo('Error response received from server', null, message.statusCode);\n                    _this.complete(err);\n                }\n            }\n            else {\n                /* Handle as non-enveloped -- as will be eg from a customer's authUrl server */\n                _this.complete(null, message);\n            }\n        };\n        var timeout = this.requestMode == XHRStates_1.default.REQ_SEND ? this.timeouts.httpRequestTimeout : this.timeouts.recvTimeout;\n        this.timer = setTimeout(this.abort.bind(this), timeout);\n        var head = document.getElementsByTagName('head')[0];\n        head.insertBefore(script, head.firstChild);\n    };\n    Request.prototype.complete = function (err, body, headers, statusCode) {\n        headers = headers || {};\n        if (!this.requestComplete) {\n            this.requestComplete = true;\n            var contentType = void 0;\n            if (body) {\n                contentType = typeof body == 'string' ? 'text/plain' : 'application/json';\n                headers['content-type'] = contentType;\n                this.emit('data', body);\n            }\n            this.emit('complete', err, body, headers, /* unpacked: */ true, statusCode);\n            this.dispose();\n        }\n    };\n    Request.prototype.abort = function () {\n        this.dispose();\n    };\n    Request.prototype.dispose = function () {\n        var timer = this.timer;\n        if (timer) {\n            clearTimeout(timer);\n            this.timer = null;\n        }\n        var script = this.script;\n        if (script.parentNode)\n            script.parentNode.removeChild(script);\n        delete _[this.id];\n        this.emit('disposed');\n    };\n    return Request;\n}(eventemitter_1.default));\nexports.Request = Request;\nfunction default_1(connectionManager) {\n    globalObject.JSONPTransport = JSONPTransport;\n    if (JSONPTransport.isAvailable()) {\n        connectionManager.supportedTransports[shortName] = JSONPTransport;\n    }\n    return JSONPTransport;\n}\nexports.default = default_1;\n\n\n/***/ }),\n/* 30 */\n/***/ (function(module, exports, __nested_webpack_require_272498__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_272498__(0);\nvar Utils = tslib_1.__importStar(__nested_webpack_require_272498__(1));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_272498__(2));\nvar defaults_1 = tslib_1.__importDefault(__nested_webpack_require_272498__(8));\nvar auth_1 = tslib_1.__importDefault(__nested_webpack_require_272498__(17));\nvar push_1 = tslib_1.__importDefault(__nested_webpack_require_272498__(46));\nvar paginatedresource_1 = tslib_1.__importDefault(__nested_webpack_require_272498__(19));\nvar channel_1 = tslib_1.__importDefault(__nested_webpack_require_272498__(33));\nvar errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_272498__(4));\nvar stats_1 = tslib_1.__importDefault(__nested_webpack_require_272498__(49));\nvar HttpMethods_1 = tslib_1.__importDefault(__nested_webpack_require_272498__(18));\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_272498__(3));\nvar message_1 = tslib_1.__importDefault(__nested_webpack_require_272498__(9));\nvar presencemessage_1 = tslib_1.__importDefault(__nested_webpack_require_272498__(15));\nvar resource_1 = tslib_1.__importDefault(__nested_webpack_require_272498__(14));\nvar noop = function () { };\nvar Rest = /** @class */ (function () {\n    function Rest(options) {\n        if (!options) {\n            var msg = 'no options provided';\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Rest()', msg);\n            throw new Error(msg);\n        }\n        var optionsObj = defaults_1.default.objectifyOptions(options);\n        if (optionsObj.log) {\n            logger_1.default.setLog(optionsObj.log.level, optionsObj.log.handler);\n        }\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Rest()', 'initialized with clientOptions ' + platform_1.default.Config.inspect(options));\n        var normalOptions = (this.options = defaults_1.default.normaliseOptions(optionsObj));\n        /* process options */\n        if (normalOptions.key) {\n            var keyMatch = normalOptions.key.match(/^([^:\\s]+):([^:.\\s]+)$/);\n            if (!keyMatch) {\n                var msg = 'invalid key parameter';\n                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Rest()', msg);\n                throw new errorinfo_1.default(msg, 40400, 404);\n            }\n            normalOptions.keyName = keyMatch[1];\n            normalOptions.keySecret = keyMatch[2];\n        }\n        if ('clientId' in normalOptions) {\n            if (!(typeof normalOptions.clientId === 'string' || normalOptions.clientId === null))\n                throw new errorinfo_1.default('clientId must be either a string or null', 40012, 400);\n            else if (normalOptions.clientId === '*')\n                throw new errorinfo_1.default('Canâ€™t use \"*\" as a clientId as that string is reserved. (To change the default token request behaviour to use a wildcard clientId, use {defaultTokenParams: {clientId: \"*\"}})', 40012, 400);\n        }\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Rest()', 'started; version = ' + defaults_1.default.version);\n        this.baseUri = this.authority = function (host) {\n            return defaults_1.default.getHttpScheme(normalOptions) + host + ':' + defaults_1.default.getPort(normalOptions, false);\n        };\n        this._currentFallback = null;\n        this.serverTimeOffset = null;\n        this.http = new platform_1.default.Http(normalOptions);\n        this.auth = new auth_1.default(this, normalOptions);\n        this.channels = new Channels(this);\n        this.push = new push_1.default(this);\n    }\n    Rest.prototype.stats = function (params, callback) {\n        /* params and callback are optional; see if params contains the callback */\n        if (callback === undefined) {\n            if (typeof params == 'function') {\n                callback = params;\n                params = null;\n            }\n            else {\n                if (this.options.promises) {\n                    return Utils.promisify(this, 'stats', [params]);\n                }\n                callback = noop;\n            }\n        }\n        var headers = Utils.defaultGetHeaders(this.options), format = this.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.http.supportsLinkHeaders ? undefined : format;\n        if (this.options.headers)\n            Utils.mixin(headers, this.options.headers);\n        new paginatedresource_1.default(this, '/stats', headers, envelope, function (body, headers, unpacked) {\n            var statsValues = unpacked ? body : JSON.parse(body);\n            for (var i = 0; i < statsValues.length; i++)\n                statsValues[i] = stats_1.default.fromValues(statsValues[i]);\n            return statsValues;\n        }).get(params, callback);\n    };\n    Rest.prototype.time = function (params, callback) {\n        var _this = this;\n        /* params and callback are optional; see if params contains the callback */\n        if (callback === undefined) {\n            if (typeof params == 'function') {\n                callback = params;\n                params = null;\n            }\n            else {\n                if (this.options.promises) {\n                    return Utils.promisify(this, 'time', [params]);\n                }\n            }\n        }\n        var _callback = callback || noop;\n        var headers = Utils.defaultGetHeaders(this.options);\n        if (this.options.headers)\n            Utils.mixin(headers, this.options.headers);\n        var timeUri = function (host) {\n            return _this.authority(host) + '/time';\n        };\n        this.http.do(HttpMethods_1.default.Get, this, timeUri, headers, null, params, function (err, res, headers, unpacked) {\n            if (err) {\n                _callback(err);\n                return;\n            }\n            if (!unpacked)\n                res = JSON.parse(res);\n            var time = res[0];\n            if (!time) {\n                _callback(new errorinfo_1.default('Internal error (unexpected result type from GET /time)', 50000, 500));\n                return;\n            }\n            /* calculate time offset only once for this device by adding to the prototype */\n            _this.serverTimeOffset = time - Utils.now();\n            _callback(null, time);\n        });\n    };\n    Rest.prototype.request = function (method, path, params, body, customHeaders, callback) {\n        var useBinary = this.options.useBinaryProtocol, encoder = useBinary ? platform_1.default.Config.msgpack.encode : JSON.stringify, decoder = useBinary ? platform_1.default.Config.msgpack.decode : JSON.parse, format = useBinary ? Utils.Format.msgpack : Utils.Format.json, envelope = this.http.supportsLinkHeaders ? undefined : format;\n        params = params || {};\n        var _method = method.toLowerCase();\n        var headers = _method == 'get' ? Utils.defaultGetHeaders(this.options, format) : Utils.defaultPostHeaders(this.options, format);\n        if (callback === undefined) {\n            if (this.options.promises) {\n                return Utils.promisify(this, 'request', [method, path, params, body, customHeaders]);\n            }\n            callback = noop;\n        }\n        if (typeof body !== 'string') {\n            body = encoder(body);\n        }\n        if (this.options.headers) {\n            Utils.mixin(headers, this.options.headers);\n        }\n        if (customHeaders) {\n            Utils.mixin(headers, customHeaders);\n        }\n        var paginatedResource = new paginatedresource_1.default(this, path, headers, envelope, function (resbody, headers, unpacked) {\n            return Utils.ensureArray(unpacked ? resbody : decoder(resbody));\n        }, \n        /* useHttpPaginatedResponse: */ true);\n        if (!Utils.arrIn(platform_1.default.Http.methods, _method)) {\n            throw new errorinfo_1.default('Unsupported method ' + _method, 40500, 405);\n        }\n        if (Utils.arrIn(platform_1.default.Http.methodsWithBody, _method)) {\n            paginatedResource[_method](params, body, callback);\n        }\n        else {\n            paginatedResource[_method](params, callback);\n        }\n    };\n    Rest.prototype.batchPublish = function (specOrSpecs, callbackArg) {\n        if (callbackArg === undefined) {\n            if (this.options.promises) {\n                return Utils.promisify(this, 'batchPublish', [specOrSpecs]);\n            }\n            callbackArg = noop;\n        }\n        var callback = callbackArg;\n        var requestBodyDTO;\n        var singleSpecMode;\n        if (Utils.isArray(specOrSpecs)) {\n            requestBodyDTO = specOrSpecs;\n            singleSpecMode = false;\n        }\n        else {\n            requestBodyDTO = [specOrSpecs];\n            singleSpecMode = true;\n        }\n        var format = this.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(this.options, format);\n        if (this.options.headers)\n            Utils.mixin(headers, this.options.headers);\n        var requestBody = Utils.encodeBody(requestBodyDTO, format);\n        resource_1.default.post(this, '/messages', requestBody, headers, { newBatchResponse: 'true' }, null, function (err, body, headers, unpacked) {\n            if (err) {\n                // TODO remove this type assertion after fixing https://github.com/ably/ably-js/issues/1405\n                callback(err);\n                return;\n            }\n            var batchResults = (unpacked ? body : Utils.decodeBody(body, format));\n            // I don't love the below type assertions for `callback` but not sure how to avoid them\n            if (singleSpecMode) {\n                callback(null, batchResults[0]);\n            }\n            else {\n                callback(null, batchResults);\n            }\n        });\n    };\n    Rest.prototype.batchPresence = function (channels, callbackArg) {\n        if (callbackArg === undefined) {\n            if (this.options.promises) {\n                return Utils.promisify(this, 'batchPresence', [channels]);\n            }\n            callbackArg = noop;\n        }\n        var callback = callbackArg;\n        var format = this.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(this.options, format);\n        if (this.options.headers)\n            Utils.mixin(headers, this.options.headers);\n        var channelsParam = channels.join(',');\n        resource_1.default.get(this, '/presence', headers, { newBatchResponse: 'true', channels: channelsParam }, null, function (err, body, headers, unpacked) {\n            if (err) {\n                // TODO remove this type assertion after fixing https://github.com/ably/ably-js/issues/1405\n                callback(err);\n                return;\n            }\n            var batchResult = (unpacked ? body : Utils.decodeBody(body, format));\n            callback(null, batchResult);\n        });\n    };\n    Rest.prototype.setLog = function (logOptions) {\n        logger_1.default.setLog(logOptions.level, logOptions.handler);\n    };\n    Rest.Promise = function (options) {\n        options = defaults_1.default.objectifyOptions(options);\n        options.promises = true;\n        return new Rest(options);\n    };\n    Rest.Callbacks = Rest;\n    Rest.Platform = platform_1.default;\n    Rest.Message = message_1.default;\n    Rest.PresenceMessage = presencemessage_1.default;\n    return Rest;\n}());\nvar Channels = /** @class */ (function () {\n    function Channels(rest) {\n        this.rest = rest;\n        this.all = Object.create(null);\n    }\n    Channels.prototype.get = function (name, channelOptions) {\n        name = String(name);\n        var channel = this.all[name];\n        if (!channel) {\n            this.all[name] = channel = new channel_1.default(this.rest, name, channelOptions);\n        }\n        else if (channelOptions) {\n            channel.setOptions(channelOptions);\n        }\n        return channel;\n    };\n    /* Included to support certain niche use-cases; most users should ignore this.\n     * Please do not use this unless you know what you're doing */\n    Channels.prototype.release = function (name) {\n        delete this.all[String(name)];\n    };\n    return Channels;\n}());\nexports.default = Rest;\n\n\n/***/ }),\n/* 31 */\n/***/ (function(module, exports, __nested_webpack_require_284643__) {\n\n;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__nested_webpack_require_284643__(6));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\treturn CryptoJS.enc.Utf8;\n\n}));\n\n/***/ }),\n/* 32 */\n/***/ (function(module, exports, __nested_webpack_require_284914__) {\n\n;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__nested_webpack_require_284914__(6));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Initialization and round constants tables\n\t    var H = [];\n\t    var K = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        function isPrime(n) {\n\t            var sqrtN = Math.sqrt(n);\n\t            for (var factor = 2; factor <= sqrtN; factor++) {\n\t                if (!(n % factor)) {\n\t                    return false;\n\t                }\n\t            }\n\n\t            return true;\n\t        }\n\n\t        function getFractionalBits(n) {\n\t            return ((n - (n | 0)) * 0x100000000) | 0;\n\t        }\n\n\t        var n = 2;\n\t        var nPrime = 0;\n\t        while (nPrime < 64) {\n\t            if (isPrime(n)) {\n\t                if (nPrime < 8) {\n\t                    H[nPrime] = getFractionalBits(Math.pow(n, 1 / 2));\n\t                }\n\t                K[nPrime] = getFractionalBits(Math.pow(n, 1 / 3));\n\n\t                nPrime++;\n\t            }\n\n\t            n++;\n\t        }\n\t    }());\n\n\t    // Reusable object\n\t    var W = [];\n\n\t    /**\n\t     * SHA-256 hash algorithm.\n\t     */\n\t    var SHA256 = C_algo.SHA256 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init(H.slice(0));\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\t            var f = H[5];\n\t            var g = H[6];\n\t            var h = H[7];\n\n\t            // Computation\n\t            for (var i = 0; i < 64; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var gamma0x = W[i - 15];\n\t                    var gamma0  = ((gamma0x << 25) | (gamma0x >>> 7))  ^\n\t                                  ((gamma0x << 14) | (gamma0x >>> 18)) ^\n\t                                   (gamma0x >>> 3);\n\n\t                    var gamma1x = W[i - 2];\n\t                    var gamma1  = ((gamma1x << 15) | (gamma1x >>> 17)) ^\n\t                                  ((gamma1x << 13) | (gamma1x >>> 19)) ^\n\t                                   (gamma1x >>> 10);\n\n\t                    W[i] = gamma0 + W[i - 7] + gamma1 + W[i - 16];\n\t                }\n\n\t                var ch  = (e & f) ^ (~e & g);\n\t                var maj = (a & b) ^ (a & c) ^ (b & c);\n\n\t                var sigma0 = ((a << 30) | (a >>> 2)) ^ ((a << 19) | (a >>> 13)) ^ ((a << 10) | (a >>> 22));\n\t                var sigma1 = ((e << 26) | (e >>> 6)) ^ ((e << 21) | (e >>> 11)) ^ ((e << 7)  | (e >>> 25));\n\n\t                var t1 = h + sigma1 + ch + K[i] + W[i];\n\t                var t2 = sigma0 + maj;\n\n\t                h = g;\n\t                g = f;\n\t                f = e;\n\t                e = (d + t1) | 0;\n\t                d = c;\n\t                c = b;\n\t                b = a;\n\t                a = (t1 + t2) | 0;\n\t            }\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t            H[5] = (H[5] + f) | 0;\n\t            H[6] = (H[6] + g) | 0;\n\t            H[7] = (H[7] + h) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA256('message');\n\t     *     var hash = CryptoJS.SHA256(wordArray);\n\t     */\n\t    C.SHA256 = Hasher._createHelper(SHA256);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA256(message, key);\n\t     */\n\t    C.HmacSHA256 = Hasher._createHmacHelper(SHA256);\n\t}(Math));\n\n\n\treturn CryptoJS.SHA256;\n\n}));\n\n/***/ }),\n/* 33 */\n/***/ (function(module, exports, __nested_webpack_require_290363__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_290363__(0);\nvar Utils = tslib_1.__importStar(__nested_webpack_require_290363__(1));\nvar eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_290363__(7));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_290363__(2));\nvar presence_1 = tslib_1.__importDefault(__nested_webpack_require_290363__(34));\nvar message_1 = tslib_1.__importDefault(__nested_webpack_require_290363__(9));\nvar errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_290363__(4));\nvar paginatedresource_1 = tslib_1.__importDefault(__nested_webpack_require_290363__(19));\nvar resource_1 = tslib_1.__importDefault(__nested_webpack_require_290363__(14));\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_290363__(3));\nfunction noop() { }\nvar MSG_ID_ENTROPY_BYTES = 9;\nfunction allEmptyIds(messages) {\n    return Utils.arrEvery(messages, function (message) {\n        return !message.id;\n    });\n}\nfunction normaliseChannelOptions(options) {\n    var channelOptions = options || {};\n    if (channelOptions.cipher) {\n        if (!platform_1.default.Crypto)\n            throw new Error('Encryption not enabled; use ably.encryption.js instead');\n        var cipher = platform_1.default.Crypto.getCipher(channelOptions.cipher);\n        channelOptions.cipher = cipher.cipherParams;\n        channelOptions.channelCipher = cipher.cipher;\n    }\n    else if ('cipher' in channelOptions) {\n        /* Don't deactivate an existing cipher unless options\n         * has a 'cipher' key that's falsey */\n        channelOptions.cipher = undefined;\n        channelOptions.channelCipher = null;\n    }\n    return channelOptions;\n}\nvar Channel = /** @class */ (function (_super) {\n    tslib_1.__extends(Channel, _super);\n    function Channel(rest, name, channelOptions) {\n        var _this = _super.call(this) || this;\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Channel()', 'started; name = ' + name);\n        _this.rest = rest;\n        _this.name = name;\n        _this.basePath = '/channels/' + encodeURIComponent(name);\n        _this.presence = new presence_1.default(_this);\n        _this.channelOptions = normaliseChannelOptions(channelOptions);\n        return _this;\n    }\n    Channel.prototype.setOptions = function (options) {\n        this.channelOptions = normaliseChannelOptions(options);\n    };\n    Channel.prototype.history = function (params, callback) {\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Channel.history()', 'channel = ' + this.name);\n        /* params and callback are optional; see if params contains the callback */\n        if (callback === undefined) {\n            if (typeof params == 'function') {\n                callback = params;\n                params = null;\n            }\n            else {\n                if (this.rest.options.promises) {\n                    return Utils.promisify(this, 'history', arguments);\n                }\n                callback = noop;\n            }\n        }\n        this._history(params, callback);\n    };\n    Channel.prototype._history = function (params, callback) {\n        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);\n        if (rest.options.headers)\n            Utils.mixin(headers, rest.options.headers);\n        var options = this.channelOptions;\n        new paginatedresource_1.default(rest, this.basePath + '/messages', headers, envelope, function (body, headers, unpacked) {\n            return message_1.default.fromResponseBody(body, options, unpacked ? undefined : format);\n        }).get(params, callback);\n    };\n    Channel.prototype.publish = function () {\n        var _this = this;\n        var argCount = arguments.length, first = arguments[0], second = arguments[1];\n        var callback = arguments[argCount - 1];\n        var messages;\n        var params;\n        if (typeof callback !== 'function') {\n            if (this.rest.options.promises) {\n                return Utils.promisify(this, 'publish', arguments);\n            }\n            callback = noop;\n        }\n        if (typeof first === 'string' || first === null) {\n            /* (name, data, ...) */\n            messages = [message_1.default.fromValues({ name: first, data: second })];\n            params = arguments[2];\n        }\n        else if (Utils.isObject(first)) {\n            messages = [message_1.default.fromValues(first)];\n            params = arguments[1];\n        }\n        else if (Utils.isArray(first)) {\n            messages = message_1.default.fromValuesArray(first);\n            params = arguments[1];\n        }\n        else {\n            throw new errorinfo_1.default('The single-argument form of publish() expects a message object or an array of message objects', 40013, 400);\n        }\n        if (typeof params !== 'object' || !params) {\n            /* No params supplied (so after-message argument is just the callback or undefined) */\n            params = {};\n        }\n        var rest = this.rest, options = rest.options, format = options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, idempotentRestPublishing = rest.options.idempotentRestPublishing, headers = Utils.defaultPostHeaders(rest.options, format);\n        if (options.headers)\n            Utils.mixin(headers, options.headers);\n        if (idempotentRestPublishing && allEmptyIds(messages)) {\n            var msgIdBase_1 = Utils.randomString(MSG_ID_ENTROPY_BYTES);\n            Utils.arrForEach(messages, function (message, index) {\n                message.id = msgIdBase_1 + ':' + index.toString();\n            });\n        }\n        message_1.default.encodeArray(messages, this.channelOptions, function (err) {\n            if (err) {\n                callback(err);\n                return;\n            }\n            /* RSL1i */\n            var size = message_1.default.getMessagesSize(messages), maxMessageSize = options.maxMessageSize;\n            if (size > maxMessageSize) {\n                callback(new errorinfo_1.default('Maximum size of messages that can be published at once exceeded ( was ' +\n                    size +\n                    ' bytes; limit is ' +\n                    maxMessageSize +\n                    ' bytes)', 40009, 400));\n                return;\n            }\n            _this._publish(message_1.default.serialize(messages, format), headers, params, callback);\n        });\n    };\n    Channel.prototype._publish = function (requestBody, headers, params, callback) {\n        resource_1.default.post(this.rest, this.basePath + '/messages', requestBody, headers, params, null, callback);\n    };\n    Channel.prototype.status = function (callback) {\n        if (typeof callback !== 'function' && this.rest.options.promises) {\n            return Utils.promisify(this, 'status', []);\n        }\n        var format = this.rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json;\n        var headers = Utils.defaultPostHeaders(this.rest.options, format);\n        resource_1.default.get(this.rest, this.basePath, headers, {}, format, callback || noop);\n    };\n    return Channel;\n}(eventemitter_1.default));\nexports.default = Channel;\n\n\n/***/ }),\n/* 34 */\n/***/ (function(module, exports, __nested_webpack_require_297668__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_297668__(0);\nvar Utils = tslib_1.__importStar(__nested_webpack_require_297668__(1));\nvar eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_297668__(7));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_297668__(2));\nvar paginatedresource_1 = tslib_1.__importDefault(__nested_webpack_require_297668__(19));\nvar presencemessage_1 = tslib_1.__importDefault(__nested_webpack_require_297668__(15));\nfunction noop() { }\nvar Presence = /** @class */ (function (_super) {\n    tslib_1.__extends(Presence, _super);\n    function Presence(channel) {\n        var _this = _super.call(this) || this;\n        _this.channel = channel;\n        _this.basePath = channel.basePath + '/presence';\n        return _this;\n    }\n    Presence.prototype.get = function (params, callback) {\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Presence.get()', 'channel = ' + this.channel.name);\n        /* params and callback are optional; see if params contains the callback */\n        if (callback === undefined) {\n            if (typeof params == 'function') {\n                callback = params;\n                params = null;\n            }\n            else {\n                if (this.channel.rest.options.promises) {\n                    return Utils.promisify(this, 'get', arguments);\n                }\n                callback = noop;\n            }\n        }\n        var rest = this.channel.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.channel.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);\n        if (rest.options.headers)\n            Utils.mixin(headers, rest.options.headers);\n        var options = this.channel.channelOptions;\n        new paginatedresource_1.default(rest, this.basePath, headers, envelope, function (body, headers, unpacked) {\n            return presencemessage_1.default.fromResponseBody(body, options, unpacked ? undefined : format);\n        }).get(params, callback);\n    };\n    Presence.prototype.history = function (params, callback) {\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Presence.history()', 'channel = ' + this.channel.name);\n        return this._history(params, callback);\n    };\n    Presence.prototype._history = function (params, callback) {\n        /* params and callback are optional; see if params contains the callback */\n        if (callback === undefined) {\n            if (typeof params == 'function') {\n                callback = params;\n                params = null;\n            }\n            else {\n                if (this.channel.rest.options.promises) {\n                    return Utils.promisify(this, '_history', [params]);\n                }\n                callback = noop;\n            }\n        }\n        var rest = this.channel.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.channel.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);\n        if (rest.options.headers)\n            Utils.mixin(headers, rest.options.headers);\n        var options = this.channel.channelOptions;\n        new paginatedresource_1.default(rest, this.basePath + '/history', headers, envelope, function (body, headers, unpacked) {\n            return presencemessage_1.default.fromResponseBody(body, options, unpacked ? undefined : format);\n        }).get(params, callback);\n    };\n    return Presence;\n}(eventemitter_1.default));\nexports.default = Presence;\n\n\n/***/ }),\n/* 35 */\n/***/ (function(module, exports, __nested_webpack_require_301348__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.TransportParams = void 0;\nvar tslib_1 = __nested_webpack_require_301348__(0);\nvar protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_301348__(10));\nvar Utils = tslib_1.__importStar(__nested_webpack_require_301348__(1));\nvar protocol_1 = tslib_1.__importStar(__nested_webpack_require_301348__(52));\nvar defaults_1 = tslib_1.__importStar(__nested_webpack_require_301348__(8));\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_301348__(3));\nvar eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_301348__(7));\nvar messagequeue_1 = tslib_1.__importDefault(__nested_webpack_require_301348__(36));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_301348__(2));\nvar connectionstatechange_1 = tslib_1.__importDefault(__nested_webpack_require_301348__(37));\nvar connectionerrors_1 = tslib_1.__importStar(__nested_webpack_require_301348__(20));\nvar errorinfo_1 = tslib_1.__importStar(__nested_webpack_require_301348__(4));\nvar auth_1 = tslib_1.__importDefault(__nested_webpack_require_301348__(17));\nvar message_1 = tslib_1.__importDefault(__nested_webpack_require_301348__(9));\nvar multicaster_1 = tslib_1.__importDefault(__nested_webpack_require_301348__(23));\nvar websockettransport_1 = tslib_1.__importDefault(__nested_webpack_require_301348__(53));\nvar transport_1 = tslib_1.__importDefault(__nested_webpack_require_301348__(26));\nvar HttpStatusCodes_1 = tslib_1.__importDefault(__nested_webpack_require_301348__(25));\nvar haveWebStorage = function () { var _a; return typeof platform_1.default.WebStorage !== 'undefined' && ((_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.localSupported); };\nvar haveSessionStorage = function () { var _a; return typeof platform_1.default.WebStorage !== 'undefined' && ((_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.sessionSupported); };\nvar actions = protocolmessage_1.default.Action;\nvar noop = function () { };\nvar transportPreferenceName = 'ably-transport-preference';\nvar sessionRecoveryName = 'ably-connection-recovery';\nfunction getSessionRecoverData() {\n    var _a, _b;\n    return haveSessionStorage() && ((_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.getSession) === null || _b === void 0 ? void 0 : _b.call(_a, sessionRecoveryName));\n}\nfunction setSessionRecoverData(value) {\n    var _a, _b;\n    return haveSessionStorage() && ((_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.setSession) === null || _b === void 0 ? void 0 : _b.call(_a, sessionRecoveryName, value));\n}\nfunction clearSessionRecoverData() {\n    var _a, _b;\n    return haveSessionStorage() && ((_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.removeSession) === null || _b === void 0 ? void 0 : _b.call(_a, sessionRecoveryName));\n}\nfunction betterTransportThan(a, b) {\n    return (Utils.arrIndexOf(platform_1.default.Defaults.transportPreferenceOrder, a.shortName) >\n        Utils.arrIndexOf(platform_1.default.Defaults.transportPreferenceOrder, b.shortName));\n}\nfunction bundleWith(dest, src, maxSize) {\n    var action;\n    if (dest.channel !== src.channel) {\n        /* RTL6d3 */\n        return false;\n    }\n    if ((action = dest.action) !== actions.PRESENCE && action !== actions.MESSAGE) {\n        /* RTL6d - can only bundle messages or presence */\n        return false;\n    }\n    if (action !== src.action) {\n        /* RTL6d4 */\n        return false;\n    }\n    var kind = action === actions.PRESENCE ? 'presence' : 'messages', proposed = dest[kind].concat(src[kind]), size = message_1.default.getMessagesSize(proposed);\n    if (size > maxSize) {\n        /* RTL6d1 */\n        return false;\n    }\n    if (!Utils.allSame(proposed, 'clientId')) {\n        /* RTL6d2 */\n        return false;\n    }\n    if (!Utils.arrEvery(proposed, function (msg) {\n        return !msg.id;\n    })) {\n        /* RTL6d7 */\n        return false;\n    }\n    /* we're good to go! */\n    dest[kind] = proposed;\n    return true;\n}\nfunction decodeRecoveryKey(recoveryKey) {\n    try {\n        return JSON.parse(recoveryKey);\n    }\n    catch (e) {\n        return null;\n    }\n}\nvar TransportParams = /** @class */ (function () {\n    function TransportParams(options, host, mode, connectionKey) {\n        this.options = options;\n        this.host = host;\n        this.mode = mode;\n        this.connectionKey = connectionKey;\n        this.format = options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json;\n    }\n    TransportParams.prototype.getConnectParams = function (authParams) {\n        var params = authParams ? Utils.copy(authParams) : {};\n        var options = this.options;\n        switch (this.mode) {\n            case 'upgrade':\n                params.upgrade = this.connectionKey;\n                break;\n            case 'resume':\n                params.resume = this.connectionKey;\n                break;\n            case 'recover': {\n                var recoveryContext = decodeRecoveryKey(options.recover);\n                if (recoveryContext) {\n                    params.recover = recoveryContext.connectionKey;\n                }\n                break;\n            }\n            default:\n        }\n        if (options.clientId !== undefined) {\n            params.clientId = options.clientId;\n        }\n        if (options.echoMessages === false) {\n            params.echo = 'false';\n        }\n        if (this.format !== undefined) {\n            params.format = this.format;\n        }\n        if (this.stream !== undefined) {\n            params.stream = this.stream;\n        }\n        if (this.heartbeats !== undefined) {\n            params.heartbeats = this.heartbeats;\n        }\n        params.v = defaults_1.default.protocolVersion;\n        params.agent = (0, defaults_1.getAgentString)(this.options);\n        if (options.transportParams !== undefined) {\n            Utils.mixin(params, options.transportParams);\n        }\n        return params;\n    };\n    TransportParams.prototype.toString = function () {\n        var result = '[mode=' + this.mode;\n        if (this.host) {\n            result += ',host=' + this.host;\n        }\n        if (this.connectionKey) {\n            result += ',connectionKey=' + this.connectionKey;\n        }\n        if (this.format) {\n            result += ',format=' + this.format;\n        }\n        result += ']';\n        return result;\n    };\n    return TransportParams;\n}());\nexports.TransportParams = TransportParams;\nvar ConnectionManager = /** @class */ (function (_super) {\n    tslib_1.__extends(ConnectionManager, _super);\n    function ConnectionManager(realtime, options) {\n        var _this = _super.call(this) || this;\n        _this.disconnectedRetryCount = 0;\n        ConnectionManager.initTransports();\n        _this.realtime = realtime;\n        _this.options = options;\n        var timeouts = options.timeouts;\n        /* connectingTimeout: leave preferenceConnectTimeout (~6s) to try the\n         * preference transport, then realtimeRequestTimeout (~10s) to establish\n         * the base transport in case that fails */\n        var connectingTimeout = timeouts.preferenceConnectTimeout + timeouts.realtimeRequestTimeout;\n        _this.states = {\n            initialized: {\n                state: 'initialized',\n                terminal: false,\n                queueEvents: true,\n                sendEvents: false,\n                failState: 'disconnected',\n            },\n            connecting: {\n                state: 'connecting',\n                terminal: false,\n                queueEvents: true,\n                sendEvents: false,\n                retryDelay: connectingTimeout,\n                failState: 'disconnected',\n            },\n            connected: {\n                state: 'connected',\n                terminal: false,\n                queueEvents: false,\n                sendEvents: true,\n                failState: 'disconnected',\n            },\n            synchronizing: {\n                state: 'connected',\n                terminal: false,\n                queueEvents: true,\n                sendEvents: false,\n                forceQueueEvents: true,\n                failState: 'disconnected',\n            },\n            disconnected: {\n                state: 'disconnected',\n                terminal: false,\n                queueEvents: true,\n                sendEvents: false,\n                retryDelay: timeouts.disconnectedRetryTimeout,\n                failState: 'disconnected',\n            },\n            suspended: {\n                state: 'suspended',\n                terminal: false,\n                queueEvents: false,\n                sendEvents: false,\n                retryDelay: timeouts.suspendedRetryTimeout,\n                failState: 'suspended',\n            },\n            closing: {\n                state: 'closing',\n                terminal: false,\n                queueEvents: false,\n                sendEvents: false,\n                retryDelay: timeouts.realtimeRequestTimeout,\n                failState: 'closed',\n            },\n            closed: { state: 'closed', terminal: true, queueEvents: false, sendEvents: false, failState: 'closed' },\n            failed: { state: 'failed', terminal: true, queueEvents: false, sendEvents: false, failState: 'failed' },\n        };\n        _this.state = _this.states.initialized;\n        _this.errorReason = null;\n        _this.queuedMessages = new messagequeue_1.default();\n        _this.msgSerial = 0;\n        _this.connectionDetails = undefined;\n        _this.connectionId = undefined;\n        _this.connectionKey = undefined;\n        _this.connectionStateTtl = timeouts.connectionStateTtl;\n        _this.maxIdleInterval = null;\n        _this.transports = Utils.intersect(options.transports || defaults_1.default.defaultTransports, ConnectionManager.supportedTransports);\n        /* baseTransports selects the leftmost transport in the Defaults.baseTransportOrder list\n         * that's both requested and supported. Normally this will be xhr_polling;\n         * if xhr isn't supported it will be jsonp. If the user has forced a\n         * transport, it'll just be that one. */\n        _this.baseTransport = Utils.intersect(defaults_1.default.baseTransportOrder, _this.transports)[0];\n        _this.upgradeTransports = Utils.intersect(_this.transports, defaults_1.default.upgradeTransports);\n        _this.transportPreference = null;\n        _this.httpHosts = defaults_1.default.getHosts(options);\n        _this.activeProtocol = null;\n        _this.proposedTransports = [];\n        _this.pendingTransports = [];\n        _this.host = null;\n        _this.lastAutoReconnectAttempt = null;\n        _this.lastActivity = null;\n        _this.forceFallbackHost = false;\n        _this.connectCounter = 0;\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Realtime.ConnectionManager()', 'started');\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Realtime.ConnectionManager()', 'requested transports = [' + (options.transports || defaults_1.default.defaultTransports) + ']');\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Realtime.ConnectionManager()', 'available transports = [' + _this.transports + ']');\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Realtime.ConnectionManager()', 'http hosts = [' + _this.httpHosts + ']');\n        if (!_this.transports.length) {\n            var msg = 'no requested transports available';\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'realtime.ConnectionManager()', msg);\n            throw new Error(msg);\n        }\n        var addEventListener = platform_1.default.Config.addEventListener;\n        if (addEventListener) {\n            /* intercept close event in browser to persist connection id if requested */\n            if (haveSessionStorage() && typeof options.recover === 'function') {\n                /* Usually can't use bind as not supported in IE8, but IE doesn't support sessionStorage, so... */\n                addEventListener('beforeunload', _this.persistConnection.bind(_this));\n            }\n            if (options.closeOnUnload === true) {\n                addEventListener('beforeunload', function () {\n                    logger_1.default.logAction(logger_1.default.LOG_MAJOR, 'Realtime.ConnectionManager()', 'beforeunload event has triggered the connection to close as closeOnUnload is true');\n                    _this.requestState({ state: 'closing' });\n                });\n            }\n            /* Listen for online and offline events */\n            addEventListener('online', function () {\n                if (_this.state == _this.states.disconnected || _this.state == _this.states.suspended) {\n                    logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager caught browser â€˜onlineâ€™ event', 'reattempting connection');\n                    _this.requestState({ state: 'connecting' });\n                }\n                else if (_this.state == _this.states.connecting) {\n                    // RTN20c: if 'online' event recieved while CONNECTING, abandon connection attempt and retry\n                    _this.pendingTransports.forEach(function (transport) {\n                        // Detach transport listeners to avoid connection state side effects from calling dispose\n                        transport.off();\n                    });\n                    _this.disconnectAllTransports();\n                    _this.startConnect();\n                }\n            });\n            addEventListener('offline', function () {\n                if (_this.state == _this.states.connected) {\n                    logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager caught browser â€˜offlineâ€™ event', 'disconnecting active transport');\n                    // Not sufficient to just go to the 'disconnected' state, want to\n                    // force all transports to reattempt the connection. Will immediately\n                    // retry.\n                    _this.disconnectAllTransports();\n                }\n            });\n        }\n        return _this;\n    }\n    ConnectionManager.initTransports = function () {\n        (0, websockettransport_1.default)(ConnectionManager);\n        Utils.arrForEach(platform_1.default.Transports, function (initFn) {\n            initFn(ConnectionManager);\n        });\n    };\n    ConnectionManager.prototype.createTransportParams = function (host, mode) {\n        return new TransportParams(this.options, host, mode, this.connectionKey);\n    };\n    ConnectionManager.prototype.getTransportParams = function (callback) {\n        var _this = this;\n        var decideMode = function (modeCb) {\n            if (_this.connectionKey) {\n                modeCb('resume');\n                return;\n            }\n            if (typeof _this.options.recover === 'string') {\n                modeCb('recover');\n                return;\n            }\n            var recoverFn = _this.options.recover, lastSessionData = getSessionRecoverData();\n            if (lastSessionData && typeof recoverFn === 'function') {\n                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Calling clientOptions-provided recover function with last session data');\n                recoverFn(lastSessionData, function (shouldRecover) {\n                    if (shouldRecover) {\n                        _this.options.recover = lastSessionData.recoveryKey;\n                        modeCb('recover');\n                    }\n                    else {\n                        modeCb('clean');\n                    }\n                });\n                return;\n            }\n            modeCb('clean');\n        };\n        decideMode(function (mode) {\n            var transportParams = _this.createTransportParams(null, mode);\n            if (mode === 'recover') {\n                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Transport recovery mode = recover; recoveryKey = ' + _this.options.recover);\n                var recoveryContext = decodeRecoveryKey(_this.options.recover);\n                if (recoveryContext) {\n                    _this.msgSerial = recoveryContext.msgSerial;\n                }\n            }\n            else {\n                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.getTransportParams()', 'Transport params = ' + transportParams.toString());\n            }\n            callback(transportParams);\n        });\n    };\n    /**\n     * Attempt to connect using a given transport\n     * @param transportParams\n     * @param candidate, the transport to try\n     * @param callback\n     */\n    ConnectionManager.prototype.tryATransport = function (transportParams, candidate, callback) {\n        var _this = this;\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.tryATransport()', 'trying ' + candidate);\n        transport_1.default.tryConnect(ConnectionManager.supportedTransports[candidate], this, this.realtime.auth, transportParams, function (wrappedErr, transport) {\n            var state = _this.state;\n            if (state == _this.states.closing || state == _this.states.closed || state == _this.states.failed) {\n                if (transport) {\n                    logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.tryATransport()', 'connection ' + state.state + ' while we were attempting the transport; closing ' + transport);\n                    transport.close();\n                }\n                callback(true);\n                return;\n            }\n            if (wrappedErr) {\n                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.tryATransport()', 'transport ' + candidate + ' ' + wrappedErr.event + ', err: ' + wrappedErr.error.toString());\n                /* Comet transport onconnect token errors can be dealt with here.\n                 * Websocket ones only happen after the transport claims to be viable,\n                 * so are dealt with as non-onconnect token errors */\n                if (auth_1.default.isTokenErr(wrappedErr.error) &&\n                    !(_this.errorReason && auth_1.default.isTokenErr(_this.errorReason))) {\n                    _this.errorReason = wrappedErr.error;\n                    /* re-get a token and try again */\n                    _this.realtime.auth._forceNewToken(null, null, function (err) {\n                        if (err) {\n                            _this.actOnErrorFromAuthorize(err);\n                            return;\n                        }\n                        _this.tryATransport(transportParams, candidate, callback);\n                    });\n                }\n                else if (wrappedErr.event === 'failed') {\n                    /* Error that's fatal to the connection */\n                    _this.notifyState({ state: 'failed', error: wrappedErr.error });\n                    callback(true);\n                }\n                else if (wrappedErr.event === 'disconnected') {\n                    if (!(0, connectionerrors_1.isRetriable)(wrappedErr.error)) {\n                        /* Error received from the server that does not call for trying a fallback host, eg a rate limit */\n                        _this.notifyState({ state: _this.states.connecting.failState, error: wrappedErr.error });\n                        callback(true);\n                    }\n                    else {\n                        /* Error with that transport only; continue trying other fallback hosts */\n                        callback(false);\n                    }\n                }\n                return;\n            }\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.tryATransport()', 'viable transport ' + candidate + '; setting pending');\n            _this.setTransportPending(transport, transportParams);\n            callback(null, transport);\n        });\n    };\n    /**\n     * Called when a transport is indicated to be viable, and the ConnectionManager\n     * expects to activate this transport as soon as it is connected.\n     * @param transport\n     * @param transportParams\n     */\n    ConnectionManager.prototype.setTransportPending = function (transport, transportParams) {\n        var _this = this;\n        var mode = transportParams.mode;\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.setTransportPending()', 'transport = ' + transport + '; mode = ' + mode);\n        Utils.arrDeleteValue(this.proposedTransports, transport);\n        this.pendingTransports.push(transport);\n        var optimalTransport = platform_1.default.Defaults.transportPreferenceOrder[platform_1.default.Defaults.transportPreferenceOrder.length - 1];\n        transport.once('connected', function (error, connectionId, connectionDetails) {\n            if (mode == 'upgrade' && _this.activeProtocol) {\n                /*  if ws and xhrs are connecting in parallel, delay xhrs activation to let ws go ahead */\n                if (transport.shortName !== optimalTransport &&\n                    Utils.arrIn(_this.getUpgradePossibilities(), optimalTransport) &&\n                    _this.activeProtocol) {\n                    setTimeout(function () {\n                        _this.scheduleTransportActivation(error, transport, connectionId, connectionDetails);\n                    }, _this.options.timeouts.parallelUpgradeDelay);\n                }\n                else {\n                    _this.scheduleTransportActivation(error, transport, connectionId, connectionDetails);\n                }\n            }\n            else {\n                _this.activateTransport(error, transport, connectionId, connectionDetails);\n                /* allow connectImpl to start the upgrade process if needed, but allow\n                 * other event handlers, including activating the transport, to run first */\n                platform_1.default.Config.nextTick(function () {\n                    _this.connectImpl(transportParams);\n                });\n            }\n            if (mode === 'recover' && _this.options.recover) {\n                /* After a successful recovery, we unpersist, as a recovery key cannot\n                 * be used more than once */\n                _this.options.recover = null;\n                _this.unpersistConnection();\n            }\n        });\n        var self = this;\n        transport.on(['disconnected', 'closed', 'failed'], function (error) {\n            self.deactivateTransport(transport, this.event, error);\n        });\n        this.emit('transport.pending', transport);\n    };\n    /**\n     * Called when an upgrade transport is connected,\n     * to schedule the activation of that transport.\n     * @param error\n     * @param transport\n     * @param connectionId\n     * @param connectionDetails\n     */\n    ConnectionManager.prototype.scheduleTransportActivation = function (error, transport, connectionId, connectionDetails) {\n        var _this = this;\n        var currentTransport = this.activeProtocol && this.activeProtocol.getTransport(), abandon = function () {\n            transport.disconnect();\n            Utils.arrDeleteValue(_this.pendingTransports, transport);\n        };\n        if (this.state !== this.states.connected && this.state !== this.states.connecting) {\n            /* This is most likely to happen for the delayed XHRs, when XHRs and ws are scheduled in parallel*/\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Current connection state (' +\n                this.state.state +\n                (this.state === this.states.synchronizing ? ', but with an upgrade already in progress' : '') +\n                ') is not valid to upgrade in; abandoning upgrade to ' +\n                transport.shortName);\n            abandon();\n            return;\n        }\n        if (currentTransport && !betterTransportThan(transport, currentTransport)) {\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Proposed transport ' +\n                transport.shortName +\n                ' is no better than current active transport ' +\n                currentTransport.shortName +\n                ' - abandoning upgrade');\n            abandon();\n            return;\n        }\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Scheduling transport upgrade; transport = ' + transport);\n        var oldProtocol = null;\n        if (!transport.isConnected) {\n            /* This is only possible if the xhr streaming transport was disconnected during the parallelUpgradeDelay */\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Proposed transport ' + transport.shortName + 'is no longer connected; abandoning upgrade');\n            abandon();\n            return;\n        }\n        if (this.state === this.states.connected) {\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.scheduleTransportActivation()', 'Currently connected, so temporarily pausing events until the upgrade is complete');\n            this.state = this.states.synchronizing;\n            oldProtocol = this.activeProtocol;\n        }\n        else if (this.state !== this.states.connecting) {\n            /* Note: upgrading from the connecting state is valid if the old active\n             * transport was deactivated after the upgrade transport first connected;\n             * see logic in deactivateTransport */\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Current connection state (' +\n                this.state.state +\n                (this.state === this.states.synchronizing ? ', but with an upgrade already in progress' : '') +\n                ') is not valid to upgrade in; abandoning upgrade to ' +\n                transport.shortName);\n            abandon();\n            return;\n        }\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Syncing transport; transport = ' + transport);\n        var finishUpgrade = function () {\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Activating transport; transport = ' + transport);\n            // Send ACTIVATE to tell the server to make this transport the\n            // active transport, which suspends channels until we re-attach.\n            transport.send(protocolmessage_1.default.fromValues({\n                action: actions.ACTIVATE,\n            }));\n            _this.activateTransport(error, transport, connectionId, connectionDetails);\n            /* Restore pre-sync state. If state has changed in the meantime,\n             * don't touch it -- since the websocket transport waits a tick before\n             * disposing itself, it's possible for it to have happily synced\n             * without err while, unknown to it, the connection has closed in the\n             * meantime and the ws transport is scheduled for death */\n            if (_this.state === _this.states.synchronizing) {\n                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.scheduleTransportActivation()', 'Pre-upgrade protocol idle, sending queued messages on upgraded transport; transport = ' + transport);\n                _this.state = _this.states.connected;\n            }\n            else {\n                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.scheduleTransportActivation()', 'Pre-upgrade protocol idle, but state is now ' + _this.state.state + ', so leaving unchanged');\n            }\n            if (_this.state.sendEvents) {\n                _this.sendQueuedMessages();\n            }\n        };\n        /* Wait until sync is done and old transport is idle before activating new transport. This\n         * guarantees that messages arrive at realtime in the same order they are sent.\n         *\n         * If a message times out on the old transport, since it's still the active transport the\n         * message will be requeued. deactivateTransport will see the pending transport and notify\n         * the `connecting` state without starting a new connection, so the new transport can take\n         * over once deactivateTransport clears the old protocol's queue.\n         *\n         * If there is no old protocol, that meant that we weren't in the connected state at the\n         * beginning of the sync - likely the base transport died just before the sync. So can just\n         * finish the upgrade. If we're actually in closing/failed rather than connecting, that's\n         * fine, activatetransport will deal with that. */\n        if (oldProtocol) {\n            /* Most of the time this will be already true: the new-transport sync will have given\n             * enough time for in-flight messages on the old transport to complete. */\n            oldProtocol.onceIdle(finishUpgrade);\n        }\n        else {\n            finishUpgrade();\n        }\n    };\n    /**\n     * Called when a transport is connected, and the connectionmanager decides that\n     * it will now be the active transport. Returns whether or not it activated\n     * the transport (if the connection is closing/closed it will choose not to).\n     * @param transport the transport instance\n     * @param connectionId the id of the new active connection\n     * @param connectionDetails the details of the new active connection\n     */\n    ConnectionManager.prototype.activateTransport = function (error, transport, connectionId, connectionDetails) {\n        var _this = this;\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.activateTransport()', 'transport = ' + transport);\n        if (error) {\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.activateTransport()', 'error = ' + error);\n        }\n        if (connectionId) {\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionId =  ' + connectionId);\n        }\n        if (connectionDetails) {\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.activateTransport()', 'connectionDetails =  ' + JSON.stringify(connectionDetails));\n        }\n        this.persistTransportPreference(transport);\n        /* if the connectionmanager moved to the closing/closed state before this\n         * connection event, then we won't activate this transport */\n        var existingState = this.state, connectedState = this.states.connected.state;\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.activateTransport()', 'current state = ' + existingState.state);\n        if (existingState.state == this.states.closing.state ||\n            existingState.state == this.states.closed.state ||\n            existingState.state == this.states.failed.state) {\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.activateTransport()', 'Disconnecting transport and abandoning');\n            transport.disconnect();\n            return false;\n        }\n        /* remove this transport from pending transports */\n        Utils.arrDeleteValue(this.pendingTransports, transport);\n        /* if the transport is not connected then don't activate it */\n        if (!transport.isConnected) {\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.activateTransport()', 'Declining to activate transport ' + transport + ' since it appears to no longer be connected');\n            return false;\n        }\n        /* the given transport is connected; this will immediately\n         * take over as the active transport */\n        var existingActiveProtocol = this.activeProtocol;\n        this.activeProtocol = new protocol_1.default(transport);\n        this.host = transport.params.host;\n        var connectionKey = connectionDetails.connectionKey;\n        if (connectionKey && this.connectionKey != connectionKey) {\n            this.setConnection(connectionId, connectionDetails, !!error);\n        }\n        /* Rebroadcast any new connectionDetails from the active transport, which\n         * can come at any time (eg following a reauth), and emit an RTN24 UPDATE\n         * event. (Listener added on nextTick because we're in a transport.on('connected')\n         * callback at the moment; if we add it now we'll be adding it to the end\n         * of the listeners array and it'll be called immediately) */\n        this.onConnectionDetailsUpdate(connectionDetails, transport);\n        platform_1.default.Config.nextTick(function () {\n            transport.on('connected', function (connectedErr, _connectionId, connectionDetails) {\n                _this.onConnectionDetailsUpdate(connectionDetails, transport);\n                _this.emit('update', new connectionstatechange_1.default(connectedState, connectedState, null, connectedErr));\n            });\n        });\n        /* If previously not connected, notify the state change (including any\n         * error). */\n        if (existingState.state === this.states.connected.state) {\n            if (error) {\n                /* if upgrading without error, leave any existing errorReason alone */\n                this.errorReason = this.realtime.connection.errorReason = error;\n                /* Only bother emitting an upgrade if there's an error; otherwise it's\n                 * just a transport upgrade, so auth details won't have changed */\n                this.emit('update', new connectionstatechange_1.default(connectedState, connectedState, null, error));\n            }\n        }\n        else {\n            this.notifyState({ state: 'connected', error: error });\n            this.errorReason = this.realtime.connection.errorReason = error || null;\n        }\n        /* Send after the connection state update, as Channels hooks into this to\n         * resend attaches on a new transport if necessary */\n        this.emit('transport.active', transport);\n        /* Gracefully terminate existing protocol */\n        if (existingActiveProtocol) {\n            if (existingActiveProtocol.messageQueue.count() > 0) {\n                /* We could just requeue pending messages on the new transport, but\n                 * actually this should never happen: transports should only take over\n                 * from other active transports when upgrading, and upgrading waits for\n                 * the old transport to be idle. So log an error. */\n                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.activateTransport()', 'Previous active protocol (for transport ' +\n                    existingActiveProtocol.transport.shortName +\n                    ', new one is ' +\n                    transport.shortName +\n                    ') finishing with ' +\n                    existingActiveProtocol.messageQueue.count() +\n                    ' messages still pending');\n            }\n            if (existingActiveProtocol.transport === transport) {\n                var msg = 'Assumption violated: activating a transport that was also the transport for the previous active protocol; transport = ' +\n                    transport.shortName +\n                    '; stack = ' +\n                    new Error().stack;\n                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.activateTransport()', msg);\n            }\n            else {\n                existingActiveProtocol.finish();\n            }\n        }\n        /* Terminate any other pending transport(s), and\n         * abort any not-yet-pending transport attempts */\n        Utils.safeArrForEach(this.pendingTransports, function (pendingTransport) {\n            if (pendingTransport === transport) {\n                var msg = 'Assumption violated: activating a transport that is still marked as a pending transport; transport = ' +\n                    transport.shortName +\n                    '; stack = ' +\n                    new Error().stack;\n                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.activateTransport()', msg);\n                Utils.arrDeleteValue(_this.pendingTransports, transport);\n            }\n            else {\n                pendingTransport.disconnect();\n            }\n        });\n        Utils.safeArrForEach(this.proposedTransports, function (proposedTransport) {\n            if (proposedTransport === transport) {\n                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.activateTransport()', 'Assumption violated: activating a transport that is still marked as a proposed transport; transport = ' +\n                    transport.shortName +\n                    '; stack = ' +\n                    new Error().stack);\n                Utils.arrDeleteValue(_this.proposedTransports, transport);\n            }\n            else {\n                proposedTransport.dispose();\n            }\n        });\n        return true;\n    };\n    /**\n     * Called when a transport is no longer the active transport. This can occur\n     * in any transport connection state.\n     * @param transport\n     */\n    ConnectionManager.prototype.deactivateTransport = function (transport, state, error) {\n        var currentProtocol = this.activeProtocol, wasActive = currentProtocol && currentProtocol.getTransport() === transport, wasPending = Utils.arrDeleteValue(this.pendingTransports, transport), wasProposed = Utils.arrDeleteValue(this.proposedTransports, transport), noTransportsScheduledForActivation = this.noTransportsScheduledForActivation();\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'transport = ' + transport);\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.deactivateTransport()', 'state = ' +\n            state +\n            (wasActive ? '; was active' : wasPending ? '; was pending' : wasProposed ? '; was proposed' : '') +\n            (noTransportsScheduledForActivation ? '' : '; another transport is scheduled for activation'));\n        if (error && error.message)\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'reason =  ' + error.message);\n        if (wasActive) {\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'Getting, clearing, and requeuing ' +\n                this.activeProtocol.messageQueue.count() +\n                ' pending messages');\n            this.queuePendingMessages(currentProtocol.getPendingMessages());\n            /* Clear any messages we requeue to allow the protocol to become idle.\n             * In case of an upgrade, this will trigger an immediate activation of\n             * the upgrade transport, so delay a tick so this transport can finish\n             * deactivating */\n            platform_1.default.Config.nextTick(function () {\n                currentProtocol.clearPendingMessages();\n            });\n            this.activeProtocol = this.host = null;\n        }\n        this.emit('transport.inactive', transport);\n        /* this transport state change is a state change for the connectionmanager if\n         * - the transport was the active transport and there are no transports\n         *   which are connected and scheduled for activation, just waiting for the\n         *   active transport to finish what its doing; or\n         * - the transport was the active transport and the error was fatal (so\n         *   unhealable by another transport); or\n         * - there is no active transport, and this is the last remaining\n         *   pending transport (so we were in the connecting state)\n         */\n        if ((wasActive && noTransportsScheduledForActivation) ||\n            (wasActive && state === 'failed') ||\n            state === 'closed' ||\n            (currentProtocol === null && wasPending && this.pendingTransports.length === 0)) {\n            /* If we're disconnected with a 5xx we need to try fallback hosts\n             * (RTN14d), but (a) due to how the upgrade sequence works, the\n             * host/transport selection sequence only cares about getting to\n             * `preconnect` (eg establishing a websocket) getting a `disconnected`\n             * protocol message afterwards is too late; and (b) host retry only\n             * applies to connectBase unless the stored preference transport doesn't\n             * work. We solve this by unpersisting the transport preference and\n             * setting an instance variable to force fallback hosts to be used (if\n             * any) here. Bit of a kludge, but no real better alternatives without\n             * rewriting the entire thing */\n            if (state === 'disconnected' && error && error.statusCode > 500 && this.httpHosts.length > 1) {\n                this.unpersistTransportPreference();\n                this.forceFallbackHost = true;\n                /* and try to connect again to try a fallback host without waiting for the usual 15s disconnectedRetryTimeout */\n                this.notifyState({ state: state, error: error, retryImmediately: true });\n                return;\n            }\n            /* TODO remove below line once realtime sends token errors as DISCONNECTEDs */\n            var newConnectionState = state === 'failed' && auth_1.default.isTokenErr(error) ? 'disconnected' : state;\n            this.notifyState({ state: newConnectionState, error: error });\n            return;\n        }\n        if (wasActive && state === 'disconnected' && this.state !== this.states.synchronizing) {\n            /* If we were active but there is another transport scheduled for\n             * activation, go into to the connecting state until that transport\n             * activates and sets us back to connected. (manually starting the\n             * transition timers in case that never happens). (If we were in the\n             * synchronizing state, then that's fine, the old transport just got its\n             * disconnected before the new one got the sync -- ignore it and keep\n             * waiting for the sync. If it fails we have a separate sync timer that\n             * will expire). */\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.deactivateTransport()', 'wasActive but another transport is connected and scheduled for activation, so going into the connecting state until it activates');\n            this.startSuspendTimer();\n            this.startTransitionTimer(this.states.connecting);\n            this.notifyState({ state: 'connecting', error: error });\n        }\n    };\n    /* Helper that returns true if there are no transports which are pending,\n     * have been connected, and are just waiting for onceNoPending to fire before\n     * being activated */\n    ConnectionManager.prototype.noTransportsScheduledForActivation = function () {\n        return (Utils.isEmpty(this.pendingTransports) ||\n            this.pendingTransports.every(function (transport) {\n                return !transport.isConnected;\n            }));\n    };\n    ConnectionManager.prototype.setConnection = function (connectionId, connectionDetails, hasConnectionError) {\n        /* if connectionKey changes but connectionId stays the same, then just a\n         * transport change on the same connection. If connectionId changes, we're\n         * on a new connection, with implications for msgSerial and channel state */\n        /* If no previous connectionId, don't reset the msgSerial as it may have\n         * been set by recover data (unless the recover failed) */\n        var prevConnId = this.connectionId, connIdChanged = prevConnId && prevConnId !== connectionId, recoverFailure = !prevConnId && hasConnectionError;\n        if (connIdChanged || recoverFailure) {\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.setConnection()', 'Resetting msgSerial');\n            this.msgSerial = 0;\n            // RTN19a2: In the event of a new connectionId, previous msgSerials are\n            // meaningless.\n            this.queuedMessages.resetSendAttempted();\n        }\n        if (this.connectionId !== connectionId) {\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.setConnection()', 'New connectionId; reattaching any attached channels');\n        }\n        this.realtime.connection.id = this.connectionId = connectionId;\n        this.realtime.connection.key = this.connectionKey = connectionDetails.connectionKey;\n    };\n    ConnectionManager.prototype.clearConnection = function () {\n        this.realtime.connection.id = this.connectionId = undefined;\n        this.realtime.connection.key = this.connectionKey = undefined;\n        this.msgSerial = 0;\n        this.unpersistConnection();\n    };\n    ConnectionManager.prototype.createRecoveryKey = function () {\n        // RTN16g2.\n        if (!this.connectionKey) {\n            return null;\n        }\n        return JSON.stringify({\n            connectionKey: this.connectionKey,\n            msgSerial: this.msgSerial,\n            channelSerials: this.realtime.channels.channelSerials(),\n        });\n    };\n    ConnectionManager.prototype.checkConnectionStateFreshness = function () {\n        if (!this.lastActivity || !this.connectionId) {\n            return;\n        }\n        var sinceLast = Utils.now() - this.lastActivity;\n        if (sinceLast > this.connectionStateTtl + this.maxIdleInterval) {\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.checkConnectionStateFreshness()', 'Last known activity from realtime was ' + sinceLast + 'ms ago; discarding connection state');\n            this.clearConnection();\n            this.states.connecting.failState = 'suspended';\n        }\n    };\n    /**\n     * Called when the connectionmanager wants to persist transport\n     * state for later recovery. Only applicable in the browser context.\n     */\n    ConnectionManager.prototype.persistConnection = function () {\n        if (haveSessionStorage()) {\n            var recoveryKey = this.createRecoveryKey();\n            if (recoveryKey) {\n                setSessionRecoverData({\n                    recoveryKey: recoveryKey,\n                    disconnectedAt: Utils.now(),\n                    location: global.location,\n                    clientId: this.realtime.auth.clientId,\n                });\n            }\n        }\n    };\n    /**\n     * Called when the connectionmanager wants to persist transport\n     * state for later recovery. Only applicable in the browser context.\n     */\n    ConnectionManager.prototype.unpersistConnection = function () {\n        clearSessionRecoverData();\n    };\n    /*********************\n     * state management\n     *********************/\n    ConnectionManager.prototype.getError = function () {\n        return this.errorReason || this.getStateError();\n    };\n    ConnectionManager.prototype.getStateError = function () {\n        var _a, _b;\n        return (_b = (_a = connectionerrors_1.default)[this.state.state]) === null || _b === void 0 ? void 0 : _b.call(_a);\n    };\n    ConnectionManager.prototype.activeState = function () {\n        return this.state.queueEvents || this.state.sendEvents;\n    };\n    ConnectionManager.prototype.enactStateChange = function (stateChange) {\n        var logLevel = stateChange.current === 'failed' ? logger_1.default.LOG_ERROR : logger_1.default.LOG_MAJOR;\n        logger_1.default.logAction(logLevel, 'Connection state', stateChange.current + (stateChange.reason ? '; reason: ' + stateChange.reason : ''));\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.enactStateChange', 'setting new state: ' +\n            stateChange.current +\n            '; reason = ' +\n            (stateChange.reason && stateChange.reason.message));\n        var newState = (this.state = this.states[stateChange.current]);\n        if (stateChange.reason) {\n            this.errorReason = stateChange.reason;\n            this.realtime.connection.errorReason = stateChange.reason;\n        }\n        if (newState.terminal || newState.state === 'suspended') {\n            /* suspended is nonterminal, but once in the suspended state, realtime\n             * will have discarded our connection state, so futher connection\n             * attempts should start from scratch */\n            this.clearConnection();\n        }\n        this.emit('connectionstate', stateChange);\n    };\n    /****************************************\n     * ConnectionManager connection lifecycle\n     ****************************************/\n    ConnectionManager.prototype.startTransitionTimer = function (transitionState) {\n        var _this = this;\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'transitionState: ' + transitionState.state);\n        if (this.transitionTimer) {\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.startTransitionTimer()', 'clearing already-running timer');\n            clearTimeout(this.transitionTimer);\n        }\n        this.transitionTimer = setTimeout(function () {\n            if (_this.transitionTimer) {\n                _this.transitionTimer = null;\n                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager ' + transitionState.state + ' timer expired', 'requesting new state: ' + transitionState.failState);\n                _this.notifyState({ state: transitionState.failState });\n            }\n        }, transitionState.retryDelay);\n    };\n    ConnectionManager.prototype.cancelTransitionTimer = function () {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.cancelTransitionTimer()', '');\n        if (this.transitionTimer) {\n            clearTimeout(this.transitionTimer);\n            this.transitionTimer = null;\n        }\n    };\n    ConnectionManager.prototype.startSuspendTimer = function () {\n        var _this = this;\n        if (this.suspendTimer)\n            return;\n        this.suspendTimer = setTimeout(function () {\n            if (_this.suspendTimer) {\n                _this.suspendTimer = null;\n                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager suspend timer expired', 'requesting new state: suspended');\n                _this.states.connecting.failState = 'suspended';\n                _this.notifyState({ state: 'suspended' });\n            }\n        }, this.connectionStateTtl);\n    };\n    ConnectionManager.prototype.checkSuspendTimer = function (state) {\n        if (state !== 'disconnected' && state !== 'suspended' && state !== 'connecting')\n            this.cancelSuspendTimer();\n    };\n    ConnectionManager.prototype.cancelSuspendTimer = function () {\n        this.states.connecting.failState = 'disconnected';\n        if (this.suspendTimer) {\n            clearTimeout(this.suspendTimer);\n            this.suspendTimer = null;\n        }\n    };\n    ConnectionManager.prototype.startRetryTimer = function (interval) {\n        var _this = this;\n        this.retryTimer = setTimeout(function () {\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager retry timer expired', 'retrying');\n            _this.retryTimer = null;\n            _this.requestState({ state: 'connecting' });\n        }, interval);\n    };\n    ConnectionManager.prototype.cancelRetryTimer = function () {\n        if (this.retryTimer) {\n            clearTimeout(this.retryTimer);\n            this.retryTimer = null;\n        }\n    };\n    ConnectionManager.prototype.notifyState = function (indicated) {\n        var _this = this;\n        var _a, _b;\n        var state = indicated.state;\n        /* We retry immediately if:\n         * - something disconnects us while we're connected, or\n         * - a viable (but not yet active) transport fails due to a token error (so\n         *   this.errorReason will be set, and startConnect will do a forced\n         *   authorize). If this.errorReason is already set (to a token error),\n         *   then there has been at least one previous attempt to connect that also\n         *   failed for a token error, so by RTN14b we go to DISCONNECTED and wait\n         *   before trying again */\n        var retryImmediately = state === 'disconnected' &&\n            (this.state === this.states.connected ||\n                this.state === this.states.synchronizing ||\n                indicated.retryImmediately ||\n                (this.state === this.states.connecting &&\n                    indicated.error &&\n                    auth_1.default.isTokenErr(indicated.error) &&\n                    !(this.errorReason && auth_1.default.isTokenErr(this.errorReason))));\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.notifyState()', 'new state: ' + state + (retryImmediately ? '; will retry connection immediately' : ''));\n        /* do nothing if we're already in the indicated state */\n        if (state == this.state.state)\n            return;\n        /* kill timers (possibly excepting suspend timer depending on the notified\n         * state), as these are superseded by this notification */\n        this.cancelTransitionTimer();\n        this.cancelRetryTimer();\n        this.checkSuspendTimer(indicated.state);\n        if (state === 'suspended' || state === 'connected') {\n            this.disconnectedRetryCount = 0;\n        }\n        /* do nothing if we're unable to move from the current state */\n        if (this.state.terminal)\n            return;\n        /* process new state */\n        var newState = this.states[indicated.state];\n        var retryDelay = newState.retryDelay;\n        if (newState.state === 'disconnected') {\n            this.disconnectedRetryCount++;\n            retryDelay = Utils.getRetryTime(newState.retryDelay, this.disconnectedRetryCount);\n        }\n        var change = new connectionstatechange_1.default(this.state.state, newState.state, retryDelay, indicated.error || ((_b = (_a = connectionerrors_1.default)[newState.state]) === null || _b === void 0 ? void 0 : _b.call(_a)));\n        if (retryImmediately) {\n            var autoReconnect = function () {\n                if (_this.state === _this.states.disconnected) {\n                    _this.lastAutoReconnectAttempt = Utils.now();\n                    _this.requestState({ state: 'connecting' });\n                }\n            };\n            var sinceLast = this.lastAutoReconnectAttempt && Utils.now() - this.lastAutoReconnectAttempt + 1;\n            if (sinceLast && sinceLast < 1000) {\n                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.notifyState()', 'Last reconnect attempt was only ' +\n                    sinceLast +\n                    'ms ago, waiting another ' +\n                    (1000 - sinceLast) +\n                    'ms before trying again');\n                setTimeout(autoReconnect, 1000 - sinceLast);\n            }\n            else {\n                platform_1.default.Config.nextTick(autoReconnect);\n            }\n        }\n        else if (state === 'disconnected' || state === 'suspended') {\n            this.startRetryTimer(retryDelay);\n        }\n        /* If going into disconnect/suspended (and not retrying immediately), or a\n         * terminal state, ensure there are no orphaned transports hanging around. */\n        if ((state === 'disconnected' && !retryImmediately) || state === 'suspended' || newState.terminal) {\n            /* Wait till the next tick so the connection state change is enacted,\n             * so aborting transports doesn't trigger redundant state changes */\n            platform_1.default.Config.nextTick(function () {\n                _this.disconnectAllTransports();\n            });\n        }\n        if (state == 'connected' && !this.activeProtocol) {\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.notifyState()', 'Broken invariant: attempted to go into connected state, but there is no active protocol');\n        }\n        /* implement the change and notify */\n        this.enactStateChange(change);\n        if (this.state.sendEvents) {\n            this.sendQueuedMessages();\n        }\n        else if (!this.state.queueEvents) {\n            this.realtime.channels.propogateConnectionInterruption(state, change.reason);\n            this.failQueuedMessages(change.reason); // RTN7c\n        }\n    };\n    ConnectionManager.prototype.requestState = function (request) {\n        var _this = this;\n        var _a, _b;\n        var state = request.state;\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.requestState()', 'requested state: ' + state + '; current state: ' + this.state.state);\n        if (state == this.state.state)\n            return; /* silently do nothing */\n        /* kill running timers, as this request supersedes them */\n        this.cancelTransitionTimer();\n        this.cancelRetryTimer();\n        /* for suspend timer check rather than cancel -- eg requesting a connecting\n         * state should not reset the suspend timer */\n        this.checkSuspendTimer(state);\n        if (state == 'connecting' && this.state.state == 'connected')\n            return;\n        if (state == 'closing' && this.state.state == 'closed')\n            return;\n        var newState = this.states[state], change = new connectionstatechange_1.default(this.state.state, newState.state, null, request.error || ((_b = (_a = connectionerrors_1.default)[newState.state]) === null || _b === void 0 ? void 0 : _b.call(_a)));\n        this.enactStateChange(change);\n        if (state == 'connecting') {\n            platform_1.default.Config.nextTick(function () {\n                _this.startConnect();\n            });\n        }\n        if (state == 'closing') {\n            this.closeImpl();\n        }\n    };\n    ConnectionManager.prototype.startConnect = function () {\n        var _this = this;\n        if (this.state !== this.states.connecting) {\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.startConnect()', 'Must be in connecting state to connect, but was ' + this.state.state);\n            return;\n        }\n        var auth = this.realtime.auth;\n        /* The point of the connectCounter mechanism is to ensure that the\n         * connection procedure can be cancelled. We want disconnectAllTransports\n         * to be able to stop any in-progress connection, even before it gets to\n         * the stage of having a pending (or even a proposed) transport that it can\n         * dispose() of. So we check that it's still current after any async stage,\n         * up until the stage that is synchronous with instantiating a transport */\n        var connectCount = ++this.connectCounter;\n        var connect = function () {\n            _this.checkConnectionStateFreshness();\n            _this.getTransportParams(function (transportParams) {\n                if (transportParams.mode === 'recover' && transportParams.options.recover) {\n                    var recoveryContext = decodeRecoveryKey(transportParams.options.recover);\n                    if (recoveryContext) {\n                        _this.realtime.channels.recoverChannels(recoveryContext.channelSerials);\n                    }\n                }\n                if (connectCount !== _this.connectCounter) {\n                    return;\n                }\n                _this.connectImpl(transportParams, connectCount);\n            });\n        };\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.startConnect()', 'starting connection');\n        this.startSuspendTimer();\n        this.startTransitionTimer(this.states.connecting);\n        if (auth.method === 'basic') {\n            connect();\n        }\n        else {\n            var authCb = function (err) {\n                if (connectCount !== _this.connectCounter) {\n                    return;\n                }\n                if (err) {\n                    _this.actOnErrorFromAuthorize(err);\n                }\n                else {\n                    connect();\n                }\n            };\n            if (this.errorReason && auth_1.default.isTokenErr(this.errorReason)) {\n                /* Force a refetch of a new token */\n                auth._forceNewToken(null, null, authCb);\n            }\n            else {\n                auth._ensureValidAuthCredentials(false, authCb);\n            }\n        }\n    };\n    /**\n     * There are three stages in connecting:\n     * - preference: if there is a cached transport preference, we try to connect\n     *   on that. If that fails or times out we abort the attempt, remove the\n     *   preference and fall back to base. If it succeeds, we try upgrading it if\n     *   needed (will only be in the case where the preference is xhrs and the\n     *   browser supports ws).\n     * - base: we try to connect with the best transport that we think will\n     *   never fail for this browser (usually this is xhr_polling; for very old\n     *   browsers will be jsonp, for node will be comet). If it doesn't work, we\n     *   try fallback hosts.\n     * - upgrade: given a connected transport, we see if there are any better\n     *   ones, and if so, try to upgrade to them.\n     *\n     * connectImpl works out what stage you're at (which is purely a function of\n     * the current connection state and whether there are any stored preferences),\n     * and dispatches accordingly. After a transport has been set pending,\n     * tryATransport calls connectImpl to see if there's another stage to be done.\n     * */\n    ConnectionManager.prototype.connectImpl = function (transportParams, connectCount) {\n        var state = this.state.state;\n        if (state !== this.states.connecting.state && state !== this.states.connected.state) {\n            /* Only keep trying as long as in the 'connecting' state (or 'connected'\n             * for upgrading). Any operation can put us into 'disconnected' to cancel\n             * connection attempts and wait before retrying, or 'failed' to fail. */\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.connectImpl()', 'Must be in connecting state to connect (or connected to upgrade), but was ' + state);\n        }\n        else if (this.pendingTransports.length) {\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.connectImpl()', 'Transports ' + this.pendingTransports[0].toString() + ' currently pending; taking no action');\n        }\n        else if (state == this.states.connected.state) {\n            this.upgradeIfNeeded(transportParams);\n        }\n        else if (this.transports.length > 1 && this.getTransportPreference()) {\n            this.connectPreference(transportParams, connectCount);\n        }\n        else {\n            this.connectBase(transportParams, connectCount);\n        }\n    };\n    ConnectionManager.prototype.connectPreference = function (transportParams, connectCount) {\n        var _this = this;\n        var preference = this.getTransportPreference();\n        var preferenceTimeoutExpired = false;\n        if (!Utils.arrIn(this.transports, preference)) {\n            this.unpersistTransportPreference();\n            this.connectImpl(transportParams, connectCount);\n        }\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.connectPreference()', 'Trying to connect with stored transport preference ' + preference);\n        var preferenceTimeout = setTimeout(function () {\n            preferenceTimeoutExpired = true;\n            if (!(_this.state.state === _this.states.connected.state)) {\n                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.connectPreference()', 'Shortcircuit connection attempt with ' + preference + ' failed; clearing preference and trying from scratch');\n                /* Abort all connection attempts. (This also disconnects the active\n                 * protocol, but none exists if we're not in the connected state) */\n                _this.disconnectAllTransports();\n                /* Be quite agressive about clearing the stored preference if ever it doesn't work */\n                _this.unpersistTransportPreference();\n            }\n            _this.connectImpl(transportParams, connectCount);\n        }, this.options.timeouts.preferenceConnectTimeout);\n        /* For connectPreference, just use the main host. If host fallback is needed, do it in connectBase.\n         * The wstransport it will substitute the httphost for an appropriate wshost */\n        transportParams.host = this.httpHosts[0];\n        this.tryATransport(transportParams, preference, function (fatal, transport) {\n            clearTimeout(preferenceTimeout);\n            if (preferenceTimeoutExpired && transport) {\n                /* Viable, but too late - connectImpl() will already be trying\n                 * connectBase, and we weren't in upgrade mode. Just remove the\n                 * onconnected listener and get rid of it */\n                transport.off();\n                transport.disconnect();\n                Utils.arrDeleteValue(_this.pendingTransports, transport);\n            }\n            else if (!transport && !fatal) {\n                /* Preference failed in a transport-specific way. Try more */\n                _this.unpersistTransportPreference();\n                _this.connectImpl(transportParams, connectCount);\n            }\n            /* If suceeded, or failed fatally, nothing to do */\n        });\n    };\n    /**\n     * Try to establish a transport on the base transport (the best transport\n     * such that if it doesn't work, nothing will work) as determined through\n     * static feature detection, checking for network connectivity and trying\n     * fallback hosts if applicable.\n     * @param transportParams\n     */\n    ConnectionManager.prototype.connectBase = function (transportParams, connectCount) {\n        var _this = this;\n        var giveUp = function (err) {\n            _this.notifyState({ state: _this.states.connecting.failState, error: err });\n        };\n        var candidateHosts = this.httpHosts.slice();\n        var hostAttemptCb = function (fatal, transport) {\n            if (connectCount !== _this.connectCounter) {\n                return;\n            }\n            if (!transport && !fatal) {\n                tryFallbackHosts();\n            }\n        };\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.connectBase()', 'Trying to connect with base transport ' + this.baseTransport);\n        /* first try to establish a connection with the priority host with http transport */\n        var host = candidateHosts.shift();\n        if (!host) {\n            giveUp(new errorinfo_1.default('Unable to connect (no available host)', 80003, 404));\n            return;\n        }\n        transportParams.host = host;\n        /* this is what we'll be doing if the attempt for the main host fails */\n        var tryFallbackHosts = function () {\n            /* if there aren't any fallback hosts, fail */\n            if (!candidateHosts.length) {\n                giveUp(new errorinfo_1.default('Unable to connect (and no more fallback hosts to try)', 80003, 404));\n                return;\n            }\n            /* before trying any fallback (or any remaining fallback) we decide if\n             * there is a problem with the ably host, or there is a general connectivity\n             * problem */\n            if (!_this.realtime.http.checkConnectivity) {\n                giveUp(new errorinfo_1.PartialErrorInfo('Internal error: Http.checkConnectivity not set', null, 500));\n                return;\n            }\n            _this.realtime.http.checkConnectivity(function (err, connectivity) {\n                if (connectCount !== _this.connectCounter) {\n                    return;\n                }\n                /* we know err won't happen but handle it here anyway */\n                if (err) {\n                    giveUp(err);\n                    return;\n                }\n                if (!connectivity) {\n                    /* the internet isn't reachable, so don't try the fallback hosts */\n                    giveUp(new errorinfo_1.default('Unable to connect (network unreachable)', 80003, 404));\n                    return;\n                }\n                /* the network is there, so there's a problem with the main host, or\n                 * its dns. Try the fallback hosts. We could try them simultaneously but\n                 * that would potentially cause a huge spike in load on the load balancer */\n                transportParams.host = Utils.arrPopRandomElement(candidateHosts);\n                _this.tryATransport(transportParams, _this.baseTransport, hostAttemptCb);\n            });\n        };\n        if (this.forceFallbackHost && candidateHosts.length) {\n            this.forceFallbackHost = false;\n            tryFallbackHosts();\n            return;\n        }\n        this.tryATransport(transportParams, this.baseTransport, hostAttemptCb);\n    };\n    ConnectionManager.prototype.getUpgradePossibilities = function () {\n        /* returns the subset of upgradeTransports to the right of the current\n         * transport in upgradeTransports (if it's in there - if not, currentSerial\n         * will be -1, so return upgradeTransports.slice(0) == upgradeTransports */\n        var current = this.activeProtocol.getTransport().shortName;\n        var currentSerial = Utils.arrIndexOf(this.upgradeTransports, current);\n        return this.upgradeTransports.slice(currentSerial + 1);\n    };\n    ConnectionManager.prototype.upgradeIfNeeded = function (transportParams) {\n        var _this = this;\n        var upgradePossibilities = this.getUpgradePossibilities();\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.upgradeIfNeeded()', 'upgrade possibilities: ' + platform_1.default.Config.inspect(upgradePossibilities));\n        if (!upgradePossibilities.length) {\n            return;\n        }\n        Utils.arrForEach(upgradePossibilities, function (upgradeTransport) {\n            /* Note: the transport may mutate the params, so give each transport a fresh one */\n            var upgradeTransportParams = _this.createTransportParams(transportParams.host, 'upgrade');\n            _this.tryATransport(upgradeTransportParams, upgradeTransport, noop);\n        });\n    };\n    ConnectionManager.prototype.closeImpl = function () {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.closeImpl()', 'closing connection');\n        this.cancelSuspendTimer();\n        this.startTransitionTimer(this.states.closing);\n        Utils.safeArrForEach(this.pendingTransports, function (transport) {\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.closeImpl()', 'Closing pending transport: ' + transport);\n            if (transport)\n                transport.close();\n        });\n        Utils.safeArrForEach(this.proposedTransports, function (transport) {\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.closeImpl()', 'Disposing of proposed transport: ' + transport);\n            if (transport)\n                transport.dispose();\n        });\n        if (this.activeProtocol) {\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.closeImpl()', 'Closing active transport: ' + this.activeProtocol.getTransport());\n            this.activeProtocol.getTransport().close();\n        }\n        /* If there was an active transport, this will probably be\n         * preempted by the notifyState call in deactivateTransport */\n        this.notifyState({ state: 'closed' });\n    };\n    ConnectionManager.prototype.onAuthUpdated = function (tokenDetails, callback) {\n        var _this = this;\n        var _a;\n        switch (this.state.state) {\n            case 'connected': {\n                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.onAuthUpdated()', 'Sending AUTH message on active transport');\n                /* If there are any proposed/pending transports (eg an upgrade that\n                 * isn't yet scheduled for activation) that hasn't yet started syncing,\n                 * just to get rid of them & restart the upgrade with the new token, to\n                 * avoid a race condition. (If it has started syncing, the AUTH will be\n                 * queued until the upgrade is complete, so everything's fine) */\n                if ((this.pendingTransports.length || this.proposedTransports.length) &&\n                    this.state !== this.states.synchronizing) {\n                    this.disconnectAllTransports(/* exceptActive: */ true);\n                    var transportParams_1 = this.activeProtocol.getTransport().params;\n                    platform_1.default.Config.nextTick(function () {\n                        if (_this.state.state === 'connected') {\n                            _this.upgradeIfNeeded(transportParams_1);\n                        }\n                    });\n                }\n                /* Do any transport-specific new-token action */\n                var activeTransport = (_a = this.activeProtocol) === null || _a === void 0 ? void 0 : _a.getTransport();\n                if (activeTransport && activeTransport.onAuthUpdated) {\n                    activeTransport.onAuthUpdated(tokenDetails);\n                }\n                var authMsg = protocolmessage_1.default.fromValues({\n                    action: actions.AUTH,\n                    auth: {\n                        accessToken: tokenDetails.token,\n                    },\n                });\n                this.send(authMsg);\n                /* The answer will come back as either a connectiondetails event\n                 * (realtime sends a CONNECTED to acknowledge the reauth) or a\n                 * statechange to failed */\n                var successListener_1 = function () {\n                    _this.off(failureListener_1);\n                    callback(null, tokenDetails);\n                };\n                var failureListener_1 = function (stateChange) {\n                    if (stateChange.current === 'failed') {\n                        _this.off(successListener_1);\n                        _this.off(failureListener_1);\n                        callback(stateChange.reason || _this.getStateError());\n                    }\n                };\n                this.once('connectiondetails', successListener_1);\n                this.on('connectionstate', failureListener_1);\n                break;\n            }\n            case 'connecting':\n                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.onAuthUpdated()', 'Aborting current connection attempts in order to start again with the new auth details');\n                this.disconnectAllTransports();\n            /* fallthrough to add statechange listener */\n            default: {\n                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.onAuthUpdated()', 'Connection state is ' + this.state.state + '; waiting until either connected or failed');\n                var listener_1 = function (stateChange) {\n                    switch (stateChange.current) {\n                        case 'connected':\n                            _this.off(listener_1);\n                            callback(null, tokenDetails);\n                            break;\n                        case 'failed':\n                        case 'closed':\n                        case 'suspended':\n                            _this.off(listener_1);\n                            callback(stateChange.reason || _this.getStateError());\n                            break;\n                        default:\n                            /* ignore till we get either connected or failed */\n                            break;\n                    }\n                };\n                this.on('connectionstate', listener_1);\n                if (this.state.state === 'connecting') {\n                    /* can happen if in the connecting state but no transport was pending\n                     * yet, so disconnectAllTransports did not trigger a disconnected state */\n                    this.startConnect();\n                }\n                else {\n                    this.requestState({ state: 'connecting' });\n                }\n            }\n        }\n    };\n    ConnectionManager.prototype.disconnectAllTransports = function (exceptActive) {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting all transports' + (exceptActive ? ' except the active transport' : ''));\n        /* This will prevent any connection procedure in an async part of one of its early stages from continuing */\n        this.connectCounter++;\n        Utils.safeArrForEach(this.pendingTransports, function (transport) {\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting pending transport: ' + transport);\n            if (transport)\n                transport.disconnect();\n        });\n        this.pendingTransports = [];\n        Utils.safeArrForEach(this.proposedTransports, function (transport) {\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disposing of proposed transport: ' + transport);\n            if (transport)\n                transport.dispose();\n        });\n        this.proposedTransports = [];\n        if (this.activeProtocol && !exceptActive) {\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.disconnectAllTransports()', 'Disconnecting active transport: ' + this.activeProtocol.getTransport());\n            this.activeProtocol.getTransport().disconnect();\n        }\n        /* No need to notify state disconnected; disconnecting the active transport\n         * will have that effect */\n    };\n    /******************\n     * event queueing\n     ******************/\n    ConnectionManager.prototype.send = function (msg, queueEvent, callback) {\n        callback = callback || noop;\n        var state = this.state;\n        if (state.sendEvents) {\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.send()', 'sending event');\n            this.sendImpl(new protocol_1.PendingMessage(msg, callback));\n            return;\n        }\n        var shouldQueue = (queueEvent && state.queueEvents) || state.forceQueueEvents;\n        if (!shouldQueue) {\n            var err = 'rejecting event, queueEvent was ' + queueEvent + ', state was ' + state.state;\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.send()', err);\n            callback(this.errorReason || new errorinfo_1.default(err, 90000, 400));\n            return;\n        }\n        if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.send()', 'queueing msg; ' + protocolmessage_1.default.stringify(msg));\n        }\n        this.queue(msg, callback);\n    };\n    ConnectionManager.prototype.sendImpl = function (pendingMessage) {\n        var msg = pendingMessage.message;\n        /* If have already attempted to send this, resend with the same msgSerial,\n         * so Ably can dedup if the previous send succeeded */\n        if (pendingMessage.ackRequired && !pendingMessage.sendAttempted) {\n            msg.msgSerial = this.msgSerial++;\n        }\n        try {\n            this.activeProtocol.send(pendingMessage);\n        }\n        catch (e) {\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.sendImpl()', 'Unexpected exception in transport.send(): ' + e.stack);\n        }\n    };\n    ConnectionManager.prototype.queue = function (msg, callback) {\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.queue()', 'queueing event');\n        var lastQueued = this.queuedMessages.last();\n        var maxSize = this.options.maxMessageSize;\n        /* If have already attempted to send a message, don't merge more messages\n         * into it, as if the previous send actually succeeded and realtime ignores\n         * the dup, they'll be lost */\n        if (lastQueued && !lastQueued.sendAttempted && bundleWith(lastQueued.message, msg, maxSize)) {\n            if (!lastQueued.merged) {\n                lastQueued.callback = multicaster_1.default.create([lastQueued.callback]);\n                lastQueued.merged = true;\n            }\n            lastQueued.callback.push(callback);\n        }\n        else {\n            this.queuedMessages.push(new protocol_1.PendingMessage(msg, callback));\n        }\n    };\n    ConnectionManager.prototype.sendQueuedMessages = function () {\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.sendQueuedMessages()', 'sending ' + this.queuedMessages.count() + ' queued messages');\n        var pendingMessage;\n        while ((pendingMessage = this.queuedMessages.shift()))\n            this.sendImpl(pendingMessage);\n    };\n    ConnectionManager.prototype.queuePendingMessages = function (pendingMessages) {\n        if (pendingMessages && pendingMessages.length) {\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.queuePendingMessages()', 'queueing ' + pendingMessages.length + ' pending messages');\n            this.queuedMessages.prepend(pendingMessages);\n        }\n    };\n    ConnectionManager.prototype.failQueuedMessages = function (err) {\n        var numQueued = this.queuedMessages.count();\n        if (numQueued > 0) {\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.failQueuedMessages()', 'failing ' + numQueued + ' queued messages, err = ' + Utils.inspectError(err));\n            this.queuedMessages.completeAllMessages(err);\n        }\n    };\n    ConnectionManager.prototype.onChannelMessage = function (message, transport) {\n        var onActiveTransport = this.activeProtocol && transport === this.activeProtocol.getTransport(), onUpgradeTransport = Utils.arrIn(this.pendingTransports, transport) && this.state == this.states.synchronizing;\n        /* As the lib now has a period where the upgrade transport is synced but\n         * before it's become active (while waiting for the old one to become\n         * idle), message can validly arrive on it even though it isn't active */\n        if (onActiveTransport || onUpgradeTransport) {\n            this.realtime.channels.onChannelMessage(message);\n        }\n        else {\n            // Message came in on a defunct transport. Allow only acks, nacks, & errors for outstanding\n            // messages,  no new messages (as sync has been sent on new transport so new messages will\n            // be resent there, or connection has been closed so don't want new messages)\n            if (Utils.arrIndexOf([actions.ACK, actions.NACK, actions.ERROR], message.action) > -1) {\n                this.realtime.channels.onChannelMessage(message);\n            }\n            else {\n                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'ConnectionManager.onChannelMessage()', 'received message ' + JSON.stringify(message) + 'on defunct transport; discarding');\n            }\n        }\n    };\n    ConnectionManager.prototype.ping = function (transport, callback) {\n        var _this = this;\n        /* if transport is specified, try that */\n        if (transport) {\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.ping()', 'transport = ' + transport);\n            var onTimeout = function () {\n                transport.off('heartbeat', onHeartbeat_1);\n                callback(new errorinfo_1.default('Timeout waiting for heartbeat response', 50000, 500));\n            };\n            var pingStart_1 = Utils.now(), id_1 = Utils.cheapRandStr();\n            var onHeartbeat_1 = function (responseId) {\n                if (responseId === id_1) {\n                    transport.off('heartbeat', onHeartbeat_1);\n                    clearTimeout(timer_1);\n                    var responseTime = Utils.now() - pingStart_1;\n                    callback(null, responseTime);\n                }\n            };\n            var timer_1 = setTimeout(onTimeout, this.options.timeouts.realtimeRequestTimeout);\n            transport.on('heartbeat', onHeartbeat_1);\n            transport.ping(id_1);\n            return;\n        }\n        /* if we're not connected, don't attempt */\n        if (this.state.state !== 'connected') {\n            callback(new errorinfo_1.default('Unable to ping service; not connected', 40000, 400));\n            return;\n        }\n        /* no transport was specified, so use the current (connected) one\n         * but ensure that we retry if the transport is superseded before we complete */\n        var completed = false;\n        var onPingComplete = function (err, responseTime) {\n            _this.off('transport.active', onTransportActive);\n            if (!completed) {\n                completed = true;\n                callback(err, responseTime);\n            }\n        };\n        var onTransportActive = function () {\n            if (!completed) {\n                /* ensure that no callback happens for the currently outstanding operation */\n                completed = true;\n                /* repeat but picking up the new transport */\n                platform_1.default.Config.nextTick(function () {\n                    _this.ping(null, callback);\n                });\n            }\n        };\n        this.on('transport.active', onTransportActive);\n        this.ping(this.activeProtocol.getTransport(), onPingComplete);\n    };\n    ConnectionManager.prototype.abort = function (error) {\n        this.activeProtocol.getTransport().fail(error);\n    };\n    ConnectionManager.prototype.registerProposedTransport = function (transport) {\n        this.proposedTransports.push(transport);\n    };\n    ConnectionManager.prototype.getTransportPreference = function () {\n        var _a, _b;\n        return this.transportPreference || (haveWebStorage() && ((_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.get) === null || _b === void 0 ? void 0 : _b.call(_a, transportPreferenceName)));\n    };\n    ConnectionManager.prototype.persistTransportPreference = function (transport) {\n        var _a, _b;\n        if (Utils.arrIn(defaults_1.default.upgradeTransports, transport.shortName)) {\n            this.transportPreference = transport.shortName;\n            if (haveWebStorage()) {\n                (_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.set) === null || _b === void 0 ? void 0 : _b.call(_a, transportPreferenceName, transport.shortName);\n            }\n        }\n    };\n    ConnectionManager.prototype.unpersistTransportPreference = function () {\n        var _a, _b;\n        this.transportPreference = null;\n        if (haveWebStorage()) {\n            (_b = (_a = platform_1.default.WebStorage) === null || _a === void 0 ? void 0 : _a.remove) === null || _b === void 0 ? void 0 : _b.call(_a, transportPreferenceName);\n        }\n    };\n    /* This method is only used during connection attempts, so implements RSA4c1, RSA4c2,\n     * and RSA4d. It is generally not invoked for serverside-triggered reauths or manual\n     * reauths, so RSA4c3 does not apply, except (per per RSA4d1) in the case that the auth\n     * server returns 403. */\n    ConnectionManager.prototype.actOnErrorFromAuthorize = function (err) {\n        if (err.code === 40171) {\n            /* No way to reauth */\n            this.notifyState({ state: 'failed', error: err });\n        }\n        else if (err.code === 40102) {\n            this.notifyState({ state: 'failed', error: err });\n        }\n        else if (err.statusCode === HttpStatusCodes_1.default.Forbidden) {\n            var msg = 'Client configured authentication provider returned 403; failing the connection';\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.actOnErrorFromAuthorize()', msg);\n            this.notifyState({ state: 'failed', error: new errorinfo_1.default(msg, 80019, 403, err) });\n        }\n        else {\n            var msg = 'Client configured authentication provider request failed';\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'ConnectionManager.actOnErrorFromAuthorize', msg);\n            this.notifyState({ state: this.state.failState, error: new errorinfo_1.default(msg, 80019, 401, err) });\n        }\n    };\n    ConnectionManager.prototype.onConnectionDetailsUpdate = function (connectionDetails, transport) {\n        if (!connectionDetails) {\n            return;\n        }\n        this.connectionDetails = connectionDetails;\n        if (connectionDetails.maxMessageSize) {\n            this.options.maxMessageSize = connectionDetails.maxMessageSize;\n        }\n        var clientId = connectionDetails.clientId;\n        if (clientId) {\n            var err = this.realtime.auth._uncheckedSetClientId(clientId);\n            if (err) {\n                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'ConnectionManager.onConnectionDetailsUpdate()', err.message);\n                /* Errors setting the clientId are fatal to the connection */\n                transport.fail(err);\n                return;\n            }\n        }\n        var connectionStateTtl = connectionDetails.connectionStateTtl;\n        if (connectionStateTtl) {\n            this.connectionStateTtl = connectionStateTtl;\n        }\n        this.maxIdleInterval = connectionDetails.maxIdleInterval;\n        this.emit('connectiondetails', connectionDetails);\n    };\n    /*********************\n     * transport management\n     *********************/\n    ConnectionManager.supportedTransports = {};\n    return ConnectionManager;\n}(eventemitter_1.default));\nexports.default = ConnectionManager;\n\n/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_301348__(13)))\n\n/***/ }),\n/* 36 */\n/***/ (function(module, exports, __nested_webpack_require_391616__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_391616__(0);\nvar eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_391616__(7));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_391616__(2));\nvar MessageQueue = /** @class */ (function (_super) {\n    tslib_1.__extends(MessageQueue, _super);\n    function MessageQueue() {\n        var _this = _super.call(this) || this;\n        _this.messages = [];\n        return _this;\n    }\n    MessageQueue.prototype.count = function () {\n        return this.messages.length;\n    };\n    MessageQueue.prototype.push = function (message) {\n        this.messages.push(message);\n    };\n    MessageQueue.prototype.shift = function () {\n        return this.messages.shift();\n    };\n    MessageQueue.prototype.last = function () {\n        return this.messages[this.messages.length - 1];\n    };\n    MessageQueue.prototype.copyAll = function () {\n        return this.messages.slice();\n    };\n    MessageQueue.prototype.append = function (messages) {\n        this.messages.push.apply(this.messages, messages);\n    };\n    MessageQueue.prototype.prepend = function (messages) {\n        this.messages.unshift.apply(this.messages, messages);\n    };\n    MessageQueue.prototype.completeMessages = function (serial, count, err) {\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'MessageQueue.completeMessages()', 'serial = ' + serial + '; count = ' + count);\n        err = err || null;\n        var messages = this.messages;\n        if (messages.length === 0) {\n            throw new Error('MessageQueue.completeMessages(): completeMessages called on any empty MessageQueue');\n        }\n        var first = messages[0];\n        if (first) {\n            var startSerial = first.message.msgSerial;\n            var endSerial = serial + count; /* the serial of the first message that is *not* the subject of this call */\n            if (endSerial > startSerial) {\n                var completeMessages = messages.splice(0, endSerial - startSerial);\n                for (var _i = 0, completeMessages_1 = completeMessages; _i < completeMessages_1.length; _i++) {\n                    var message = completeMessages_1[_i];\n                    message.callback(err);\n                }\n            }\n            if (messages.length == 0)\n                this.emit('idle');\n        }\n    };\n    MessageQueue.prototype.completeAllMessages = function (err) {\n        this.completeMessages(0, Number.MAX_SAFE_INTEGER || Number.MAX_VALUE, err);\n    };\n    MessageQueue.prototype.resetSendAttempted = function () {\n        for (var _i = 0, _a = this.messages; _i < _a.length; _i++) {\n            var msg = _a[_i];\n            msg.sendAttempted = false;\n        }\n    };\n    MessageQueue.prototype.clear = function () {\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'MessageQueue.clear()', 'clearing ' + this.messages.length + ' messages');\n        this.messages = [];\n        this.emit('idle');\n    };\n    return MessageQueue;\n}(eventemitter_1.default));\nexports.default = MessageQueue;\n\n\n/***/ }),\n/* 37 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ConnectionStateChange = /** @class */ (function () {\n    function ConnectionStateChange(previous, current, retryIn, reason) {\n        this.previous = previous;\n        this.current = current;\n        if (retryIn)\n            this.retryIn = retryIn;\n        if (reason)\n            this.reason = reason;\n    }\n    return ConnectionStateChange;\n}());\nexports.default = ConnectionStateChange;\n\n\n/***/ }),\n/* 38 */\n/***/ (function(module, exports, __nested_webpack_require_395321__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_395321__(0);\nvar protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_395321__(10));\nvar eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_395321__(7));\nvar Utils = tslib_1.__importStar(__nested_webpack_require_395321__(1));\nvar channel_1 = tslib_1.__importDefault(__nested_webpack_require_395321__(33));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_395321__(2));\nvar realtimepresence_1 = tslib_1.__importDefault(__nested_webpack_require_395321__(54));\nvar message_1 = tslib_1.__importDefault(__nested_webpack_require_395321__(9));\nvar channelstatechange_1 = tslib_1.__importDefault(__nested_webpack_require_395321__(39));\nvar errorinfo_1 = tslib_1.__importStar(__nested_webpack_require_395321__(4));\nvar presencemessage_1 = tslib_1.__importDefault(__nested_webpack_require_395321__(15));\nvar connectionerrors_1 = tslib_1.__importDefault(__nested_webpack_require_395321__(20));\nvar actions = protocolmessage_1.default.Action;\nvar noop = function () { };\nfunction validateChannelOptions(options) {\n    if (options && 'params' in options && !Utils.isObject(options.params)) {\n        return new errorinfo_1.default('options.params must be an object', 40000, 400);\n    }\n    if (options && 'modes' in options) {\n        if (!Utils.isArray(options.modes)) {\n            return new errorinfo_1.default('options.modes must be an array', 40000, 400);\n        }\n        for (var i = 0; i < options.modes.length; i++) {\n            var currentMode = options.modes[i];\n            if (!currentMode ||\n                typeof currentMode !== 'string' ||\n                !Utils.arrIn(protocolmessage_1.default.channelModes, String.prototype.toUpperCase.call(currentMode))) {\n                return new errorinfo_1.default('Invalid channel mode: ' + currentMode, 40000, 400);\n            }\n        }\n    }\n}\nvar RealtimeChannel = /** @class */ (function (_super) {\n    tslib_1.__extends(RealtimeChannel, _super);\n    function RealtimeChannel(realtime, name, options) {\n        var _this = _super.call(this, realtime, name, options) || this;\n        _this.retryCount = 0;\n        _this.history = function (params, callback) {\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.history()', 'channel = ' + this.name);\n            /* params and callback are optional; see if params contains the callback */\n            if (callback === undefined) {\n                if (typeof params == 'function') {\n                    callback = params;\n                    params = null;\n                }\n                else {\n                    if (this.rest.options.promises) {\n                        return Utils.promisify(this, 'history', arguments);\n                    }\n                    callback = noop;\n                }\n            }\n            if (params && params.untilAttach) {\n                if (this.state !== 'attached') {\n                    callback(new errorinfo_1.default('option untilAttach requires the channel to be attached', 40000, 400));\n                    return;\n                }\n                if (!this.properties.attachSerial) {\n                    callback(new errorinfo_1.default('untilAttach was specified and channel is attached, but attachSerial is not defined', 40000, 400));\n                    return;\n                }\n                delete params.untilAttach;\n                params.from_serial = this.properties.attachSerial;\n            }\n            channel_1.default.prototype._history.call(this, params, callback);\n        };\n        _this.whenState = (function (state, listener) {\n            return eventemitter_1.default.prototype.whenState.call(_this, state, _this.state, listener);\n        });\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel()', 'started; name = ' + name);\n        _this.realtime = realtime;\n        _this.presence = new realtimepresence_1.default(_this);\n        _this.connectionManager = realtime.connection.connectionManager;\n        _this.state = 'initialized';\n        _this.subscriptions = new eventemitter_1.default();\n        _this.syncChannelSerial = undefined;\n        _this.properties = {\n            attachSerial: undefined,\n            channelSerial: undefined,\n        };\n        _this.setOptions(options);\n        _this.errorReason = null;\n        _this._requestedFlags = null;\n        _this._mode = null;\n        _this._attachResume = false;\n        _this._decodingContext = {\n            channelOptions: _this.channelOptions,\n            plugins: realtime.options.plugins || {},\n            baseEncodedPreviousPayload: undefined,\n        };\n        _this._lastPayload = {\n            messageId: null,\n            protocolMessageChannelSerial: null,\n            decodeFailureRecoveryInProgress: null,\n        };\n        /* Only differences between this and the public event emitter is that this emits an\n         * update event for all ATTACHEDs, whether resumed or not */\n        _this._allChannelChanges = new eventemitter_1.default();\n        return _this;\n    }\n    RealtimeChannel.prototype.invalidStateError = function () {\n        return new errorinfo_1.default('Channel operation failed as channel state is ' + this.state, 90001, 400, this.errorReason || undefined);\n    };\n    RealtimeChannel.processListenerArgs = function (args) {\n        /* [event], listener, [callback] */\n        args = Array.prototype.slice.call(args);\n        if (typeof args[0] === 'function') {\n            args.unshift(null);\n        }\n        if (args[args.length - 1] == undefined) {\n            args.pop();\n        }\n        return args;\n    };\n    RealtimeChannel.prototype.setOptions = function (options, callback) {\n        var previousChannelOptions = this.channelOptions;\n        if (!callback) {\n            if (this.rest.options.promises) {\n                return Utils.promisify(this, 'setOptions', arguments);\n            }\n        }\n        var _callback = callback ||\n            function (err) {\n                if (err) {\n                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel.setOptions()', 'Set options failed: ' + err.toString());\n                }\n            };\n        var err = validateChannelOptions(options);\n        if (err) {\n            _callback(err);\n            return;\n        }\n        channel_1.default.prototype.setOptions.call(this, options);\n        if (this._decodingContext)\n            this._decodingContext.channelOptions = this.channelOptions;\n        if (this._shouldReattachToSetOptions(options, previousChannelOptions)) {\n            /* This does not just do _attach(true, null, callback) because that would put us\n             * into the 'attaching' state until we receive the new attached, which is\n             * conceptually incorrect: we are still attached, we just have a pending request to\n             * change some channel params. Per RTL17 going into the attaching state would mean\n             * rejecting messages until we have confirmation that the options have changed,\n             * which would unnecessarily lose message continuity. */\n            this.attachImpl();\n            // Ignore 'attaching' -- could be just due to to a resume & reattach, should not\n            // call back setOptions until we're definitely attached with the new options (or\n            // else in a terminal state)\n            this._allChannelChanges.once(['attached', 'update', 'detached', 'failed'], function (stateChange) {\n                switch (this.event) {\n                    case 'update':\n                    case 'attached':\n                        _callback === null || _callback === void 0 ? void 0 : _callback(null);\n                        return;\n                    default:\n                        _callback === null || _callback === void 0 ? void 0 : _callback(stateChange.reason);\n                        return;\n                }\n            });\n        }\n        else {\n            _callback();\n        }\n    };\n    RealtimeChannel.prototype._shouldReattachToSetOptions = function (options, prevOptions) {\n        if (!(this.state === 'attached' || this.state === 'attaching')) {\n            return false;\n        }\n        if (options === null || options === void 0 ? void 0 : options.params) {\n            // Don't check against the `agent` param - it isn't returned in the ATTACHED message\n            var requestedParams = omitAgent(options.params);\n            var existingParams = omitAgent(prevOptions.params);\n            if (Object.keys(requestedParams).length !== Object.keys(existingParams).length) {\n                return true;\n            }\n            if (!Utils.shallowEquals(existingParams, requestedParams)) {\n                return true;\n            }\n        }\n        if (options === null || options === void 0 ? void 0 : options.modes) {\n            if (!prevOptions.modes || !Utils.arrEquals(options.modes, prevOptions.modes)) {\n                return true;\n            }\n        }\n        return false;\n    };\n    RealtimeChannel.prototype.publish = function () {\n        var _this = this;\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        var messages = args[0];\n        var argCount = args.length;\n        var callback = args[argCount - 1];\n        if (typeof callback !== 'function') {\n            if (this.realtime.options.promises) {\n                return Utils.promisify(this, 'publish', arguments);\n            }\n            callback = noop;\n            ++argCount;\n        }\n        if (!this.connectionManager.activeState()) {\n            callback(this.connectionManager.getError());\n            return;\n        }\n        if (argCount == 2) {\n            if (Utils.isObject(messages))\n                messages = [message_1.default.fromValues(messages)];\n            else if (Utils.isArray(messages))\n                messages = message_1.default.fromValuesArray(messages);\n            else\n                throw new errorinfo_1.default('The single-argument form of publish() expects a message object or an array of message objects', 40013, 400);\n        }\n        else {\n            messages = [message_1.default.fromValues({ name: args[0], data: args[1] })];\n        }\n        var maxMessageSize = this.realtime.options.maxMessageSize;\n        message_1.default.encodeArray(messages, this.channelOptions, function (err) {\n            if (err) {\n                callback(err);\n                return;\n            }\n            /* RSL1i */\n            var size = message_1.default.getMessagesSize(messages);\n            if (size > maxMessageSize) {\n                callback(new errorinfo_1.default('Maximum size of messages that can be published at once exceeded ( was ' +\n                    size +\n                    ' bytes; limit is ' +\n                    maxMessageSize +\n                    ' bytes)', 40009, 400));\n                return;\n            }\n            _this.__publish(messages, callback);\n        });\n    };\n    // Double underscore used to prevent type conflict with underlying Channel._publish method\n    RealtimeChannel.prototype.__publish = function (messages, callback) {\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.publish()', 'message count = ' + messages.length);\n        var state = this.state;\n        switch (state) {\n            case 'failed':\n            case 'suspended':\n                callback(errorinfo_1.default.fromValues(this.invalidStateError()));\n                break;\n            default: {\n                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.publish()', 'sending message; channel state is ' + state);\n                var msg = new protocolmessage_1.default();\n                msg.action = actions.MESSAGE;\n                msg.channel = this.name;\n                msg.messages = messages;\n                this.sendMessage(msg, callback);\n                break;\n            }\n        }\n    };\n    RealtimeChannel.prototype.onEvent = function (messages) {\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.onEvent()', 'received message');\n        var subscriptions = this.subscriptions;\n        for (var i = 0; i < messages.length; i++) {\n            var message = messages[i];\n            subscriptions.emit(message.name, message);\n        }\n    };\n    RealtimeChannel.prototype.attach = function (flags, callback) {\n        var _flags;\n        if (typeof flags === 'function') {\n            callback = flags;\n            _flags = null;\n        }\n        else {\n            _flags = flags;\n        }\n        if (!callback) {\n            if (this.realtime.options.promises) {\n                return Utils.promisify(this, 'attach', arguments);\n            }\n            callback = function (err) {\n                if (err) {\n                    logger_1.default.logAction(logger_1.default.LOG_MAJOR, 'RealtimeChannel.attach()', 'Channel attach failed: ' + err.toString());\n                }\n            };\n        }\n        if (_flags) {\n            logger_1.default.deprecated('channel.attach() with flags', 'channel.setOptions() with channelOptions.params');\n            /* If flags requested, always do a re-attach. TODO only do this if\n             * current mode differs from requested mode */\n            this._requestedFlags = _flags;\n        }\n        else if (this.state === 'attached') {\n            callback(null, null);\n            return;\n        }\n        this._attach(false, null, callback);\n    };\n    RealtimeChannel.prototype._attach = function (forceReattach, attachReason, callback) {\n        if (!callback) {\n            callback = function (err) {\n                if (err) {\n                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel._attach()', 'Channel attach failed: ' + err.toString());\n                }\n            };\n        }\n        var connectionManager = this.connectionManager;\n        if (!connectionManager.activeState()) {\n            callback(connectionManager.getError());\n            return;\n        }\n        if (this.state !== 'attaching' || forceReattach) {\n            this.requestState('attaching', attachReason);\n        }\n        this.once(function (stateChange) {\n            switch (this.event) {\n                case 'attached':\n                    callback === null || callback === void 0 ? void 0 : callback(null, stateChange);\n                    break;\n                case 'detached':\n                case 'suspended':\n                case 'failed':\n                    callback === null || callback === void 0 ? void 0 : callback(stateChange.reason ||\n                        connectionManager.getError() ||\n                        new errorinfo_1.default('Unable to attach; reason unknown; state = ' + this.event, 90000, 500));\n                    break;\n                case 'detaching':\n                    callback === null || callback === void 0 ? void 0 : callback(new errorinfo_1.default('Attach request superseded by a subsequent detach request', 90000, 409));\n                    break;\n            }\n        });\n    };\n    RealtimeChannel.prototype.attachImpl = function () {\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.attachImpl()', 'sending ATTACH message');\n        var attachMsg = protocolmessage_1.default.fromValues({\n            action: actions.ATTACH,\n            channel: this.name,\n            params: this.channelOptions.params,\n            // RTL4c1: Includes the channel serial to resume from a previous message\n            // or attachment.\n            channelSerial: this.properties.channelSerial,\n        });\n        if (this._requestedFlags) {\n            attachMsg.encodeModesToFlags(this._requestedFlags);\n        }\n        else if (this.channelOptions.modes) {\n            attachMsg.encodeModesToFlags(Utils.allToUpperCase(this.channelOptions.modes));\n        }\n        if (this._attachResume) {\n            attachMsg.setFlag('ATTACH_RESUME');\n        }\n        if (this._lastPayload.decodeFailureRecoveryInProgress) {\n            attachMsg.channelSerial = this._lastPayload.protocolMessageChannelSerial;\n        }\n        this.sendMessage(attachMsg, noop);\n    };\n    RealtimeChannel.prototype.detach = function (callback) {\n        if (!callback) {\n            if (this.realtime.options.promises) {\n                return Utils.promisify(this, 'detach', arguments);\n            }\n            callback = noop;\n        }\n        var connectionManager = this.connectionManager;\n        if (!connectionManager.activeState()) {\n            callback(connectionManager.getError());\n            return;\n        }\n        switch (this.state) {\n            case 'suspended':\n                this.notifyState('detached');\n                callback();\n                break;\n            case 'detached':\n                callback();\n                break;\n            case 'failed':\n                callback(new errorinfo_1.default('Unable to detach; channel state = failed', 90001, 400));\n                break;\n            default:\n                this.requestState('detaching');\n            // eslint-disable-next-line no-fallthrough\n            case 'detaching':\n                this.once(function (stateChange) {\n                    switch (this.event) {\n                        case 'detached':\n                            callback();\n                            break;\n                        case 'attached':\n                        case 'suspended':\n                        case 'failed':\n                            callback(stateChange.reason ||\n                                connectionManager.getError() ||\n                                new errorinfo_1.default('Unable to detach; reason unknown; state = ' + this.event, 90000, 500));\n                            break;\n                        case 'attaching':\n                            callback(new errorinfo_1.default('Detach request superseded by a subsequent attach request', 90000, 409));\n                            break;\n                    }\n                });\n        }\n    };\n    RealtimeChannel.prototype.detachImpl = function (callback) {\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.detach()', 'sending DETACH message');\n        var msg = protocolmessage_1.default.fromValues({ action: actions.DETACH, channel: this.name });\n        this.sendMessage(msg, callback || noop);\n    };\n    RealtimeChannel.prototype.subscribe = function () {\n        var args = []; /* [event], listener, [callback] */\n        for (var _i = 0 /* [event], listener, [callback] */; _i < arguments.length /* [event], listener, [callback] */; _i++ /* [event], listener, [callback] */) {\n            args[_i] = arguments[_i]; /* [event], listener, [callback] */\n        }\n        var _a = RealtimeChannel.processListenerArgs(args), event = _a[0], listener = _a[1], callback = _a[2];\n        if (!callback && this.realtime.options.promises) {\n            return Utils.promisify(this, 'subscribe', [event, listener]);\n        }\n        if (this.state === 'failed') {\n            callback === null || callback === void 0 ? void 0 : callback(errorinfo_1.default.fromValues(this.invalidStateError()));\n            return;\n        }\n        // Filtered\n        if (event && typeof event === 'object' && !Array.isArray(event)) {\n            this._subscribeFilter(event, listener);\n        }\n        else {\n            this.subscriptions.on(event, listener);\n        }\n        return this.attach(callback || noop);\n    };\n    RealtimeChannel.prototype._subscribeFilter = function (filter, listener) {\n        var filteredListener = function (m) {\n            var _a, _b, _c, _d, _e, _f;\n            var mapping = {\n                name: m.name,\n                refTimeserial: (_b = (_a = m.extras) === null || _a === void 0 ? void 0 : _a.ref) === null || _b === void 0 ? void 0 : _b.timeserial,\n                refType: (_d = (_c = m.extras) === null || _c === void 0 ? void 0 : _c.ref) === null || _d === void 0 ? void 0 : _d.type,\n                isRef: !!((_f = (_e = m.extras) === null || _e === void 0 ? void 0 : _e.ref) === null || _f === void 0 ? void 0 : _f.timeserial),\n                clientId: m.clientId,\n            };\n            // Check if any values are defined in the filter and if they match the value in the message object\n            if (Object.entries(filter).find(function (_a) {\n                var key = _a[0], value = _a[1];\n                return value !== undefined ? mapping[key] !== value : false;\n            })) {\n                return;\n            }\n            listener(m);\n        };\n        this._addFilteredSubscription(filter, listener, filteredListener);\n        this.subscriptions.on(filteredListener);\n    };\n    // Adds a new filtered subscription\n    RealtimeChannel.prototype._addFilteredSubscription = function (filter, realListener, filteredListener) {\n        var _a;\n        if (!this.filteredSubscriptions) {\n            this.filteredSubscriptions = new Map();\n        }\n        if (this.filteredSubscriptions.has(realListener)) {\n            var realListenerMap = this.filteredSubscriptions.get(realListener);\n            // Add the filtered listener to the map, or append to the array if this filter has already been used\n            realListenerMap.set(filter, ((_a = realListenerMap === null || realListenerMap === void 0 ? void 0 : realListenerMap.get(filter)) === null || _a === void 0 ? void 0 : _a.concat(filteredListener)) || [filteredListener]);\n        }\n        else {\n            this.filteredSubscriptions.set(realListener, new Map([[filter, [filteredListener]]]));\n        }\n    };\n    RealtimeChannel.prototype._getAndDeleteFilteredSubscriptions = function (filter, realListener) {\n        var _this = this;\n        // No filtered subscriptions map means there has been no filtered subscriptions yet, so return nothing\n        if (!this.filteredSubscriptions) {\n            return [];\n        }\n        // Only a filter is passed in with no specific listener\n        if (!realListener && filter) {\n            // Return each listener which is attached to the specified filter object\n            return Array.from(this.filteredSubscriptions.entries())\n                .map(function (_a) {\n                var _b;\n                var key = _a[0], filterMaps = _a[1];\n                // Get (then delete) the maps matching this filter\n                var listenerMaps = filterMaps.get(filter);\n                filterMaps.delete(filter);\n                // Clear the parent if nothing is left\n                if (filterMaps.size === 0) {\n                    (_b = _this.filteredSubscriptions) === null || _b === void 0 ? void 0 : _b.delete(key);\n                }\n                return listenerMaps;\n            })\n                .reduce(function (prev, cur) {\n                var _a;\n                return (cur ? (_a = prev).concat.apply(_a, cur) : prev);\n            }, []);\n        }\n        // No subscriptions for this listener\n        if (!realListener || !this.filteredSubscriptions.has(realListener)) {\n            return [];\n        }\n        var realListenerMap = this.filteredSubscriptions.get(realListener);\n        // If no filter is specified return all listeners using that function\n        if (!filter) {\n            // array.flat is not available unless we support es2019 or higher\n            var listeners_1 = Array.from(realListenerMap.values()).reduce(function (prev, cur) { return prev.concat.apply(prev, cur); }, []);\n            // remove the listener from the map\n            this.filteredSubscriptions.delete(realListener);\n            return listeners_1;\n        }\n        var listeners = realListenerMap.get(filter);\n        realListenerMap.delete(filter);\n        return listeners || [];\n    };\n    RealtimeChannel.prototype.unsubscribe = function () {\n        var _this = this;\n        var _a;\n        var args = []; /* [event], listener */\n        for (var _i = 0 /* [event], listener */; _i < arguments.length /* [event], listener */; _i++ /* [event], listener */) {\n            args[_i] = arguments[_i]; /* [event], listener */\n        }\n        var _b = RealtimeChannel.processListenerArgs(args), event = _b[0], listener = _b[1];\n        // If we either have a filtered listener, a filter or both we need to do additional processing to find the original function(s)\n        if ((typeof event === 'object' && !listener) || ((_a = this.filteredSubscriptions) === null || _a === void 0 ? void 0 : _a.has(listener))) {\n            this._getAndDeleteFilteredSubscriptions(event, listener).forEach(function (l) { return _this.subscriptions.off(l); });\n            return;\n        }\n        this.subscriptions.off(event, listener);\n    };\n    RealtimeChannel.prototype.sync = function () {\n        /* check preconditions */\n        switch (this.state) {\n            case 'initialized':\n            case 'detaching':\n            case 'detached':\n                throw new errorinfo_1.PartialErrorInfo('Unable to sync to channel; not attached', 40000);\n            default:\n        }\n        var connectionManager = this.connectionManager;\n        if (!connectionManager.activeState()) {\n            throw connectionManager.getError();\n        }\n        /* send sync request */\n        var syncMessage = protocolmessage_1.default.fromValues({ action: actions.SYNC, channel: this.name });\n        if (this.syncChannelSerial) {\n            syncMessage.channelSerial = this.syncChannelSerial;\n        }\n        connectionManager.send(syncMessage);\n    };\n    RealtimeChannel.prototype.sendMessage = function (msg, callback) {\n        this.connectionManager.send(msg, this.realtime.options.queueMessages, callback);\n    };\n    RealtimeChannel.prototype.sendPresence = function (presence, callback) {\n        var msg = protocolmessage_1.default.fromValues({\n            action: actions.PRESENCE,\n            channel: this.name,\n            presence: Utils.isArray(presence)\n                ? presencemessage_1.default.fromValuesArray(presence)\n                : [presencemessage_1.default.fromValues(presence)],\n        });\n        this.sendMessage(msg, callback);\n    };\n    RealtimeChannel.prototype.onMessage = function (message) {\n        if (message.action === actions.ATTACHED ||\n            message.action === actions.MESSAGE ||\n            message.action === actions.PRESENCE) {\n            // RTL15b\n            this.setChannelSerial(message.channelSerial);\n        }\n        var syncChannelSerial, isSync = false;\n        switch (message.action) {\n            case actions.ATTACHED: {\n                this.properties.attachSerial = message.channelSerial;\n                this._mode = message.getMode();\n                this.params = message.params || {};\n                var modesFromFlags = message.decodeModesFromFlags();\n                this.modes = (modesFromFlags && Utils.allToLowerCase(modesFromFlags)) || undefined;\n                var resumed = message.hasFlag('RESUMED');\n                var hasPresence = message.hasFlag('HAS_PRESENCE');\n                var hasBacklog = message.hasFlag('HAS_BACKLOG');\n                if (this.state === 'attached') {\n                    if (!resumed) {\n                        /* On a loss of continuity, the presence set needs to be re-synced */\n                        this.presence.onAttached(hasPresence);\n                    }\n                    var change = new channelstatechange_1.default(this.state, this.state, resumed, hasBacklog, message.error);\n                    this._allChannelChanges.emit('update', change);\n                    if (!resumed || this.channelOptions.updateOnAttached) {\n                        this.emit('update', change);\n                    }\n                }\n                else if (this.state === 'detaching') {\n                    /* RTL5i: re-send DETACH and remain in the 'detaching' state */\n                    this.checkPendingState();\n                }\n                else {\n                    this.notifyState('attached', message.error, resumed, hasPresence, hasBacklog);\n                }\n                break;\n            }\n            case actions.DETACHED: {\n                var detachErr = message.error\n                    ? errorinfo_1.default.fromValues(message.error)\n                    : new errorinfo_1.default('Channel detached', 90001, 404);\n                if (this.state === 'detaching') {\n                    this.notifyState('detached', detachErr);\n                }\n                else if (this.state === 'attaching') {\n                    /* Only retry immediately if we were previously attached. If we were\n                     * attaching, go into suspended, fail messages, and wait a few seconds\n                     * before retrying */\n                    this.notifyState('suspended', detachErr);\n                }\n                else {\n                    this.requestState('attaching', detachErr);\n                }\n                break;\n            }\n            case actions.SYNC:\n                /* syncs can have channelSerials, but might not if the sync is one page long */\n                isSync = true;\n                syncChannelSerial = this.syncChannelSerial = message.channelSerial;\n                /* syncs can happen on channels with no presence data as part of connection\n                 * resuming, in which case protocol message has no presence property */\n                if (!message.presence)\n                    break;\n            // eslint-disable-next-line no-fallthrough\n            case actions.PRESENCE: {\n                var presence = message.presence;\n                var id = message.id, connectionId = message.connectionId, timestamp = message.timestamp;\n                var options = this.channelOptions;\n                var presenceMsg = void 0;\n                for (var i = 0; i < presence.length; i++) {\n                    try {\n                        presenceMsg = presence[i];\n                        presencemessage_1.default.decode(presenceMsg, options);\n                        if (!presenceMsg.connectionId)\n                            presenceMsg.connectionId = connectionId;\n                        if (!presenceMsg.timestamp)\n                            presenceMsg.timestamp = timestamp;\n                        if (!presenceMsg.id)\n                            presenceMsg.id = id + ':' + i;\n                    }\n                    catch (e) {\n                        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel.onMessage()', e.toString());\n                    }\n                }\n                this.presence.setPresence(presence, isSync, syncChannelSerial);\n                break;\n            }\n            case actions.MESSAGE: {\n                //RTL17\n                if (this.state !== 'attached') {\n                    logger_1.default.logAction(logger_1.default.LOG_MAJOR, 'RealtimeChannel.onMessage()', 'Message \"' +\n                        message.id +\n                        '\" skipped as this channel \"' +\n                        this.name +\n                        '\" state is not \"attached\" (state is \"' +\n                        this.state +\n                        '\").');\n                    return;\n                }\n                var messages = message.messages, firstMessage = messages[0], lastMessage = messages[messages.length - 1], id = message.id, connectionId = message.connectionId, timestamp = message.timestamp;\n                if (firstMessage.extras &&\n                    firstMessage.extras.delta &&\n                    firstMessage.extras.delta.from !== this._lastPayload.messageId) {\n                    var msg = 'Delta message decode failure - previous message not available for message \"' +\n                        message.id +\n                        '\" on this channel \"' +\n                        this.name +\n                        '\".';\n                    logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel.onMessage()', msg);\n                    this._startDecodeFailureRecovery(new errorinfo_1.default(msg, 40018, 400));\n                    break;\n                }\n                for (var i = 0; i < messages.length; i++) {\n                    var msg = messages[i];\n                    try {\n                        message_1.default.decode(msg, this._decodingContext);\n                    }\n                    catch (e) {\n                        /* decrypt failed .. the most likely cause is that we have the wrong key */\n                        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel.onMessage()', e.toString());\n                        switch (e.code) {\n                            case 40018:\n                                /* decode failure */\n                                this._startDecodeFailureRecovery(e);\n                                return;\n                            case 40019:\n                            /* No vcdiff plugin passed in - no point recovering, give up */\n                            // eslint-disable-next-line no-fallthrough\n                            case 40021:\n                                /* Browser does not support deltas, similarly no point recovering */\n                                this.notifyState('failed', e);\n                                return;\n                        }\n                    }\n                    if (!msg.connectionId)\n                        msg.connectionId = connectionId;\n                    if (!msg.timestamp)\n                        msg.timestamp = timestamp;\n                    if (!msg.id)\n                        msg.id = id + ':' + i;\n                }\n                this._lastPayload.messageId = lastMessage.id;\n                this._lastPayload.protocolMessageChannelSerial = message.channelSerial;\n                this.onEvent(messages);\n                break;\n            }\n            case actions.ERROR: {\n                /* there was a channel-specific error */\n                var err = message.error;\n                if (err && err.code == 80016) {\n                    /* attach/detach operation attempted on superseded transport handle */\n                    this.checkPendingState();\n                }\n                else {\n                    this.notifyState('failed', errorinfo_1.default.fromValues(err));\n                }\n                break;\n            }\n            default:\n                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimeChannel.onMessage()', 'Fatal protocol error: unrecognised action (' + message.action + ')');\n                this.connectionManager.abort(connectionerrors_1.default.unknownChannelErr());\n        }\n    };\n    RealtimeChannel.prototype._startDecodeFailureRecovery = function (reason) {\n        var _this = this;\n        if (!this._lastPayload.decodeFailureRecoveryInProgress) {\n            logger_1.default.logAction(logger_1.default.LOG_MAJOR, 'RealtimeChannel.onMessage()', 'Starting decode failure recovery process.');\n            this._lastPayload.decodeFailureRecoveryInProgress = true;\n            this._attach(true, reason, function () {\n                _this._lastPayload.decodeFailureRecoveryInProgress = false;\n            });\n        }\n    };\n    RealtimeChannel.prototype.onAttached = function () {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.onAttached', 'activating channel; name = ' + this.name);\n    };\n    RealtimeChannel.prototype.notifyState = function (state, reason, resumed, hasPresence, hasBacklog) {\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.notifyState', 'name = ' + this.name + ', current state = ' + this.state + ', notifying state ' + state);\n        this.clearStateTimer();\n        // RTP5a1\n        if (Utils.arrIn(['detached', 'suspended', 'failed'], state)) {\n            this.properties.channelSerial = null;\n        }\n        if (state === this.state) {\n            return;\n        }\n        this.presence.actOnChannelState(state, hasPresence, reason);\n        if (state === 'suspended' && this.connectionManager.state.sendEvents) {\n            this.startRetryTimer();\n        }\n        else {\n            this.cancelRetryTimer();\n        }\n        if (reason) {\n            this.errorReason = reason;\n        }\n        var change = new channelstatechange_1.default(this.state, state, resumed, hasBacklog, reason);\n        var logLevel = state === 'failed' ? logger_1.default.LOG_ERROR : logger_1.default.LOG_MAJOR;\n        logger_1.default.logAction(logLevel, 'Channel state for channel \"' + this.name + '\"', state + (reason ? '; reason: ' + reason : ''));\n        if (state !== 'attaching' && state !== 'suspended') {\n            this.retryCount = 0;\n        }\n        /* Note: we don't set inProgress for pending states until the request is actually in progress */\n        if (state === 'attached') {\n            this.onAttached();\n        }\n        if (state === 'attached') {\n            this._attachResume = true;\n        }\n        else if (state === 'detaching' || state === 'failed') {\n            this._attachResume = false;\n        }\n        this.state = state;\n        this._allChannelChanges.emit(state, change);\n        this.emit(state, change);\n    };\n    RealtimeChannel.prototype.requestState = function (state, reason) {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.requestState', 'name = ' + this.name + ', state = ' + state);\n        this.notifyState(state, reason);\n        /* send the event and await response */\n        this.checkPendingState();\n    };\n    RealtimeChannel.prototype.checkPendingState = function () {\n        /* if can't send events, do nothing */\n        var cmState = this.connectionManager.state;\n        /* Allow attach messages to queue up when synchronizing, since this will be\n         * the state we'll be in when upgrade transport.active triggers a checkpendingstate */\n        if (!(cmState.sendEvents || cmState.forceQueueEvents)) {\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.checkPendingState', 'sendEvents is false; state is ' + this.connectionManager.state.state);\n            return;\n        }\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.checkPendingState', 'name = ' + this.name + ', state = ' + this.state);\n        /* Only start the state timer running when actually sending the event */\n        switch (this.state) {\n            case 'attaching':\n                this.startStateTimerIfNotRunning();\n                this.attachImpl();\n                break;\n            case 'detaching':\n                this.startStateTimerIfNotRunning();\n                this.detachImpl();\n                break;\n            case 'attached':\n                /* resume any sync operation that was in progress */\n                this.sync();\n                break;\n            default:\n                break;\n        }\n    };\n    RealtimeChannel.prototype.timeoutPendingState = function () {\n        switch (this.state) {\n            case 'attaching': {\n                var err = new errorinfo_1.default('Channel attach timed out', 90007, 408);\n                this.notifyState('suspended', err);\n                break;\n            }\n            case 'detaching': {\n                var err = new errorinfo_1.default('Channel detach timed out', 90007, 408);\n                this.notifyState('attached', err);\n                break;\n            }\n            default:\n                this.checkPendingState();\n                break;\n        }\n    };\n    RealtimeChannel.prototype.startStateTimerIfNotRunning = function () {\n        var _this = this;\n        if (!this.stateTimer) {\n            this.stateTimer = setTimeout(function () {\n                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.startStateTimerIfNotRunning', 'timer expired');\n                _this.stateTimer = null;\n                _this.timeoutPendingState();\n            }, this.realtime.options.timeouts.realtimeRequestTimeout);\n        }\n    };\n    RealtimeChannel.prototype.clearStateTimer = function () {\n        var stateTimer = this.stateTimer;\n        if (stateTimer) {\n            clearTimeout(stateTimer);\n            this.stateTimer = null;\n        }\n    };\n    RealtimeChannel.prototype.startRetryTimer = function () {\n        var _this = this;\n        if (this.retryTimer)\n            return;\n        this.retryCount++;\n        var retryDelay = Utils.getRetryTime(this.realtime.options.timeouts.channelRetryTimeout, this.retryCount);\n        this.retryTimer = setTimeout(function () {\n            /* If connection is not connected, just leave in suspended, a reattach\n             * will be triggered once it connects again */\n            if (_this.state === 'suspended' && _this.connectionManager.state.sendEvents) {\n                _this.retryTimer = null;\n                logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel retry timer expired', 'attempting a new attach');\n                _this.requestState('attaching');\n            }\n        }, retryDelay);\n    };\n    RealtimeChannel.prototype.cancelRetryTimer = function () {\n        if (this.retryTimer) {\n            clearTimeout(this.retryTimer);\n            this.retryTimer = null;\n        }\n    };\n    /* @returns null (if can safely be released) | ErrorInfo (if cannot) */\n    RealtimeChannel.prototype.getReleaseErr = function () {\n        var s = this.state;\n        if (s === 'initialized' || s === 'detached' || s === 'failed') {\n            return null;\n        }\n        return new errorinfo_1.default('Can only release a channel in a state where there is no possibility of further updates from the server being received (initialized, detached, or failed); was ' +\n            s, 90001, 400);\n    };\n    RealtimeChannel.prototype.setChannelSerial = function (channelSerial) {\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimeChannel.setChannelSerial()', 'Updating channel serial; serial = ' + channelSerial + '; previous = ' + this.properties.channelSerial);\n        // RTP17h: Only update the channel serial if its present (it won't always\n        // be set).\n        if (channelSerial) {\n            this.properties.channelSerial = channelSerial;\n        }\n    };\n    return RealtimeChannel;\n}(channel_1.default));\nfunction omitAgent(channelParams) {\n    var _a = channelParams || {}, _ = _a.agent, paramsWithoutAgent = tslib_1.__rest(_a, [\"agent\"]);\n    return paramsWithoutAgent;\n}\nexports.default = RealtimeChannel;\n\n\n/***/ }),\n/* 39 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar ChannelStateChange = /** @class */ (function () {\n    function ChannelStateChange(previous, current, resumed, hasBacklog, reason) {\n        this.previous = previous;\n        this.current = current;\n        if (current === 'attached') {\n            this.resumed = resumed;\n            this.hasBacklog = hasBacklog;\n        }\n        if (reason)\n            this.reason = reason;\n    }\n    return ChannelStateChange;\n}());\nexports.default = ChannelStateChange;\n\n\n/***/ }),\n/* 40 */\n/***/ (function(module, exports, __nested_webpack_require_438599__) {\n\n;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__nested_webpack_require_438599__(6));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Reusable object\n\t    var W = [];\n\n\t    /**\n\t     * SHA-1 hash algorithm.\n\t     */\n\t    var SHA1 = C_algo.SHA1 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init([\n\t                0x67452301, 0xefcdab89,\n\t                0x98badcfe, 0x10325476,\n\t                0xc3d2e1f0\n\t            ]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Shortcut\n\t            var H = this._hash.words;\n\n\t            // Working variables\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\t            var e = H[4];\n\n\t            // Computation\n\t            for (var i = 0; i < 80; i++) {\n\t                if (i < 16) {\n\t                    W[i] = M[offset + i] | 0;\n\t                } else {\n\t                    var n = W[i - 3] ^ W[i - 8] ^ W[i - 14] ^ W[i - 16];\n\t                    W[i] = (n << 1) | (n >>> 31);\n\t                }\n\n\t                var t = ((a << 5) | (a >>> 27)) + e + W[i];\n\t                if (i < 20) {\n\t                    t += ((b & c) | (~b & d)) + 0x5a827999;\n\t                } else if (i < 40) {\n\t                    t += (b ^ c ^ d) + 0x6ed9eba1;\n\t                } else if (i < 60) {\n\t                    t += ((b & c) | (b & d) | (c & d)) - 0x70e44324;\n\t                } else /* if (i < 80) */ {\n\t                    t += (b ^ c ^ d) - 0x359d3e2a;\n\t                }\n\n\t                e = d;\n\t                d = c;\n\t                c = (b << 30) | (b >>> 2);\n\t                b = a;\n\t                a = t;\n\t            }\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t            H[4] = (H[4] + e) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = Math.floor(nBitsTotal / 0x100000000);\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = nBitsTotal;\n\t            data.sigBytes = dataWords.length * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Return final computed hash\n\t            return this._hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.SHA1('message');\n\t     *     var hash = CryptoJS.SHA1(wordArray);\n\t     */\n\t    C.SHA1 = Hasher._createHelper(SHA1);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacSHA1(message, key);\n\t     */\n\t    C.HmacSHA1 = Hasher._createHmacHelper(SHA1);\n\t}());\n\n\n\treturn CryptoJS.SHA1;\n\n}));\n\n/***/ }),\n/* 41 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nfunction inspect(buffer) {\n    if (buffer === undefined)\n        return 'undefined';\n    var view;\n    var type;\n    if (buffer instanceof ArrayBuffer) {\n        type = 'ArrayBuffer';\n        view = new DataView(buffer);\n    }\n    else if (buffer instanceof DataView) {\n        type = 'DataView';\n        view = buffer;\n    }\n    if (!view)\n        return JSON.stringify(buffer);\n    var bytes = [];\n    for (var i = 0; i < buffer.byteLength; i++) {\n        if (i > 20) {\n            bytes.push('...');\n            break;\n        }\n        var byte_ = view.getUint8(i).toString(16);\n        if (byte_.length === 1)\n            byte_ = '0' + byte_;\n        bytes.push(byte_);\n    }\n    return '<' + type + ' ' + bytes.join(' ') + '>';\n}\n// Encode string as utf8 into dataview at offset\nfunction utf8Write(view, offset, string) {\n    for (var i = 0, l = string.length; i < l; i++) {\n        var codePoint = string.charCodeAt(i);\n        // One byte of UTF-8\n        if (codePoint < 0x80) {\n            view.setUint8(offset++, ((codePoint >>> 0) & 0x7f) | 0x00);\n            continue;\n        }\n        // Two bytes of UTF-8\n        if (codePoint < 0x800) {\n            view.setUint8(offset++, ((codePoint >>> 6) & 0x1f) | 0xc0);\n            view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);\n            continue;\n        }\n        // Three bytes of UTF-8.\n        if (codePoint < 0x10000) {\n            view.setUint8(offset++, ((codePoint >>> 12) & 0x0f) | 0xe0);\n            view.setUint8(offset++, ((codePoint >>> 6) & 0x3f) | 0x80);\n            view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);\n            continue;\n        }\n        // Four bytes of UTF-8\n        if (codePoint < 0x110000) {\n            view.setUint8(offset++, ((codePoint >>> 18) & 0x07) | 0xf0);\n            view.setUint8(offset++, ((codePoint >>> 12) & 0x3f) | 0x80);\n            view.setUint8(offset++, ((codePoint >>> 6) & 0x3f) | 0x80);\n            view.setUint8(offset++, ((codePoint >>> 0) & 0x3f) | 0x80);\n            continue;\n        }\n        throw new Error('bad codepoint ' + codePoint);\n    }\n}\nfunction utf8Read(view, offset, length) {\n    var string = '';\n    for (var i = offset, end = offset + length; i < end; i++) {\n        var byte_ = view.getUint8(i);\n        // One byte character\n        if ((byte_ & 0x80) === 0x00) {\n            string += String.fromCharCode(byte_);\n            continue;\n        }\n        // Two byte character\n        if ((byte_ & 0xe0) === 0xc0) {\n            string += String.fromCharCode(((byte_ & 0x0f) << 6) | (view.getUint8(++i) & 0x3f));\n            continue;\n        }\n        // Three byte character\n        if ((byte_ & 0xf0) === 0xe0) {\n            string += String.fromCharCode(((byte_ & 0x0f) << 12) | ((view.getUint8(++i) & 0x3f) << 6) | ((view.getUint8(++i) & 0x3f) << 0));\n            continue;\n        }\n        // Four byte character\n        if ((byte_ & 0xf8) === 0xf0) {\n            string += String.fromCharCode(((byte_ & 0x07) << 18) |\n                ((view.getUint8(++i) & 0x3f) << 12) |\n                ((view.getUint8(++i) & 0x3f) << 6) |\n                ((view.getUint8(++i) & 0x3f) << 0));\n            continue;\n        }\n        throw new Error('Invalid byte ' + byte_.toString(16));\n    }\n    return string;\n}\nfunction utf8ByteCount(string) {\n    var count = 0;\n    for (var i = 0, l = string.length; i < l; i++) {\n        var codePoint = string.charCodeAt(i);\n        if (codePoint < 0x80) {\n            count += 1;\n            continue;\n        }\n        if (codePoint < 0x800) {\n            count += 2;\n            continue;\n        }\n        if (codePoint < 0x10000) {\n            count += 3;\n            continue;\n        }\n        if (codePoint < 0x110000) {\n            count += 4;\n            continue;\n        }\n        throw new Error('bad codepoint ' + codePoint);\n    }\n    return count;\n}\nfunction encode(value, sparse) {\n    var size = sizeof(value, sparse);\n    if (size === 0)\n        return undefined;\n    var buffer = new ArrayBuffer(size);\n    var view = new DataView(buffer);\n    _encode(value, view, 0, sparse);\n    return buffer;\n}\nvar SH_L_32 = (1 << 16) * (1 << 16), SH_R_32 = 1 / SH_L_32;\nfunction getInt64(view, offset) {\n    offset = offset || 0;\n    return view.getInt32(offset) * SH_L_32 + view.getUint32(offset + 4);\n}\nfunction getUint64(view, offset) {\n    offset = offset || 0;\n    return view.getUint32(offset) * SH_L_32 + view.getUint32(offset + 4);\n}\nfunction setInt64(view, offset, val) {\n    if (val < 0x8000000000000000) {\n        view.setInt32(offset, Math.floor(val * SH_R_32));\n        view.setInt32(offset + 4, val & -1);\n    }\n    else {\n        view.setUint32(offset, 0x7fffffff);\n        view.setUint32(offset + 4, 0x7fffffff);\n    }\n}\nfunction setUint64(view, offset, val) {\n    if (val < 0x10000000000000000) {\n        view.setUint32(offset, Math.floor(val * SH_R_32));\n        view.setInt32(offset + 4, val & -1);\n    }\n    else {\n        view.setUint32(offset, 0xffffffff);\n        view.setUint32(offset + 4, 0xffffffff);\n    }\n}\n// https://gist.github.com/frsyuki/5432559 - v5 spec\n//\n// I've used one extension point from `fixext 1` to store `undefined`. On the wire this\n// should translate to exactly 0xd40000\n//\n// +--------+--------+--------+\n// |  0xd4  |  0x00  |  0x00  |\n// +--------+--------+--------+\n//    ^ fixext |        ^ value part unused (fixed to be 0)\n//             ^ indicates undefined value\n//\nvar Decoder = /** @class */ (function () {\n    function Decoder(view, offset) {\n        var _this = this;\n        this.map = function (length) {\n            var value = {};\n            for (var i = 0; i < length; i++) {\n                var key = _this.parse();\n                value[key] = _this.parse();\n            }\n            return value;\n        };\n        this.bin = function (length) {\n            var value = new ArrayBuffer(length);\n            new Uint8Array(value).set(new Uint8Array(_this.view.buffer, _this.offset, length), 0);\n            _this.offset += length;\n            return value;\n        };\n        this.buf = this.bin;\n        this.str = function (length) {\n            var value = utf8Read(_this.view, _this.offset, length);\n            _this.offset += length;\n            return value;\n        };\n        this.array = function (length) {\n            var value = new Array(length);\n            for (var i = 0; i < length; i++) {\n                value[i] = _this.parse();\n            }\n            return value;\n        };\n        this.ext = function (length) {\n            _this.offset += length;\n            return {\n                type: _this.view.getInt8(_this.offset),\n                data: _this.buf(length),\n            };\n        };\n        this.parse = function () {\n            var type = _this.view.getUint8(_this.offset);\n            var value, length;\n            // Positive FixInt - 0xxxxxxx\n            if ((type & 0x80) === 0x00) {\n                _this.offset++;\n                return type;\n            }\n            // FixMap - 1000xxxx\n            if ((type & 0xf0) === 0x80) {\n                length = type & 0x0f;\n                _this.offset++;\n                return _this.map(length);\n            }\n            // FixArray - 1001xxxx\n            if ((type & 0xf0) === 0x90) {\n                length = type & 0x0f;\n                _this.offset++;\n                return _this.array(length);\n            }\n            // FixStr - 101xxxxx\n            if ((type & 0xe0) === 0xa0) {\n                length = type & 0x1f;\n                _this.offset++;\n                return _this.str(length);\n            }\n            // Negative FixInt - 111xxxxx\n            if ((type & 0xe0) === 0xe0) {\n                value = _this.view.getInt8(_this.offset);\n                _this.offset++;\n                return value;\n            }\n            switch (type) {\n                // nil\n                case 0xc0:\n                    _this.offset++;\n                    return null;\n                // 0xc1 never used - use for undefined (NON-STANDARD)\n                case 0xc1:\n                    _this.offset++;\n                    return undefined;\n                // false\n                case 0xc2:\n                    _this.offset++;\n                    return false;\n                // true\n                case 0xc3:\n                    _this.offset++;\n                    return true;\n                // bin 8\n                case 0xc4:\n                    length = _this.view.getUint8(_this.offset + 1);\n                    _this.offset += 2;\n                    return _this.bin(length);\n                // bin 16\n                case 0xc5:\n                    length = _this.view.getUint16(_this.offset + 1);\n                    _this.offset += 3;\n                    return _this.bin(length);\n                // bin 32\n                case 0xc6:\n                    length = _this.view.getUint32(_this.offset + 1);\n                    _this.offset += 5;\n                    return _this.bin(length);\n                // ext 8\n                case 0xc7:\n                    length = _this.view.getUint8(_this.offset + 1);\n                    _this.offset += 2;\n                    return _this.ext(length);\n                // ext 16\n                case 0xc8:\n                    length = _this.view.getUint16(_this.offset + 1);\n                    _this.offset += 3;\n                    return _this.ext(length);\n                // ext 32\n                case 0xc9:\n                    length = _this.view.getUint32(_this.offset + 1);\n                    _this.offset += 5;\n                    return _this.ext(length);\n                // float 32\n                case 0xca:\n                    value = _this.view.getFloat32(_this.offset + 1);\n                    _this.offset += 5;\n                    return value;\n                // float 64\n                case 0xcb:\n                    value = _this.view.getFloat64(_this.offset + 1);\n                    _this.offset += 9;\n                    return value;\n                // uint8\n                case 0xcc:\n                    value = _this.view.getUint8(_this.offset + 1);\n                    _this.offset += 2;\n                    return value;\n                // uint 16\n                case 0xcd:\n                    value = _this.view.getUint16(_this.offset + 1);\n                    _this.offset += 3;\n                    return value;\n                // uint 32\n                case 0xce:\n                    value = _this.view.getUint32(_this.offset + 1);\n                    _this.offset += 5;\n                    return value;\n                // uint 64\n                case 0xcf:\n                    value = getUint64(_this.view, _this.offset + 1);\n                    _this.offset += 9;\n                    return value;\n                // int 8\n                case 0xd0:\n                    value = _this.view.getInt8(_this.offset + 1);\n                    _this.offset += 2;\n                    return value;\n                // int 16\n                case 0xd1:\n                    value = _this.view.getInt16(_this.offset + 1);\n                    _this.offset += 3;\n                    return value;\n                // int 32\n                case 0xd2:\n                    value = _this.view.getInt32(_this.offset + 1);\n                    _this.offset += 5;\n                    return value;\n                // int 64\n                case 0xd3:\n                    value = getInt64(_this.view, _this.offset + 1);\n                    _this.offset += 9;\n                    return value;\n                // fixext 1\n                case 0xd4:\n                    length = 1;\n                    _this.offset++;\n                    return _this.ext(length);\n                // fixext 2\n                case 0xd5:\n                    length = 2;\n                    _this.offset++;\n                    return _this.ext(length);\n                // fixext 4\n                case 0xd6:\n                    length = 4;\n                    _this.offset++;\n                    return _this.ext(length);\n                // fixext 8\n                case 0xd7:\n                    length = 8;\n                    _this.offset++;\n                    return _this.ext(length);\n                // fixext 16\n                case 0xd8:\n                    length = 16;\n                    _this.offset++;\n                    return _this.ext(length);\n                // str8\n                case 0xd9:\n                    length = _this.view.getUint8(_this.offset + 1);\n                    _this.offset += 2;\n                    return _this.str(length);\n                // str 16\n                case 0xda:\n                    length = _this.view.getUint16(_this.offset + 1);\n                    _this.offset += 3;\n                    return _this.str(length);\n                // str 32\n                case 0xdb:\n                    length = _this.view.getUint32(_this.offset + 1);\n                    _this.offset += 5;\n                    return _this.str(length);\n                // array 16\n                case 0xdc:\n                    length = _this.view.getUint16(_this.offset + 1);\n                    _this.offset += 3;\n                    return _this.array(length);\n                // array 32\n                case 0xdd:\n                    length = _this.view.getUint32(_this.offset + 1);\n                    _this.offset += 5;\n                    return _this.array(length);\n                // map 16\n                case 0xde:\n                    length = _this.view.getUint16(_this.offset + 1);\n                    _this.offset += 3;\n                    return _this.map(length);\n                // map 32\n                case 0xdf:\n                    length = _this.view.getUint32(_this.offset + 1);\n                    _this.offset += 5;\n                    return _this.map(length);\n            }\n            throw new Error('Unknown type 0x' + type.toString(16));\n        };\n        this.offset = offset || 0;\n        this.view = view;\n    }\n    return Decoder;\n}());\nfunction decode(buffer) {\n    var view = new DataView(buffer);\n    var decoder = new Decoder(view);\n    var value = decoder.parse();\n    if (decoder.offset !== buffer.byteLength)\n        throw new Error(buffer.byteLength - decoder.offset + ' trailing bytes');\n    return value;\n}\nfunction encodeableKeys(value, sparse) {\n    return Object.keys(value).filter(function (e) {\n        var val = value[e], type = typeof val;\n        return (!sparse || (val !== undefined && val !== null)) && ('function' !== type || !!val.toJSON);\n    });\n}\nfunction _encode(value, view, offset, sparse) {\n    var type = typeof value;\n    // Strings Bytes\n    // There are four string types: fixstr/str8/str16/str32\n    if (typeof value === 'string') {\n        var length_1 = utf8ByteCount(value);\n        // fixstr\n        if (length_1 < 0x20) {\n            view.setUint8(offset, length_1 | 0xa0);\n            utf8Write(view, offset + 1, value);\n            return 1 + length_1;\n        }\n        // str8\n        if (length_1 < 0x100) {\n            view.setUint8(offset, 0xd9);\n            view.setUint8(offset + 1, length_1);\n            utf8Write(view, offset + 2, value);\n            return 2 + length_1;\n        }\n        // str16\n        if (length_1 < 0x10000) {\n            view.setUint8(offset, 0xda);\n            view.setUint16(offset + 1, length_1);\n            utf8Write(view, offset + 3, value);\n            return 3 + length_1;\n        }\n        // str32\n        if (length_1 < 0x100000000) {\n            view.setUint8(offset, 0xdb);\n            view.setUint32(offset + 1, length_1);\n            utf8Write(view, offset + 5, value);\n            return 5 + length_1;\n        }\n    }\n    if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {\n        // extract the arraybuffer and fallthrough\n        value = value.buffer;\n    }\n    // There are three bin types: bin8/bin16/bin32\n    if (value instanceof ArrayBuffer) {\n        var length_2 = value.byteLength;\n        // bin8\n        if (length_2 < 0x100) {\n            view.setUint8(offset, 0xc4);\n            view.setUint8(offset + 1, length_2);\n            new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 2);\n            return 2 + length_2;\n        }\n        // bin16\n        if (length_2 < 0x10000) {\n            view.setUint8(offset, 0xc5);\n            view.setUint16(offset + 1, length_2);\n            new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 3);\n            return 3 + length_2;\n        }\n        // bin 32\n        if (length_2 < 0x100000000) {\n            view.setUint8(offset, 0xc6);\n            view.setUint32(offset + 1, length_2);\n            new Uint8Array(view.buffer).set(new Uint8Array(value), offset + 5);\n            return 5 + length_2;\n        }\n    }\n    if (typeof value === 'number') {\n        // Floating Point\n        // NOTE: We're always using float64\n        if (Math.floor(value) !== value) {\n            view.setUint8(offset, 0xcb);\n            view.setFloat64(offset + 1, value);\n            return 9;\n        }\n        // Integers\n        if (value >= 0) {\n            // positive fixnum\n            if (value < 0x80) {\n                view.setUint8(offset, value);\n                return 1;\n            }\n            // uint 8\n            if (value < 0x100) {\n                view.setUint8(offset, 0xcc);\n                view.setUint8(offset + 1, value);\n                return 2;\n            }\n            // uint 16\n            if (value < 0x10000) {\n                view.setUint8(offset, 0xcd);\n                view.setUint16(offset + 1, value);\n                return 3;\n            }\n            // uint 32\n            if (value < 0x100000000) {\n                view.setUint8(offset, 0xce);\n                view.setUint32(offset + 1, value);\n                return 5;\n            }\n            // uint 64\n            if (value < 0x10000000000000000) {\n                view.setUint8(offset, 0xcf);\n                setUint64(view, offset + 1, value);\n                return 9;\n            }\n            throw new Error('Number too big 0x' + value.toString(16));\n        }\n        // negative fixnum\n        if (value >= -0x20) {\n            view.setInt8(offset, value);\n            return 1;\n        }\n        // int 8\n        if (value >= -0x80) {\n            view.setUint8(offset, 0xd0);\n            view.setInt8(offset + 1, value);\n            return 2;\n        }\n        // int 16\n        if (value >= -0x8000) {\n            view.setUint8(offset, 0xd1);\n            view.setInt16(offset + 1, value);\n            return 3;\n        }\n        // int 32\n        if (value >= -0x80000000) {\n            view.setUint8(offset, 0xd2);\n            view.setInt32(offset + 1, value);\n            return 5;\n        }\n        // int 64\n        if (value >= -0x8000000000000000) {\n            view.setUint8(offset, 0xd3);\n            setInt64(view, offset + 1, value);\n            return 9;\n        }\n        throw new Error('Number too small -0x' + (-value).toString(16).substr(1));\n    }\n    // undefined - use d4 (NON-STANDARD)\n    if (type === 'undefined') {\n        if (sparse)\n            return 0;\n        view.setUint8(offset, 0xd4);\n        view.setUint8(offset + 1, 0x00);\n        view.setUint8(offset + 2, 0x00);\n        return 3;\n    }\n    // null\n    if (value === null) {\n        if (sparse)\n            return 0;\n        view.setUint8(offset, 0xc0);\n        return 1;\n    }\n    // Boolean\n    if (type === 'boolean') {\n        view.setUint8(offset, value ? 0xc3 : 0xc2);\n        return 1;\n    }\n    if ('function' === typeof value.toJSON)\n        return _encode(value.toJSON(), view, offset, sparse);\n    // Container Types\n    if (type === 'object') {\n        var length_3, size = 0;\n        var keys = void 0;\n        var isArray = Array.isArray(value);\n        if (isArray) {\n            length_3 = value.length;\n        }\n        else {\n            keys = encodeableKeys(value, sparse);\n            length_3 = keys.length;\n        }\n        if (length_3 < 0x10) {\n            view.setUint8(offset, length_3 | (isArray ? 0x90 : 0x80));\n            size = 1;\n        }\n        else if (length_3 < 0x10000) {\n            view.setUint8(offset, isArray ? 0xdc : 0xde);\n            view.setUint16(offset + 1, length_3);\n            size = 3;\n        }\n        else if (length_3 < 0x100000000) {\n            view.setUint8(offset, isArray ? 0xdd : 0xdf);\n            view.setUint32(offset + 1, length_3);\n            size = 5;\n        }\n        if (isArray) {\n            for (var i = 0; i < length_3; i++) {\n                size += _encode(value[i], view, offset + size, sparse);\n            }\n        }\n        else if (keys) {\n            for (var i = 0; i < length_3; i++) {\n                var key = keys[i];\n                size += _encode(key, view, offset + size);\n                size += _encode(value[key], view, offset + size, sparse);\n            }\n        }\n        return size;\n    }\n    if (type === 'function')\n        return 0;\n    throw new Error('Unknown type ' + type);\n}\nfunction sizeof(value, sparse) {\n    var type = typeof value;\n    // fixstr or str8 or str16 or str32\n    if (type === 'string') {\n        var length_4 = utf8ByteCount(value);\n        if (length_4 < 0x20) {\n            return 1 + length_4;\n        }\n        if (length_4 < 0x100) {\n            return 2 + length_4;\n        }\n        if (length_4 < 0x10000) {\n            return 3 + length_4;\n        }\n        if (length_4 < 0x100000000) {\n            return 5 + length_4;\n        }\n    }\n    if (ArrayBuffer.isView && ArrayBuffer.isView(value)) {\n        // extract the arraybuffer and fallthrough\n        value = value.buffer;\n    }\n    // bin8 or bin16 or bin32\n    if (value instanceof ArrayBuffer) {\n        var length_5 = value.byteLength;\n        if (length_5 < 0x100) {\n            return 2 + length_5;\n        }\n        if (length_5 < 0x10000) {\n            return 3 + length_5;\n        }\n        if (length_5 < 0x100000000) {\n            return 5 + length_5;\n        }\n    }\n    if (typeof value === 'number') {\n        // Floating Point (32 bits)\n        // double\n        if (Math.floor(value) !== value)\n            return 9;\n        // Integers\n        if (value >= 0) {\n            // positive fixint\n            if (value < 0x80)\n                return 1;\n            // uint 8\n            if (value < 0x100)\n                return 2;\n            // uint 16\n            if (value < 0x10000)\n                return 3;\n            // uint 32\n            if (value < 0x100000000)\n                return 5;\n            // uint 64\n            if (value < 0x10000000000000000)\n                return 9;\n            // Too big\n            throw new Error('Number too big 0x' + value.toString(16));\n        }\n        // negative fixint\n        if (value >= -0x20)\n            return 1;\n        // int 8\n        if (value >= -0x80)\n            return 2;\n        // int 16\n        if (value >= -0x8000)\n            return 3;\n        // int 32\n        if (value >= -0x80000000)\n            return 5;\n        // int 64\n        if (value >= -0x8000000000000000)\n            return 9;\n        // Too small\n        throw new Error('Number too small -0x' + value.toString(16).substr(1));\n    }\n    // Boolean\n    if (type === 'boolean')\n        return 1;\n    // undefined, null\n    if (value === null)\n        return sparse ? 0 : 1;\n    if (value === undefined)\n        return sparse ? 0 : 3;\n    if ('function' === typeof value.toJSON)\n        return sizeof(value.toJSON(), sparse);\n    // Container Types\n    if (type === 'object') {\n        var length_6, size = 0;\n        if (Array.isArray(value)) {\n            length_6 = value.length;\n            for (var i = 0; i < length_6; i++) {\n                size += sizeof(value[i], sparse);\n            }\n        }\n        else {\n            var keys = encodeableKeys(value, sparse);\n            length_6 = keys.length;\n            for (var i = 0; i < length_6; i++) {\n                var key = keys[i];\n                size += sizeof(key) + sizeof(value[key], sparse);\n            }\n        }\n        if (length_6 < 0x10) {\n            return 1 + size;\n        }\n        if (length_6 < 0x10000) {\n            return 3 + size;\n        }\n        if (length_6 < 0x100000000) {\n            return 5 + size;\n        }\n        throw new Error('Array or object too long 0x' + length_6.toString(16));\n    }\n    if (type === 'function')\n        return 0;\n    throw new Error('Unknown type ' + type);\n}\nexports.default = {\n    encode: encode,\n    decode: decode,\n    inspect: inspect,\n    utf8Write: utf8Write,\n    utf8Read: utf8Read,\n    utf8ByteCount: utf8ByteCount,\n};\n\n\n/***/ }),\n/* 42 */\n/***/ (function(module, exports, __nested_webpack_require_467389__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_467389__(0);\n// Common\nvar rest_1 = tslib_1.__importDefault(__nested_webpack_require_467389__(30));\nvar realtime_1 = tslib_1.__importDefault(__nested_webpack_require_467389__(50));\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_467389__(3));\nvar errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_467389__(4));\n// Platform Specific\nvar bufferutils_1 = tslib_1.__importDefault(__nested_webpack_require_467389__(55));\n// @ts-ignore\nvar crypto_1 = tslib_1.__importDefault(__nested_webpack_require_467389__(57));\nvar http_1 = tslib_1.__importDefault(__nested_webpack_require_467389__(62));\nvar config_1 = tslib_1.__importDefault(__nested_webpack_require_467389__(64));\n// @ts-ignore\nvar transport_1 = tslib_1.__importDefault(__nested_webpack_require_467389__(68));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_467389__(2));\nvar defaults_1 = __nested_webpack_require_467389__(8);\nvar webstorage_1 = tslib_1.__importDefault(__nested_webpack_require_467389__(65));\nvar defaults_2 = tslib_1.__importDefault(__nested_webpack_require_467389__(66));\nvar msgpack_1 = tslib_1.__importDefault(__nested_webpack_require_467389__(41));\nvar Crypto = (0, crypto_1.default)(config_1.default, bufferutils_1.default);\nplatform_1.default.Crypto = Crypto;\nplatform_1.default.BufferUtils = bufferutils_1.default;\nplatform_1.default.Http = http_1.default;\nplatform_1.default.Config = config_1.default;\nplatform_1.default.Transports = transport_1.default;\nplatform_1.default.WebStorage = webstorage_1.default;\nrest_1.default.Crypto = Crypto;\nrealtime_1.default.Crypto = Crypto;\nlogger_1.default.initLogHandlers();\nplatform_1.default.Defaults = (0, defaults_1.getDefaults)(defaults_2.default);\nif (platform_1.default.Config.agent) {\n    // @ts-ignore\n    platform_1.default.Defaults.agent += ' ' + platform_1.default.Config.agent;\n}\n/* If using IE8, don't attempt to upgrade from xhr_polling to xhr_streaming -\n * while it can do streaming, the low max http-connections-per-host limit means\n * that the polling transport is crippled during the upgrade process. So just\n * leave it at the base transport */\nif (platform_1.default.Config.noUpgrade) {\n    platform_1.default.Defaults.upgradeTransports = [];\n}\nexports.default = {\n    ErrorInfo: errorinfo_1.default,\n    Rest: rest_1.default,\n    Realtime: realtime_1.default,\n    msgpack: msgpack_1.default,\n};\n\n\n/***/ }),\n/* 43 */\n/***/ (function(module) {\n\nmodule.exports = JSON.parse(\"{\\\"name\\\":\\\"ably\\\",\\\"description\\\":\\\"Realtime client library for Ably, the realtime messaging service\\\",\\\"version\\\":\\\"1.2.49\\\",\\\"license\\\":\\\"Apache-2.0\\\",\\\"bugs\\\":{\\\"url\\\":\\\"https://github.com/ably/ably-js/issues\\\",\\\"email\\\":\\\"support@ably.com\\\"},\\\"main\\\":\\\"./build/ably-node.js\\\",\\\"typings\\\":\\\"./ably.d.ts\\\",\\\"react-native\\\":{\\\"./build/ably-node.js\\\":\\\"./build/ably-reactnative.js\\\"},\\\"browser\\\":{\\\"./build/ably-node.js\\\":\\\"./build/ably-commonjs.js\\\"},\\\"files\\\":[\\\"build/**\\\",\\\"ably.d.ts\\\",\\\"callbacks.d.ts\\\",\\\"callbacks.js\\\",\\\"promises.d.ts\\\",\\\"promises.js\\\",\\\"resources/**\\\",\\\"src/**\\\",\\\"react/**\\\"],\\\"dependencies\\\":{\\\"@ably/msgpack-js\\\":\\\"^0.4.0\\\",\\\"got\\\":\\\"^11.8.5\\\",\\\"ws\\\":\\\"^8.14.2\\\"},\\\"peerDependencies\\\":{\\\"react\\\":\\\">=16.8.0\\\",\\\"react-dom\\\":\\\">=16.8.0\\\"},\\\"peerDependenciesMeta\\\":{\\\"react\\\":{\\\"optional\\\":true},\\\"react-dom\\\":{\\\"optional\\\":true}},\\\"devDependencies\\\":{\\\"@ably/vcdiff-decoder\\\":\\\"1.0.4\\\",\\\"@arethetypeswrong/cli\\\":\\\"^0.13.1\\\",\\\"@babel/preset-env\\\":\\\"^7.23.6\\\",\\\"@testing-library/react\\\":\\\"^13.3.0\\\",\\\"@types/crypto-js\\\":\\\"^4.0.1\\\",\\\"@types/jmespath\\\":\\\"^0.15.2\\\",\\\"@types/node\\\":\\\"^15.0.0\\\",\\\"@types/request\\\":\\\"^2.48.7\\\",\\\"@types/ws\\\":\\\"^8.2.0\\\",\\\"@typescript-eslint/eslint-plugin\\\":\\\"^5.14.0\\\",\\\"@typescript-eslint/parser\\\":\\\"^5.14.0\\\",\\\"@vitejs/plugin-react\\\":\\\"^1.3.2\\\",\\\"async\\\":\\\"ably-forks/async#requirejs\\\",\\\"aws-sdk\\\":\\\"^2.1413.0\\\",\\\"babel-loader\\\":\\\"^8.3.0\\\",\\\"chai\\\":\\\"^4.2.0\\\",\\\"copy-webpack-plugin\\\":\\\"^6.4.1\\\",\\\"cors\\\":\\\"^2.8.5\\\",\\\"crypto-js\\\":\\\"ably-forks/crypto-js#crypto-lite\\\",\\\"eslint\\\":\\\"^7.13.0\\\",\\\"eslint-plugin-import\\\":\\\"^2.28.0\\\",\\\"eslint-plugin-jsdoc\\\":\\\"^40.0.0\\\",\\\"eslint-plugin-react\\\":\\\"^7.32.2\\\",\\\"eslint-plugin-react-hooks\\\":\\\"^4.6.0\\\",\\\"eslint-plugin-security\\\":\\\"^1.4.0\\\",\\\"express\\\":\\\"^4.17.1\\\",\\\"glob\\\":\\\"~4.4\\\",\\\"google-closure-compiler\\\":\\\"^20180610.0.1\\\",\\\"grunt\\\":\\\"^1.6.1\\\",\\\"grunt-bump\\\":\\\"^0.3.1\\\",\\\"grunt-cli\\\":\\\"~1.2.0\\\",\\\"grunt-closure-tools\\\":\\\"^1.0.0\\\",\\\"grunt-contrib-concat\\\":\\\"~0.5\\\",\\\"grunt-shell\\\":\\\"~1.1\\\",\\\"grunt-webpack\\\":\\\"^4.0.2\\\",\\\"hexy\\\":\\\"~0.2\\\",\\\"jmespath\\\":\\\"^0.16.0\\\",\\\"jsdom\\\":\\\"^20.0.0\\\",\\\"kexec\\\":\\\"ably-forks/node-kexec#update-for-node-12\\\",\\\"minimist\\\":\\\"^1.2.5\\\",\\\"mocha\\\":\\\"^8.1.3\\\",\\\"mocha-junit-reporter\\\":\\\"^2.2.1\\\",\\\"null-loader\\\":\\\"^4.0.1\\\",\\\"playwright\\\":\\\"^1.39.0\\\",\\\"prettier\\\":\\\"^2.5.1\\\",\\\"react\\\":\\\">=18.1.0\\\",\\\"react-dom\\\":\\\">=18.1.0\\\",\\\"requirejs\\\":\\\"~2.1\\\",\\\"shelljs\\\":\\\"~0.8\\\",\\\"source-map-explorer\\\":\\\"^2.5.2\\\",\\\"ts-loader\\\":\\\"^8.2.0\\\",\\\"tsconfig-paths-webpack-plugin\\\":\\\"^4.0.1\\\",\\\"tslib\\\":\\\"^2.3.1\\\",\\\"typedoc\\\":\\\"^0.23.8\\\",\\\"typescript\\\":\\\"^4.6.4\\\",\\\"vite\\\":\\\"^4.4.9\\\",\\\"vitest\\\":\\\"^0.18.0\\\",\\\"webpack\\\":\\\"^4.44.2\\\",\\\"webpack-cli\\\":\\\"^4.2.0\\\",\\\"webpack-node-externals\\\":\\\"^3.0.0\\\"},\\\"engines\\\":{\\\"node\\\":\\\">=5.10.x\\\"},\\\"repository\\\":\\\"ably/ably-js\\\",\\\"jspm\\\":{\\\"registry\\\":\\\"npm\\\",\\\"directories\\\":{\\\"lib\\\":\\\"build\\\"},\\\"main\\\":\\\"ably\\\"},\\\"scripts\\\":{\\\"start:react\\\":\\\"npx vite serve\\\",\\\"grunt\\\":\\\"grunt\\\",\\\"test\\\":\\\"grunt test\\\",\\\"test:node\\\":\\\"grunt test:node\\\",\\\"test:node:skip-build\\\":\\\"grunt mocha\\\",\\\"test:webserver\\\":\\\"grunt test:webserver\\\",\\\"test:playwright\\\":\\\"node test/support/runPlaywrightTests.js\\\",\\\"test:react\\\":\\\"vitest run\\\",\\\"concat\\\":\\\"grunt concat\\\",\\\"build\\\":\\\"grunt build:all && npm run build:react\\\",\\\"build:node\\\":\\\"grunt build:node\\\",\\\"build:browser\\\":\\\"grunt build:browser\\\",\\\"build:react\\\":\\\"npm run build:react:mjs && npm run build:react:cjs && cp src/platform/react-hooks/res/package.react.json react/package.json\\\",\\\"build:react:mjs\\\":\\\"tsc --project src/platform/react-hooks/tsconfig.mjs.json && cp src/platform/react-hooks/res/package.mjs.json react/mjs/package.json\\\",\\\"build:react:cjs\\\":\\\"tsc --project src/platform/react-hooks/tsconfig.cjs.json && cp src/platform/react-hooks/res/package.cjs.json react/cjs/package.json\\\",\\\"requirejs\\\":\\\"grunt requirejs\\\",\\\"lint\\\":\\\"eslint .\\\",\\\"lint:fix\\\":\\\"eslint --fix .\\\",\\\"check-closure-compiler\\\":\\\"grunt check-closure-compiler\\\",\\\"prepare\\\":\\\"npm run build\\\",\\\"format\\\":\\\"prettier --write --ignore-path .gitignore --ignore-path .prettierignore src test ably.d.ts webpack.config.js Gruntfile.js scripts/cdn_deploy.js docs/chrome-mv3.md\\\",\\\"format:check\\\":\\\"prettier --check --ignore-path .gitignore --ignore-path .prettierignore src test ably.d.ts webpack.config.js Gruntfile.js scripts/cdn_deploy.js\\\",\\\"sourcemap\\\":\\\"source-map-explorer build/ably.min.js\\\",\\\"sourcemap:noencryption\\\":\\\"source-map-explorer build/ably.noencryption.min.js\\\",\\\"docs\\\":\\\"typedoc --entryPoints ably.d.ts --out docs/generated/default --readme docs/landing-pages/default.md && typedoc --entryPoints promises.d.ts --out docs/generated/promises --name \\\\\\\"ably (Promise-based)\\\\\\\" --readme docs/landing-pages/promises.md && cp docs/landing-pages/choose-library.html docs/generated/index.html\\\"}}\");\n\n/***/ }),\n/* 44 */\n/***/ (function(module, exports) {\n\n\n\n/***/ }),\n/* 45 */\n/***/ (function(module, exports, __nested_webpack_require_474650__) {\n\n;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__nested_webpack_require_474650__(6), __nested_webpack_require_474650__(32), __nested_webpack_require_474650__(24));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\treturn CryptoJS.HmacSHA256;\n\n}));\n\n/***/ }),\n/* 46 */\n/***/ (function(module, exports, __nested_webpack_require_474973__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_474973__(0);\nvar Utils = tslib_1.__importStar(__nested_webpack_require_474973__(1));\nvar devicedetails_1 = tslib_1.__importDefault(__nested_webpack_require_474973__(47));\nvar resource_1 = tslib_1.__importDefault(__nested_webpack_require_474973__(14));\nvar paginatedresource_1 = tslib_1.__importDefault(__nested_webpack_require_474973__(19));\nvar errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_474973__(4));\nvar pushchannelsubscription_1 = tslib_1.__importDefault(__nested_webpack_require_474973__(48));\nvar noop = function () { };\nvar Push = /** @class */ (function () {\n    function Push(rest) {\n        this.rest = rest;\n        this.admin = new Admin(rest);\n    }\n    return Push;\n}());\nvar Admin = /** @class */ (function () {\n    function Admin(rest) {\n        this.rest = rest;\n        this.deviceRegistrations = new DeviceRegistrations(rest);\n        this.channelSubscriptions = new ChannelSubscriptions(rest);\n    }\n    Admin.prototype.publish = function (recipient, payload, callback) {\n        var rest = this.rest;\n        var format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(rest.options, format), params = {};\n        var body = Utils.mixin({ recipient: recipient }, payload);\n        if (typeof callback !== 'function') {\n            if (this.rest.options.promises) {\n                return Utils.promisify(this, 'publish', arguments);\n            }\n            callback = noop;\n        }\n        if (rest.options.headers)\n            Utils.mixin(headers, rest.options.headers);\n        if (rest.options.pushFullWait)\n            Utils.mixin(params, { fullWait: 'true' });\n        var requestBody = Utils.encodeBody(body, format);\n        resource_1.default.post(rest, '/push/publish', requestBody, headers, params, null, function (err) { return callback(err); });\n    };\n    return Admin;\n}());\nvar DeviceRegistrations = /** @class */ (function () {\n    function DeviceRegistrations(rest) {\n        this.rest = rest;\n    }\n    DeviceRegistrations.prototype.save = function (device, callback) {\n        var rest = this.rest;\n        var body = devicedetails_1.default.fromValues(device);\n        var format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(rest.options, format), params = {};\n        if (typeof callback !== 'function') {\n            if (this.rest.options.promises) {\n                return Utils.promisify(this, 'save', arguments);\n            }\n            callback = noop;\n        }\n        if (rest.options.headers)\n            Utils.mixin(headers, rest.options.headers);\n        if (rest.options.pushFullWait)\n            Utils.mixin(params, { fullWait: 'true' });\n        var requestBody = Utils.encodeBody(body, format);\n        resource_1.default.put(rest, '/push/deviceRegistrations/' + encodeURIComponent(device.id), requestBody, headers, params, null, function (err, body, headers, unpacked) {\n            callback(err, !err\n                ? devicedetails_1.default.fromResponseBody(body, unpacked ? undefined : format)\n                : undefined);\n        });\n    };\n    DeviceRegistrations.prototype.get = function (deviceIdOrDetails, callback) {\n        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultGetHeaders(rest.options, format), deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n        if (typeof callback !== 'function') {\n            if (this.rest.options.promises) {\n                return Utils.promisify(this, 'get', arguments);\n            }\n            callback = noop;\n        }\n        if (typeof deviceId !== 'string' || !deviceId.length) {\n            callback(new errorinfo_1.default('First argument to DeviceRegistrations#get must be a deviceId string or DeviceDetails', 40000, 400));\n            return;\n        }\n        if (rest.options.headers)\n            Utils.mixin(headers, rest.options.headers);\n        resource_1.default.get(rest, '/push/deviceRegistrations/' + encodeURIComponent(deviceId), headers, {}, null, function (err, body, headers, unpacked) {\n            callback(err, !err\n                ? devicedetails_1.default.fromResponseBody(body, unpacked ? undefined : format)\n                : undefined);\n        });\n    };\n    DeviceRegistrations.prototype.list = function (params, callback) {\n        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);\n        if (typeof callback !== 'function') {\n            if (this.rest.options.promises) {\n                return Utils.promisify(this, 'list', arguments);\n            }\n            callback = noop;\n        }\n        if (rest.options.headers)\n            Utils.mixin(headers, rest.options.headers);\n        new paginatedresource_1.default(rest, '/push/deviceRegistrations', headers, envelope, function (body, headers, unpacked) {\n            return devicedetails_1.default.fromResponseBody(body, unpacked ? undefined : format);\n        }).get(params, callback);\n    };\n    DeviceRegistrations.prototype.remove = function (deviceIdOrDetails, callback) {\n        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultGetHeaders(rest.options, format), params = {}, deviceId = deviceIdOrDetails.id || deviceIdOrDetails;\n        if (typeof callback !== 'function') {\n            if (this.rest.options.promises) {\n                return Utils.promisify(this, 'remove', arguments);\n            }\n            callback = noop;\n        }\n        if (typeof deviceId !== 'string' || !deviceId.length) {\n            callback(new errorinfo_1.default('First argument to DeviceRegistrations#remove must be a deviceId string or DeviceDetails', 40000, 400));\n            return;\n        }\n        if (rest.options.headers)\n            Utils.mixin(headers, rest.options.headers);\n        if (rest.options.pushFullWait)\n            Utils.mixin(params, { fullWait: 'true' });\n        resource_1.default['delete'](rest, '/push/deviceRegistrations/' + encodeURIComponent(deviceId), headers, params, null, function (err) { return callback(err); });\n    };\n    DeviceRegistrations.prototype.removeWhere = function (params, callback) {\n        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultGetHeaders(rest.options, format);\n        if (typeof callback !== 'function') {\n            if (this.rest.options.promises) {\n                return Utils.promisify(this, 'removeWhere', arguments);\n            }\n            callback = noop;\n        }\n        if (rest.options.headers)\n            Utils.mixin(headers, rest.options.headers);\n        if (rest.options.pushFullWait)\n            Utils.mixin(params, { fullWait: 'true' });\n        resource_1.default['delete'](rest, '/push/deviceRegistrations', headers, params, null, function (err) { return callback(err); });\n    };\n    return DeviceRegistrations;\n}());\nvar ChannelSubscriptions = /** @class */ (function () {\n    function ChannelSubscriptions(rest) {\n        /* ChannelSubscriptions have no unique id; removing one is equivalent to removeWhere by its properties */\n        this.remove = ChannelSubscriptions.prototype.removeWhere;\n        this.rest = rest;\n    }\n    ChannelSubscriptions.prototype.save = function (subscription, callback) {\n        var rest = this.rest;\n        var body = pushchannelsubscription_1.default.fromValues(subscription);\n        var format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultPostHeaders(rest.options, format), params = {};\n        if (typeof callback !== 'function') {\n            if (this.rest.options.promises) {\n                return Utils.promisify(this, 'save', arguments);\n            }\n            callback = noop;\n        }\n        if (rest.options.headers)\n            Utils.mixin(headers, rest.options.headers);\n        if (rest.options.pushFullWait)\n            Utils.mixin(params, { fullWait: 'true' });\n        var requestBody = Utils.encodeBody(body, format);\n        resource_1.default.post(rest, '/push/channelSubscriptions', requestBody, headers, params, null, function (err, body, headers, unpacked) {\n            callback(err, !err && pushchannelsubscription_1.default.fromResponseBody(body, unpacked ? undefined : format));\n        });\n    };\n    ChannelSubscriptions.prototype.list = function (params, callback) {\n        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);\n        if (typeof callback !== 'function') {\n            if (this.rest.options.promises) {\n                return Utils.promisify(this, 'list', arguments);\n            }\n            callback = noop;\n        }\n        if (rest.options.headers)\n            Utils.mixin(headers, rest.options.headers);\n        new paginatedresource_1.default(rest, '/push/channelSubscriptions', headers, envelope, function (body, headers, unpacked) {\n            return pushchannelsubscription_1.default.fromResponseBody(body, unpacked ? undefined : format);\n        }).get(params, callback);\n    };\n    ChannelSubscriptions.prototype.removeWhere = function (params, callback) {\n        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, headers = Utils.defaultGetHeaders(rest.options, format);\n        if (typeof callback !== 'function') {\n            if (this.rest.options.promises) {\n                return Utils.promisify(this, 'removeWhere', arguments);\n            }\n            callback = noop;\n        }\n        if (rest.options.headers)\n            Utils.mixin(headers, rest.options.headers);\n        if (rest.options.pushFullWait)\n            Utils.mixin(params, { fullWait: 'true' });\n        resource_1.default['delete'](rest, '/push/channelSubscriptions', headers, params, null, function (err) { return callback(err); });\n    };\n    ChannelSubscriptions.prototype.listChannels = function (params, callback) {\n        var rest = this.rest, format = rest.options.useBinaryProtocol ? Utils.Format.msgpack : Utils.Format.json, envelope = this.rest.http.supportsLinkHeaders ? undefined : format, headers = Utils.defaultGetHeaders(rest.options, format);\n        if (typeof callback !== 'function') {\n            if (this.rest.options.promises) {\n                return Utils.promisify(this, 'listChannels', arguments);\n            }\n            callback = noop;\n        }\n        if (rest.options.headers)\n            Utils.mixin(headers, rest.options.headers);\n        if (rest.options.pushFullWait)\n            Utils.mixin(params, { fullWait: 'true' });\n        new paginatedresource_1.default(rest, '/push/channels', headers, envelope, function (body, headers, unpacked) {\n            var parsedBody = (!unpacked && format ? Utils.decodeBody(body, format) : body);\n            for (var i = 0; i < parsedBody.length; i++) {\n                parsedBody[i] = String(parsedBody[i]);\n            }\n            return parsedBody;\n        }).get(params, callback);\n    };\n    return ChannelSubscriptions;\n}());\nexports.default = Push;\n\n\n/***/ }),\n/* 47 */\n/***/ (function(module, exports, __nested_webpack_require_486552__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_486552__(0);\nvar Utils = tslib_1.__importStar(__nested_webpack_require_486552__(1));\nvar errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_486552__(4));\nvar DeviceFormFactor;\n(function (DeviceFormFactor) {\n    DeviceFormFactor[\"Phone\"] = \"phone\";\n    DeviceFormFactor[\"Tablet\"] = \"tablet\";\n    DeviceFormFactor[\"Desktop\"] = \"desktop\";\n    DeviceFormFactor[\"TV\"] = \"tv\";\n    DeviceFormFactor[\"Watch\"] = \"watch\";\n    DeviceFormFactor[\"Car\"] = \"car\";\n    DeviceFormFactor[\"Embedded\"] = \"embedded\";\n    DeviceFormFactor[\"Other\"] = \"other\";\n})(DeviceFormFactor || (DeviceFormFactor = {}));\nvar DevicePlatform;\n(function (DevicePlatform) {\n    DevicePlatform[\"Android\"] = \"android\";\n    DevicePlatform[\"IOS\"] = \"ios\";\n    DevicePlatform[\"Browser\"] = \"browser\";\n})(DevicePlatform || (DevicePlatform = {}));\nvar DeviceDetails = /** @class */ (function () {\n    function DeviceDetails() {\n    }\n    DeviceDetails.prototype.toJSON = function () {\n        var _a, _b, _c;\n        return {\n            id: this.id,\n            deviceSecret: this.deviceSecret,\n            platform: this.platform,\n            formFactor: this.formFactor,\n            clientId: this.clientId,\n            metadata: this.metadata,\n            deviceIdentityToken: this.deviceIdentityToken,\n            push: {\n                recipient: (_a = this.push) === null || _a === void 0 ? void 0 : _a.recipient,\n                state: (_b = this.push) === null || _b === void 0 ? void 0 : _b.state,\n                error: (_c = this.push) === null || _c === void 0 ? void 0 : _c.error,\n            },\n        };\n    };\n    DeviceDetails.prototype.toString = function () {\n        var _a, _b, _c, _d;\n        var result = '[DeviceDetails';\n        if (this.id)\n            result += '; id=' + this.id;\n        if (this.platform)\n            result += '; platform=' + this.platform;\n        if (this.formFactor)\n            result += '; formFactor=' + this.formFactor;\n        if (this.clientId)\n            result += '; clientId=' + this.clientId;\n        if (this.metadata)\n            result += '; metadata=' + this.metadata;\n        if (this.deviceIdentityToken)\n            result += '; deviceIdentityToken=' + JSON.stringify(this.deviceIdentityToken);\n        if ((_a = this.push) === null || _a === void 0 ? void 0 : _a.recipient)\n            result += '; push.recipient=' + JSON.stringify(this.push.recipient);\n        if ((_b = this.push) === null || _b === void 0 ? void 0 : _b.state)\n            result += '; push.state=' + this.push.state;\n        if ((_c = this.push) === null || _c === void 0 ? void 0 : _c.error)\n            result += '; push.error=' + JSON.stringify(this.push.error);\n        if ((_d = this.push) === null || _d === void 0 ? void 0 : _d.metadata)\n            result += '; push.metadata=' + this.push.metadata;\n        result += ']';\n        return result;\n    };\n    DeviceDetails.fromResponseBody = function (body, format) {\n        if (format) {\n            body = Utils.decodeBody(body, format);\n        }\n        if (Utils.isArray(body)) {\n            return DeviceDetails.fromValuesArray(body);\n        }\n        else {\n            return DeviceDetails.fromValues(body);\n        }\n    };\n    DeviceDetails.fromValues = function (values) {\n        values.error = values.error && errorinfo_1.default.fromValues(values.error);\n        return Object.assign(new DeviceDetails(), values);\n    };\n    DeviceDetails.fromValuesArray = function (values) {\n        var count = values.length, result = new Array(count);\n        for (var i = 0; i < count; i++)\n            result[i] = DeviceDetails.fromValues(values[i]);\n        return result;\n    };\n    DeviceDetails.toRequestBody = Utils.encodeBody;\n    return DeviceDetails;\n}());\nexports.default = DeviceDetails;\n\n\n/***/ }),\n/* 48 */\n/***/ (function(module, exports, __nested_webpack_require_490472__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_490472__(0);\nvar Utils = tslib_1.__importStar(__nested_webpack_require_490472__(1));\nvar PushChannelSubscription = /** @class */ (function () {\n    function PushChannelSubscription() {\n    }\n    /**\n     * Overload toJSON() to intercept JSON.stringify()\n     * @return {*}\n     */\n    PushChannelSubscription.prototype.toJSON = function () {\n        return {\n            channel: this.channel,\n            deviceId: this.deviceId,\n            clientId: this.clientId,\n        };\n    };\n    PushChannelSubscription.prototype.toString = function () {\n        var result = '[PushChannelSubscription';\n        if (this.channel)\n            result += '; channel=' + this.channel;\n        if (this.deviceId)\n            result += '; deviceId=' + this.deviceId;\n        if (this.clientId)\n            result += '; clientId=' + this.clientId;\n        result += ']';\n        return result;\n    };\n    PushChannelSubscription.fromResponseBody = function (body, format) {\n        if (format) {\n            body = Utils.decodeBody(body, format);\n        }\n        if (Utils.isArray(body)) {\n            return PushChannelSubscription.fromValuesArray(body);\n        }\n        else {\n            return PushChannelSubscription.fromValues(body);\n        }\n    };\n    PushChannelSubscription.fromValues = function (values) {\n        return Object.assign(new PushChannelSubscription(), values);\n    };\n    PushChannelSubscription.fromValuesArray = function (values) {\n        var count = values.length, result = new Array(count);\n        for (var i = 0; i < count; i++)\n            result[i] = PushChannelSubscription.fromValues(values[i]);\n        return result;\n    };\n    PushChannelSubscription.toRequestBody = Utils.encodeBody;\n    return PushChannelSubscription;\n}());\nexports.default = PushChannelSubscription;\n\n\n/***/ }),\n/* 49 */\n/***/ (function(module, exports, __nested_webpack_require_492440__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_492440__(0);\nvar Utils = tslib_1.__importStar(__nested_webpack_require_492440__(1));\nvar MessageCount = /** @class */ (function () {\n    function MessageCount(values) {\n        this.count = (values && values.count) || 0;\n        this.data = (values && values.data) || 0;\n        this.uncompressedData = (values && values.uncompressedData) || 0;\n        this.failed = (values && values.failed) || 0;\n        this.refused = (values && values.refused) || 0;\n    }\n    return MessageCount;\n}());\nvar MessageCategory = /** @class */ (function (_super) {\n    tslib_1.__extends(MessageCategory, _super);\n    function MessageCategory(values) {\n        var _this = _super.call(this, values) || this;\n        if (values && values.category) {\n            _this.category = {};\n            Utils.forInOwnNonNullProperties(values.category, function (prop) {\n                _this.category[prop] = new MessageCount(values.category[prop]);\n            });\n        }\n        return _this;\n    }\n    return MessageCategory;\n}(MessageCount));\nvar ResourceCount = /** @class */ (function () {\n    function ResourceCount(values) {\n        this.peak = (values && values.peak) || 0;\n        this.min = (values && values.min) || 0;\n        this.mean = (values && values.mean) || 0;\n        this.opened = (values && values.opened) || 0;\n        this.refused = (values && values.refused) || 0;\n    }\n    return ResourceCount;\n}());\nvar RequestCount = /** @class */ (function () {\n    function RequestCount(values) {\n        this.succeeded = (values && values.succeeded) || 0;\n        this.failed = (values && values.failed) || 0;\n        this.refused = (values && values.refused) || 0;\n    }\n    return RequestCount;\n}());\nvar ConnectionTypes = /** @class */ (function () {\n    function ConnectionTypes(values) {\n        this.plain = new ResourceCount(values && values.plain);\n        this.tls = new ResourceCount(values && values.tls);\n        this.all = new ResourceCount(values && values.all);\n    }\n    return ConnectionTypes;\n}());\nvar MessageTypes = /** @class */ (function () {\n    function MessageTypes(values) {\n        this.messages = new MessageCategory(values && values.messages);\n        this.presence = new MessageCategory(values && values.presence);\n        this.all = new MessageCategory(values && values.all);\n    }\n    return MessageTypes;\n}());\nvar MessageTraffic = /** @class */ (function () {\n    function MessageTraffic(values) {\n        this.realtime = new MessageTypes(values && values.realtime);\n        this.rest = new MessageTypes(values && values.rest);\n        this.webhook = new MessageTypes(values && values.webhook);\n        this.sharedQueue = new MessageTypes(values && values.sharedQueue);\n        this.externalQueue = new MessageTypes(values && values.externalQueue);\n        this.httpEvent = new MessageTypes(values && values.httpEvent);\n        this.push = new MessageTypes(values && values.push);\n        this.all = new MessageTypes(values && values.all);\n    }\n    return MessageTraffic;\n}());\nvar MessageDirections = /** @class */ (function () {\n    function MessageDirections(values) {\n        this.all = new MessageTypes(values && values.all);\n        this.inbound = new MessageTraffic(values && values.inbound);\n        this.outbound = new MessageTraffic(values && values.outbound);\n    }\n    return MessageDirections;\n}());\nvar XchgMessages = /** @class */ (function () {\n    function XchgMessages(values) {\n        this.all = new MessageTypes(values && values.all);\n        this.producerPaid = new MessageDirections(values && values.producerPaid);\n        this.consumerPaid = new MessageDirections(values && values.consumerPaid);\n    }\n    return XchgMessages;\n}());\nvar PushStats = /** @class */ (function () {\n    function PushStats(values) {\n        this.messages = (values && values.messages) || 0;\n        var notifications = values && values.notifications;\n        this.notifications = {\n            invalid: (notifications && notifications.invalid) || 0,\n            attempted: (notifications && notifications.attempted) || 0,\n            successful: (notifications && notifications.successful) || 0,\n            failed: (notifications && notifications.failed) || 0,\n        };\n        this.directPublishes = (values && values.directPublishes) || 0;\n    }\n    return PushStats;\n}());\nvar ProcessedCount = /** @class */ (function () {\n    function ProcessedCount(values) {\n        this.succeeded = (values && values.succeeded) || 0;\n        this.skipped = (values && values.skipped) || 0;\n        this.failed = (values && values.failed) || 0;\n    }\n    return ProcessedCount;\n}());\nvar ProcessedMessages = /** @class */ (function () {\n    function ProcessedMessages(values) {\n        var _this = this;\n        this.delta = undefined;\n        if (values && values.delta) {\n            this.delta = {};\n            Utils.forInOwnNonNullProperties(values.delta, function (prop) {\n                _this.delta[prop] = new ProcessedCount(values.delta[prop]);\n            });\n        }\n    }\n    return ProcessedMessages;\n}());\nvar Stats = /** @class */ (function (_super) {\n    tslib_1.__extends(Stats, _super);\n    function Stats(values) {\n        var _this = _super.call(this, values) || this;\n        _this.persisted = new MessageTypes(values && values.persisted);\n        _this.connections = new ConnectionTypes(values && values.connections);\n        _this.channels = new ResourceCount(values && values.channels);\n        _this.apiRequests = new RequestCount(values && values.apiRequests);\n        _this.tokenRequests = new RequestCount(values && values.tokenRequests);\n        _this.xchgProducer = new XchgMessages(values && values.xchgProducer);\n        _this.xchgConsumer = new XchgMessages(values && values.xchgConsumer);\n        _this.push = new PushStats(values && values.pushStats);\n        _this.processed = new ProcessedMessages(values && values.processed);\n        _this.inProgress = (values && values.inProgress) || undefined;\n        _this.unit = (values && values.unit) || undefined;\n        _this.intervalId = (values && values.intervalId) || undefined;\n        return _this;\n    }\n    Stats.fromValues = function (values) {\n        return new Stats(values);\n    };\n    return Stats;\n}(MessageDirections));\nexports.default = Stats;\n\n\n/***/ }),\n/* 50 */\n/***/ (function(module, exports, __nested_webpack_require_498876__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_498876__(0);\nvar Utils = tslib_1.__importStar(__nested_webpack_require_498876__(1));\nvar rest_1 = tslib_1.__importDefault(__nested_webpack_require_498876__(30));\nvar eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_498876__(7));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_498876__(2));\nvar connection_1 = tslib_1.__importDefault(__nested_webpack_require_498876__(51));\nvar realtimechannel_1 = tslib_1.__importDefault(__nested_webpack_require_498876__(38));\nvar defaults_1 = tslib_1.__importDefault(__nested_webpack_require_498876__(8));\nvar errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_498876__(4));\nvar protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_498876__(10));\nvar connectionmanager_1 = tslib_1.__importDefault(__nested_webpack_require_498876__(35));\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_498876__(3));\nvar message_1 = tslib_1.__importDefault(__nested_webpack_require_498876__(9));\nvar Realtime = /** @class */ (function (_super) {\n    tslib_1.__extends(Realtime, _super);\n    function Realtime(options) {\n        var _this = _super.call(this, options) || this;\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Realtime()', '');\n        _this.connection = new connection_1.default(_this, _this.options);\n        _this.channels = new Channels(_this);\n        if (options.autoConnect !== false)\n            _this.connect();\n        return _this;\n    }\n    Realtime.prototype.connect = function () {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Realtime.connect()', '');\n        this.connection.connect();\n    };\n    Realtime.prototype.close = function () {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Realtime.close()', '');\n        this.connection.close();\n    };\n    Realtime.Promise = function (options) {\n        options = defaults_1.default.objectifyOptions(options);\n        options.promises = true;\n        return new Realtime(options);\n    };\n    Realtime.Callbacks = Realtime;\n    Realtime.Utils = Utils;\n    Realtime.ConnectionManager = connectionmanager_1.default;\n    Realtime.Platform = platform_1.default;\n    Realtime.ProtocolMessage = protocolmessage_1.default;\n    Realtime.Message = message_1.default;\n    return Realtime;\n}(rest_1.default));\nvar Channels = /** @class */ (function (_super) {\n    tslib_1.__extends(Channels, _super);\n    function Channels(realtime) {\n        var _this = _super.call(this) || this;\n        _this.realtime = realtime;\n        _this.all = Object.create(null);\n        realtime.connection.connectionManager.on('transport.active', function () {\n            _this.onTransportActive();\n        });\n        return _this;\n    }\n    Channels.prototype.channelSerials = function () {\n        var serials = {};\n        for (var _i = 0, _a = Utils.keysArray(this.all, true); _i < _a.length; _i++) {\n            var name_1 = _a[_i];\n            var channel = this.all[name_1];\n            if (channel.properties.channelSerial) {\n                serials[name_1] = channel.properties.channelSerial;\n            }\n        }\n        return serials;\n    };\n    // recoverChannels gets the given channels and sets their channel serials.\n    Channels.prototype.recoverChannels = function (channelSerials) {\n        for (var _i = 0, _a = Utils.keysArray(channelSerials, true); _i < _a.length; _i++) {\n            var name_2 = _a[_i];\n            var channel = this.get(name_2);\n            channel.properties.channelSerial = channelSerials[name_2];\n        }\n    };\n    Channels.prototype.onChannelMessage = function (msg) {\n        var channelName = msg.channel;\n        if (channelName === undefined) {\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Channels.onChannelMessage()', 'received event unspecified channel, action = ' + msg.action);\n            return;\n        }\n        var channel = this.all[channelName];\n        if (!channel) {\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Channels.onChannelMessage()', 'received event for non-existent channel: ' + channelName);\n            return;\n        }\n        channel.onMessage(msg);\n    };\n    /* called when a transport becomes connected; reattempt attach/detach\n     * for channels that are attaching or detaching. */\n    Channels.prototype.onTransportActive = function () {\n        for (var channelName in this.all) {\n            var channel = this.all[channelName];\n            if (channel.state === 'attaching' || channel.state === 'detaching') {\n                channel.checkPendingState();\n            }\n            else if (channel.state === 'suspended') {\n                channel._attach(false, null);\n            }\n            else if (channel.state === 'attached') {\n                // Note explicity request the state, channel.attach() would do nothing\n                // as its already attached.\n                channel.requestState('attaching');\n            }\n        }\n    };\n    /* Connection interruptions (ie when the connection will no longer queue\n     * events) imply connection state changes for any channel which is either\n     * attached, pending, or will attempt to become attached in the future */\n    Channels.prototype.propogateConnectionInterruption = function (connectionState, reason) {\n        var connectionStateToChannelState = {\n            closing: 'detached',\n            closed: 'detached',\n            failed: 'failed',\n            suspended: 'suspended',\n        };\n        var fromChannelStates = ['attaching', 'attached', 'detaching', 'suspended'];\n        var toChannelState = connectionStateToChannelState[connectionState];\n        for (var channelId in this.all) {\n            var channel = this.all[channelId];\n            if (Utils.arrIn(fromChannelStates, channel.state)) {\n                channel.notifyState(toChannelState, reason);\n            }\n        }\n    };\n    Channels.prototype.get = function (name, channelOptions) {\n        name = String(name);\n        var channel = this.all[name];\n        if (!channel) {\n            channel = this.all[name] = new realtimechannel_1.default(this.realtime, name, channelOptions);\n        }\n        else if (channelOptions) {\n            if (channel._shouldReattachToSetOptions(channelOptions, channel.channelOptions)) {\n                throw new errorinfo_1.default('Channels.get() cannot be used to set channel options that would cause the channel to reattach. Please, use RealtimeChannel.setOptions() instead.', 40000, 400);\n            }\n            channel.setOptions(channelOptions);\n        }\n        return channel;\n    };\n    Channels.prototype.getDerived = function (name, deriveOptions, channelOptions) {\n        if (deriveOptions.filter) {\n            var filter = Utils.toBase64(deriveOptions.filter);\n            var match = Utils.matchDerivedChannel(name);\n            name = \"[filter=\".concat(filter).concat(match.qualifierParam, \"]\").concat(match.channelName);\n        }\n        return this.get(name, channelOptions);\n    };\n    /* Included to support certain niche use-cases; most users should ignore this.\n     * Please do not use this unless you know what you're doing */\n    Channels.prototype.release = function (name) {\n        name = String(name);\n        var channel = this.all[name];\n        if (!channel) {\n            return;\n        }\n        var releaseErr = channel.getReleaseErr();\n        if (releaseErr) {\n            throw releaseErr;\n        }\n        delete this.all[name];\n    };\n    return Channels;\n}(eventemitter_1.default));\nexports.default = Realtime;\n\n\n/***/ }),\n/* 51 */\n/***/ (function(module, exports, __nested_webpack_require_506473__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_506473__(0);\nvar Utils = tslib_1.__importStar(__nested_webpack_require_506473__(1));\nvar eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_506473__(7));\nvar connectionmanager_1 = tslib_1.__importDefault(__nested_webpack_require_506473__(35));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_506473__(2));\nvar connectionstatechange_1 = tslib_1.__importDefault(__nested_webpack_require_506473__(37));\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_506473__(3));\nfunction noop() { }\nvar Connection = /** @class */ (function (_super) {\n    tslib_1.__extends(Connection, _super);\n    function Connection(ably, options) {\n        var _this = _super.call(this) || this;\n        _this.whenState = (function (state, listener) {\n            return eventemitter_1.default.prototype.whenState.call(_this, state, _this.state, listener, new connectionstatechange_1.default(undefined, state));\n        });\n        _this.ably = ably;\n        _this.connectionManager = new connectionmanager_1.default(ably, options);\n        _this.state = _this.connectionManager.state.state;\n        _this.key = undefined;\n        _this.id = undefined;\n        _this.errorReason = null;\n        _this.connectionManager.on('connectionstate', function (stateChange) {\n            var state = (_this.state = stateChange.current);\n            platform_1.default.Config.nextTick(function () {\n                _this.emit(state, stateChange);\n            });\n        });\n        _this.connectionManager.on('update', function (stateChange) {\n            platform_1.default.Config.nextTick(function () {\n                _this.emit('update', stateChange);\n            });\n        });\n        return _this;\n    }\n    Connection.prototype.connect = function () {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Connection.connect()', '');\n        this.connectionManager.requestState({ state: 'connecting' });\n    };\n    Connection.prototype.ping = function (callback) {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Connection.ping()', '');\n        if (!callback) {\n            if (this.ably.options.promises) {\n                return Utils.promisify(this, 'ping', arguments);\n            }\n            callback = noop;\n        }\n        this.connectionManager.ping(null, callback);\n    };\n    Connection.prototype.close = function () {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'Connection.close()', 'connectionKey = ' + this.key);\n        this.connectionManager.requestState({ state: 'closing' });\n    };\n    Object.defineProperty(Connection.prototype, \"recoveryKey\", {\n        get: function () {\n            return this.createRecoveryKey();\n        },\n        enumerable: false,\n        configurable: true\n    });\n    Connection.prototype.createRecoveryKey = function () {\n        return this.connectionManager.createRecoveryKey();\n    };\n    return Connection;\n}(eventemitter_1.default));\nexports.default = Connection;\n\n\n/***/ }),\n/* 52 */\n/***/ (function(module, exports, __nested_webpack_require_509554__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.PendingMessage = void 0;\nvar tslib_1 = __nested_webpack_require_509554__(0);\nvar protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_509554__(10));\nvar Utils = tslib_1.__importStar(__nested_webpack_require_509554__(1));\nvar eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_509554__(7));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_509554__(2));\nvar messagequeue_1 = tslib_1.__importDefault(__nested_webpack_require_509554__(36));\nvar errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_509554__(4));\nvar actions = protocolmessage_1.default.Action;\nvar PendingMessage = /** @class */ (function () {\n    function PendingMessage(message, callback) {\n        this.message = message;\n        this.callback = callback;\n        this.merged = false;\n        var action = message.action;\n        this.sendAttempted = false;\n        this.ackRequired = action == actions.MESSAGE || action == actions.PRESENCE;\n    }\n    return PendingMessage;\n}());\nexports.PendingMessage = PendingMessage;\nvar Protocol = /** @class */ (function (_super) {\n    tslib_1.__extends(Protocol, _super);\n    function Protocol(transport) {\n        var _this = _super.call(this) || this;\n        _this.transport = transport;\n        _this.messageQueue = new messagequeue_1.default();\n        transport.on('ack', function (serial, count) {\n            _this.onAck(serial, count);\n        });\n        transport.on('nack', function (serial, count, err) {\n            _this.onNack(serial, count, err);\n        });\n        return _this;\n    }\n    Protocol.prototype.onAck = function (serial, count) {\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Protocol.onAck()', 'serial = ' + serial + '; count = ' + count);\n        this.messageQueue.completeMessages(serial, count);\n    };\n    Protocol.prototype.onNack = function (serial, count, err) {\n        logger_1.default.logAction(logger_1.default.LOG_ERROR, 'Protocol.onNack()', 'serial = ' + serial + '; count = ' + count + '; err = ' + Utils.inspectError(err));\n        if (!err) {\n            err = new errorinfo_1.default('Unable to send message; channel not responding', 50001, 500);\n        }\n        this.messageQueue.completeMessages(serial, count, err);\n    };\n    Protocol.prototype.onceIdle = function (listener) {\n        var messageQueue = this.messageQueue;\n        if (messageQueue.count() === 0) {\n            listener();\n            return;\n        }\n        messageQueue.once('idle', listener);\n    };\n    Protocol.prototype.send = function (pendingMessage) {\n        if (pendingMessage.ackRequired) {\n            this.messageQueue.push(pendingMessage);\n        }\n        if (logger_1.default.shouldLog(logger_1.default.LOG_MICRO)) {\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'Protocol.send()', 'sending msg; ' + protocolmessage_1.default.stringify(pendingMessage.message));\n        }\n        pendingMessage.sendAttempted = true;\n        this.transport.send(pendingMessage.message);\n    };\n    Protocol.prototype.getTransport = function () {\n        return this.transport;\n    };\n    Protocol.prototype.getPendingMessages = function () {\n        return this.messageQueue.copyAll();\n    };\n    Protocol.prototype.clearPendingMessages = function () {\n        return this.messageQueue.clear();\n    };\n    Protocol.prototype.finish = function () {\n        var transport = this.transport;\n        this.onceIdle(function () {\n            transport.disconnect();\n        });\n    };\n    return Protocol;\n}(eventemitter_1.default));\nexports.default = Protocol;\n\n\n/***/ }),\n/* 53 */\n/***/ (function(module, exports, __nested_webpack_require_513204__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_513204__(0);\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_513204__(3));\nvar Utils = tslib_1.__importStar(__nested_webpack_require_513204__(1));\nvar transport_1 = tslib_1.__importDefault(__nested_webpack_require_513204__(26));\nvar defaults_1 = tslib_1.__importDefault(__nested_webpack_require_513204__(8));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_513204__(2));\nvar protocolmessage_1 = tslib_1.__importDefault(__nested_webpack_require_513204__(10));\nvar errorinfo_1 = tslib_1.__importDefault(__nested_webpack_require_513204__(4));\nvar shortName = 'web_socket';\nfunction isNodeWebSocket(ws) {\n    return !!ws.on;\n}\nvar WebSocketTransport = /** @class */ (function (_super) {\n    tslib_1.__extends(WebSocketTransport, _super);\n    function WebSocketTransport(connectionManager, auth, params) {\n        var _this = _super.call(this, connectionManager, auth, params) || this;\n        _this.shortName = shortName;\n        /* If is a browser, can't detect pings, so request protocol heartbeats */\n        params.heartbeats = platform_1.default.Config.useProtocolHeartbeats;\n        _this.wsHost = defaults_1.default.getHost(params.options, params.host, true);\n        return _this;\n    }\n    WebSocketTransport.isAvailable = function () {\n        return !!platform_1.default.Config.WebSocket;\n    };\n    WebSocketTransport.prototype.createWebSocket = function (uri, connectParams) {\n        this.uri = uri + Utils.toQueryString(connectParams);\n        return new platform_1.default.Config.WebSocket(this.uri);\n    };\n    WebSocketTransport.prototype.toString = function () {\n        return 'WebSocketTransport; uri=' + this.uri;\n    };\n    WebSocketTransport.prototype.connect = function () {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.connect()', 'starting');\n        transport_1.default.prototype.connect.call(this);\n        var self = this, params = this.params, options = params.options;\n        var wsScheme = options.tls ? 'wss://' : 'ws://';\n        var wsUri = wsScheme + this.wsHost + ':' + defaults_1.default.getPort(options) + '/';\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.connect()', 'uri: ' + wsUri);\n        this.auth.getAuthParams(function (err, authParams) {\n            if (self.isDisposed) {\n                return;\n            }\n            var paramStr = '';\n            for (var param in authParams)\n                paramStr += ' ' + param + ': ' + authParams[param] + ';';\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.connect()', 'authParams:' + paramStr + ' err: ' + err);\n            if (err) {\n                self.disconnect(err);\n                return;\n            }\n            var connectParams = params.getConnectParams(authParams);\n            try {\n                var wsConnection = (self.wsConnection = self.createWebSocket(wsUri, connectParams));\n                wsConnection.binaryType = platform_1.default.Config.binaryType;\n                wsConnection.onopen = function () {\n                    self.onWsOpen();\n                };\n                wsConnection.onclose = function (ev) {\n                    self.onWsClose(ev);\n                };\n                wsConnection.onmessage = function (ev) {\n                    self.onWsData(ev.data);\n                };\n                wsConnection.onerror = function (ev) {\n                    self.onWsError(ev);\n                };\n                if (isNodeWebSocket(wsConnection)) {\n                    /* node; browsers currently don't have a general eventemitter and can't detect\n                     * pings. Also, no need to reply with a pong explicitly, ws lib handles that */\n                    wsConnection.on('ping', function () {\n                        self.onActivity();\n                    });\n                }\n            }\n            catch (e) {\n                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'WebSocketTransport.connect()', 'Unexpected exception creating websocket: err = ' + (e.stack || e.message));\n                self.disconnect(e);\n            }\n        });\n    };\n    WebSocketTransport.prototype.send = function (message) {\n        var wsConnection = this.wsConnection;\n        if (!wsConnection) {\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'WebSocketTransport.send()', 'No socket connection');\n            return;\n        }\n        try {\n            wsConnection.send(protocolmessage_1.default.serialize(message, this.params.format));\n        }\n        catch (e) {\n            var msg = 'Exception from ws connection when trying to send: ' + Utils.inspectError(e);\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'WebSocketTransport.send()', msg);\n            /* Don't try to request a disconnect, that'll just involve sending data\n             * down the websocket again. Just finish the transport. */\n            this.finish('disconnected', new errorinfo_1.default(msg, 50000, 500));\n        }\n    };\n    WebSocketTransport.prototype.onWsData = function (data) {\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'WebSocketTransport.onWsData()', 'data received; length = ' + data.length + '; type = ' + typeof data);\n        try {\n            this.onProtocolMessage(protocolmessage_1.default.deserialize(data, this.format));\n        }\n        catch (e) {\n            logger_1.default.logAction(logger_1.default.LOG_ERROR, 'WebSocketTransport.onWsData()', 'Unexpected exception handing channel message: ' + e.stack);\n        }\n    };\n    WebSocketTransport.prototype.onWsOpen = function () {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.onWsOpen()', 'opened WebSocket');\n        this.emit('preconnect');\n    };\n    WebSocketTransport.prototype.onWsClose = function (ev) {\n        var wasClean, code;\n        if (typeof ev == 'object') {\n            /* W3C spec-compatible */\n            code = ev.code;\n            // ev.wasClean is undefined in reactnative\n            wasClean = ev.wasClean || code === 1000;\n        } /*if(typeof(ev) == 'number')*/\n        else {\n            /* ws in node */\n            code = ev;\n            wasClean = code == 1000;\n        }\n        delete this.wsConnection;\n        if (wasClean) {\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.onWsClose()', 'Cleanly closed WebSocket');\n            var err = new errorinfo_1.default('Websocket closed', 80003, 400);\n            this.finish('disconnected', err);\n        }\n        else {\n            var msg = 'Unclean disconnection of WebSocket ; code = ' + code, err = new errorinfo_1.default(msg, 80003, 400);\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.onWsClose()', msg);\n            this.finish('disconnected', err);\n        }\n        this.emit('disposed');\n    };\n    WebSocketTransport.prototype.onWsError = function (err) {\n        var _this = this;\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.onError()', 'Error from WebSocket: ' + err.message);\n        /* Wait a tick before aborting: if the websocket was connected, this event\n         * will be immediately followed by an onclose event with a close code. Allow\n         * that to close it (so we see the close code) rather than anticipating it */\n        platform_1.default.Config.nextTick(function () {\n            _this.disconnect(Error(err.message));\n        });\n    };\n    WebSocketTransport.prototype.dispose = function () {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'WebSocketTransport.dispose()', '');\n        this.isDisposed = true;\n        var wsConnection = this.wsConnection;\n        if (wsConnection) {\n            /* Ignore any messages that come through after dispose() is called but before\n             * websocket is actually closed. (mostly would be harmless, but if it's a\n             * CONNECTED, it'll re-tick isConnected and cause all sorts of havoc) */\n            wsConnection.onmessage = function () { };\n            delete this.wsConnection;\n            /* defer until the next event loop cycle before closing the socket,\n             * giving some implementations the opportunity to send any outstanding close message */\n            platform_1.default.Config.nextTick(function () {\n                logger_1.default.logAction(logger_1.default.LOG_MICRO, 'WebSocketTransport.dispose()', 'closing websocket');\n                if (!wsConnection) {\n                    throw new Error('WebSocketTransport.dispose(): wsConnection is not defined');\n                }\n                wsConnection.close();\n            });\n        }\n    };\n    return WebSocketTransport;\n}(transport_1.default));\nfunction initialiseTransport(connectionManager) {\n    if (WebSocketTransport.isAvailable())\n        connectionManager.supportedTransports[shortName] = WebSocketTransport;\n    return WebSocketTransport;\n}\nexports.default = initialiseTransport;\n\n\n/***/ }),\n/* 54 */\n/***/ (function(module, exports, __nested_webpack_require_522322__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_522322__(0);\nvar Utils = tslib_1.__importStar(__nested_webpack_require_522322__(1));\nvar presence_1 = tslib_1.__importDefault(__nested_webpack_require_522322__(34));\nvar eventemitter_1 = tslib_1.__importDefault(__nested_webpack_require_522322__(7));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_522322__(2));\nvar presencemessage_1 = tslib_1.__importDefault(__nested_webpack_require_522322__(15));\nvar errorinfo_1 = tslib_1.__importStar(__nested_webpack_require_522322__(4));\nvar realtimechannel_1 = tslib_1.__importDefault(__nested_webpack_require_522322__(38));\nvar multicaster_1 = tslib_1.__importDefault(__nested_webpack_require_522322__(23));\nvar channelstatechange_1 = tslib_1.__importDefault(__nested_webpack_require_522322__(39));\nvar noop = function () { };\nfunction getClientId(realtimePresence) {\n    return realtimePresence.channel.realtime.auth.clientId;\n}\nfunction isAnonymousOrWildcard(realtimePresence) {\n    var realtime = realtimePresence.channel.realtime;\n    /* If not currently connected, we can't assume that we're an anonymous\n     * client, as realtime may inform us of our clientId in the CONNECTED\n     * message. So assume we're not anonymous and leave it to realtime to\n     * return an error if we are */\n    var clientId = realtime.auth.clientId;\n    return (!clientId || clientId === '*') && realtime.connection.state === 'connected';\n}\n/* Callback is called only in the event of an error */\nfunction waitAttached(channel, callback, action) {\n    switch (channel.state) {\n        case 'attached':\n        case 'suspended':\n            action();\n            break;\n        case 'initialized':\n        case 'detached':\n        case 'detaching':\n        case 'attaching':\n            channel.attach(function (err) {\n                if (err)\n                    callback(err);\n                else\n                    action();\n            });\n            break;\n        default:\n            callback(errorinfo_1.default.fromValues(channel.invalidStateError()));\n    }\n}\nfunction newerThan(item, existing) {\n    /* RTP2b1: if either is synthesised, compare by timestamp */\n    if (item.isSynthesized() || existing.isSynthesized()) {\n        // RTP2b1a: if equal, prefer the newly-arrived one\n        return item.timestamp >= existing.timestamp;\n    }\n    /* RTP2b2 */\n    var itemOrderings = item.parseId(), existingOrderings = existing.parseId();\n    if (itemOrderings.msgSerial === existingOrderings.msgSerial) {\n        return itemOrderings.index > existingOrderings.index;\n    }\n    else {\n        return itemOrderings.msgSerial > existingOrderings.msgSerial;\n    }\n}\nvar RealtimePresence = /** @class */ (function (_super) {\n    tslib_1.__extends(RealtimePresence, _super);\n    function RealtimePresence(channel) {\n        var _this = _super.call(this, channel) || this;\n        _this.channel = channel;\n        _this.syncComplete = false;\n        _this.members = new PresenceMap(_this, function (item) { return item.clientId + ':' + item.connectionId; });\n        // RTP17h: Store own members by clientId only.\n        _this._myMembers = new PresenceMap(_this, function (item) { return item.clientId; });\n        _this.subscriptions = new eventemitter_1.default();\n        _this.pendingPresence = [];\n        return _this;\n    }\n    RealtimePresence.prototype.enter = function (data, callback) {\n        if (isAnonymousOrWildcard(this)) {\n            throw new errorinfo_1.default('clientId must be specified to enter a presence channel', 40012, 400);\n        }\n        return this._enterOrUpdateClient(undefined, undefined, data, 'enter', callback);\n    };\n    RealtimePresence.prototype.update = function (data, callback) {\n        if (isAnonymousOrWildcard(this)) {\n            throw new errorinfo_1.default('clientId must be specified to update presence data', 40012, 400);\n        }\n        return this._enterOrUpdateClient(undefined, undefined, data, 'update', callback);\n    };\n    RealtimePresence.prototype.enterClient = function (clientId, data, callback) {\n        return this._enterOrUpdateClient(undefined, clientId, data, 'enter', callback);\n    };\n    RealtimePresence.prototype.updateClient = function (clientId, data, callback) {\n        return this._enterOrUpdateClient(undefined, clientId, data, 'update', callback);\n    };\n    RealtimePresence.prototype._enterOrUpdateClient = function (id, clientId, data, action, callback) {\n        var _this = this;\n        if (!callback) {\n            if (typeof data === 'function') {\n                callback = data;\n                data = null;\n            }\n            else {\n                if (this.channel.realtime.options.promises) {\n                    return Utils.promisify(this, '_enterOrUpdateClient', [id, clientId, data, action]);\n                }\n                callback = noop;\n            }\n        }\n        var channel = this.channel;\n        if (!channel.connectionManager.activeState()) {\n            callback(channel.connectionManager.getError());\n            return;\n        }\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence.' + action + 'Client()', 'channel = ' + channel.name + ', id = ' + id + ', client = ' + (clientId || '(implicit) ' + getClientId(this)));\n        var presence = presencemessage_1.default.fromData(data);\n        presence.action = action;\n        if (id) {\n            presence.id = id;\n        }\n        if (clientId) {\n            presence.clientId = clientId;\n        }\n        presencemessage_1.default.encode(presence, channel.channelOptions, function (err) {\n            if (err) {\n                callback(err);\n                return;\n            }\n            switch (channel.state) {\n                case 'attached':\n                    channel.sendPresence(presence, callback);\n                    break;\n                case 'initialized':\n                case 'detached':\n                    channel.attach();\n                // eslint-disable-next-line no-fallthrough\n                case 'attaching':\n                    _this.pendingPresence.push({\n                        presence: presence,\n                        callback: callback,\n                    });\n                    break;\n                default:\n                    err = new errorinfo_1.PartialErrorInfo('Unable to ' + action + ' presence channel while in ' + channel.state + ' state', 90001);\n                    err.code = 90001;\n                    callback(err);\n            }\n        });\n    };\n    RealtimePresence.prototype.leave = function (data, callback) {\n        if (isAnonymousOrWildcard(this)) {\n            throw new errorinfo_1.default('clientId must have been specified to enter or leave a presence channel', 40012, 400);\n        }\n        return this.leaveClient(undefined, data, callback);\n    };\n    RealtimePresence.prototype.leaveClient = function (clientId, data, callback) {\n        if (!callback) {\n            if (typeof data === 'function') {\n                callback = data;\n                data = null;\n            }\n            else {\n                if (this.channel.realtime.options.promises) {\n                    return Utils.promisify(this, 'leaveClient', [clientId, data]);\n                }\n                callback = noop;\n            }\n        }\n        var channel = this.channel;\n        if (!channel.connectionManager.activeState()) {\n            callback === null || callback === void 0 ? void 0 : callback(channel.connectionManager.getError());\n            return;\n        }\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence.leaveClient()', 'leaving; channel = ' + this.channel.name + ', client = ' + clientId);\n        var presence = presencemessage_1.default.fromData(data);\n        presence.action = 'leave';\n        if (clientId) {\n            presence.clientId = clientId;\n        }\n        switch (channel.state) {\n            case 'attached':\n                channel.sendPresence(presence, callback);\n                break;\n            case 'attaching':\n                this.pendingPresence.push({\n                    presence: presence,\n                    callback: callback,\n                });\n                break;\n            case 'initialized':\n            case 'failed': {\n                /* we're not attached; therefore we let any entered status\n                 * timeout by itself instead of attaching just in order to leave */\n                var err = new errorinfo_1.PartialErrorInfo('Unable to leave presence channel (incompatible state)', 90001);\n                callback === null || callback === void 0 ? void 0 : callback(err);\n                break;\n            }\n            default:\n                callback === null || callback === void 0 ? void 0 : callback(channel.invalidStateError());\n        }\n    };\n    // Return type is any to avoid conflict with base Presence class\n    RealtimePresence.prototype.get = function (params, callback) {\n        var _this = this;\n        var args = Array.prototype.slice.call(arguments);\n        if (args.length == 1 && typeof args[0] == 'function')\n            args.unshift(null);\n        params = args[0];\n        callback = args[1];\n        var waitForSync = !params || ('waitForSync' in params ? params.waitForSync : true);\n        if (!callback) {\n            if (this.channel.realtime.options.promises) {\n                return Utils.promisify(this, 'get', args);\n            }\n            callback = noop;\n        }\n        function returnMembers(members) {\n            callback(null, params ? members.list(params) : members.values());\n        }\n        /* Special-case the suspended state: can still get (stale) presence set if waitForSync is false */\n        if (this.channel.state === 'suspended') {\n            if (waitForSync) {\n                callback(errorinfo_1.default.fromValues({\n                    statusCode: 400,\n                    code: 91005,\n                    message: 'Presence state is out of sync due to channel being in the SUSPENDED state',\n                }));\n            }\n            else {\n                returnMembers(this.members);\n            }\n            return;\n        }\n        waitAttached(this.channel, callback, function () {\n            var members = _this.members;\n            if (waitForSync) {\n                members.waitSync(function () {\n                    returnMembers(members);\n                });\n            }\n            else {\n                returnMembers(members);\n            }\n        });\n    };\n    RealtimePresence.prototype.history = function (params, callback) {\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence.history()', 'channel = ' + this.name);\n        /* params and callback are optional; see if params contains the callback */\n        if (callback === undefined) {\n            if (typeof params == 'function') {\n                callback = params;\n                params = null;\n            }\n            else {\n                if (this.channel.realtime.options.promises) {\n                    return Utils.promisify(this, 'history', arguments);\n                }\n                callback = noop;\n            }\n        }\n        if (params && params.untilAttach) {\n            if (this.channel.state === 'attached') {\n                delete params.untilAttach;\n                params.from_serial = this.channel.properties.attachSerial;\n            }\n            else {\n                callback(new errorinfo_1.default('option untilAttach requires the channel to be attached, was: ' + this.channel.state, 40000, 400));\n            }\n        }\n        presence_1.default.prototype._history.call(this, params, callback);\n    };\n    RealtimePresence.prototype.setPresence = function (presenceSet, isSync, syncChannelSerial) {\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence.setPresence()', 'received presence for ' + presenceSet.length + ' participants; syncChannelSerial = ' + syncChannelSerial);\n        var syncCursor, match;\n        var members = this.members, myMembers = this._myMembers, broadcastMessages = [], connId = this.channel.connectionManager.connectionId;\n        if (isSync) {\n            this.members.startSync();\n            if (syncChannelSerial && (match = syncChannelSerial.match(/^[\\w-]+:(.*)$/))) {\n                syncCursor = match[1];\n            }\n        }\n        for (var i = 0; i < presenceSet.length; i++) {\n            var presence = presencemessage_1.default.fromValues(presenceSet[i]);\n            switch (presence.action) {\n                case 'leave':\n                    if (members.remove(presence)) {\n                        broadcastMessages.push(presence);\n                    }\n                    if (presence.connectionId === connId && !presence.isSynthesized()) {\n                        myMembers.remove(presence);\n                    }\n                    break;\n                case 'enter':\n                case 'present':\n                case 'update':\n                    if (members.put(presence)) {\n                        broadcastMessages.push(presence);\n                    }\n                    if (presence.connectionId === connId) {\n                        myMembers.put(presence);\n                    }\n                    break;\n            }\n        }\n        /* if this is the last (or only) message in a sequence of sync updates, end the sync */\n        if (isSync && !syncCursor) {\n            members.endSync();\n            this.channel.syncChannelSerial = null;\n        }\n        /* broadcast to listeners */\n        for (var i = 0; i < broadcastMessages.length; i++) {\n            var presence = broadcastMessages[i];\n            this.subscriptions.emit(presence.action, presence);\n        }\n    };\n    RealtimePresence.prototype.onAttached = function (hasPresence) {\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimePresence.onAttached()', 'channel = ' + this.channel.name + ', hasPresence = ' + hasPresence);\n        if (hasPresence) {\n            this.members.startSync();\n        }\n        else {\n            this._synthesizeLeaves(this.members.values());\n            this.members.clear();\n        }\n        // RTP17f: Re-enter own members when moving into the attached state.\n        this._ensureMyMembersPresent();\n        /* NB this must be after the _ensureMyMembersPresent call, which may add items to pendingPresence */\n        var pendingPresence = this.pendingPresence, pendingPresCount = pendingPresence.length;\n        if (pendingPresCount) {\n            this.pendingPresence = [];\n            var presenceArray = [];\n            var multicaster = multicaster_1.default.create();\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence.onAttached', 'sending ' + pendingPresCount + ' queued presence messages');\n            for (var i = 0; i < pendingPresCount; i++) {\n                var event_1 = pendingPresence[i];\n                presenceArray.push(event_1.presence);\n                multicaster.push(event_1.callback);\n            }\n            this.channel.sendPresence(presenceArray, multicaster);\n        }\n    };\n    RealtimePresence.prototype.actOnChannelState = function (state, hasPresence, err) {\n        switch (state) {\n            case 'attached':\n                this.onAttached(hasPresence);\n                break;\n            case 'detached':\n            case 'failed':\n                this._clearMyMembers();\n                this.members.clear();\n            /* falls through */\n            case 'suspended':\n                this.failPendingPresence(err);\n                break;\n        }\n    };\n    RealtimePresence.prototype.failPendingPresence = function (err) {\n        if (this.pendingPresence.length) {\n            logger_1.default.logAction(logger_1.default.LOG_MINOR, 'RealtimeChannel.failPendingPresence', 'channel; name = ' + this.channel.name + ', err = ' + Utils.inspectError(err));\n            for (var i = 0; i < this.pendingPresence.length; i++)\n                try {\n                    this.pendingPresence[i].callback(err);\n                    // eslint-disable-next-line no-empty\n                }\n                catch (e) { }\n            this.pendingPresence = [];\n        }\n    };\n    RealtimePresence.prototype._clearMyMembers = function () {\n        this._myMembers.clear();\n    };\n    RealtimePresence.prototype._ensureMyMembersPresent = function () {\n        var _this = this;\n        var myMembers = this._myMembers, reenterCb = function (err) {\n            if (err) {\n                var msg = 'Presence auto-re-enter failed: ' + err.toString();\n                var wrappedErr = new errorinfo_1.default(msg, 91004, 400);\n                logger_1.default.logAction(logger_1.default.LOG_ERROR, 'RealtimePresence._ensureMyMembersPresent()', msg);\n                var change = new channelstatechange_1.default(_this.channel.state, _this.channel.state, true, false, wrappedErr);\n                _this.channel.emit('update', change);\n            }\n        };\n        for (var memberKey in myMembers.map) {\n            var entry = myMembers.map[memberKey];\n            logger_1.default.logAction(logger_1.default.LOG_MICRO, 'RealtimePresence._ensureMyMembersPresent()', 'Auto-reentering clientId \"' + entry.clientId + '\" into the presence set');\n            // RTP17g: Send ENTER containing the member id, clientId and data\n            // attributes.\n            this._enterOrUpdateClient(entry.id, entry.clientId, entry.data, 'enter', reenterCb);\n        }\n    };\n    RealtimePresence.prototype._synthesizeLeaves = function (items) {\n        var subscriptions = this.subscriptions;\n        Utils.arrForEach(items, function (item) {\n            var presence = presencemessage_1.default.fromValues({\n                action: 'leave',\n                connectionId: item.connectionId,\n                clientId: item.clientId,\n                data: item.data,\n                encoding: item.encoding,\n                timestamp: Utils.now(),\n            });\n            subscriptions.emit('leave', presence);\n        });\n    };\n    /* Deprecated */\n    RealtimePresence.prototype.on = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        logger_1.default.deprecated('presence.on', 'presence.subscribe');\n        this.subscribe.apply(this, args);\n    };\n    /* Deprecated */\n    RealtimePresence.prototype.off = function () {\n        var args = [];\n        for (var _i = 0; _i < arguments.length; _i++) {\n            args[_i] = arguments[_i];\n        }\n        logger_1.default.deprecated('presence.off', 'presence.unsubscribe');\n        this.unsubscribe.apply(this, args);\n    };\n    RealtimePresence.prototype.subscribe = function () {\n        var _args = []; /* [event], listener, [callback] */\n        for (var _i = 0 /* [event], listener, [callback] */; _i < arguments.length /* [event], listener, [callback] */; _i++ /* [event], listener, [callback] */) {\n            _args[_i] = arguments[_i]; /* [event], listener, [callback] */\n        }\n        var args = realtimechannel_1.default.processListenerArgs(_args);\n        var event = args[0];\n        var listener = args[1];\n        var callback = args[2];\n        var channel = this.channel;\n        if (!callback) {\n            if (this.channel.realtime.options.promises) {\n                return Utils.promisify(this, 'subscribe', [event, listener]);\n            }\n            callback = noop;\n        }\n        if (channel.state === 'failed') {\n            callback(errorinfo_1.default.fromValues(channel.invalidStateError()));\n            return;\n        }\n        this.subscriptions.on(event, listener);\n        channel.attach(callback);\n    };\n    RealtimePresence.prototype.unsubscribe = function () {\n        var _args = []; /* [event], listener */\n        for (var _i = 0 /* [event], listener */; _i < arguments.length /* [event], listener */; _i++ /* [event], listener */) {\n            _args[_i] = arguments[_i]; /* [event], listener */\n        }\n        var args = realtimechannel_1.default.processListenerArgs(_args);\n        var event = args[0];\n        var listener = args[1];\n        this.subscriptions.off(event, listener);\n    };\n    return RealtimePresence;\n}(presence_1.default));\nvar PresenceMap = /** @class */ (function (_super) {\n    tslib_1.__extends(PresenceMap, _super);\n    function PresenceMap(presence, memberKey) {\n        var _this = _super.call(this) || this;\n        _this.presence = presence;\n        _this.map = Object.create(null);\n        _this.syncInProgress = false;\n        _this.residualMembers = null;\n        _this.memberKey = memberKey;\n        return _this;\n    }\n    PresenceMap.prototype.get = function (key) {\n        return this.map[key];\n    };\n    PresenceMap.prototype.getClient = function (clientId) {\n        var map = this.map, result = [];\n        for (var key in map) {\n            var item = map[key];\n            if (item.clientId == clientId && item.action != 'absent')\n                result.push(item);\n        }\n        return result;\n    };\n    PresenceMap.prototype.list = function (params) {\n        var map = this.map, clientId = params && params.clientId, connectionId = params && params.connectionId, result = [];\n        for (var key in map) {\n            var item = map[key];\n            if (item.action === 'absent')\n                continue;\n            if (clientId && clientId != item.clientId)\n                continue;\n            if (connectionId && connectionId != item.connectionId)\n                continue;\n            result.push(item);\n        }\n        return result;\n    };\n    PresenceMap.prototype.put = function (item) {\n        if (item.action === 'enter' || item.action === 'update') {\n            item = presencemessage_1.default.fromValues(item);\n            item.action = 'present';\n        }\n        var map = this.map, key = this.memberKey(item);\n        /* we've seen this member, so do not remove it at the end of sync */\n        if (this.residualMembers)\n            delete this.residualMembers[key];\n        /* compare the timestamp of the new item with any existing member (or ABSENT witness) */\n        var existingItem = map[key];\n        if (existingItem && !newerThan(item, existingItem)) {\n            return false;\n        }\n        map[key] = item;\n        return true;\n    };\n    PresenceMap.prototype.values = function () {\n        var map = this.map, result = [];\n        for (var key in map) {\n            var item = map[key];\n            if (item.action != 'absent')\n                result.push(item);\n        }\n        return result;\n    };\n    PresenceMap.prototype.remove = function (item) {\n        var map = this.map, key = this.memberKey(item);\n        var existingItem = map[key];\n        if (existingItem && !newerThan(item, existingItem)) {\n            return false;\n        }\n        /* RTP2f */\n        if (this.syncInProgress) {\n            item = presencemessage_1.default.fromValues(item);\n            item.action = 'absent';\n            map[key] = item;\n        }\n        else {\n            delete map[key];\n        }\n        return true;\n    };\n    PresenceMap.prototype.startSync = function () {\n        var map = this.map, syncInProgress = this.syncInProgress;\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'PresenceMap.startSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);\n        /* we might be called multiple times while a sync is in progress */\n        if (!this.syncInProgress) {\n            this.residualMembers = Utils.copy(map);\n            this.setInProgress(true);\n        }\n    };\n    PresenceMap.prototype.endSync = function () {\n        var map = this.map, syncInProgress = this.syncInProgress;\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'PresenceMap.endSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);\n        if (syncInProgress) {\n            /* we can now strip out the ABSENT members, as we have\n             * received all of the out-of-order sync messages */\n            for (var memberKey in map) {\n                var entry = map[memberKey];\n                if (entry.action === 'absent') {\n                    delete map[memberKey];\n                }\n            }\n            /* any members that were present at the start of the sync,\n             * and have not been seen in sync, can be removed, and leave events emitted */\n            this.presence._synthesizeLeaves(Utils.valuesArray(this.residualMembers));\n            for (var memberKey in this.residualMembers) {\n                delete map[memberKey];\n            }\n            this.residualMembers = null;\n            /* finish, notifying any waiters */\n            this.setInProgress(false);\n        }\n        this.emit('sync');\n    };\n    PresenceMap.prototype.waitSync = function (callback) {\n        var syncInProgress = this.syncInProgress;\n        logger_1.default.logAction(logger_1.default.LOG_MINOR, 'PresenceMap.waitSync()', 'channel = ' + this.presence.channel.name + '; syncInProgress = ' + syncInProgress);\n        if (!syncInProgress) {\n            callback();\n            return;\n        }\n        this.once('sync', callback);\n    };\n    PresenceMap.prototype.clear = function () {\n        this.map = {};\n        this.setInProgress(false);\n        this.residualMembers = null;\n    };\n    PresenceMap.prototype.setInProgress = function (inProgress) {\n        logger_1.default.logAction(logger_1.default.LOG_MICRO, 'PresenceMap.setInProgress()', 'inProgress = ' + inProgress);\n        this.syncInProgress = inProgress;\n        this.presence.syncComplete = !inProgress;\n    };\n    return PresenceMap;\n}(eventemitter_1.default));\nexports.default = RealtimePresence;\n\n\n/***/ }),\n/* 55 */\n/***/ (function(module, exports, __nested_webpack_require_548181__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_548181__(0);\nvar enc_hex_1 = __nested_webpack_require_548181__(56);\nvar enc_utf8_1 = __nested_webpack_require_548181__(31);\nvar enc_base64_1 = __nested_webpack_require_548181__(11);\nvar lib_typedarrays_1 = tslib_1.__importDefault(__nested_webpack_require_548181__(5));\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_548181__(3));\nvar BufferUtils = /** @class */ (function () {\n    function BufferUtils() {\n        this.base64CharSet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';\n        this.hexCharSet = '0123456789abcdef';\n    }\n    BufferUtils.prototype.isWordArray = function (ob) {\n        return ob !== null && ob !== undefined && ob.sigBytes !== undefined;\n    };\n    BufferUtils.prototype.isArrayBuffer = function (ob) {\n        return ob !== null && ob !== undefined && ob.constructor === ArrayBuffer;\n    };\n    BufferUtils.prototype.isTypedArray = function (ob) {\n        return !!ArrayBuffer && ArrayBuffer.isView && ArrayBuffer.isView(ob);\n    };\n    // // https://gist.githubusercontent.com/jonleighton/958841/raw/f200e30dfe95212c0165ccf1ae000ca51e9de803/gistfile1.js\n    BufferUtils.prototype.uint8ViewToBase64 = function (bytes) {\n        var base64 = '';\n        var encodings = this.base64CharSet;\n        var byteLength = bytes.byteLength;\n        var byteRemainder = byteLength % 3;\n        var mainLength = byteLength - byteRemainder;\n        var a, b, c, d;\n        var chunk;\n        // Main loop deals with bytes in chunks of 3\n        for (var i = 0; i < mainLength; i = i + 3) {\n            // Combine the three bytes into a single integer\n            chunk = (bytes[i] << 16) | (bytes[i + 1] << 8) | bytes[i + 2];\n            // Use bitmasks to extract 6-bit segments from the triplet\n            a = (chunk & 16515072) >> 18; // 16515072 = (2^6 - 1) << 18\n            b = (chunk & 258048) >> 12; // 258048   = (2^6 - 1) << 12\n            c = (chunk & 4032) >> 6; // 4032     = (2^6 - 1) << 6\n            d = chunk & 63; // 63       = 2^6 - 1\n            // Convert the raw binary segments to the appropriate ASCII encoding\n            base64 += encodings[a] + encodings[b] + encodings[c] + encodings[d];\n        }\n        // Deal with the remaining bytes and padding\n        if (byteRemainder == 1) {\n            chunk = bytes[mainLength];\n            a = (chunk & 252) >> 2; // 252 = (2^6 - 1) << 2\n            // Set the 4 least significant bits to zero\n            b = (chunk & 3) << 4; // 3   = 2^2 - 1\n            base64 += encodings[a] + encodings[b] + '==';\n        }\n        else if (byteRemainder == 2) {\n            chunk = (bytes[mainLength] << 8) | bytes[mainLength + 1];\n            a = (chunk & 64512) >> 10; // 64512 = (2^6 - 1) << 10\n            b = (chunk & 1008) >> 4; // 1008  = (2^6 - 1) << 4\n            // Set the 2 least significant bits to zero\n            c = (chunk & 15) << 2; // 15    = 2^4 - 1\n            base64 += encodings[a] + encodings[b] + encodings[c] + '=';\n        }\n        return base64;\n    };\n    BufferUtils.prototype.base64ToArrayBuffer = function (base64) {\n        var binary_string = atob === null || atob === void 0 ? void 0 : atob(base64); // this will always be defined in browser so it's safe to cast\n        var len = binary_string.length;\n        var bytes = new Uint8Array(len);\n        for (var i = 0; i < len; i++) {\n            var ascii = binary_string.charCodeAt(i);\n            bytes[i] = ascii;\n        }\n        return bytes.buffer;\n    };\n    BufferUtils.prototype.isBuffer = function (buffer) {\n        return this.isArrayBuffer(buffer) || this.isWordArray(buffer) || this.isTypedArray(buffer);\n    };\n    /* In browsers, returns a Uint8Array */\n    BufferUtils.prototype.toBuffer = function (buffer) {\n        if (!ArrayBuffer) {\n            throw new Error(\"Can't convert to Buffer: browser does not support the necessary types\");\n        }\n        if (this.isArrayBuffer(buffer)) {\n            return new Uint8Array(buffer);\n        }\n        if (this.isTypedArray(buffer)) {\n            return new Uint8Array(buffer.buffer);\n        }\n        if (this.isWordArray(buffer)) {\n            /* Backported from unreleased CryptoJS\n             * https://code.google.com/p/crypto-js/source/browse/branches/3.x/src/lib-typedarrays.js?r=661 */\n            var arrayBuffer = new ArrayBuffer(buffer.sigBytes);\n            var uint8View = new Uint8Array(arrayBuffer);\n            for (var i = 0; i < buffer.sigBytes; i++) {\n                uint8View[i] = (buffer.words[i >>> 2] >>> (24 - (i % 4) * 8)) & 0xff;\n            }\n            return uint8View;\n        }\n        throw new Error('BufferUtils.toBuffer expected an arraybuffer, typed array, or CryptoJS wordarray');\n    };\n    BufferUtils.prototype.toArrayBuffer = function (buffer) {\n        if (this.isArrayBuffer(buffer)) {\n            return buffer;\n        }\n        return this.toBuffer(buffer).buffer;\n    };\n    BufferUtils.prototype.toWordArray = function (buffer) {\n        if (this.isTypedArray(buffer)) {\n            buffer = buffer.buffer;\n        }\n        return this.isWordArray(buffer) ? buffer : lib_typedarrays_1.default.create(buffer);\n    };\n    BufferUtils.prototype.base64Encode = function (buffer) {\n        if (this.isWordArray(buffer)) {\n            return (0, enc_base64_1.stringify)(buffer);\n        }\n        return this.uint8ViewToBase64(this.toBuffer(buffer));\n    };\n    BufferUtils.prototype.base64Decode = function (str) {\n        if (ArrayBuffer && platform_1.default.Config.atob) {\n            return this.base64ToArrayBuffer(str);\n        }\n        return (0, enc_base64_1.parse)(str);\n    };\n    BufferUtils.prototype.hexEncode = function (buffer) {\n        return (0, enc_hex_1.stringify)(this.toWordArray(buffer));\n    };\n    BufferUtils.prototype.hexDecode = function (string) {\n        var wordArray = (0, enc_hex_1.parse)(string);\n        return ArrayBuffer ? this.toArrayBuffer(wordArray) : wordArray;\n    };\n    BufferUtils.prototype.utf8Encode = function (string) {\n        if (platform_1.default.Config.TextEncoder) {\n            return new platform_1.default.Config.TextEncoder().encode(string).buffer;\n        }\n        return (0, enc_utf8_1.parse)(string);\n    };\n    /* For utf8 decoding we apply slightly stricter input validation than to\n     * hexEncode/base64Encode/etc: in those we accept anything that Buffer.from\n     * can take (in particular allowing strings, which are just interpreted as\n     * binary); here we ensure that the input is actually a buffer since trying\n     * to utf8-decode a string to another string is almost certainly a mistake */\n    BufferUtils.prototype.utf8Decode = function (buffer) {\n        if (!this.isBuffer(buffer)) {\n            throw new Error('Expected input of utf8decode to be an arraybuffer, typed array, or CryptoJS wordarray');\n        }\n        if (TextDecoder && !this.isWordArray(buffer)) {\n            return new TextDecoder().decode(buffer);\n        }\n        buffer = this.toWordArray(buffer);\n        return (0, enc_utf8_1.stringify)(buffer);\n    };\n    BufferUtils.prototype.bufferCompare = function (buffer1, buffer2) {\n        if (!buffer1)\n            return -1;\n        if (!buffer2)\n            return 1;\n        var wordArray1 = this.toWordArray(buffer1);\n        var wordArray2 = this.toWordArray(buffer2);\n        wordArray1.clamp();\n        wordArray2.clamp();\n        var cmp = wordArray1.sigBytes - wordArray2.sigBytes;\n        if (cmp != 0)\n            return cmp;\n        var words1 = wordArray1.words;\n        var words2 = wordArray2.words;\n        for (var i = 0; i < words1.length; i++) {\n            cmp = words1[i] - words2[i];\n            if (cmp != 0)\n                return cmp;\n        }\n        return 0;\n    };\n    BufferUtils.prototype.byteLength = function (buffer) {\n        if (this.isArrayBuffer(buffer) || this.isTypedArray(buffer)) {\n            return buffer.byteLength;\n        }\n        else if (this.isWordArray(buffer)) {\n            return buffer.sigBytes;\n        }\n        return -1;\n    };\n    /* Returns ArrayBuffer on browser and Buffer on Node.js */\n    BufferUtils.prototype.typedArrayToBuffer = function (typedArray) {\n        return typedArray.buffer;\n    };\n    return BufferUtils;\n}());\nexports.default = new BufferUtils();\n\n\n/***/ }),\n/* 56 */\n/***/ (function(module, exports, __nested_webpack_require_556556__) {\n\n;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__nested_webpack_require_556556__(6));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\treturn CryptoJS.enc.Hex;\n\n}));\n\n/***/ }),\n/* 57 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_556838__) {\n\n\"use strict\";\n__nested_webpack_require_556838__.r(__webpack_exports__);\n/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0__ = __nested_webpack_require_556838__(5);\n/* harmony import */ var crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__nested_webpack_require_556838__.n(crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__ = __nested_webpack_require_556838__(11);\n/* harmony import */ var crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__nested_webpack_require_556838__.n(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var crypto_js_build__WEBPACK_IMPORTED_MODULE_2__ = __nested_webpack_require_556838__(22);\n/* harmony import */ var crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__nested_webpack_require_556838__.n(crypto_js_build__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3__ = __nested_webpack_require_556838__(2);\n/* harmony import */ var _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__nested_webpack_require_556838__.n(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_4__ = __nested_webpack_require_556838__(4);\n/* harmony import */ var common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__nested_webpack_require_556838__.n(common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_4__);\n\n\n\n\n\n\nvar CryptoFactory = function (config, bufferUtils) {\n  var DEFAULT_ALGORITHM = 'aes';\n  var DEFAULT_KEYLENGTH = 256; // bits\n  var DEFAULT_MODE = 'cbc';\n  var DEFAULT_BLOCKLENGTH = 16; // bytes\n  var DEFAULT_BLOCKLENGTH_WORDS = 4; // 32-bit words\n  var UINT32_SUP = 0x100000000;\n  var INT32_SUP = 0x80000000;\n\n  /**\n   * Internal: generate an array of secure random words corresponding to the given length of bytes\n   * @param bytes\n   * @param callback\n   */\n  var generateRandom;\n  if (config.getRandomWordArray) {\n    generateRandom = config.getRandomWordArray;\n  } else if (typeof Uint32Array !== 'undefined' && config.getRandomValues) {\n    var blockRandomArray = new Uint32Array(DEFAULT_BLOCKLENGTH_WORDS);\n    generateRandom = function (bytes, callback) {\n      var words = bytes / 4,\n        nativeArray = words == DEFAULT_BLOCKLENGTH_WORDS ? blockRandomArray : new Uint32Array(words);\n      config.getRandomValues(nativeArray, function (err) {\n        if (typeof callback !== 'undefined') {\n          callback(err, bufferUtils.toWordArray(nativeArray));\n        }\n      });\n    };\n  } else {\n    generateRandom = function (bytes, callback) {\n      _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.logAction(\n        _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.LOG_MAJOR,\n        'Ably.Crypto.generateRandom()',\n        'Warning: the browser you are using does not support secure cryptographically secure randomness generation; falling back to insecure Math.random()'\n      );\n      var words = bytes / 4,\n        array = new Array(words);\n      for (var i = 0; i < words; i++) {\n        /* cryptojs wordarrays use signed ints. When WordArray.create is fed a\n         * Uint32Array unsigned are converted to signed automatically, but when\n         * fed a normal array they aren't, so need to do so ourselves by\n         * subtracting INT32_SUP */\n        array[i] = Math.floor(Math.random() * UINT32_SUP) - INT32_SUP;\n      }\n\n      callback(null, crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(array));\n    };\n  }\n\n  /**\n   * Internal: calculate the padded length of a given plaintext\n   * using PKCS5.\n   * @param plaintextLength\n   * @return\n   */\n  function getPaddedLength(plaintextLength) {\n    return (plaintextLength + DEFAULT_BLOCKLENGTH) & -DEFAULT_BLOCKLENGTH;\n  }\n\n  /**\n   * Internal: checks that the cipherParams are a valid combination. Currently\n   * just checks that the calculated keyLength is a valid one for aes-cbc\n   */\n  function validateCipherParams(params) {\n    if (params.algorithm === 'aes' && params.mode === 'cbc') {\n      if (params.keyLength === 128 || params.keyLength === 256) {\n        return;\n      }\n      throw new Error(\n        'Unsupported key length ' +\n          params.keyLength +\n          ' for aes-cbc encryption. Encryption key must be 128 or 256 bits (16 or 32 ASCII characters)'\n      );\n    }\n  }\n\n  function normaliseBase64(string) {\n    /* url-safe base64 strings use _ and - instread of / and + */\n    return string.replace('_', '/').replace('-', '+');\n  }\n\n  /**\n   * Internal: obtain the pkcs5 padding string for a given padded length;\n   */\n  var pkcs5Padding = [\n    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x10101010, 0x10101010, 0x10101010, 0x10101010], 16),\n    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x01000000], 1),\n    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x02020000], 2),\n    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x03030300], 3),\n    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x04040404], 4),\n    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x05050505, 0x05000000], 5),\n    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x06060606, 0x06060000], 6),\n    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x07070707, 0x07070700], 7),\n    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x08080808, 0x08080808], 8),\n    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x09090909, 0x09090909, 0x09000000], 9),\n    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0a0a0a0a, 0x0a0a0a0a, 0x0a0a0000], 10),\n    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0b0b0b0b, 0x0b0b0b0b, 0x0b0b0b00], 11),\n    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0c0c0c0c, 0x0c0c0c0c, 0x0c0c0c0c], 12),\n    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0d0d0d0d, 0x0d0d0d0d, 0x0d0d0d0d, 0x0d000000], 13),\n    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0e0e0e0e, 0x0e0e0e0e, 0x0e0e0e0e, 0x0e0e0000], 14),\n    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f, 0x0f0f0f0f], 15),\n    crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create([0x10101010, 0x10101010, 0x10101010, 0x10101010], 16),\n  ];\n\n  /**\n   * Utility classes and interfaces for message payload encryption.\n   *\n   * This class supports AES/CBC/PKCS5 with a default keylength of 128 bits\n   * but supporting other keylengths. Other algorithms and chaining modes are\n   * not supported directly, but supportable by extending/implementing the base\n   * classes and interfaces here.\n   *-\n   * Secure random data for creation of Initialization Vectors (IVs) and keys\n   * is obtained from window.crypto.getRandomValues if available, or from\n   * Math.random() if not. Clients who do not want to depend on Math.random()\n   * should polyfill window.crypto.getRandomValues with a library that seeds\n   * a PRNG with real entropy.\n   *\n   * Each message payload is encrypted with an IV in CBC mode, and the IV is\n   * concatenated with the resulting raw ciphertext to construct the \"ciphertext\"\n   * data passed to the recipient.\n   */\n  function Crypto() {}\n\n  /**\n   * A class encapsulating the client-specifiable parameters for\n   * the cipher.\n   *\n   * algorithm is the name of the algorithm in the default system provider,\n   * or the lower-cased version of it; eg \"aes\" or \"AES\".\n   *\n   * Clients are recommended to not call this directly, but instead to use the\n   * Crypto.getDefaultParams helper, which will fill in any fields not supplied\n   * with default values and validation the result.\n   */\n  function CipherParams() {\n    this.algorithm = null;\n    this.keyLength = null;\n    this.mode = null;\n    this.key = null;\n  }\n  Crypto.CipherParams = CipherParams;\n\n  /**\n   * Obtain a complete CipherParams instance from the provided params, filling\n   * in any not provided with default values, calculating a keyLength from\n   * the supplied key, and validating the result.\n   * @param params an object containing at a minimum a `key` key with value the\n   * key, as either a binary (ArrayBuffer, Array, WordArray) or a\n   * base64-encoded string. May optionally also contain: algorithm (defaults to\n   * AES), mode (defaults to 'cbc')\n   */\n  Crypto.getDefaultParams = function (params) {\n    var key;\n    /* Backward compatibility */\n    if (typeof params === 'function' || typeof params === 'string') {\n      _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.deprecated('Crypto.getDefaultParams(key, callback)', 'Crypto.getDefaultParams({key: key})');\n      if (typeof params === 'function') {\n        Crypto.generateRandomKey(function (key) {\n          params(null, Crypto.getDefaultParams({ key: key }));\n        });\n      } else if (typeof arguments[1] === 'function') {\n        arguments[1](null, Crypto.getDefaultParams({ key: params }));\n      } else {\n        throw new Error('Invalid arguments for Crypto.getDefaultParams');\n      }\n      return;\n    }\n\n    if (!params.key) {\n      throw new Error('Crypto.getDefaultParams: a key is required');\n    }\n\n    if (typeof params.key === 'string') {\n      key = Object(crypto_js_build_enc_base64__WEBPACK_IMPORTED_MODULE_1__[\"parse\"])(normaliseBase64(params.key));\n    } else {\n      key = bufferUtils.toWordArray(params.key); // Expect key to be an Array, ArrayBuffer, or WordArray at this point\n    }\n\n    var cipherParams = new CipherParams();\n    cipherParams.key = key;\n    cipherParams.algorithm = params.algorithm || DEFAULT_ALGORITHM;\n    cipherParams.keyLength = key.words.length * (4 * 8);\n    cipherParams.mode = params.mode || DEFAULT_MODE;\n\n    if (params.keyLength && params.keyLength !== cipherParams.keyLength) {\n      throw new Error(\n        'Crypto.getDefaultParams: a keyLength of ' +\n          params.keyLength +\n          ' was specified, but the key actually has length ' +\n          cipherParams.keyLength\n      );\n    }\n\n    validateCipherParams(cipherParams);\n    return cipherParams;\n  };\n\n  /**\n   * Generate a random encryption key from the supplied keylength (or the\n   * default keyLength if none supplied) as a CryptoJS WordArray\n   * @param keyLength (optional) the required keyLength in bits\n   * @param callback (optional) (err, key)\n   */\n  Crypto.generateRandomKey = function (keyLength, callback) {\n    if (arguments.length == 1 && typeof keyLength == 'function') {\n      callback = keyLength;\n      keyLength = undefined;\n    }\n\n    generateRandom((keyLength || DEFAULT_KEYLENGTH) / 8, function (err, buf) {\n      if (callback !== undefined) {\n        callback(err ? common_lib_types_errorinfo__WEBPACK_IMPORTED_MODULE_4___default.a.fromValues(err) : null, buf);\n      }\n    });\n  };\n\n  /**\n   * Internal; get a ChannelCipher instance based on the given cipherParams\n   * @param params either a CipherParams instance or some subset of its\n   * fields that includes a key\n   */\n  Crypto.getCipher = function (params) {\n    var cipherParams = params instanceof CipherParams ? params : Crypto.getDefaultParams(params);\n\n    return { cipherParams: cipherParams, cipher: new CBCCipher(cipherParams, DEFAULT_BLOCKLENGTH_WORDS, params.iv) };\n  };\n\n  function CBCCipher(params, blockLengthWords, iv) {\n    this.algorithm = params.algorithm + '-' + String(params.keyLength) + '-' + params.mode;\n    this.cjsAlgorithm = params.algorithm.toUpperCase().replace(/-\\d+$/, '');\n    this.key = bufferUtils.toWordArray(params.key);\n    if (iv) {\n      this.iv = bufferUtils.toWordArray(iv).clone();\n    }\n    this.blockLengthWords = blockLengthWords;\n  }\n\n  CBCCipher.prototype.encrypt = function (plaintext, callback) {\n    _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.LOG_MICRO, 'CBCCipher.encrypt()', '');\n    plaintext = bufferUtils.toWordArray(plaintext);\n    var plaintextLength = plaintext.sigBytes,\n      paddedLength = getPaddedLength(plaintextLength),\n      self = this;\n\n    var then = function () {\n      self.getIv(function (err, iv) {\n        if (err) {\n          callback(err);\n          return;\n        }\n        var cipherOut = self.encryptCipher.process(plaintext.concat(pkcs5Padding[paddedLength - plaintextLength]));\n        var ciphertext = iv.concat(cipherOut);\n        callback(null, ciphertext);\n      });\n    };\n\n    if (!this.encryptCipher) {\n      if (this.iv) {\n        this.encryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[this.cjsAlgorithm].createEncryptor(this.key, { iv: this.iv });\n        then();\n      } else {\n        generateRandom(DEFAULT_BLOCKLENGTH, function (err, iv) {\n          if (err) {\n            callback(err);\n            return;\n          }\n          self.encryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[self.cjsAlgorithm].createEncryptor(self.key, { iv: iv });\n          self.iv = iv;\n          then();\n        });\n      }\n    } else {\n      then();\n    }\n  };\n\n  CBCCipher.prototype.decrypt = function (ciphertext) {\n    _common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.logAction(_common_lib_util_logger__WEBPACK_IMPORTED_MODULE_3___default.a.LOG_MICRO, 'CBCCipher.decrypt()', '');\n    ciphertext = bufferUtils.toWordArray(ciphertext);\n    var blockLengthWords = this.blockLengthWords,\n      ciphertextWords = ciphertext.words,\n      iv = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(ciphertextWords.slice(0, blockLengthWords)),\n      ciphertextBody = crypto_js_build_lib_typedarrays__WEBPACK_IMPORTED_MODULE_0___default.a.create(ciphertextWords.slice(blockLengthWords));\n\n    var decryptCipher = crypto_js_build__WEBPACK_IMPORTED_MODULE_2___default.a.algo[this.cjsAlgorithm].createDecryptor(this.key, { iv: iv });\n    var plaintext = decryptCipher.process(ciphertextBody);\n    var epilogue = decryptCipher.finalize();\n    decryptCipher.reset();\n    if (epilogue && epilogue.sigBytes) plaintext.concat(epilogue);\n    return plaintext;\n  };\n\n  CBCCipher.prototype.getIv = function (callback) {\n    if (this.iv) {\n      var iv = this.iv;\n      this.iv = null;\n      callback(null, iv);\n      return;\n    }\n\n    /* Since the iv for a new block is the ciphertext of the last, this\n     * sets a new iv (= aes(randomBlock XOR lastCipherText)) as well as\n     * returning it */\n    var self = this;\n    generateRandom(DEFAULT_BLOCKLENGTH, function (err, randomBlock) {\n      if (err) {\n        callback(err);\n        return;\n      }\n      callback(null, self.encryptCipher.process(randomBlock));\n    });\n  };\n\n  return Crypto;\n};\n\n/* harmony default export */ __webpack_exports__[\"default\"] = (CryptoFactory);\n\n\n/***/ }),\n/* 58 */\n/***/ (function(module, exports, __nested_webpack_require_572055__) {\n\n;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__nested_webpack_require_572055__(6));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var C_enc = C.enc;\n\n\t    /**\n\t     * UTF-16 BE encoding strategy.\n\t     */\n\t    var Utf16BE = C_enc.Utf16 = C_enc.Utf16BE = {\n\t        /**\n\t         * Converts a word array to a UTF-16 BE string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-16 BE string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf16String = CryptoJS.enc.Utf16.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var utf16Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 2) {\n\t                var codePoint = (words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff;\n\t                utf16Chars.push(String.fromCharCode(codePoint));\n\t            }\n\n\t            return utf16Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a UTF-16 BE string to a word array.\n\t         *\n\t         * @param {string} utf16Str The UTF-16 BE string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf16.parse(utf16String);\n\t         */\n\t        parse: function (utf16Str) {\n\t            // Shortcut\n\t            var utf16StrLength = utf16Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < utf16StrLength; i++) {\n\t                words[i >>> 1] |= utf16Str.charCodeAt(i) << (16 - (i % 2) * 16);\n\t            }\n\n\t            return WordArray.create(words, utf16StrLength * 2);\n\t        }\n\t    };\n\n\t    /**\n\t     * UTF-16 LE encoding strategy.\n\t     */\n\t    C_enc.Utf16LE = {\n\t        /**\n\t         * Converts a word array to a UTF-16 LE string.\n\t         *\n\t         * @param {WordArray} wordArray The word array.\n\t         *\n\t         * @return {string} The UTF-16 LE string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var utf16Str = CryptoJS.enc.Utf16LE.stringify(wordArray);\n\t         */\n\t        stringify: function (wordArray) {\n\t            // Shortcuts\n\t            var words = wordArray.words;\n\t            var sigBytes = wordArray.sigBytes;\n\n\t            // Convert\n\t            var utf16Chars = [];\n\t            for (var i = 0; i < sigBytes; i += 2) {\n\t                var codePoint = swapEndian((words[i >>> 2] >>> (16 - (i % 4) * 8)) & 0xffff);\n\t                utf16Chars.push(String.fromCharCode(codePoint));\n\t            }\n\n\t            return utf16Chars.join('');\n\t        },\n\n\t        /**\n\t         * Converts a UTF-16 LE string to a word array.\n\t         *\n\t         * @param {string} utf16Str The UTF-16 LE string.\n\t         *\n\t         * @return {WordArray} The word array.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var wordArray = CryptoJS.enc.Utf16LE.parse(utf16Str);\n\t         */\n\t        parse: function (utf16Str) {\n\t            // Shortcut\n\t            var utf16StrLength = utf16Str.length;\n\n\t            // Convert\n\t            var words = [];\n\t            for (var i = 0; i < utf16StrLength; i++) {\n\t                words[i >>> 1] |= swapEndian(utf16Str.charCodeAt(i) << (16 - (i % 2) * 16));\n\t            }\n\n\t            return WordArray.create(words, utf16StrLength * 2);\n\t        }\n\t    };\n\n\t    function swapEndian(word) {\n\t        return ((word << 8) & 0xff00ff00) | ((word >>> 8) & 0x00ff00ff);\n\t    }\n\t}());\n\n\n\treturn CryptoJS.enc.Utf16;\n\n}));\n\n/***/ }),\n/* 59 */\n/***/ (function(module, exports, __nested_webpack_require_576052__) {\n\n;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__nested_webpack_require_576052__(6), __nested_webpack_require_576052__(28));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function (undefined) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var CipherParams = C_lib.CipherParams;\n\t    var C_enc = C.enc;\n\t    var Hex = C_enc.Hex;\n\t    var C_format = C.format;\n\n\t    var HexFormatter = C_format.Hex = {\n\t        /**\n\t         * Converts the ciphertext of a cipher params object to a hexadecimally encoded string.\n\t         *\n\t         * @param {CipherParams} cipherParams The cipher params object.\n\t         *\n\t         * @return {string} The hexadecimally encoded string.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var hexString = CryptoJS.format.Hex.stringify(cipherParams);\n\t         */\n\t        stringify: function (cipherParams) {\n\t            return cipherParams.ciphertext.toString(Hex);\n\t        },\n\n\t        /**\n\t         * Converts a hexadecimally encoded ciphertext string to a cipher params object.\n\t         *\n\t         * @param {string} input The hexadecimally encoded string.\n\t         *\n\t         * @return {CipherParams} The cipher params object.\n\t         *\n\t         * @static\n\t         *\n\t         * @example\n\t         *\n\t         *     var cipherParams = CryptoJS.format.Hex.parse(hexString);\n\t         */\n\t        parse: function (input) {\n\t            var ciphertext = Hex.parse(input);\n\t            return CipherParams.create({ ciphertext: ciphertext });\n\t        }\n\t    };\n\t}());\n\n\n\treturn CryptoJS.format.Hex;\n\n}));\n\n/***/ }),\n/* 60 */\n/***/ (function(module, exports, __nested_webpack_require_577760__) {\n\n;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__nested_webpack_require_577760__(6), __nested_webpack_require_577760__(11), __nested_webpack_require_577760__(61), __nested_webpack_require_577760__(27), __nested_webpack_require_577760__(28));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function () {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var BlockCipher = C_lib.BlockCipher;\n\t    var C_algo = C.algo;\n\n\t    // Lookup tables\n\t    var SBOX = [];\n\t    var INV_SBOX = [];\n\t    var SUB_MIX_0 = [];\n\t    var SUB_MIX_1 = [];\n\t    var SUB_MIX_2 = [];\n\t    var SUB_MIX_3 = [];\n\t    var INV_SUB_MIX_0 = [];\n\t    var INV_SUB_MIX_1 = [];\n\t    var INV_SUB_MIX_2 = [];\n\t    var INV_SUB_MIX_3 = [];\n\n\t    // Compute lookup tables\n\t    (function () {\n\t        // Compute double table\n\t        var d = [];\n\t        for (var i = 0; i < 256; i++) {\n\t            if (i < 128) {\n\t                d[i] = i << 1;\n\t            } else {\n\t                d[i] = (i << 1) ^ 0x11b;\n\t            }\n\t        }\n\n\t        // Walk GF(2^8)\n\t        var x = 0;\n\t        var xi = 0;\n\t        for (var i = 0; i < 256; i++) {\n\t            // Compute sbox\n\t            var sx = xi ^ (xi << 1) ^ (xi << 2) ^ (xi << 3) ^ (xi << 4);\n\t            sx = (sx >>> 8) ^ (sx & 0xff) ^ 0x63;\n\t            SBOX[x] = sx;\n\t            INV_SBOX[sx] = x;\n\n\t            // Compute multiplication\n\t            var x2 = d[x];\n\t            var x4 = d[x2];\n\t            var x8 = d[x4];\n\n\t            // Compute sub bytes, mix columns tables\n\t            var t = (d[sx] * 0x101) ^ (sx * 0x1010100);\n\t            SUB_MIX_0[x] = (t << 24) | (t >>> 8);\n\t            SUB_MIX_1[x] = (t << 16) | (t >>> 16);\n\t            SUB_MIX_2[x] = (t << 8)  | (t >>> 24);\n\t            SUB_MIX_3[x] = t;\n\n\t            // Compute inv sub bytes, inv mix columns tables\n\t            var t = (x8 * 0x1010101) ^ (x4 * 0x10001) ^ (x2 * 0x101) ^ (x * 0x1010100);\n\t            INV_SUB_MIX_0[sx] = (t << 24) | (t >>> 8);\n\t            INV_SUB_MIX_1[sx] = (t << 16) | (t >>> 16);\n\t            INV_SUB_MIX_2[sx] = (t << 8)  | (t >>> 24);\n\t            INV_SUB_MIX_3[sx] = t;\n\n\t            // Compute next counter\n\t            if (!x) {\n\t                x = xi = 1;\n\t            } else {\n\t                x = x2 ^ d[d[d[x8 ^ x2]]];\n\t                xi ^= d[d[xi]];\n\t            }\n\t        }\n\t    }());\n\n\t    // Precomputed Rcon lookup\n\t    var RCON = [0x00, 0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36];\n\n\t    /**\n\t     * AES block cipher algorithm.\n\t     */\n\t    var AES = C_algo.AES = BlockCipher.extend({\n\t        _doReset: function () {\n\t            var t;\n\n\t            // Skip reset of nRounds has been set before and key did not change\n\t            if (this._nRounds && this._keyPriorReset === this._key) {\n\t                return;\n\t            }\n\n\t            // Shortcuts\n\t            var key = this._keyPriorReset = this._key;\n\t            var keyWords = key.words;\n\t            var keySize = key.sigBytes / 4;\n\n\t            // Compute number of rounds\n\t            var nRounds = this._nRounds = keySize + 6;\n\n\t            // Compute number of key schedule rows\n\t            var ksRows = (nRounds + 1) * 4;\n\n\t            // Compute key schedule\n\t            var keySchedule = this._keySchedule = [];\n\t            for (var ksRow = 0; ksRow < ksRows; ksRow++) {\n\t                if (ksRow < keySize) {\n\t                    keySchedule[ksRow] = keyWords[ksRow];\n\t                } else {\n\t                    t = keySchedule[ksRow - 1];\n\n\t                    if (!(ksRow % keySize)) {\n\t                        // Rot word\n\t                        t = (t << 8) | (t >>> 24);\n\n\t                        // Sub word\n\t                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n\n\t                        // Mix Rcon\n\t                        t ^= RCON[(ksRow / keySize) | 0] << 24;\n\t                    } else if (keySize > 6 && ksRow % keySize == 4) {\n\t                        // Sub word\n\t                        t = (SBOX[t >>> 24] << 24) | (SBOX[(t >>> 16) & 0xff] << 16) | (SBOX[(t >>> 8) & 0xff] << 8) | SBOX[t & 0xff];\n\t                    }\n\n\t                    keySchedule[ksRow] = keySchedule[ksRow - keySize] ^ t;\n\t                }\n\t            }\n\n\t            // Compute inv key schedule\n\t            var invKeySchedule = this._invKeySchedule = [];\n\t            for (var invKsRow = 0; invKsRow < ksRows; invKsRow++) {\n\t                var ksRow = ksRows - invKsRow;\n\n\t                if (invKsRow % 4) {\n\t                    var t = keySchedule[ksRow];\n\t                } else {\n\t                    var t = keySchedule[ksRow - 4];\n\t                }\n\n\t                if (invKsRow < 4 || ksRow <= 4) {\n\t                    invKeySchedule[invKsRow] = t;\n\t                } else {\n\t                    invKeySchedule[invKsRow] = INV_SUB_MIX_0[SBOX[t >>> 24]] ^ INV_SUB_MIX_1[SBOX[(t >>> 16) & 0xff]] ^\n\t                                               INV_SUB_MIX_2[SBOX[(t >>> 8) & 0xff]] ^ INV_SUB_MIX_3[SBOX[t & 0xff]];\n\t                }\n\t            }\n\t        },\n\n\t        encryptBlock: function (M, offset) {\n\t            this._doCryptBlock(M, offset, this._keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX);\n\t        },\n\n\t        decryptBlock: function (M, offset) {\n\t            // Swap 2nd and 4th rows\n\t            var t = M[offset + 1];\n\t            M[offset + 1] = M[offset + 3];\n\t            M[offset + 3] = t;\n\n\t            this._doCryptBlock(M, offset, this._invKeySchedule, INV_SUB_MIX_0, INV_SUB_MIX_1, INV_SUB_MIX_2, INV_SUB_MIX_3, INV_SBOX);\n\n\t            // Inv swap 2nd and 4th rows\n\t            var t = M[offset + 1];\n\t            M[offset + 1] = M[offset + 3];\n\t            M[offset + 3] = t;\n\t        },\n\n\t        _doCryptBlock: function (M, offset, keySchedule, SUB_MIX_0, SUB_MIX_1, SUB_MIX_2, SUB_MIX_3, SBOX) {\n\t            // Shortcut\n\t            var nRounds = this._nRounds;\n\n\t            // Get input, add round key\n\t            var s0 = M[offset]     ^ keySchedule[0];\n\t            var s1 = M[offset + 1] ^ keySchedule[1];\n\t            var s2 = M[offset + 2] ^ keySchedule[2];\n\t            var s3 = M[offset + 3] ^ keySchedule[3];\n\n\t            // Key schedule row counter\n\t            var ksRow = 4;\n\n\t            // Rounds\n\t            for (var round = 1; round < nRounds; round++) {\n\t                // Shift rows, sub bytes, mix columns, add round key\n\t                var t0 = SUB_MIX_0[s0 >>> 24] ^ SUB_MIX_1[(s1 >>> 16) & 0xff] ^ SUB_MIX_2[(s2 >>> 8) & 0xff] ^ SUB_MIX_3[s3 & 0xff] ^ keySchedule[ksRow++];\n\t                var t1 = SUB_MIX_0[s1 >>> 24] ^ SUB_MIX_1[(s2 >>> 16) & 0xff] ^ SUB_MIX_2[(s3 >>> 8) & 0xff] ^ SUB_MIX_3[s0 & 0xff] ^ keySchedule[ksRow++];\n\t                var t2 = SUB_MIX_0[s2 >>> 24] ^ SUB_MIX_1[(s3 >>> 16) & 0xff] ^ SUB_MIX_2[(s0 >>> 8) & 0xff] ^ SUB_MIX_3[s1 & 0xff] ^ keySchedule[ksRow++];\n\t                var t3 = SUB_MIX_0[s3 >>> 24] ^ SUB_MIX_1[(s0 >>> 16) & 0xff] ^ SUB_MIX_2[(s1 >>> 8) & 0xff] ^ SUB_MIX_3[s2 & 0xff] ^ keySchedule[ksRow++];\n\n\t                // Update state\n\t                s0 = t0;\n\t                s1 = t1;\n\t                s2 = t2;\n\t                s3 = t3;\n\t            }\n\n\t            // Shift rows, sub bytes, add round key\n\t            var t0 = ((SBOX[s0 >>> 24] << 24) | (SBOX[(s1 >>> 16) & 0xff] << 16) | (SBOX[(s2 >>> 8) & 0xff] << 8) | SBOX[s3 & 0xff]) ^ keySchedule[ksRow++];\n\t            var t1 = ((SBOX[s1 >>> 24] << 24) | (SBOX[(s2 >>> 16) & 0xff] << 16) | (SBOX[(s3 >>> 8) & 0xff] << 8) | SBOX[s0 & 0xff]) ^ keySchedule[ksRow++];\n\t            var t2 = ((SBOX[s2 >>> 24] << 24) | (SBOX[(s3 >>> 16) & 0xff] << 16) | (SBOX[(s0 >>> 8) & 0xff] << 8) | SBOX[s1 & 0xff]) ^ keySchedule[ksRow++];\n\t            var t3 = ((SBOX[s3 >>> 24] << 24) | (SBOX[(s0 >>> 16) & 0xff] << 16) | (SBOX[(s1 >>> 8) & 0xff] << 8) | SBOX[s2 & 0xff]) ^ keySchedule[ksRow++];\n\n\t            // Set output\n\t            M[offset]     = t0;\n\t            M[offset + 1] = t1;\n\t            M[offset + 2] = t2;\n\t            M[offset + 3] = t3;\n\t        },\n\n\t        keySize: 256/32\n\t    });\n\n\t    /**\n\t     * Shortcut functions to the cipher's object interface.\n\t     *\n\t     * @example\n\t     *\n\t     *     var ciphertext = CryptoJS.AES.encrypt(message, key, cfg);\n\t     *     var plaintext  = CryptoJS.AES.decrypt(ciphertext, key, cfg);\n\t     */\n\t    C.AES = BlockCipher._createHelper(AES);\n\t}());\n\n\n\treturn CryptoJS.AES;\n\n}));\n\n/***/ }),\n/* 61 */\n/***/ (function(module, exports, __nested_webpack_require_586269__) {\n\n;(function (root, factory) {\n\tif (true) {\n\t\t// CommonJS\n\t\tmodule.exports = exports = factory(__nested_webpack_require_586269__(6));\n\t}\n\telse {}\n}(this, function (CryptoJS) {\n\n\t(function (Math) {\n\t    // Shortcuts\n\t    var C = CryptoJS;\n\t    var C_lib = C.lib;\n\t    var WordArray = C_lib.WordArray;\n\t    var Hasher = C_lib.Hasher;\n\t    var C_algo = C.algo;\n\n\t    // Constants table\n\t    var T = [];\n\n\t    // Compute constants\n\t    (function () {\n\t        for (var i = 0; i < 64; i++) {\n\t            T[i] = (Math.abs(Math.sin(i + 1)) * 0x100000000) | 0;\n\t        }\n\t    }());\n\n\t    /**\n\t     * MD5 hash algorithm.\n\t     */\n\t    var MD5 = C_algo.MD5 = Hasher.extend({\n\t        _doReset: function () {\n\t            this._hash = new WordArray.init([\n\t                0x67452301, 0xefcdab89,\n\t                0x98badcfe, 0x10325476\n\t            ]);\n\t        },\n\n\t        _doProcessBlock: function (M, offset) {\n\t            // Swap endian\n\t            for (var i = 0; i < 16; i++) {\n\t                // Shortcuts\n\t                var offset_i = offset + i;\n\t                var M_offset_i = M[offset_i];\n\n\t                M[offset_i] = (\n\t                    (((M_offset_i << 8)  | (M_offset_i >>> 24)) & 0x00ff00ff) |\n\t                    (((M_offset_i << 24) | (M_offset_i >>> 8))  & 0xff00ff00)\n\t                );\n\t            }\n\n\t            // Shortcuts\n\t            var H = this._hash.words;\n\n\t            var M_offset_0  = M[offset + 0];\n\t            var M_offset_1  = M[offset + 1];\n\t            var M_offset_2  = M[offset + 2];\n\t            var M_offset_3  = M[offset + 3];\n\t            var M_offset_4  = M[offset + 4];\n\t            var M_offset_5  = M[offset + 5];\n\t            var M_offset_6  = M[offset + 6];\n\t            var M_offset_7  = M[offset + 7];\n\t            var M_offset_8  = M[offset + 8];\n\t            var M_offset_9  = M[offset + 9];\n\t            var M_offset_10 = M[offset + 10];\n\t            var M_offset_11 = M[offset + 11];\n\t            var M_offset_12 = M[offset + 12];\n\t            var M_offset_13 = M[offset + 13];\n\t            var M_offset_14 = M[offset + 14];\n\t            var M_offset_15 = M[offset + 15];\n\n\t            // Working varialbes\n\t            var a = H[0];\n\t            var b = H[1];\n\t            var c = H[2];\n\t            var d = H[3];\n\n\t            // Computation\n\t            a = FF(a, b, c, d, M_offset_0,  7,  T[0]);\n\t            d = FF(d, a, b, c, M_offset_1,  12, T[1]);\n\t            c = FF(c, d, a, b, M_offset_2,  17, T[2]);\n\t            b = FF(b, c, d, a, M_offset_3,  22, T[3]);\n\t            a = FF(a, b, c, d, M_offset_4,  7,  T[4]);\n\t            d = FF(d, a, b, c, M_offset_5,  12, T[5]);\n\t            c = FF(c, d, a, b, M_offset_6,  17, T[6]);\n\t            b = FF(b, c, d, a, M_offset_7,  22, T[7]);\n\t            a = FF(a, b, c, d, M_offset_8,  7,  T[8]);\n\t            d = FF(d, a, b, c, M_offset_9,  12, T[9]);\n\t            c = FF(c, d, a, b, M_offset_10, 17, T[10]);\n\t            b = FF(b, c, d, a, M_offset_11, 22, T[11]);\n\t            a = FF(a, b, c, d, M_offset_12, 7,  T[12]);\n\t            d = FF(d, a, b, c, M_offset_13, 12, T[13]);\n\t            c = FF(c, d, a, b, M_offset_14, 17, T[14]);\n\t            b = FF(b, c, d, a, M_offset_15, 22, T[15]);\n\n\t            a = GG(a, b, c, d, M_offset_1,  5,  T[16]);\n\t            d = GG(d, a, b, c, M_offset_6,  9,  T[17]);\n\t            c = GG(c, d, a, b, M_offset_11, 14, T[18]);\n\t            b = GG(b, c, d, a, M_offset_0,  20, T[19]);\n\t            a = GG(a, b, c, d, M_offset_5,  5,  T[20]);\n\t            d = GG(d, a, b, c, M_offset_10, 9,  T[21]);\n\t            c = GG(c, d, a, b, M_offset_15, 14, T[22]);\n\t            b = GG(b, c, d, a, M_offset_4,  20, T[23]);\n\t            a = GG(a, b, c, d, M_offset_9,  5,  T[24]);\n\t            d = GG(d, a, b, c, M_offset_14, 9,  T[25]);\n\t            c = GG(c, d, a, b, M_offset_3,  14, T[26]);\n\t            b = GG(b, c, d, a, M_offset_8,  20, T[27]);\n\t            a = GG(a, b, c, d, M_offset_13, 5,  T[28]);\n\t            d = GG(d, a, b, c, M_offset_2,  9,  T[29]);\n\t            c = GG(c, d, a, b, M_offset_7,  14, T[30]);\n\t            b = GG(b, c, d, a, M_offset_12, 20, T[31]);\n\n\t            a = HH(a, b, c, d, M_offset_5,  4,  T[32]);\n\t            d = HH(d, a, b, c, M_offset_8,  11, T[33]);\n\t            c = HH(c, d, a, b, M_offset_11, 16, T[34]);\n\t            b = HH(b, c, d, a, M_offset_14, 23, T[35]);\n\t            a = HH(a, b, c, d, M_offset_1,  4,  T[36]);\n\t            d = HH(d, a, b, c, M_offset_4,  11, T[37]);\n\t            c = HH(c, d, a, b, M_offset_7,  16, T[38]);\n\t            b = HH(b, c, d, a, M_offset_10, 23, T[39]);\n\t            a = HH(a, b, c, d, M_offset_13, 4,  T[40]);\n\t            d = HH(d, a, b, c, M_offset_0,  11, T[41]);\n\t            c = HH(c, d, a, b, M_offset_3,  16, T[42]);\n\t            b = HH(b, c, d, a, M_offset_6,  23, T[43]);\n\t            a = HH(a, b, c, d, M_offset_9,  4,  T[44]);\n\t            d = HH(d, a, b, c, M_offset_12, 11, T[45]);\n\t            c = HH(c, d, a, b, M_offset_15, 16, T[46]);\n\t            b = HH(b, c, d, a, M_offset_2,  23, T[47]);\n\n\t            a = II(a, b, c, d, M_offset_0,  6,  T[48]);\n\t            d = II(d, a, b, c, M_offset_7,  10, T[49]);\n\t            c = II(c, d, a, b, M_offset_14, 15, T[50]);\n\t            b = II(b, c, d, a, M_offset_5,  21, T[51]);\n\t            a = II(a, b, c, d, M_offset_12, 6,  T[52]);\n\t            d = II(d, a, b, c, M_offset_3,  10, T[53]);\n\t            c = II(c, d, a, b, M_offset_10, 15, T[54]);\n\t            b = II(b, c, d, a, M_offset_1,  21, T[55]);\n\t            a = II(a, b, c, d, M_offset_8,  6,  T[56]);\n\t            d = II(d, a, b, c, M_offset_15, 10, T[57]);\n\t            c = II(c, d, a, b, M_offset_6,  15, T[58]);\n\t            b = II(b, c, d, a, M_offset_13, 21, T[59]);\n\t            a = II(a, b, c, d, M_offset_4,  6,  T[60]);\n\t            d = II(d, a, b, c, M_offset_11, 10, T[61]);\n\t            c = II(c, d, a, b, M_offset_2,  15, T[62]);\n\t            b = II(b, c, d, a, M_offset_9,  21, T[63]);\n\n\t            // Intermediate hash value\n\t            H[0] = (H[0] + a) | 0;\n\t            H[1] = (H[1] + b) | 0;\n\t            H[2] = (H[2] + c) | 0;\n\t            H[3] = (H[3] + d) | 0;\n\t        },\n\n\t        _doFinalize: function () {\n\t            // Shortcuts\n\t            var data = this._data;\n\t            var dataWords = data.words;\n\n\t            var nBitsTotal = this._nDataBytes * 8;\n\t            var nBitsLeft = data.sigBytes * 8;\n\n\t            // Add padding\n\t            dataWords[nBitsLeft >>> 5] |= 0x80 << (24 - nBitsLeft % 32);\n\n\t            var nBitsTotalH = Math.floor(nBitsTotal / 0x100000000);\n\t            var nBitsTotalL = nBitsTotal;\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 15] = (\n\t                (((nBitsTotalH << 8)  | (nBitsTotalH >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotalH << 24) | (nBitsTotalH >>> 8))  & 0xff00ff00)\n\t            );\n\t            dataWords[(((nBitsLeft + 64) >>> 9) << 4) + 14] = (\n\t                (((nBitsTotalL << 8)  | (nBitsTotalL >>> 24)) & 0x00ff00ff) |\n\t                (((nBitsTotalL << 24) | (nBitsTotalL >>> 8))  & 0xff00ff00)\n\t            );\n\n\t            data.sigBytes = (dataWords.length + 1) * 4;\n\n\t            // Hash final blocks\n\t            this._process();\n\n\t            // Shortcuts\n\t            var hash = this._hash;\n\t            var H = hash.words;\n\n\t            // Swap endian\n\t            for (var i = 0; i < 4; i++) {\n\t                // Shortcut\n\t                var H_i = H[i];\n\n\t                H[i] = (((H_i << 8)  | (H_i >>> 24)) & 0x00ff00ff) |\n\t                       (((H_i << 24) | (H_i >>> 8))  & 0xff00ff00);\n\t            }\n\n\t            // Return final computed hash\n\t            return hash;\n\t        },\n\n\t        clone: function () {\n\t            var clone = Hasher.clone.call(this);\n\t            clone._hash = this._hash.clone();\n\n\t            return clone;\n\t        }\n\t    });\n\n\t    function FF(a, b, c, d, x, s, t) {\n\t        var n = a + ((b & c) | (~b & d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function GG(a, b, c, d, x, s, t) {\n\t        var n = a + ((b & d) | (c & ~d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function HH(a, b, c, d, x, s, t) {\n\t        var n = a + (b ^ c ^ d) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    function II(a, b, c, d, x, s, t) {\n\t        var n = a + (c ^ (b | ~d)) + x + t;\n\t        return ((n << s) | (n >>> (32 - s))) + b;\n\t    }\n\n\t    /**\n\t     * Shortcut function to the hasher's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     *\n\t     * @return {WordArray} The hash.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hash = CryptoJS.MD5('message');\n\t     *     var hash = CryptoJS.MD5(wordArray);\n\t     */\n\t    C.MD5 = Hasher._createHelper(MD5);\n\n\t    /**\n\t     * Shortcut function to the HMAC's object interface.\n\t     *\n\t     * @param {WordArray|string} message The message to hash.\n\t     * @param {WordArray|string} key The secret key.\n\t     *\n\t     * @return {WordArray} The HMAC.\n\t     *\n\t     * @static\n\t     *\n\t     * @example\n\t     *\n\t     *     var hmac = CryptoJS.HmacMD5(message, key);\n\t     */\n\t    C.HmacMD5 = Hasher._createHmacHelper(MD5);\n\t}(Math));\n\n\n\treturn CryptoJS.MD5;\n\n}));\n\n/***/ }),\n/* 62 */\n/***/ (function(module, exports, __nested_webpack_require_595598__) {\n\n\"use strict\";\n\nvar _a;\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_595598__(0);\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_595598__(3));\nvar Utils = tslib_1.__importStar(__nested_webpack_require_595598__(1));\nvar defaults_1 = tslib_1.__importDefault(__nested_webpack_require_595598__(8));\nvar errorinfo_1 = __nested_webpack_require_595598__(4);\nvar HttpMethods_1 = tslib_1.__importDefault(__nested_webpack_require_595598__(18));\nvar xhrrequest_1 = tslib_1.__importDefault(__nested_webpack_require_595598__(16));\nvar XHRStates_1 = tslib_1.__importDefault(__nested_webpack_require_595598__(21));\nvar logger_1 = tslib_1.__importDefault(__nested_webpack_require_595598__(2));\nvar jsonptransport_1 = __nested_webpack_require_595598__(29);\nvar fetchrequest_1 = tslib_1.__importDefault(__nested_webpack_require_595598__(63));\nvar HttpStatusCodes_1 = __nested_webpack_require_595598__(25);\nfunction shouldFallback(errorInfo) {\n    var statusCode = errorInfo.statusCode;\n    /* 400 + no code = a generic xhr onerror. Browser doesn't give us enough\n     * detail to know whether it's fallback-fixable, but it may be (eg if a\n     * network issue), so try just in case */\n    return ((statusCode === 408 && !errorInfo.code) ||\n        (statusCode === 400 && !errorInfo.code) ||\n        (statusCode >= 500 && statusCode <= 504));\n}\nfunction getHosts(client) {\n    /* If we're a connected realtime client, try the endpoint we're connected\n     * to first -- but still have fallbacks, being connected is not an absolute\n     * guarantee that a datacenter has free capacity to service REST requests. */\n    var connection = client.connection, connectionHost = connection && connection.connectionManager.host;\n    if (connectionHost) {\n        return [connectionHost].concat(defaults_1.default.getFallbackHosts(client.options));\n    }\n    return defaults_1.default.getHosts(client.options);\n}\nvar Http = (_a = /** @class */ (function () {\n        function class_1(options) {\n            this.checksInProgress = null;\n            this.checkConnectivity = undefined;\n            this.supportsAuthHeaders = false;\n            this.supportsLinkHeaders = false;\n            this._getHosts = getHosts;\n            this.options = options || {};\n            var connectivityCheckUrl = this.options.connectivityCheckUrl || defaults_1.default.connectivityCheckUrl;\n            var connectivityCheckParams = this.options.connectivityCheckParams;\n            var connectivityUrlIsDefault = !this.options.connectivityCheckUrl;\n            if (platform_1.default.Config.xhrSupported) {\n                this.supportsAuthHeaders = true;\n                this.Request = function (method, rest, uri, headers, params, body, callback) {\n                    var req = xhrrequest_1.default.createRequest(uri, headers, params, body, XHRStates_1.default.REQ_SEND, rest && rest.options.timeouts, method);\n                    req.once('complete', callback);\n                    req.exec();\n                    return req;\n                };\n                if (this.options.disableConnectivityCheck) {\n                    this.checkConnectivity = function (callback) {\n                        callback(null, true);\n                    };\n                }\n                else {\n                    this.checkConnectivity = function (callback) {\n                        logger_1.default.logAction(logger_1.default.LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Sending; ' + connectivityCheckUrl);\n                        this.doUri(HttpMethods_1.default.Get, null, connectivityCheckUrl, null, null, connectivityCheckParams, function (err, responseText, headers, unpacked, statusCode) {\n                            var result = false;\n                            if (!connectivityUrlIsDefault) {\n                                result = !err && (0, HttpStatusCodes_1.isSuccessCode)(statusCode);\n                            }\n                            else {\n                                result = !err && (responseText === null || responseText === void 0 ? void 0 : responseText.replace(/\\n/, '')) == 'yes';\n                            }\n                            logger_1.default.logAction(logger_1.default.LOG_MICRO, '(XHRRequest)Http.checkConnectivity()', 'Result: ' + result);\n                            callback(null, result);\n                        });\n                    };\n                }\n            }\n            else if (platform_1.default.Config.jsonpSupported) {\n                this.Request = function (method, rest, uri, headers, params, body, callback) {\n                    var req = (0, jsonptransport_1.createRequest)(uri, headers, params, body, XHRStates_1.default.REQ_SEND, rest && rest.options.timeouts, method);\n                    req.once('complete', callback);\n                    platform_1.default.Config.nextTick(function () {\n                        req.exec();\n                    });\n                    return req;\n                };\n                if (this.options.disableConnectivityCheck) {\n                    this.checkConnectivity = function (callback) {\n                        callback(null, true);\n                    };\n                }\n                else {\n                    this.checkConnectivity = function (callback) {\n                        var _this = this;\n                        var upUrl = defaults_1.default.jsonpInternetUpUrl;\n                        if (this.checksInProgress) {\n                            this.checksInProgress.push(callback);\n                            return;\n                        }\n                        this.checksInProgress = [callback];\n                        logger_1.default.logAction(logger_1.default.LOG_MICRO, '(JSONP)Http.checkConnectivity()', 'Sending; ' + upUrl);\n                        var req = new jsonptransport_1.Request('isTheInternetUp', upUrl, null, null, null, XHRStates_1.default.REQ_SEND, defaults_1.default.TIMEOUTS);\n                        req.once('complete', function (err, response) {\n                            var result = !err && response;\n                            logger_1.default.logAction(logger_1.default.LOG_MICRO, '(JSONP)Http.checkConnectivity()', 'Result: ' + result);\n                            for (var i = 0; i < _this.checksInProgress.length; i++)\n                                _this.checksInProgress[i](null, result);\n                            _this.checksInProgress = null;\n                        });\n                        platform_1.default.Config.nextTick(function () {\n                            req.exec();\n                        });\n                    };\n                }\n            }\n            else if (platform_1.default.Config.fetchSupported) {\n                this.supportsAuthHeaders = true;\n                this.Request = fetchrequest_1.default;\n                this.checkConnectivity = function (callback) {\n                    logger_1.default.logAction(logger_1.default.LOG_MICRO, '(Fetch)Http.checkConnectivity()', 'Sending; ' + connectivityCheckUrl);\n                    this.doUri(HttpMethods_1.default.Get, null, connectivityCheckUrl, null, null, null, function (err, responseText) {\n                        var result = !err && (responseText === null || responseText === void 0 ? void 0 : responseText.replace(/\\n/, '')) == 'yes';\n                        logger_1.default.logAction(logger_1.default.LOG_MICRO, '(Fetch)Http.checkConnectivity()', 'Result: ' + result);\n                        callback(null, result);\n                    });\n                };\n            }\n            else {\n                this.Request = function (method, rest, uri, headers, params, body, callback) {\n                    callback(new errorinfo_1.PartialErrorInfo('no supported HTTP transports available', null, 400), null);\n                };\n            }\n        }\n        /* Unlike for doUri, the 'rest' param here is mandatory, as it's used to generate the hosts */\n        class_1.prototype.do = function (method, rest, path, headers, body, params, callback) {\n            var _this = this;\n            var uriFromHost = typeof path == 'function'\n                ? path\n                : function (host) {\n                    return rest.baseUri(host) + path;\n                };\n            var currentFallback = rest._currentFallback;\n            if (currentFallback) {\n                if (currentFallback.validUntil > Utils.now()) {\n                    /* Use stored fallback */\n                    if (!this.Request) {\n                        callback === null || callback === void 0 ? void 0 : callback(new errorinfo_1.PartialErrorInfo('Request invoked before assigned to', null, 500));\n                        return;\n                    }\n                    this.Request(method, rest, uriFromHost(currentFallback.host), headers, params, body, function (err) {\n                        var args = [];\n                        for (var _i = 1; _i < arguments.length; _i++) {\n                            args[_i - 1] = arguments[_i];\n                        }\n                        // This typecast is safe because ErrnoExceptions are only thrown in NodeJS\n                        if (err && shouldFallback(err)) {\n                            /* unstore the fallback and start from the top with the default sequence */\n                            rest._currentFallback = null;\n                            _this.do(method, rest, path, headers, body, params, callback);\n                            return;\n                        }\n                        callback === null || callback === void 0 ? void 0 : callback.apply(void 0, tslib_1.__spreadArray([err], args, false));\n                    });\n                    return;\n                }\n                else {\n                    /* Fallback expired; remove it and fallthrough to normal sequence */\n                    rest._currentFallback = null;\n                }\n            }\n            var hosts = getHosts(rest);\n            /* if there is only one host do it */\n            if (hosts.length === 1) {\n                this.doUri(method, rest, uriFromHost(hosts[0]), headers, body, params, callback);\n                return;\n            }\n            /* hosts is an array with preferred host plus at least one fallback */\n            var tryAHost = function (candidateHosts, persistOnSuccess) {\n                var host = candidateHosts.shift();\n                _this.doUri(method, rest, uriFromHost(host), headers, body, params, function (err) {\n                    var args = [];\n                    for (var _i = 1; _i < arguments.length; _i++) {\n                        args[_i - 1] = arguments[_i];\n                    }\n                    // This typecast is safe because ErrnoExceptions are only thrown in NodeJS\n                    if (err && shouldFallback(err) && candidateHosts.length) {\n                        tryAHost(candidateHosts, true);\n                        return;\n                    }\n                    if (persistOnSuccess) {\n                        /* RSC15f */\n                        rest._currentFallback = {\n                            host: host,\n                            validUntil: Utils.now() + rest.options.timeouts.fallbackRetryTimeout,\n                        };\n                    }\n                    callback === null || callback === void 0 ? void 0 : callback.apply(void 0, tslib_1.__spreadArray([err], args, false));\n                });\n            };\n            tryAHost(hosts);\n        };\n        class_1.prototype.doUri = function (method, rest, uri, headers, body, params, callback) {\n            if (!this.Request) {\n                callback(new errorinfo_1.PartialErrorInfo('Request invoked before assigned to', null, 500));\n                return;\n            }\n            this.Request(method, rest, uri, headers, params, body, callback);\n        };\n        return class_1;\n    }()),\n    _a.methods = [HttpMethods_1.default.Get, HttpMethods_1.default.Delete, HttpMethods_1.default.Post, HttpMethods_1.default.Put, HttpMethods_1.default.Patch],\n    _a.methodsWithoutBody = [HttpMethods_1.default.Get, HttpMethods_1.default.Delete],\n    _a.methodsWithBody = [HttpMethods_1.default.Post, HttpMethods_1.default.Put, HttpMethods_1.default.Patch],\n    _a);\nexports.default = Http;\n\n\n/***/ }),\n/* 63 */\n/***/ (function(module, exports, __nested_webpack_require_607826__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_607826__(0);\nvar errorinfo_1 = tslib_1.__importStar(__nested_webpack_require_607826__(4));\nvar platform_1 = tslib_1.__importDefault(__nested_webpack_require_607826__(3));\nvar defaults_1 = tslib_1.__importDefault(__nested_webpack_require_607826__(8));\nvar Utils = tslib_1.__importStar(__nested_webpack_require_607826__(1));\nvar utils_1 = __nested_webpack_require_607826__(1);\nfunction isAblyError(responseBody, headers) {\n    return !!headers.get('x-ably-errorcode');\n}\nfunction getAblyError(responseBody, headers) {\n    if (isAblyError(responseBody, headers)) {\n        return responseBody.error && errorinfo_1.default.fromValues(responseBody.error);\n    }\n}\nfunction fetchRequest(method, rest, uri, headers, params, body, callback) {\n    var fetchHeaders = new Headers(headers || {});\n    var _method = method ? method.toUpperCase() : Utils.isEmptyArg(body) ? 'GET' : 'POST';\n    var controller = new AbortController();\n    var timeout = setTimeout(function () {\n        controller.abort();\n        callback(new errorinfo_1.PartialErrorInfo('Request timed out', null, 408));\n    }, rest ? rest.options.timeouts.httpRequestTimeout : defaults_1.default.TIMEOUTS.httpRequestTimeout);\n    var requestInit = {\n        method: _method,\n        headers: fetchHeaders,\n        body: body,\n    };\n    if (!platform_1.default.Config.isWebworker) {\n        requestInit.credentials = fetchHeaders.has('authorization') ? 'include' : 'same-origin';\n    }\n    (0, utils_1.getGlobalObject)()\n        .fetch(uri + '?' + new URLSearchParams(params || {}), requestInit)\n        .then(function (res) {\n        clearTimeout(timeout);\n        var contentType = res.headers.get('Content-Type');\n        var prom;\n        if (contentType && contentType.indexOf('application/x-msgpack') > -1) {\n            prom = res.arrayBuffer();\n        }\n        else if (contentType && contentType.indexOf('application/json') > -1) {\n            prom = res.json();\n        }\n        else {\n            prom = res.text();\n        }\n        prom.then(function (body) {\n            var unpacked = !!contentType && contentType.indexOf('application/x-msgpack') === -1;\n            if (!res.ok) {\n                var err = getAblyError(body, res.headers) ||\n                    new errorinfo_1.PartialErrorInfo('Error response received from server: ' + res.status + ' body was: ' + platform_1.default.Config.inspect(body), null, res.status);\n                callback(err, body, res.headers, unpacked, res.status);\n            }\n            else {\n                callback(null, body, res.headers, unpacked, res.status);\n            }\n        });\n    })\n        .catch(function (err) {\n        clearTimeout(timeout);\n        callback(err);\n    });\n}\nexports.default = fetchRequest;\n\n\n/***/ }),\n/* 64 */\n/***/ (function(module, exports, __nested_webpack_require_610677__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_610677__(0);\nvar msgpack_1 = tslib_1.__importDefault(__nested_webpack_require_610677__(41));\nvar Utils = tslib_1.__importStar(__nested_webpack_require_610677__(1));\n// Workaround for salesforce lightning locker compat\nvar globalObject = Utils.getGlobalObject();\nif (typeof Window === 'undefined' && typeof WorkerGlobalScope === 'undefined') {\n    console.log(\"Warning: this distribution of Ably is intended for browsers. On nodejs, please use the 'ably' package on npm\");\n}\nfunction allowComet() {\n    /* xhr requests from local files are unreliable in some browsers, such as Chrome 65 and higher -- see eg\n     * https://stackoverflow.com/questions/49256429/chrome-65-unable-to-make-post-requests-from-local-files-to-flask\n     * So if websockets are supported, then just forget about comet transports and use that */\n    var loc = globalObject.location;\n    return !globalObject.WebSocket || !loc || !loc.origin || loc.origin.indexOf('http') > -1;\n}\nvar userAgent = globalObject.navigator && globalObject.navigator.userAgent.toString();\nvar currentUrl = globalObject.location && globalObject.location.href;\nvar Config = {\n    agent: 'browser',\n    logTimestamps: true,\n    userAgent: userAgent,\n    currentUrl: currentUrl,\n    noUpgrade: userAgent && !!userAgent.match(/MSIE\\s8\\.0/),\n    binaryType: 'arraybuffer',\n    WebSocket: globalObject.WebSocket,\n    fetchSupported: !!globalObject.fetch,\n    xhrSupported: globalObject.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest(),\n    jsonpSupported: typeof document !== 'undefined',\n    allowComet: allowComet(),\n    streamingSupported: true,\n    useProtocolHeartbeats: true,\n    createHmac: null,\n    msgpack: msgpack_1.default,\n    supportsBinary: !!globalObject.TextDecoder,\n    /* Per Paddy (https://ably-real-time.slack.com/archives/CURL4U2FP/p1705674537763479) web intentionally prefers JSON to MessagePack:\n     *\n     * > browsers' support for binary types in general was historically poor, and JSON transport performance is significantly better in a browser than msgpack. In modern browsers then binary is supported consistently, but I'd still expect that JSON encode/decode performance is dramatically better than msgpack in a browser.\n     */\n    preferBinary: false,\n    ArrayBuffer: globalObject.ArrayBuffer,\n    atob: globalObject.atob,\n    nextTick: typeof globalObject.setImmediate !== 'undefined'\n        ? globalObject.setImmediate.bind(globalObject)\n        : function (f) {\n            setTimeout(f, 0);\n        },\n    addEventListener: globalObject.addEventListener,\n    inspect: JSON.stringify,\n    stringByteSize: function (str) {\n        /* str.length will be an underestimate for non-ascii strings. But if we're\n         * in a browser too old to support TextDecoder, not much we can do. Better\n         * to underestimate, so if we do go over-size, the server will reject the\n         * message */\n        return (globalObject.TextDecoder && new globalObject.TextEncoder().encode(str).length) || str.length;\n    },\n    TextEncoder: globalObject.TextEncoder,\n    TextDecoder: globalObject.TextDecoder,\n    Promise: globalObject.Promise,\n    getRandomValues: (function (crypto) {\n        if (crypto === undefined) {\n            return undefined;\n        }\n        return function (arr, callback) {\n            crypto.getRandomValues(arr);\n            if (callback) {\n                callback(null);\n            }\n        };\n    })(globalObject.crypto || msCrypto),\n};\nexports.default = Config;\n\n\n/***/ }),\n/* 65 */\n/***/ (function(module, exports, __nested_webpack_require_614308__) {\n\n\"use strict\";\n/* WEBPACK VAR INJECTION */(function(global) {\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_614308__(0);\nvar Utils = tslib_1.__importStar(__nested_webpack_require_614308__(1));\nvar test = 'ablyjs-storage-test';\nvar Webstorage = /** @class */ (function () {\n    function Webstorage() {\n        /* Even just accessing the session/localStorage object can throw a\n         * security exception in some circumstances with some browsers. In\n         * others, calling setItem will throw. So have to check in this\n         * somewhat roundabout way. (If unsupported or no global object,\n         * will throw on accessing a property of undefined) */\n        try {\n            global.sessionStorage.setItem(test, test);\n            global.sessionStorage.removeItem(test);\n            this.sessionSupported = true;\n        }\n        catch (e) {\n            this.sessionSupported = false;\n        }\n        try {\n            global.localStorage.setItem(test, test);\n            global.localStorage.removeItem(test);\n            this.localSupported = true;\n        }\n        catch (e) {\n            this.localSupported = false;\n        }\n    }\n    Webstorage.prototype.get = function (name) {\n        return this._get(name, false);\n    };\n    Webstorage.prototype.getSession = function (name) {\n        return this._get(name, true);\n    };\n    Webstorage.prototype.remove = function (name) {\n        return this._remove(name, false);\n    };\n    Webstorage.prototype.removeSession = function (name) {\n        return this._remove(name, true);\n    };\n    Webstorage.prototype.set = function (name, value, ttl) {\n        return this._set(name, value, ttl, false);\n    };\n    Webstorage.prototype.setSession = function (name, value, ttl) {\n        return this._set(name, value, ttl, true);\n    };\n    Webstorage.prototype._set = function (name, value, ttl, session) {\n        var wrappedValue = { value: value };\n        if (ttl) {\n            wrappedValue.expires = Utils.now() + ttl;\n        }\n        return this.storageInterface(session).setItem(name, JSON.stringify(wrappedValue));\n    };\n    Webstorage.prototype._get = function (name, session) {\n        if (session && !this.sessionSupported)\n            throw new Error('Session Storage not supported');\n        if (!session && !this.localSupported)\n            throw new Error('Local Storage not supported');\n        var rawItem = this.storageInterface(session).getItem(name);\n        if (!rawItem)\n            return null;\n        var wrappedValue = JSON.parse(rawItem);\n        if (wrappedValue.expires && wrappedValue.expires < Utils.now()) {\n            this.storageInterface(session).removeItem(name);\n            return null;\n        }\n        return wrappedValue.value;\n    };\n    Webstorage.prototype._remove = function (name, session) {\n        return this.storageInterface(session).removeItem(name);\n    };\n    Webstorage.prototype.storageInterface = function (session) {\n        return session ? global.sessionStorage : global.localStorage;\n    };\n    return Webstorage;\n}());\nexports.default = new Webstorage();\n\n/* WEBPACK VAR INJECTION */}.call(this, __nested_webpack_require_614308__(13)))\n\n/***/ }),\n/* 66 */\n/***/ (function(module, exports, __nested_webpack_require_617562__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar tslib_1 = __nested_webpack_require_617562__(0);\nvar TransportNames_1 = tslib_1.__importDefault(__nested_webpack_require_617562__(67));\nvar Defaults = {\n    connectivityCheckUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up.txt',\n    jsonpInternetUpUrl: 'https://internet-up.ably-realtime.com/is-the-internet-up-0-9.js',\n    /* Order matters here: the base transport is the leftmost one in the\n     * intersection of baseTransportOrder and the transports clientOption that's\n     * supported.  This is not quite the same as the preference order -- e.g.\n     * xhr_polling is preferred to jsonp, but for browsers that support it we want\n     * the base transport to be xhr_polling, not jsonp */\n    defaultTransports: [\n        TransportNames_1.default.XhrPolling,\n        TransportNames_1.default.XhrStreaming,\n        TransportNames_1.default.JsonP,\n        TransportNames_1.default.WebSocket,\n    ],\n    baseTransportOrder: [\n        TransportNames_1.default.XhrPolling,\n        TransportNames_1.default.XhrStreaming,\n        TransportNames_1.default.JsonP,\n        TransportNames_1.default.WebSocket,\n    ],\n    transportPreferenceOrder: [\n        TransportNames_1.default.JsonP,\n        TransportNames_1.default.XhrPolling,\n        TransportNames_1.default.XhrStreaming,\n        TransportNames_1.default.WebSocket,\n    ],\n    upgradeTransports: [TransportNames_1.default.XhrStreaming, TransportNames_1.default.WebSocket],\n};\nexports.default = Defaults;\n\n\n/***/ }),\n/* 67 */\n/***/ (function(module, exports, __webpack_require__) {\n\n\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", { value: true });\nvar TransportNames;\n(function (TransportNames) {\n    TransportNames[\"WebSocket\"] = \"web_socket\";\n    TransportNames[\"Comet\"] = \"comet\";\n    TransportNames[\"XhrStreaming\"] = \"xhr_streaming\";\n    TransportNames[\"XhrPolling\"] = \"xhr_polling\";\n    TransportNames[\"JsonP\"] = \"jsonp\";\n})(TransportNames || (TransportNames = {}));\nexports.default = TransportNames;\n\n\n/***/ }),\n/* 68 */\n/***/ (function(module, __webpack_exports__, __nested_webpack_require_619689__) {\n\n\"use strict\";\n// ESM COMPAT FLAG\n__nested_webpack_require_619689__.r(__webpack_exports__);\n\n// EXTERNAL MODULE: ./src/platform/web/lib/transport/jsonptransport.ts\nvar jsonptransport = __nested_webpack_require_619689__(29);\nvar jsonptransport_default = /*#__PURE__*/__nested_webpack_require_619689__.n(jsonptransport);\n\n// EXTERNAL MODULE: ./src/common/lib/util/utils.ts\nvar utils = __nested_webpack_require_619689__(1);\n\n// EXTERNAL MODULE: ./src/common/platform.ts\nvar platform = __nested_webpack_require_619689__(3);\nvar platform_default = /*#__PURE__*/__nested_webpack_require_619689__.n(platform);\n\n// EXTERNAL MODULE: ./src/common/lib/transport/comettransport.ts\nvar comettransport = __nested_webpack_require_619689__(12);\nvar comettransport_default = /*#__PURE__*/__nested_webpack_require_619689__.n(comettransport);\n\n// EXTERNAL MODULE: ./src/platform/web/lib/transport/xhrrequest.ts\nvar xhrrequest = __nested_webpack_require_619689__(16);\nvar xhrrequest_default = /*#__PURE__*/__nested_webpack_require_619689__.n(xhrrequest);\n\n// CONCATENATED MODULE: ./src/platform/web/lib/transport/xhrpollingtransport.js\n\n\n\n\n\nvar xhrpollingtransport_XHRPollingTransport = function (connectionManager) {\n  var shortName = 'xhr_polling';\n\n  function XHRPollingTransport(connectionManager, auth, params) {\n    params.stream = false;\n    comettransport_default.a.call(this, connectionManager, auth, params);\n    this.shortName = shortName;\n  }\n  utils[\"inherits\"](XHRPollingTransport, comettransport_default.a);\n\n  XHRPollingTransport.isAvailable = function () {\n    return platform_default.a.Config.xhrSupported && platform_default.a.Config.allowComet;\n  };\n\n  XHRPollingTransport.prototype.toString = function () {\n    return 'XHRPollingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;\n  };\n\n  XHRPollingTransport.prototype.createRequest = function (uri, headers, params, body, requestMode) {\n    return xhrrequest_default.a.createRequest(uri, headers, params, body, requestMode, this.timeouts);\n  };\n\n  if (typeof connectionManager !== 'undefined' && XHRPollingTransport.isAvailable()) {\n    connectionManager.supportedTransports[shortName] = XHRPollingTransport;\n  }\n\n  return XHRPollingTransport;\n};\n\n/* harmony default export */ var xhrpollingtransport = (xhrpollingtransport_XHRPollingTransport);\n\n// CONCATENATED MODULE: ./src/platform/web/lib/transport/xhrstreamingtransport.js\n\n\n\n\n\nvar xhrstreamingtransport_XHRStreamingTransport = function (connectionManager) {\n  var shortName = 'xhr_streaming';\n\n  /* public constructor */\n  function XHRStreamingTransport(connectionManager, auth, params) {\n    comettransport_default.a.call(this, connectionManager, auth, params);\n    this.shortName = shortName;\n  }\n  utils[\"inherits\"](XHRStreamingTransport, comettransport_default.a);\n\n  XHRStreamingTransport.isAvailable = function () {\n    return platform_default.a.Config.xhrSupported && platform_default.a.Config.streamingSupported && platform_default.a.Config.allowComet;\n  };\n\n  XHRStreamingTransport.prototype.toString = function () {\n    return 'XHRStreamingTransport; uri=' + this.baseUri + '; isConnected=' + this.isConnected;\n  };\n\n  XHRStreamingTransport.prototype.createRequest = function (uri, headers, params, body, requestMode) {\n    return xhrrequest_default.a.createRequest(uri, headers, params, body, requestMode, this.timeouts);\n  };\n\n  if (typeof connectionManager !== 'undefined' && XHRStreamingTransport.isAvailable()) {\n    connectionManager.supportedTransports[shortName] = XHRStreamingTransport;\n  }\n\n  return XHRStreamingTransport;\n};\n\n/* harmony default export */ var xhrstreamingtransport = (xhrstreamingtransport_XHRStreamingTransport);\n\n// CONCATENATED MODULE: ./src/platform/web/lib/transport/index.js\n\n\n\n\n/* harmony default export */ var transport = __webpack_exports__[\"default\"] = ([jsonptransport_default.a, xhrpollingtransport, xhrstreamingtransport]);\n\n\n/***/ })\n/******/ ])[\"default\"];\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL2FibHkvYnVpbGQvYWJseS1jb21tb25qcy5qcy5qcyIsIm1hcHBpbmdzIjoiO0FBQUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSSxJQUF5RDtBQUM3RDtBQUNBLE1BQU0sRUFLcUI7QUFDM0IsQ0FBQztBQUNELHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQiw4QkFBbUI7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwRUFBMEUsOEJBQW1CO0FBQzdGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQTtBQUNBLFVBQVUsOEJBQW1CO0FBQzdCO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QixlQUFlLDhCQUFtQjtBQUNsQyxtREFBbUQsK0JBQStCO0FBQ2xGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQSxpRUFBaUUsaUJBQWlCO0FBQ2xGO0FBQ0EsMERBQTBELGFBQWE7QUFDdkU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxVQUFVLDhCQUFtQjtBQUM3QixnQ0FBZ0MsOEJBQW1CO0FBQ25EO0FBQ0E7QUFDQTtBQUNBLFdBQVcsOEJBQW1CO0FBQzlCLGtEQUFrRCxnQ0FBZ0M7QUFDbEYsMEVBQTBFLDhCQUFtQiw0QkFBNEIsb0JBQW9CO0FBQzdJO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7QUFDN0I7QUFDQSxvQ0FBb0MsNEJBQTRCO0FBQ2hFLDBDQUEwQztBQUMxQyxXQUFXLDhCQUFtQjtBQUM5QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVUsOEJBQW1CLGtDQUFrQztBQUMvRDtBQUNBO0FBQ0EsVUFBVSw4QkFBbUI7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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixTQUFTO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFNBQVM7QUFDakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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QTtBQUNBO0FBQ0EscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQkFBZ0I7QUFDaEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdCQUF3QixxQkFBcUI7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0NBQStDO0FBQy9DO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLGtCQUFrQjtBQUNsRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7OztBQUdBLE9BQU87QUFDUDtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0Es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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaURBQWlEO0FBQ2pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7O0FBRUEsNEJBQTRCLFlBQVksaUNBQW1COztBQUUzRCxPQUFPO0FBQ1A7QUFDQSxpQ0FBaUMsaUNBQW1COztBQUVwRDs7QUFFQSwrQ0FBK0MsYUFBYTtBQUM1RCxjQUFjLGlDQUFtQjtBQUNqQyx1Q0FBdUMsaUNBQW1CO0FBQzFELGlDQUFpQyxpQ0FBbUI7QUFDcEQsNENBQTRDLGlDQUFtQjtBQUMvRCwwQ0FBMEMsaUNBQW1CO0FBQzdELDRDQUE0QyxpQ0FBbUI7QUFDL0QsbUJBQW1CLGlDQUFtQjtBQUN0Qyw0Q0FBNEMsaUNBQW1CO0FBQy9ELGdEQUFnRCxpQ0FBbUI7QUFDbkUseUNBQXlDLGlDQUFtQjtBQUM1RCx5Q0FBeUMsaUNBQW1CO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQixpQkFBaUI7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrREFBK0Q7QUFDL0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUhBQXVILGFBQWE7QUFDcEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCx3Q0FBd0M7QUFDeEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLGlDQUFpQyxpQ0FBbUI7O0FBRXBEOztBQUVBLCtDQUErQyxhQUFhO0FBQzVEO0FBQ0EsY0FBYyxpQ0FBbUI7QUFDakMsMENBQTBDLGlDQUFtQjtBQUM3RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0EsT0FBTztBQUNQO0FBQ0E7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QUE2QztBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyRUFBMkUsMEJBQTBCO0FBQ3JHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkRBQTZELG1EQUFtRDtBQUNoSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxD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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixzQkFBc0IsNkZBQTZGO0FBQ25ILHNCQUFzQiw2RkFBNkY7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7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Q3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtMQUFrTDtBQUNsTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUxBQWlMO0FBQ2pMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0Msc0RBQXNEO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFCQUFxQjtBQUNyQixpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkpBQTJKO0FBQzNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QyxxQkFBcUI7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlEQUFpRDtBQUNqRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4R0FBOEc7QUFDOUc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzTEFBc0w7QUFDdEw7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRUFBc0U7QUFDdEU7QUFD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NkJBQTZCO0FBQzdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNIQUFzSDtBQUN0SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUVBQW1FLGdCQUFnQjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvRUFBb0U7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkVBQTJFLGdCQUFnQjtBQUMzRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseURBQXlELDRDQUE0QztBQUNyRztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkIsNkRBQTZELDJEQUEyRDtBQUN4SCxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUdBQWlHLHNDQUFzQztBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCLGlEQUFpRCwrQ0FBK0M7QUFDaEcsc0NBQXNDO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEZBQTRGLG9DQUFvQztBQUNoSTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1GQUFtRjtBQUNuRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlFQUFpRSwwQ0FBMEM7QUFDM0c7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxxQkFBcUI7QUFDckQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLHFCQUFxQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esa0hBQWtIO0FBQ2xIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSEFBbUg7QUFDbkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhIQUE4SDtBQUM5SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtNQUFrTTtBQUNsTTtBQUNBO0FBQ0E7QUFDQSwrSEFBK0gsZ0NBQWdDO0FBQy9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztB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QUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixZQUFZO0FBQ3hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLFlBQVk7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsY0FBYztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDRCQUE0QixjQUFjO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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Q0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJHQUEyRztBQUMzRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtB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RUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsNkJBQTZCLE9BQU87QUFDcEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLFVBQVU7O0FBRVY7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxNQUFNOztBQUVOO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdCQUFnQixrQkFBa0I7QUFDbEM7QUFDQSxpQkFBaUIsV0FBVztBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBLHFCQUFxQixpQ0FBbUI7QUFDeEMsMENBQTBDLGlDQUFtQjs7QUFFN0Q7QUFDQSxpQkFBaUIsaUNBQW1CO0FBQ3BDLHNDQUFzQyxpQ0FBbUI7O0FBRXpEOzs7Ozs7QUFNQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUMsMEJBQTBCO0FBQzNEOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTs7Ozs7O0FBTUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0EsbUNBQW1DLDBCQUEwQjtBQUM3RDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7Ozs7O0FBS0E7OztBQUdBLE9BQU87QUFDUDtBQUNBLENBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL2FibHkvYnVpbGQvYWJseS1jb21tb25qcy5qcz8zMzQ2Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogQGxpY2Vuc2UgQ29weXJpZ2h0IDIwMTUtMjAyMiBBYmx5IFJlYWwtdGltZSBMdGQgKGFibHkuY29tKVxuICogXG4gKiBBYmx5IEphdmFTY3JpcHQgTGlicmFyeSB2MS4yLjQ5XG4gKiBodHRwczovL2dpdGh1Yi5jb20vYWJseS9hYmx5LWpzXG4gKiBcbiAqIFJlbGVhc2VkIHVuZGVyIHRoZSBBcGFjaGUgTGljZW5jZSB2Mi4wXG4gKi9cbihmdW5jdGlvbiB3ZWJwYWNrVW5pdmVyc2FsTW9kdWxlRGVmaW5pdGlvbihyb290LCBmYWN0b3J5KSB7XG5cdGlmKHR5cGVvZiBleHBvcnRzID09PSAnb2JqZWN0JyAmJiB0eXBlb2YgbW9kdWxlID09PSAnb2JqZWN0Jylcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKTtcblx0ZWxzZSBpZih0eXBlb2YgZGVmaW5lID09PSAnZnVuY3Rpb24nICYmIGRlZmluZS5hbWQpXG5cdFx0ZGVmaW5lKFtdLCBmYWN0b3J5KTtcblx0ZWxzZSBpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcpXG5cdFx0ZXhwb3J0c1tcIkFibHlcIl0gPSBmYWN0b3J5KCk7XG5cdGVsc2Vcblx0XHRyb290W1wiQWJseVwiXSA9IGZhY3RvcnkoKTtcbn0pKHdpbmRvdywgZnVuY3Rpb24oKSB7XG5yZXR1cm4gLyoqKioqKi8gKGZ1bmN0aW9uKG1vZHVsZXMpIHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBpbnN0YWxsZWRNb2R1bGVzID0ge307XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgcmVxdWlyZSBmdW5jdGlvblxuLyoqKioqKi8gXHRmdW5jdGlvbiBfX3dlYnBhY2tfcmVxdWlyZV9fKG1vZHVsZUlkKSB7XG4vKioqKioqL1xuLyoqKioqKi8gXHRcdC8vIENoZWNrIGlmIG1vZHVsZSBpcyBpbiBjYWNoZVxuLyoqKioqKi8gXHRcdGlmKGluc3RhbGxlZE1vZHVsZXNbbW9kdWxlSWRdKSB7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0uZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gaW5zdGFsbGVkTW9kdWxlc1ttb2R1bGVJZF0gPSB7XG4vKioqKioqLyBcdFx0XHRpOiBtb2R1bGVJZCxcbi8qKioqKiovIFx0XHRcdGw6IGZhbHNlLFxuLyoqKioqKi8gXHRcdFx0ZXhwb3J0czoge31cbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0XHQvLyBFeGVjdXRlIHRoZSBtb2R1bGUgZnVuY3Rpb25cbi8qKioqKiovIFx0XHRtb2R1bGVzW21vZHVsZUlkXS5jYWxsKG1vZHVsZS5leHBvcnRzLCBtb2R1bGUsIG1vZHVsZS5leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gRmxhZyB0aGUgbW9kdWxlIGFzIGxvYWRlZFxuLyoqKioqKi8gXHRcdG1vZHVsZS5sID0gdHJ1ZTtcbi8qKioqKiovXG4vKioqKioqLyBcdFx0Ly8gUmV0dXJuIHRoZSBleHBvcnRzIG9mIHRoZSBtb2R1bGVcbi8qKioqKiovIFx0XHRyZXR1cm4gbW9kdWxlLmV4cG9ydHM7XG4vKioqKioqLyBcdH1cbi8qKioqKiovXG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBleHBvc2UgdGhlIG1vZHVsZXMgb2JqZWN0IChfX3dlYnBhY2tfbW9kdWxlc19fKVxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm0gPSBtb2R1bGVzO1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZXhwb3NlIHRoZSBtb2R1bGUgY2FjaGVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5jID0gaW5zdGFsbGVkTW9kdWxlcztcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIGRlZmluZSBnZXR0ZXIgZnVuY3Rpb24gZm9yIGhhcm1vbnkgZXhwb3J0c1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQgPSBmdW5jdGlvbihleHBvcnRzLCBuYW1lLCBnZXR0ZXIpIHtcbi8qKioqKiovIFx0XHRpZighX193ZWJwYWNrX3JlcXVpcmVfXy5vKGV4cG9ydHMsIG5hbWUpKSB7XG4vKioqKioqLyBcdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgbmFtZSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGdldHRlciB9KTtcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBkZWZpbmUgX19lc01vZHVsZSBvbiBleHBvcnRzXG4vKioqKioqLyBcdF9fd2VicGFja19yZXF1aXJlX18uciA9IGZ1bmN0aW9uKGV4cG9ydHMpIHtcbi8qKioqKiovIFx0XHRpZih0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcpIHtcbi8qKioqKiovIFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdH1cbi8qKioqKiovIFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgJ19fZXNNb2R1bGUnLCB7IHZhbHVlOiB0cnVlIH0pO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gY3JlYXRlIGEgZmFrZSBuYW1lc3BhY2Ugb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiAxOiB2YWx1ZSBpcyBhIG1vZHVsZSBpZCwgcmVxdWlyZSBpdFxuLyoqKioqKi8gXHQvLyBtb2RlICYgMjogbWVyZ2UgYWxsIHByb3BlcnRpZXMgb2YgdmFsdWUgaW50byB0aGUgbnNcbi8qKioqKiovIFx0Ly8gbW9kZSAmIDQ6IHJldHVybiB2YWx1ZSB3aGVuIGFscmVhZHkgbnMgb2JqZWN0XG4vKioqKioqLyBcdC8vIG1vZGUgJiA4fDE6IGJlaGF2ZSBsaWtlIHJlcXVpcmVcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy50ID0gZnVuY3Rpb24odmFsdWUsIG1vZGUpIHtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMSkgdmFsdWUgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKHZhbHVlKTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgOCkgcmV0dXJuIHZhbHVlO1xuLyoqKioqKi8gXHRcdGlmKChtb2RlICYgNCkgJiYgdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JyAmJiB2YWx1ZSAmJiB2YWx1ZS5fX2VzTW9kdWxlKSByZXR1cm4gdmFsdWU7XG4vKioqKioqLyBcdFx0dmFyIG5zID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIobnMpO1xuLyoqKioqKi8gXHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShucywgJ2RlZmF1bHQnLCB7IGVudW1lcmFibGU6IHRydWUsIHZhbHVlOiB2YWx1ZSB9KTtcbi8qKioqKiovIFx0XHRpZihtb2RlICYgMiAmJiB0eXBlb2YgdmFsdWUgIT0gJ3N0cmluZycpIGZvcih2YXIga2V5IGluIHZhbHVlKSBfX3dlYnBhY2tfcmVxdWlyZV9fLmQobnMsIGtleSwgZnVuY3Rpb24oa2V5KSB7IHJldHVybiB2YWx1ZVtrZXldOyB9LmJpbmQobnVsbCwga2V5KSk7XG4vKioqKioqLyBcdFx0cmV0dXJuIG5zO1xuLyoqKioqKi8gXHR9O1xuLyoqKioqKi9cbi8qKioqKiovIFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0X193ZWJwYWNrX3JlcXVpcmVfXy5uID0gZnVuY3Rpb24obW9kdWxlKSB7XG4vKioqKioqLyBcdFx0dmFyIGdldHRlciA9IG1vZHVsZSAmJiBtb2R1bGUuX19lc01vZHVsZSA/XG4vKioqKioqLyBcdFx0XHRmdW5jdGlvbiBnZXREZWZhdWx0KCkgeyByZXR1cm4gbW9kdWxlWydkZWZhdWx0J107IH0gOlxuLyoqKioqKi8gXHRcdFx0ZnVuY3Rpb24gZ2V0TW9kdWxlRXhwb3J0cygpIHsgcmV0dXJuIG1vZHVsZTsgfTtcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLmQoZ2V0dGVyLCAnYScsIGdldHRlcik7XG4vKioqKioqLyBcdFx0cmV0dXJuIGdldHRlcjtcbi8qKioqKiovIFx0fTtcbi8qKioqKiovXG4vKioqKioqLyBcdC8vIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbFxuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLm8gPSBmdW5jdGlvbihvYmplY3QsIHByb3BlcnR5KSB7IHJldHVybiBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2JqZWN0LCBwcm9wZXJ0eSk7IH07XG4vKioqKioqL1xuLyoqKioqKi8gXHQvLyBfX3dlYnBhY2tfcHVibGljX3BhdGhfX1xuLyoqKioqKi8gXHRfX3dlYnBhY2tfcmVxdWlyZV9fLnAgPSBcIlwiO1xuLyoqKioqKi9cbi8qKioqKiovXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHRyZXR1cm4gX193ZWJwYWNrX3JlcXVpcmVfXyhfX3dlYnBhY2tfcmVxdWlyZV9fLnMgPSA0Mik7XG4vKioqKioqLyB9KVxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKioqKiovIChbXG4vKiAwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZXh0ZW5kc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fZXh0ZW5kczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19hc3NpZ25cIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2Fzc2lnbjsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19yZXN0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19yZXN0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2RlY29yYXRlXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19kZWNvcmF0ZTsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19wYXJhbVwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fcGFyYW07IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fbWV0YWRhdGFcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX21ldGFkYXRhOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2F3YWl0ZXJcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2F3YWl0ZXI7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fZ2VuZXJhdG9yXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19nZW5lcmF0b3I7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fY3JlYXRlQmluZGluZ1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fY3JlYXRlQmluZGluZzsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19leHBvcnRTdGFyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19leHBvcnRTdGFyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX3ZhbHVlc1wiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fdmFsdWVzOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX3JlYWRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX3JlYWQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fc3ByZWFkXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19zcHJlYWQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fc3ByZWFkQXJyYXlzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19zcHJlYWRBcnJheXM7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fc3ByZWFkQXJyYXlcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX3NwcmVhZEFycmF5OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2F3YWl0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19hd2FpdDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19hc3luY0dlbmVyYXRvclwiLCBmdW5jdGlvbigpIHsgcmV0dXJuIF9fYXN5bmNHZW5lcmF0b3I7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fYXN5bmNEZWxlZ2F0b3JcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2FzeW5jRGVsZWdhdG9yOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2FzeW5jVmFsdWVzXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19hc3luY1ZhbHVlczsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19tYWtlVGVtcGxhdGVPYmplY3RcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX21ha2VUZW1wbGF0ZU9iamVjdDsgfSk7XG4vKiBoYXJtb255IGV4cG9ydCAoYmluZGluZykgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIFwiX19pbXBvcnRTdGFyXCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19pbXBvcnRTdGFyOyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2ltcG9ydERlZmF1bHRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2ltcG9ydERlZmF1bHQ7IH0pO1xuLyogaGFybW9ueSBleHBvcnQgKGJpbmRpbmcpICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCBcIl9fY2xhc3NQcml2YXRlRmllbGRHZXRcIiwgZnVuY3Rpb24oKSB7IHJldHVybiBfX2NsYXNzUHJpdmF0ZUZpZWxkR2V0OyB9KTtcbi8qIGhhcm1vbnkgZXhwb3J0IChiaW5kaW5nKSAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywgXCJfX2NsYXNzUHJpdmF0ZUZpZWxkU2V0XCIsIGZ1bmN0aW9uKCkgeyByZXR1cm4gX19jbGFzc1ByaXZhdGVGaWVsZFNldDsgfSk7XG4vKiEgKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH1cclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3Jlc3QocywgZSkge1xyXG4gICAgdmFyIHQgPSB7fTtcclxuICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSAmJiBlLmluZGV4T2YocCkgPCAwKVxyXG4gICAgICAgIHRbcF0gPSBzW3BdO1xyXG4gICAgaWYgKHMgIT0gbnVsbCAmJiB0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyA9PT0gXCJmdW5jdGlvblwiKVxyXG4gICAgICAgIGZvciAodmFyIGkgPSAwLCBwID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhzKTsgaSA8IHAubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICAgICAgaWYgKGUuaW5kZXhPZihwW2ldKSA8IDAgJiYgT2JqZWN0LnByb3RvdHlwZS5wcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKHMsIHBbaV0pKVxyXG4gICAgICAgICAgICAgICAgdFtwW2ldXSA9IHNbcFtpXV07XHJcbiAgICAgICAgfVxyXG4gICAgcmV0dXJuIHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpIHtcclxuICAgIHZhciBjID0gYXJndW1lbnRzLmxlbmd0aCwgciA9IGMgPCAzID8gdGFyZ2V0IDogZGVzYyA9PT0gbnVsbCA/IGRlc2MgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHRhcmdldCwga2V5KSA6IGRlc2MsIGQ7XHJcbiAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09IFwib2JqZWN0XCIgJiYgdHlwZW9mIFJlZmxlY3QuZGVjb3JhdGUgPT09IFwiZnVuY3Rpb25cIikgciA9IFJlZmxlY3QuZGVjb3JhdGUoZGVjb3JhdG9ycywgdGFyZ2V0LCBrZXksIGRlc2MpO1xyXG4gICAgZWxzZSBmb3IgKHZhciBpID0gZGVjb3JhdG9ycy5sZW5ndGggLSAxOyBpID49IDA7IGktLSkgaWYgKGQgPSBkZWNvcmF0b3JzW2ldKSByID0gKGMgPCAzID8gZChyKSA6IGMgPiAzID8gZCh0YXJnZXQsIGtleSwgcikgOiBkKHRhcmdldCwga2V5KSkgfHwgcjtcclxuICAgIHJldHVybiBjID4gMyAmJiByICYmIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgciksIHI7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fcGFyYW0ocGFyYW1JbmRleCwgZGVjb3JhdG9yKSB7XHJcbiAgICByZXR1cm4gZnVuY3Rpb24gKHRhcmdldCwga2V5KSB7IGRlY29yYXRvcih0YXJnZXQsIGtleSwgcGFyYW1JbmRleCk7IH1cclxufVxyXG5cclxuZnVuY3Rpb24gX19tZXRhZGF0YShtZXRhZGF0YUtleSwgbWV0YWRhdGFWYWx1ZSkge1xyXG4gICAgaWYgKHR5cGVvZiBSZWZsZWN0ID09PSBcIm9iamVjdFwiICYmIHR5cGVvZiBSZWZsZWN0Lm1ldGFkYXRhID09PSBcImZ1bmN0aW9uXCIpIHJldHVybiBSZWZsZWN0Lm1ldGFkYXRhKG1ldGFkYXRhS2V5LCBtZXRhZGF0YVZhbHVlKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdGVyKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xyXG4gICAgZnVuY3Rpb24gYWRvcHQodmFsdWUpIHsgcmV0dXJuIHZhbHVlIGluc3RhbmNlb2YgUCA/IHZhbHVlIDogbmV3IFAoZnVuY3Rpb24gKHJlc29sdmUpIHsgcmVzb2x2ZSh2YWx1ZSk7IH0pOyB9XHJcbiAgICByZXR1cm4gbmV3IChQIHx8IChQID0gUHJvbWlzZSkpKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcclxuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gcmVqZWN0ZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3JbXCJ0aHJvd1wiXSh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XHJcbiAgICAgICAgZnVuY3Rpb24gc3RlcChyZXN1bHQpIHsgcmVzdWx0LmRvbmUgPyByZXNvbHZlKHJlc3VsdC52YWx1ZSkgOiBhZG9wdChyZXN1bHQudmFsdWUpLnRoZW4oZnVsZmlsbGVkLCByZWplY3RlZCk7IH1cclxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XHJcbiAgICB9KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19nZW5lcmF0b3IodGhpc0FyZywgYm9keSkge1xyXG4gICAgdmFyIF8gPSB7IGxhYmVsOiAwLCBzZW50OiBmdW5jdGlvbigpIHsgaWYgKHRbMF0gJiAxKSB0aHJvdyB0WzFdOyByZXR1cm4gdFsxXTsgfSwgdHJ5czogW10sIG9wczogW10gfSwgZiwgeSwgdCwgZztcclxuICAgIHJldHVybiBnID0geyBuZXh0OiB2ZXJiKDApLCBcInRocm93XCI6IHZlcmIoMSksIFwicmV0dXJuXCI6IHZlcmIoMikgfSwgdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIChnW1N5bWJvbC5pdGVyYXRvcl0gPSBmdW5jdGlvbigpIHsgcmV0dXJuIHRoaXM7IH0pLCBnO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IHJldHVybiBmdW5jdGlvbiAodikgeyByZXR1cm4gc3RlcChbbiwgdl0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKG9wKSB7XHJcbiAgICAgICAgaWYgKGYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJHZW5lcmF0b3IgaXMgYWxyZWFkeSBleGVjdXRpbmcuXCIpO1xyXG4gICAgICAgIHdoaWxlIChfKSB0cnkge1xyXG4gICAgICAgICAgICBpZiAoZiA9IDEsIHkgJiYgKHQgPSBvcFswXSAmIDIgPyB5W1wicmV0dXJuXCJdIDogb3BbMF0gPyB5W1widGhyb3dcIl0gfHwgKCh0ID0geVtcInJldHVyblwiXSkgJiYgdC5jYWxsKHkpLCAwKSA6IHkubmV4dCkgJiYgISh0ID0gdC5jYWxsKHksIG9wWzFdKSkuZG9uZSkgcmV0dXJuIHQ7XHJcbiAgICAgICAgICAgIGlmICh5ID0gMCwgdCkgb3AgPSBbb3BbMF0gJiAyLCB0LnZhbHVlXTtcclxuICAgICAgICAgICAgc3dpdGNoIChvcFswXSkge1xyXG4gICAgICAgICAgICAgICAgY2FzZSAwOiBjYXNlIDE6IHQgPSBvcDsgYnJlYWs7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IF8ubGFiZWwrKzsgcmV0dXJuIHsgdmFsdWU6IG9wWzFdLCBkb25lOiBmYWxzZSB9O1xyXG4gICAgICAgICAgICAgICAgY2FzZSA1OiBfLmxhYmVsKys7IHkgPSBvcFsxXTsgb3AgPSBbMF07IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA3OiBvcCA9IF8ub3BzLnBvcCgpOyBfLnRyeXMucG9wKCk7IGNvbnRpbnVlO1xyXG4gICAgICAgICAgICAgICAgZGVmYXVsdDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISh0ID0gXy50cnlzLCB0ID0gdC5sZW5ndGggPiAwICYmIHRbdC5sZW5ndGggLSAxXSkgJiYgKG9wWzBdID09PSA2IHx8IG9wWzBdID09PSAyKSkgeyBfID0gMDsgY29udGludWU7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDMgJiYgKCF0IHx8IChvcFsxXSA+IHRbMF0gJiYgb3BbMV0gPCB0WzNdKSkpIHsgXy5sYWJlbCA9IG9wWzFdOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmIChvcFswXSA9PT0gNiAmJiBfLmxhYmVsIDwgdFsxXSkgeyBfLmxhYmVsID0gdFsxXTsgdCA9IG9wOyBicmVhazsgfVxyXG4gICAgICAgICAgICAgICAgICAgIGlmICh0ICYmIF8ubGFiZWwgPCB0WzJdKSB7IF8ubGFiZWwgPSB0WzJdOyBfLm9wcy5wdXNoKG9wKTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodFsyXSkgXy5vcHMucG9wKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBvcCA9IGJvZHkuY2FsbCh0aGlzQXJnLCBfKTtcclxuICAgICAgICB9IGNhdGNoIChlKSB7IG9wID0gWzYsIGVdOyB5ID0gMDsgfSBmaW5hbGx5IHsgZiA9IHQgPSAwOyB9XHJcbiAgICAgICAgaWYgKG9wWzBdICYgNSkgdGhyb3cgb3BbMV07IHJldHVybiB7IHZhbHVlOiBvcFswXSA/IG9wWzFdIDogdm9pZCAwLCBkb25lOiB0cnVlIH07XHJcbiAgICB9XHJcbn1cclxuXHJcbnZhciBfX2NyZWF0ZUJpbmRpbmcgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIG0sIGssIGsyKSB7XHJcbiAgICBpZiAoazIgPT09IHVuZGVmaW5lZCkgazIgPSBrO1xyXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KG8sIGsyLCB7IGVudW1lcmFibGU6IHRydWUsIGdldDogZnVuY3Rpb24oKSB7IHJldHVybiBtW2tdOyB9IH0pO1xyXG59KSA6IChmdW5jdGlvbihvLCBtLCBrLCBrMikge1xyXG4gICAgaWYgKGsyID09PSB1bmRlZmluZWQpIGsyID0gaztcclxuICAgIG9bazJdID0gbVtrXTtcclxufSk7XHJcblxyXG5mdW5jdGlvbiBfX2V4cG9ydFN0YXIobSwgbykge1xyXG4gICAgZm9yICh2YXIgcCBpbiBtKSBpZiAocCAhPT0gXCJkZWZhdWx0XCIgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvLCBwKSkgX19jcmVhdGVCaW5kaW5nKG8sIG0sIHApO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX3ZhbHVlcyhvKSB7XHJcbiAgICB2YXIgcyA9IHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiBTeW1ib2wuaXRlcmF0b3IsIG0gPSBzICYmIG9bc10sIGkgPSAwO1xyXG4gICAgaWYgKG0pIHJldHVybiBtLmNhbGwobyk7XHJcbiAgICBpZiAobyAmJiB0eXBlb2Ygby5sZW5ndGggPT09IFwibnVtYmVyXCIpIHJldHVybiB7XHJcbiAgICAgICAgbmV4dDogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAobyAmJiBpID49IG8ubGVuZ3RoKSBvID0gdm9pZCAwO1xyXG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogbyAmJiBvW2krK10sIGRvbmU6ICFvIH07XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IocyA/IFwiT2JqZWN0IGlzIG5vdCBpdGVyYWJsZS5cIiA6IFwiU3ltYm9sLml0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19yZWFkKG8sIG4pIHtcclxuICAgIHZhciBtID0gdHlwZW9mIFN5bWJvbCA9PT0gXCJmdW5jdGlvblwiICYmIG9bU3ltYm9sLml0ZXJhdG9yXTtcclxuICAgIGlmICghbSkgcmV0dXJuIG87XHJcbiAgICB2YXIgaSA9IG0uY2FsbChvKSwgciwgYXIgPSBbXSwgZTtcclxuICAgIHRyeSB7XHJcbiAgICAgICAgd2hpbGUgKChuID09PSB2b2lkIDAgfHwgbi0tID4gMCkgJiYgIShyID0gaS5uZXh0KCkpLmRvbmUpIGFyLnB1c2goci52YWx1ZSk7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZXJyb3IpIHsgZSA9IHsgZXJyb3I6IGVycm9yIH07IH1cclxuICAgIGZpbmFsbHkge1xyXG4gICAgICAgIHRyeSB7XHJcbiAgICAgICAgICAgIGlmIChyICYmICFyLmRvbmUgJiYgKG0gPSBpW1wicmV0dXJuXCJdKSkgbS5jYWxsKGkpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBmaW5hbGx5IHsgaWYgKGUpIHRocm93IGUuZXJyb3I7IH1cclxuICAgIH1cclxuICAgIHJldHVybiBhcjtcclxufVxyXG5cclxuLyoqIEBkZXByZWNhdGVkICovXHJcbmZ1bmN0aW9uIF9fc3ByZWFkKCkge1xyXG4gICAgZm9yICh2YXIgYXIgPSBbXSwgaSA9IDA7IGkgPCBhcmd1bWVudHMubGVuZ3RoOyBpKyspXHJcbiAgICAgICAgYXIgPSBhci5jb25jYXQoX19yZWFkKGFyZ3VtZW50c1tpXSkpO1xyXG4gICAgcmV0dXJuIGFyO1xyXG59XHJcblxyXG4vKiogQGRlcHJlY2F0ZWQgKi9cclxuZnVuY3Rpb24gX19zcHJlYWRBcnJheXMoKSB7XHJcbiAgICBmb3IgKHZhciBzID0gMCwgaSA9IDAsIGlsID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IGlsOyBpKyspIHMgKz0gYXJndW1lbnRzW2ldLmxlbmd0aDtcclxuICAgIGZvciAodmFyIHIgPSBBcnJheShzKSwgayA9IDAsIGkgPSAwOyBpIDwgaWw7IGkrKylcclxuICAgICAgICBmb3IgKHZhciBhID0gYXJndW1lbnRzW2ldLCBqID0gMCwgamwgPSBhLmxlbmd0aDsgaiA8IGpsOyBqKyssIGsrKylcclxuICAgICAgICAgICAgcltrXSA9IGFbal07XHJcbiAgICByZXR1cm4gcjtcclxufVxyXG5cclxuZnVuY3Rpb24gX19zcHJlYWRBcnJheSh0bywgZnJvbSwgcGFjaykge1xyXG4gICAgaWYgKHBhY2sgfHwgYXJndW1lbnRzLmxlbmd0aCA9PT0gMikgZm9yICh2YXIgaSA9IDAsIGwgPSBmcm9tLmxlbmd0aCwgYXI7IGkgPCBsOyBpKyspIHtcclxuICAgICAgICBpZiAoYXIgfHwgIShpIGluIGZyb20pKSB7XHJcbiAgICAgICAgICAgIGlmICghYXIpIGFyID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSwgMCwgaSk7XHJcbiAgICAgICAgICAgIGFyW2ldID0gZnJvbVtpXTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdG8uY29uY2F0KGFyIHx8IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGZyb20pKTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hd2FpdCh2KSB7XHJcbiAgICByZXR1cm4gdGhpcyBpbnN0YW5jZW9mIF9fYXdhaXQgPyAodGhpcy52ID0gdiwgdGhpcykgOiBuZXcgX19hd2FpdCh2KTtcclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY0dlbmVyYXRvcih0aGlzQXJnLCBfYXJndW1lbnRzLCBnZW5lcmF0b3IpIHtcclxuICAgIGlmICghU3ltYm9sLmFzeW5jSXRlcmF0b3IpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJTeW1ib2wuYXN5bmNJdGVyYXRvciBpcyBub3QgZGVmaW5lZC5cIik7XHJcbiAgICB2YXIgZyA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSwgaSwgcSA9IFtdO1xyXG4gICAgcmV0dXJuIGkgPSB7fSwgdmVyYihcIm5leHRcIiksIHZlcmIoXCJ0aHJvd1wiKSwgdmVyYihcInJldHVyblwiKSwgaVtTeW1ib2wuYXN5bmNJdGVyYXRvcl0gPSBmdW5jdGlvbiAoKSB7IHJldHVybiB0aGlzOyB9LCBpO1xyXG4gICAgZnVuY3Rpb24gdmVyYihuKSB7IGlmIChnW25dKSBpW25dID0gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChhLCBiKSB7IHEucHVzaChbbiwgdiwgYSwgYl0pID4gMSB8fCByZXN1bWUobiwgdik7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiByZXN1bWUobiwgdikgeyB0cnkgeyBzdGVwKGdbbl0odikpOyB9IGNhdGNoIChlKSB7IHNldHRsZShxWzBdWzNdLCBlKTsgfSB9XHJcbiAgICBmdW5jdGlvbiBzdGVwKHIpIHsgci52YWx1ZSBpbnN0YW5jZW9mIF9fYXdhaXQgPyBQcm9taXNlLnJlc29sdmUoci52YWx1ZS52KS50aGVuKGZ1bGZpbGwsIHJlamVjdCkgOiBzZXR0bGUocVswXVsyXSwgcik7IH1cclxuICAgIGZ1bmN0aW9uIGZ1bGZpbGwodmFsdWUpIHsgcmVzdW1lKFwibmV4dFwiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHJlamVjdCh2YWx1ZSkgeyByZXN1bWUoXCJ0aHJvd1wiLCB2YWx1ZSk7IH1cclxuICAgIGZ1bmN0aW9uIHNldHRsZShmLCB2KSB7IGlmIChmKHYpLCBxLnNoaWZ0KCksIHEubGVuZ3RoKSByZXN1bWUocVswXVswXSwgcVswXVsxXSk7IH1cclxufVxyXG5cclxuZnVuY3Rpb24gX19hc3luY0RlbGVnYXRvcihvKSB7XHJcbiAgICB2YXIgaSwgcDtcclxuICAgIHJldHVybiBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiwgZnVuY3Rpb24gKGUpIHsgdGhyb3cgZTsgfSksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uICgpIHsgcmV0dXJuIHRoaXM7IH0sIGk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4sIGYpIHsgaVtuXSA9IG9bbl0gPyBmdW5jdGlvbiAodikgeyByZXR1cm4gKHAgPSAhcCkgPyB7IHZhbHVlOiBfX2F3YWl0KG9bbl0odikpLCBkb25lOiBuID09PSBcInJldHVyblwiIH0gOiBmID8gZih2KSA6IHY7IH0gOiBmOyB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fYXN5bmNWYWx1ZXMobykge1xyXG4gICAgaWYgKCFTeW1ib2wuYXN5bmNJdGVyYXRvcikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIlN5bWJvbC5hc3luY0l0ZXJhdG9yIGlzIG5vdCBkZWZpbmVkLlwiKTtcclxuICAgIHZhciBtID0gb1tTeW1ib2wuYXN5bmNJdGVyYXRvcl0sIGk7XHJcbiAgICByZXR1cm4gbSA/IG0uY2FsbChvKSA6IChvID0gdHlwZW9mIF9fdmFsdWVzID09PSBcImZ1bmN0aW9uXCIgPyBfX3ZhbHVlcyhvKSA6IG9bU3ltYm9sLml0ZXJhdG9yXSgpLCBpID0ge30sIHZlcmIoXCJuZXh0XCIpLCB2ZXJiKFwidGhyb3dcIiksIHZlcmIoXCJyZXR1cm5cIiksIGlbU3ltYm9sLmFzeW5jSXRlcmF0b3JdID0gZnVuY3Rpb24gKCkgeyByZXR1cm4gdGhpczsgfSwgaSk7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgaVtuXSA9IG9bbl0gJiYgZnVuY3Rpb24gKHYpIHsgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHsgdiA9IG9bbl0odiksIHNldHRsZShyZXNvbHZlLCByZWplY3QsIHYuZG9uZSwgdi52YWx1ZSk7IH0pOyB9OyB9XHJcbiAgICBmdW5jdGlvbiBzZXR0bGUocmVzb2x2ZSwgcmVqZWN0LCBkLCB2KSB7IFByb21pc2UucmVzb2x2ZSh2KS50aGVuKGZ1bmN0aW9uKHYpIHsgcmVzb2x2ZSh7IHZhbHVlOiB2LCBkb25lOiBkIH0pOyB9LCByZWplY3QpOyB9XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fbWFrZVRlbXBsYXRlT2JqZWN0KGNvb2tlZCwgcmF3KSB7XHJcbiAgICBpZiAoT2JqZWN0LmRlZmluZVByb3BlcnR5KSB7IE9iamVjdC5kZWZpbmVQcm9wZXJ0eShjb29rZWQsIFwicmF3XCIsIHsgdmFsdWU6IHJhdyB9KTsgfSBlbHNlIHsgY29va2VkLnJhdyA9IHJhdzsgfVxyXG4gICAgcmV0dXJuIGNvb2tlZDtcclxufTtcclxuXHJcbnZhciBfX3NldE1vZHVsZURlZmF1bHQgPSBPYmplY3QuY3JlYXRlID8gKGZ1bmN0aW9uKG8sIHYpIHtcclxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvLCBcImRlZmF1bHRcIiwgeyBlbnVtZXJhYmxlOiB0cnVlLCB2YWx1ZTogdiB9KTtcclxufSkgOiBmdW5jdGlvbihvLCB2KSB7XHJcbiAgICBvW1wiZGVmYXVsdFwiXSA9IHY7XHJcbn07XHJcblxyXG5mdW5jdGlvbiBfX2ltcG9ydFN0YXIobW9kKSB7XHJcbiAgICBpZiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSByZXR1cm4gbW9kO1xyXG4gICAgdmFyIHJlc3VsdCA9IHt9O1xyXG4gICAgaWYgKG1vZCAhPSBudWxsKSBmb3IgKHZhciBrIGluIG1vZCkgaWYgKGsgIT09IFwiZGVmYXVsdFwiICYmIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChtb2QsIGspKSBfX2NyZWF0ZUJpbmRpbmcocmVzdWx0LCBtb2QsIGspO1xyXG4gICAgX19zZXRNb2R1bGVEZWZhdWx0KHJlc3VsdCwgbW9kKTtcclxuICAgIHJldHVybiByZXN1bHQ7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9faW1wb3J0RGVmYXVsdChtb2QpIHtcclxuICAgIHJldHVybiAobW9kICYmIG1vZC5fX2VzTW9kdWxlKSA/IG1vZCA6IHsgZGVmYXVsdDogbW9kIH07XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRHZXQocmVjZWl2ZXIsIHN0YXRlLCBraW5kLCBmKSB7XHJcbiAgICBpZiAoa2luZCA9PT0gXCJhXCIgJiYgIWYpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJQcml2YXRlIGFjY2Vzc29yIHdhcyBkZWZpbmVkIHdpdGhvdXQgYSBnZXR0ZXJcIik7XHJcbiAgICBpZiAodHlwZW9mIHN0YXRlID09PSBcImZ1bmN0aW9uXCIgPyByZWNlaXZlciAhPT0gc3RhdGUgfHwgIWYgOiAhc3RhdGUuaGFzKHJlY2VpdmVyKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkNhbm5vdCByZWFkIHByaXZhdGUgbWVtYmVyIGZyb20gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiBraW5kID09PSBcIm1cIiA/IGYgOiBraW5kID09PSBcImFcIiA/IGYuY2FsbChyZWNlaXZlcikgOiBmID8gZi52YWx1ZSA6IHN0YXRlLmdldChyZWNlaXZlcik7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fY2xhc3NQcml2YXRlRmllbGRTZXQocmVjZWl2ZXIsIHN0YXRlLCB2YWx1ZSwga2luZCwgZikge1xyXG4gICAgaWYgKGtpbmQgPT09IFwibVwiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBtZXRob2QgaXMgbm90IHdyaXRhYmxlXCIpO1xyXG4gICAgaWYgKGtpbmQgPT09IFwiYVwiICYmICFmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiUHJpdmF0ZSBhY2Nlc3NvciB3YXMgZGVmaW5lZCB3aXRob3V0IGEgc2V0dGVyXCIpO1xyXG4gICAgaWYgKHR5cGVvZiBzdGF0ZSA9PT0gXCJmdW5jdGlvblwiID8gcmVjZWl2ZXIgIT09IHN0YXRlIHx8ICFmIDogIXN0YXRlLmhhcyhyZWNlaXZlcikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDYW5ub3Qgd3JpdGUgcHJpdmF0ZSBtZW1iZXIgdG8gYW4gb2JqZWN0IHdob3NlIGNsYXNzIGRpZCBub3QgZGVjbGFyZSBpdFwiKTtcclxuICAgIHJldHVybiAoa2luZCA9PT0gXCJhXCIgPyBmLmNhbGwocmVjZWl2ZXIsIHZhbHVlKSA6IGYgPyBmLnZhbHVlID0gdmFsdWUgOiBzdGF0ZS5zZXQocmVjZWl2ZXIsIHZhbHVlKSksIHZhbHVlO1xyXG59XHJcblxuXG4vKioqLyB9KSxcbi8qIDEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmFsbFRvVXBwZXJDYXNlID0gZXhwb3J0cy5hbGxUb0xvd2VyQ2FzZSA9IGV4cG9ydHMuZW5jb2RlQm9keSA9IGV4cG9ydHMuZGVjb2RlQm9keSA9IGV4cG9ydHMuRm9ybWF0ID0gZXhwb3J0cy5wcm9taXNpZnkgPSBleHBvcnRzLnRyaW0gPSBleHBvcnRzLmFyckNob29zZU4gPSBleHBvcnRzLnJhbmRvbUhleFN0cmluZyA9IGV4cG9ydHMucmFuZG9tU3RyaW5nID0gZXhwb3J0cy5jaGVhcFJhbmRTdHIgPSBleHBvcnRzLmRhdGFTaXplQnl0ZXMgPSBleHBvcnRzLmluc3BlY3RCb2R5ID0gZXhwb3J0cy5pbnNwZWN0RXJyb3IgPSBleHBvcnRzLmlzRXJyb3JJbmZvT3JQYXJ0aWFsRXJyb3JJbmZvID0gZXhwb3J0cy5ub3cgPSBleHBvcnRzLnBhcnNlUXVlcnlTdHJpbmcgPSBleHBvcnRzLnRvUXVlcnlTdHJpbmcgPSBleHBvcnRzLmFyclBvcFJhbmRvbUVsZW1lbnQgPSBleHBvcnRzLmRlZmF1bHRQb3N0SGVhZGVycyA9IGV4cG9ydHMuZGVmYXVsdEdldEhlYWRlcnMgPSBleHBvcnRzLmFsbFNhbWUgPSBleHBvcnRzLmFyckV2ZXJ5ID0gZXhwb3J0cy5hcnJGaWx0ZXIgPSBleHBvcnRzLmFyck1hcCA9IGV4cG9ydHMuc2FmZUFyckZvckVhY2ggPSBleHBvcnRzLmFyckZvckVhY2ggPSBleHBvcnRzLmZvckluT3duTm9uTnVsbFByb3BlcnRpZXMgPSBleHBvcnRzLnZhbHVlc0FycmF5ID0gZXhwb3J0cy5rZXlzQXJyYXkgPSBleHBvcnRzLmFycldpdGhvdXRWYWx1ZSA9IGV4cG9ydHMuYXJyRGVsZXRlVmFsdWUgPSBleHBvcnRzLmFyckluID0gZXhwb3J0cy5hcnJJbmRleE9mID0gZXhwb3J0cy5hcnJTdWJ0cmFjdCA9IGV4cG9ydHMuYXJySW50ZXJzZWN0T2IgPSBleHBvcnRzLmFyckludGVyc2VjdCA9IGV4cG9ydHMuaW50ZXJzZWN0ID0gZXhwb3J0cy5jb250YWluc1ZhbHVlID0gZXhwb3J0cy5pbmhlcml0cyA9IGV4cG9ydHMucHJvdG90eXBpY2FsQ2xvbmUgPSBleHBvcnRzLnNoYWxsb3dDbG9uZSA9IGV4cG9ydHMuaXNFbXB0eUFyZyA9IGV4cG9ydHMuaXNPbmx5UHJvcEluID0gZXhwb3J0cy5pc0VtcHR5ID0gZXhwb3J0cy5pc09iamVjdCA9IGV4cG9ydHMuZW5zdXJlQXJyYXkgPSBleHBvcnRzLmlzQXJyYXkgPSBleHBvcnRzLmNvcHkgPSBleHBvcnRzLm1peGluID0gdm9pZCAwO1xuZXhwb3J0cy5hcnJFcXVhbHMgPSBleHBvcnRzLnRvQmFzZTY0ID0gZXhwb3J0cy5tYXRjaERlcml2ZWRDaGFubmVsID0gZXhwb3J0cy5zaGFsbG93RXF1YWxzID0gZXhwb3J0cy5nZXRHbG9iYWxPYmplY3QgPSBleHBvcnRzLmdldFJldHJ5VGltZSA9IGV4cG9ydHMuZ2V0Sml0dGVyQ29lZmZpY2llbnQgPSBleHBvcnRzLmdldEJhY2tvZmZDb2VmZmljaWVudCA9IHZvaWQgMDtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgZGVmYXVsdHNfMSA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oOCkpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgZW5jX2Jhc2U2NF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMSk7XG52YXIgZW5jX3V0ZjhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xuZnVuY3Rpb24gcmFuZG9tUG9zbihhcnJPclN0cikge1xuICAgIHJldHVybiBNYXRoLmZsb29yKE1hdGgucmFuZG9tKCkgKiBhcnJPclN0ci5sZW5ndGgpO1xufVxuLypcbiAqIEFkZCBhIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGEgdGFyZ2V0IG9iamVjdFxuICogdGFyZ2V0OiB0aGUgdGFyZ2V0IG9iamVjdFxuICogcHJvcHM6ICBhbiBvYmplY3Qgd2hvc2UgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZVxuICogICAgICAgICBhZGRlZCwgYnkgcmVmZXJlbmNlIG9ubHlcbiAqL1xuZnVuY3Rpb24gbWl4aW4odGFyZ2V0KSB7XG4gICAgdmFyIGFyZ3MgPSBbXTtcbiAgICBmb3IgKHZhciBfaSA9IDE7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgIH1cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIHNvdXJjZSA9IGFyZ3NbaV07XG4gICAgICAgIGlmICghc291cmNlKSB7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgICAgICB2YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gc291cmNlKSB7XG4gICAgICAgICAgICBpZiAoIWhhc093blByb3BlcnR5IHx8IGhhc093blByb3BlcnR5LmNhbGwoc291cmNlLCBrZXkpKSB7XG4gICAgICAgICAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdGFyZ2V0O1xufVxuZXhwb3J0cy5taXhpbiA9IG1peGluO1xuLypcbiAqIEFkZCBhIHNldCBvZiBwcm9wZXJ0aWVzIHRvIGEgdGFyZ2V0IG9iamVjdFxuICogdGFyZ2V0OiB0aGUgdGFyZ2V0IG9iamVjdFxuICogcHJvcHM6ICBhbiBvYmplY3Qgd2hvc2UgZW51bWVyYWJsZSBwcm9wZXJ0aWVzIGFyZVxuICogICAgICAgICBhZGRlZCwgYnkgcmVmZXJlbmNlIG9ubHlcbiAqL1xuZnVuY3Rpb24gY29weShzcmMpIHtcbiAgICByZXR1cm4gbWl4aW4oe30sIHNyYyk7XG59XG5leHBvcnRzLmNvcHkgPSBjb3B5O1xuLypcbiAqIERldGVybWluZSB3aGV0aGVyIG9yIG5vdCBhIGdpdmVuIG9iamVjdCBpc1xuICogYW4gYXJyYXkuXG4gKi9cbmV4cG9ydHMuaXNBcnJheSA9IEFycmF5LmlzQXJyYXkgfHxcbiAgICBmdW5jdGlvbiAodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbCh2YWx1ZSkgPT0gJ1tvYmplY3QgQXJyYXldJztcbiAgICB9O1xuLypcbiAqIEVuc3VyZXMgdGhhdCBhbiBBcnJheSBvYmplY3QgaXMgYWx3YXlzIHJldHVybmVkXG4gKiByZXR1cm5pbmcgdGhlIG9yaWdpbmFsIEFycmF5IG9mIG9iaiBpcyBhbiBBcnJheVxuICogZWxzZSB3cmFwcGluZyB0aGUgb2JqIGluIGEgc2luZ2xlIGVsZW1lbnQgQXJyYXlcbiAqL1xuZnVuY3Rpb24gZW5zdXJlQXJyYXkob2JqKSB7XG4gICAgaWYgKGlzRW1wdHlBcmcob2JqKSkge1xuICAgICAgICByZXR1cm4gW107XG4gICAgfVxuICAgIGlmICgoMCwgZXhwb3J0cy5pc0FycmF5KShvYmopKSB7XG4gICAgICAgIHJldHVybiBvYmo7XG4gICAgfVxuICAgIHJldHVybiBbb2JqXTtcbn1cbmV4cG9ydHMuZW5zdXJlQXJyYXkgPSBlbnN1cmVBcnJheTtcbmZ1bmN0aW9uIGlzT2JqZWN0KG9iKSB7XG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYikgPT0gJ1tvYmplY3QgT2JqZWN0XSc7XG59XG5leHBvcnRzLmlzT2JqZWN0ID0gaXNPYmplY3Q7XG4vKlxuICogRGV0ZXJtaW5lIHdoZXRoZXIgb3Igbm90IGFuIG9iamVjdCBjb250YWluc1xuICogYW55IGVudW1lcmFibGUgcHJvcGVydGllcy5cbiAqIG9iOiB0aGUgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIGlzRW1wdHkob2IpIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iKVxuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzRW1wdHkgPSBpc0VtcHR5O1xuZnVuY3Rpb24gaXNPbmx5UHJvcEluKG9iLCBwcm9wZXJ0eSkge1xuICAgIGZvciAodmFyIHByb3AgaW4gb2IpIHtcbiAgICAgICAgaWYgKHByb3AgIT09IHByb3BlcnR5KSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59XG5leHBvcnRzLmlzT25seVByb3BJbiA9IGlzT25seVByb3BJbjtcbi8qXG4gKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYW4gYXJndW1lbnQgdG8gYW4gb3ZlcmxvYWRlZCBmdW5jdGlvbiBpc1xuICogdW5kZWZpbmVkIChtaXNzaW5nKSBvciBudWxsLlxuICogVGhpcyBtZXRob2QgaXMgdXNlZnVsIHdoZW4gY29uc3RydWN0aW5nIGZ1bmN0aW9ucyBzdWNoIGFzIChXZWJJREwgdGVybWlub2xvZ3kpOlxuICogICBvZmYoW1RyZWF0VW5kZWZpbmVkQXM9TnVsbF0gRE9NU3RyaW5nPyBldmVudClcbiAqIGFzIHlvdSBjYW4gdGhlbiBjb25maXJtIHRoZSBhcmd1bWVudCB1c2luZzpcbiAqICAgVXRpbHMuaXNFbXB0eUFyZyhldmVudClcbiAqL1xuZnVuY3Rpb24gaXNFbXB0eUFyZyhhcmcpIHtcbiAgICByZXR1cm4gYXJnID09PSBudWxsIHx8IGFyZyA9PT0gdW5kZWZpbmVkO1xufVxuZXhwb3J0cy5pc0VtcHR5QXJnID0gaXNFbXB0eUFyZztcbi8qXG4gKiBQZXJmb3JtIGEgc2ltcGxlIHNoYWxsb3cgY2xvbmUgb2YgYW4gb2JqZWN0LlxuICogUmVzdWx0IGlzIGFuIG9iamVjdCBpcnJlc3BlY3RpdmUgb2Ygd2hldGhlclxuICogdGhlIGlucHV0IGlzIGFuIG9iamVjdCBvciBhcnJheS4gQWxsXG4gKiBlbnVtZXJhYmxlIHByb3BlcnRpZXMgYXJlIGNvcGllZC5cbiAqIG9iOiB0aGUgb2JqZWN0XG4gKi9cbmZ1bmN0aW9uIHNoYWxsb3dDbG9uZShvYikge1xuICAgIHZhciByZXN1bHQgPSBuZXcgT2JqZWN0KCk7XG4gICAgZm9yICh2YXIgcHJvcCBpbiBvYilcbiAgICAgICAgcmVzdWx0W3Byb3BdID0gb2JbcHJvcF07XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuc2hhbGxvd0Nsb25lID0gc2hhbGxvd0Nsb25lO1xuLypcbiAqIENsb25lIGFuIG9iamVjdCBieSBjcmVhdGluZyBhIG5ldyBvYmplY3Qgd2l0aCB0aGVcbiAqIGdpdmVuIG9iamVjdCBhcyBpdHMgcHJvdG90eXBlLiBPcHRpb25hbGx5XG4gKiBhIHNldCBvZiBhZGRpdGlvbmFsIG93biBwcm9wZXJ0aWVzIGNhbiBiZVxuICogc3VwcGxpZWQgdG8gYmUgYWRkZWQgdG8gdGhlIG5ld2x5IGNyZWF0ZWQgY2xvbmUuXG4gKiBvYjogICAgICAgICAgICB0aGUgb2JqZWN0IHRvIGJlIGNsb25lZFxuICogb3duUHJvcGVydGllczogb3B0aW9uYWwgb2JqZWN0IHdpdGggYWRkaXRpb25hbFxuICogICAgICAgICAgICAgICAgcHJvcGVydGllcyB0byBhZGRcbiAqL1xuZnVuY3Rpb24gcHJvdG90eXBpY2FsQ2xvbmUob2IsIG93blByb3BlcnRpZXMpIHtcbiAgICB2YXIgRiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgZnVuY3Rpb24gRigpIHtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gRjtcbiAgICB9KCkpO1xuICAgIEYucHJvdG90eXBlID0gb2I7XG4gICAgdmFyIHJlc3VsdCA9IG5ldyBGKCk7XG4gICAgaWYgKG93blByb3BlcnRpZXMpXG4gICAgICAgIG1peGluKHJlc3VsdCwgb3duUHJvcGVydGllcyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMucHJvdG90eXBpY2FsQ2xvbmUgPSBwcm90b3R5cGljYWxDbG9uZTtcbi8qXG4gKiBEZWNsYXJlIGEgY29uc3RydWN0b3IgdG8gcmVwcmVzZW50IGEgc3ViY2xhc3NcbiAqIG9mIGFub3RoZXIgY29uc3RydWN0b3JcbiAqIElmIHBsYXRmb3JtIGhhcyBhIGJ1aWx0LWluIHZlcnNpb24gd2UgdXNlIHRoYXQgZnJvbSBQbGF0Zm9ybSwgZWxzZSB3ZVxuICogZGVmaW5lIGhlcmUgKHNvIGNhbiBtYWtlIHVzZSBvZiBvdGhlciBVdGlscyBmbnMpXG4gKiBTZWUgbm9kZS5qcyB1dGlsLmluaGVyaXRzXG4gKi9cbnZhciBpbmhlcml0cyA9IGZ1bmN0aW9uIChjdG9yLCBzdXBlckN0b3IpIHtcbiAgICBpZiAocGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbmhlcml0cykge1xuICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluaGVyaXRzKGN0b3IsIHN1cGVyQ3Rvcik7XG4gICAgICAgIHJldHVybjtcbiAgICB9XG4gICAgY3Rvci5zdXBlcl8gPSBzdXBlckN0b3I7XG4gICAgY3Rvci5wcm90b3R5cGUgPSBwcm90b3R5cGljYWxDbG9uZShzdXBlckN0b3IucHJvdG90eXBlLCB7IGNvbnN0cnVjdG9yOiBjdG9yIH0pO1xufTtcbmV4cG9ydHMuaW5oZXJpdHMgPSBpbmhlcml0cztcbi8qXG4gKiBEZXRlcm1pbmUgd2hldGhlciBvciBub3QgYW4gb2JqZWN0IGhhcyBhbiBlbnVtZXJhYmxlXG4gKiBwcm9wZXJ0eSB3aG9zZSB2YWx1ZSBlcXVhbHMgYSBnaXZlbiB2YWx1ZS5cbiAqIG9iOiAgdGhlIG9iamVjdFxuICogdmFsOiB0aGUgdmFsdWUgdG8gZmluZFxuICovXG5mdW5jdGlvbiBjb250YWluc1ZhbHVlKG9iLCB2YWwpIHtcbiAgICBmb3IgKHZhciBpIGluIG9iKSB7XG4gICAgICAgIGlmIChvYltpXSA9PSB2YWwpXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGZhbHNlO1xufVxuZXhwb3J0cy5jb250YWluc1ZhbHVlID0gY29udGFpbnNWYWx1ZTtcbmZ1bmN0aW9uIGludGVyc2VjdChhcnIsIG9iKSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmlzQXJyYXkpKG9iKSA/IGFyckludGVyc2VjdChhcnIsIG9iKSA6IGFyckludGVyc2VjdE9iKGFyciwgb2IpO1xufVxuZXhwb3J0cy5pbnRlcnNlY3QgPSBpbnRlcnNlY3Q7XG5mdW5jdGlvbiBhcnJJbnRlcnNlY3QoYXJyMSwgYXJyMikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFycjEubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIG1lbWJlciA9IGFycjFbaV07XG4gICAgICAgIGlmICgoMCwgZXhwb3J0cy5hcnJJbmRleE9mKShhcnIyLCBtZW1iZXIpICE9IC0xKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobWVtYmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuYXJySW50ZXJzZWN0ID0gYXJySW50ZXJzZWN0O1xuZnVuY3Rpb24gYXJySW50ZXJzZWN0T2IoYXJyLCBvYikge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbWVtYmVyID0gYXJyW2ldO1xuICAgICAgICBpZiAobWVtYmVyIGluIG9iKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2gobWVtYmVyKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuYXJySW50ZXJzZWN0T2IgPSBhcnJJbnRlcnNlY3RPYjtcbmZ1bmN0aW9uIGFyclN1YnRyYWN0KGFycjEsIGFycjIpIHtcbiAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnIxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBlbGVtZW50ID0gYXJyMVtpXTtcbiAgICAgICAgaWYgKCgwLCBleHBvcnRzLmFyckluZGV4T2YpKGFycjIsIGVsZW1lbnQpID09IC0xKVxuICAgICAgICAgICAgcmVzdWx0LnB1c2goZWxlbWVudCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmFyclN1YnRyYWN0ID0gYXJyU3VidHJhY3Q7XG5leHBvcnRzLmFyckluZGV4T2YgPSBBcnJheS5wcm90b3R5cGUuaW5kZXhPZlxuICAgID8gZnVuY3Rpb24gKGFyciwgZWxlbSwgZnJvbUluZGV4KSB7XG4gICAgICAgIHJldHVybiBhcnIuaW5kZXhPZihlbGVtLCBmcm9tSW5kZXgpO1xuICAgIH1cbiAgICA6IGZ1bmN0aW9uIChhcnIsIGVsZW0sIGZyb21JbmRleCkge1xuICAgICAgICBmcm9tSW5kZXggPSBmcm9tSW5kZXggfHwgMDtcbiAgICAgICAgdmFyIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgICAgIGZvciAoOyBmcm9tSW5kZXggPCBsZW47IGZyb21JbmRleCsrKSB7XG4gICAgICAgICAgICBpZiAoYXJyW2Zyb21JbmRleF0gPT09IGVsZW0pIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gZnJvbUluZGV4O1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiAtMTtcbiAgICB9O1xuZnVuY3Rpb24gYXJySW4oYXJyLCB2YWwpIHtcbiAgICByZXR1cm4gKDAsIGV4cG9ydHMuYXJySW5kZXhPZikoYXJyLCB2YWwpICE9PSAtMTtcbn1cbmV4cG9ydHMuYXJySW4gPSBhcnJJbjtcbmZ1bmN0aW9uIGFyckRlbGV0ZVZhbHVlKGFyciwgdmFsKSB7XG4gICAgdmFyIGlkeCA9ICgwLCBleHBvcnRzLmFyckluZGV4T2YpKGFyciwgdmFsKTtcbiAgICB2YXIgcmVzID0gaWR4ICE9IC0xO1xuICAgIGlmIChyZXMpXG4gICAgICAgIGFyci5zcGxpY2UoaWR4LCAxKTtcbiAgICByZXR1cm4gcmVzO1xufVxuZXhwb3J0cy5hcnJEZWxldGVWYWx1ZSA9IGFyckRlbGV0ZVZhbHVlO1xuZnVuY3Rpb24gYXJyV2l0aG91dFZhbHVlKGFyciwgdmFsKSB7XG4gICAgdmFyIG5ld0FyciA9IGFyci5zbGljZSgpO1xuICAgIGFyckRlbGV0ZVZhbHVlKG5ld0FyciwgdmFsKTtcbiAgICByZXR1cm4gbmV3QXJyO1xufVxuZXhwb3J0cy5hcnJXaXRob3V0VmFsdWUgPSBhcnJXaXRob3V0VmFsdWU7XG4vKlxuICogQ29uc3RydWN0IGFuIGFycmF5IG9mIHRoZSBrZXlzIG9mIHRoZSBlbnVtZXJhYmxlXG4gKiBwcm9wZXJ0aWVzIG9mIGEgZ2l2ZW4gb2JqZWN0LCBvcHRpb25hbGx5IGxpbWl0ZWRcbiAqIHRvIG9ubHkgdGhlIG93biBwcm9wZXJ0aWVzLlxuICogb2I6ICAgICAgdGhlIG9iamVjdFxuICogb3duT25seTogYm9vbGVhbiwgZ2V0IG93biBwcm9wZXJ0aWVzIG9ubHlcbiAqL1xuZnVuY3Rpb24ga2V5c0FycmF5KG9iLCBvd25Pbmx5KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIHByb3AgaW4gb2IpIHtcbiAgICAgICAgaWYgKG93bk9ubHkgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYiwgcHJvcCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmVzdWx0LnB1c2gocHJvcCk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG59XG5leHBvcnRzLmtleXNBcnJheSA9IGtleXNBcnJheTtcbi8qXG4gKiBDb25zdHJ1Y3QgYW4gYXJyYXkgb2YgdGhlIHZhbHVlcyBvZiB0aGUgZW51bWVyYWJsZVxuICogcHJvcGVydGllcyBvZiBhIGdpdmVuIG9iamVjdCwgb3B0aW9uYWxseSBsaW1pdGVkXG4gKiB0byBvbmx5IHRoZSBvd24gcHJvcGVydGllcy5cbiAqIG9iOiAgICAgIHRoZSBvYmplY3RcbiAqIG93bk9ubHk6IGJvb2xlYW4sIGdldCBvd24gcHJvcGVydGllcyBvbmx5XG4gKi9cbmZ1bmN0aW9uIHZhbHVlc0FycmF5KG9iLCBvd25Pbmx5KSB7XG4gICAgdmFyIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIHByb3AgaW4gb2IpIHtcbiAgICAgICAgaWYgKG93bk9ubHkgJiYgIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYiwgcHJvcCkpXG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgcmVzdWx0LnB1c2gob2JbcHJvcF0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy52YWx1ZXNBcnJheSA9IHZhbHVlc0FycmF5O1xuZnVuY3Rpb24gZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllcyhvYiwgZm4pIHtcbiAgICBmb3IgKHZhciBwcm9wIGluIG9iKSB7XG4gICAgICAgIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwob2IsIHByb3ApICYmIG9iW3Byb3BdKSB7XG4gICAgICAgICAgICBmbihwcm9wKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmV4cG9ydHMuZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllcyA9IGZvckluT3duTm9uTnVsbFByb3BlcnRpZXM7XG5leHBvcnRzLmFyckZvckVhY2ggPSBBcnJheS5wcm90b3R5cGUuZm9yRWFjaFxuICAgID8gZnVuY3Rpb24gKGFyciwgZm4pIHtcbiAgICAgICAgYXJyLmZvckVhY2goZm4pO1xuICAgIH1cbiAgICA6IGZ1bmN0aW9uIChhcnIsIGZuKSB7XG4gICAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBmbihhcnJbaV0sIGksIGFycik7XG4gICAgICAgIH1cbiAgICB9O1xuLyogVXNlZnVsIHdoZW4gdGhlIGZ1bmN0aW9uIG1heSBtdXRhdGUgdGhlIGFycmF5ICovXG5mdW5jdGlvbiBzYWZlQXJyRm9yRWFjaChhcnIsIGZuKSB7XG4gICAgcmV0dXJuICgwLCBleHBvcnRzLmFyckZvckVhY2gpKGFyci5zbGljZSgpLCBmbik7XG59XG5leHBvcnRzLnNhZmVBcnJGb3JFYWNoID0gc2FmZUFyckZvckVhY2g7XG5leHBvcnRzLmFyck1hcCA9IEFycmF5LnByb3RvdHlwZS5tYXBcbiAgICA/IGZ1bmN0aW9uIChhcnIsIGZuKSB7XG4gICAgICAgIHJldHVybiBhcnIubWFwKGZuKTtcbiAgICB9XG4gICAgOiBmdW5jdGlvbiAoYXJyLCBmbikge1xuICAgICAgICB2YXIgcmVzdWx0ID0gW107XG4gICAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICByZXN1bHQucHVzaChmbihhcnJbaV0sIGksIGFycikpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbmV4cG9ydHMuYXJyRmlsdGVyID0gQXJyYXkucHJvdG90eXBlLmZpbHRlclxuICAgID8gZnVuY3Rpb24gKGFyciwgZm4pIHtcbiAgICAgICAgcmV0dXJuIGFyci5maWx0ZXIoZm4pO1xuICAgIH1cbiAgICA6IGZ1bmN0aW9uIChhcnIsIGZuKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSBbXSwgbGVuID0gYXJyLmxlbmd0aDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgICAgICAgICAgaWYgKGZuKGFycltpXSkpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQucHVzaChhcnJbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbmV4cG9ydHMuYXJyRXZlcnkgPSBBcnJheS5wcm90b3R5cGUuZXZlcnlcbiAgICA/IGZ1bmN0aW9uIChhcnIsIGZuKSB7XG4gICAgICAgIHJldHVybiBhcnIuZXZlcnkoZm4pO1xuICAgIH1cbiAgICA6IGZ1bmN0aW9uIChhcnIsIGZuKSB7XG4gICAgICAgIHZhciBsZW4gPSBhcnIubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICBpZiAoIWZuKGFycltpXSwgaSwgYXJyKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuZnVuY3Rpb24gYWxsU2FtZShhcnIsIHByb3ApIHtcbiAgICBpZiAoYXJyLmxlbmd0aCA9PT0gMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgdmFyIGZpcnN0ID0gYXJyWzBdW3Byb3BdO1xuICAgIHJldHVybiAoMCwgZXhwb3J0cy5hcnJFdmVyeSkoYXJyLCBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICByZXR1cm4gaXRlbVtwcm9wXSA9PT0gZmlyc3Q7XG4gICAgfSk7XG59XG5leHBvcnRzLmFsbFNhbWUgPSBhbGxTYW1lO1xudmFyIGNvbnRlbnRUeXBlcyA9IHtcbiAgICBqc29uOiAnYXBwbGljYXRpb24vanNvbicsXG4gICAganNvbnA6ICdhcHBsaWNhdGlvbi9qYXZhc2NyaXB0JyxcbiAgICB4bWw6ICdhcHBsaWNhdGlvbi94bWwnLFxuICAgIGh0bWw6ICd0ZXh0L2h0bWwnLFxuICAgIG1zZ3BhY2s6ICdhcHBsaWNhdGlvbi94LW1zZ3BhY2snLFxufTtcbmZ1bmN0aW9uIGRlZmF1bHRHZXRIZWFkZXJzKG9wdGlvbnMsIGZvcm1hdCkge1xuICAgIHZhciBhY2NlcHQgPSBjb250ZW50VHlwZXNbZm9ybWF0IHx8IEZvcm1hdC5qc29uXTtcbiAgICByZXR1cm4ge1xuICAgICAgICBhY2NlcHQ6IGFjY2VwdCxcbiAgICAgICAgJ1gtQWJseS1WZXJzaW9uJzogZGVmYXVsdHNfMS5kZWZhdWx0LnByb3RvY29sVmVyc2lvbi50b1N0cmluZygpLFxuICAgICAgICAnQWJseS1BZ2VudCc6ICgwLCBkZWZhdWx0c18xLmdldEFnZW50U3RyaW5nKShvcHRpb25zKSxcbiAgICB9O1xufVxuZXhwb3J0cy5kZWZhdWx0R2V0SGVhZGVycyA9IGRlZmF1bHRHZXRIZWFkZXJzO1xuZnVuY3Rpb24gZGVmYXVsdFBvc3RIZWFkZXJzKG9wdGlvbnMsIGZvcm1hdCkge1xuICAgIHZhciBjb250ZW50VHlwZTtcbiAgICB2YXIgYWNjZXB0ID0gKGNvbnRlbnRUeXBlID0gY29udGVudFR5cGVzW2Zvcm1hdCB8fCBGb3JtYXQuanNvbl0pO1xuICAgIHJldHVybiB7XG4gICAgICAgIGFjY2VwdDogYWNjZXB0LFxuICAgICAgICAnY29udGVudC10eXBlJzogY29udGVudFR5cGUsXG4gICAgICAgICdYLUFibHktVmVyc2lvbic6IGRlZmF1bHRzXzEuZGVmYXVsdC5wcm90b2NvbFZlcnNpb24udG9TdHJpbmcoKSxcbiAgICAgICAgJ0FibHktQWdlbnQnOiAoMCwgZGVmYXVsdHNfMS5nZXRBZ2VudFN0cmluZykob3B0aW9ucyksXG4gICAgfTtcbn1cbmV4cG9ydHMuZGVmYXVsdFBvc3RIZWFkZXJzID0gZGVmYXVsdFBvc3RIZWFkZXJzO1xuZnVuY3Rpb24gYXJyUG9wUmFuZG9tRWxlbWVudChhcnIpIHtcbiAgICByZXR1cm4gYXJyLnNwbGljZShyYW5kb21Qb3NuKGFyciksIDEpWzBdO1xufVxuZXhwb3J0cy5hcnJQb3BSYW5kb21FbGVtZW50ID0gYXJyUG9wUmFuZG9tRWxlbWVudDtcbmZ1bmN0aW9uIHRvUXVlcnlTdHJpbmcocGFyYW1zKSB7XG4gICAgdmFyIHBhcnRzID0gW107XG4gICAgaWYgKHBhcmFtcykge1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gcGFyYW1zKVxuICAgICAgICAgICAgcGFydHMucHVzaChlbmNvZGVVUklDb21wb25lbnQoa2V5KSArICc9JyArIGVuY29kZVVSSUNvbXBvbmVudChwYXJhbXNba2V5XSkpO1xuICAgIH1cbiAgICByZXR1cm4gcGFydHMubGVuZ3RoID8gJz8nICsgcGFydHMuam9pbignJicpIDogJyc7XG59XG5leHBvcnRzLnRvUXVlcnlTdHJpbmcgPSB0b1F1ZXJ5U3RyaW5nO1xuZnVuY3Rpb24gcGFyc2VRdWVyeVN0cmluZyhxdWVyeSkge1xuICAgIHZhciBtYXRjaDtcbiAgICB2YXIgc2VhcmNoID0gLyhbXj8mPV0rKT0/KFteJl0qKS9nO1xuICAgIHZhciByZXN1bHQgPSB7fTtcbiAgICB3aGlsZSAoKG1hdGNoID0gc2VhcmNoLmV4ZWMocXVlcnkpKSlcbiAgICAgICAgcmVzdWx0W2RlY29kZVVSSUNvbXBvbmVudChtYXRjaFsxXSldID0gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzJdKTtcbiAgICByZXR1cm4gcmVzdWx0O1xufVxuZXhwb3J0cy5wYXJzZVF1ZXJ5U3RyaW5nID0gcGFyc2VRdWVyeVN0cmluZztcbmV4cG9ydHMubm93ID0gRGF0ZS5ub3cgfHxcbiAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIElFIDggKi9cbiAgICAgICAgcmV0dXJuIG5ldyBEYXRlKCkuZ2V0VGltZSgpO1xuICAgIH07XG5mdW5jdGlvbiBpc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbyhlcnIpIHtcbiAgICByZXR1cm4gKHR5cGVvZiBlcnIgPT0gJ29iamVjdCcgJiZcbiAgICAgICAgZXJyICE9PSBudWxsICYmXG4gICAgICAgIChlcnIuY29uc3RydWN0b3IubmFtZSA9PSAnRXJyb3JJbmZvJyB8fCBlcnIuY29uc3RydWN0b3IubmFtZSA9PSAnUGFydGlhbEVycm9ySW5mbycpKTtcbn1cbmV4cG9ydHMuaXNFcnJvckluZm9PclBhcnRpYWxFcnJvckluZm8gPSBpc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbztcbmZ1bmN0aW9uIGluc3BlY3RFcnJvcihlcnIpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvciB8fFxuICAgICAgICAoKF9hID0gZXJyID09PSBudWxsIHx8IGVyciA9PT0gdm9pZCAwID8gdm9pZCAwIDogZXJyLmNvbnN0cnVjdG9yKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EubmFtZSkgPT09ICdFcnJvckluZm8nIHx8XG4gICAgICAgICgoX2IgPSBlcnIgPT09IG51bGwgfHwgZXJyID09PSB2b2lkIDAgPyB2b2lkIDAgOiBlcnIuY29uc3RydWN0b3IpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5uYW1lKSA9PT0gJ1BhcnRpYWxFcnJvckluZm8nKVxuICAgICAgICByZXR1cm4gZXJyLnRvU3RyaW5nKCk7XG4gICAgcmV0dXJuIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdChlcnIpO1xufVxuZXhwb3J0cy5pbnNwZWN0RXJyb3IgPSBpbnNwZWN0RXJyb3I7XG5mdW5jdGlvbiBpbnNwZWN0Qm9keShib2R5KSB7XG4gICAgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5pc0J1ZmZlcihib2R5KSkge1xuICAgICAgICByZXR1cm4gYm9keS50b1N0cmluZygpO1xuICAgIH1cbiAgICBlbHNlIGlmICh0eXBlb2YgYm9keSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgcmV0dXJuIGJvZHk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KGJvZHkpO1xuICAgIH1cbn1cbmV4cG9ydHMuaW5zcGVjdEJvZHkgPSBpbnNwZWN0Qm9keTtcbi8qIERhdGEgaXMgYXNzdW1lZCB0byBiZSBlaXRoZXIgYSBzdHJpbmcgb3IgYSBidWZmZXIuICovXG5mdW5jdGlvbiBkYXRhU2l6ZUJ5dGVzKGRhdGEpIHtcbiAgICBpZiAocGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmlzQnVmZmVyKGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuYnl0ZUxlbmd0aChkYXRhKTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBkYXRhID09PSAnc3RyaW5nJykge1xuICAgICAgICByZXR1cm4gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5zdHJpbmdCeXRlU2l6ZShkYXRhKTtcbiAgICB9XG4gICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnB1dCBvZiBVdGlscy5kYXRhU2l6ZUJ5dGVzIHRvIGJlIGEgYnVmZmVyIG9yIHN0cmluZywgYnV0IHdhczogJyArIHR5cGVvZiBkYXRhKTtcbn1cbmV4cG9ydHMuZGF0YVNpemVCeXRlcyA9IGRhdGFTaXplQnl0ZXM7XG5mdW5jdGlvbiBjaGVhcFJhbmRTdHIoKSB7XG4gICAgcmV0dXJuIFN0cmluZyhNYXRoLnJhbmRvbSgpKS5zdWJzdHIoMik7XG59XG5leHBvcnRzLmNoZWFwUmFuZFN0ciA9IGNoZWFwUmFuZFN0cjtcbi8qIFRha2VzIHBhcmFtIHRoZSBtaW5pbXVtIG51bWJlciBvZiBieXRlcyBvZiBlbnRyb3B5IHRoZSBzdHJpbmcgbXVzdFxuICogaW5jbHVkZSwgbm90IHRoZSBsZW5ndGggb2YgdGhlIHN0cmluZy4gU3RyaW5nIGxlbmd0aCBwcm9kdWNlZCBpcyBub3RcbiAqIGd1YXJhbnRlZWQuICovXG52YXIgcmFuZG9tU3RyaW5nID0gZnVuY3Rpb24gKG51bUJ5dGVzKSB7XG4gICAgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuZ2V0UmFuZG9tVmFsdWVzICYmIHR5cGVvZiBVaW50OEFycmF5ICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICB2YXIgdUludEFyciA9IG5ldyBVaW50OEFycmF5KG51bUJ5dGVzKTtcbiAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5nZXRSYW5kb21WYWx1ZXModUludEFycik7XG4gICAgICAgIHJldHVybiBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKHVJbnRBcnIpO1xuICAgIH1cbiAgICAvKiBPbGQgYnJvd3NlcjsgZmFsbCBiYWNrIHRvIE1hdGgucmFuZG9tLiBDb3VsZCBqdXN0IHVzZSBhXG4gICAgICogQ3J5cHRvSlMgdmVyc2lvbiBvZiB0aGUgYWJvdmUsIGJ1dCB3YW50IHRoaXMgdG8gc3RpbGwgd29yayBpbiBub2NyeXB0b1xuICAgICAqIHZlcnNpb25zIG9mIHRoZSBsaWJyYXJ5ICovXG4gICAgdmFyIGNoYXJzZXQgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuYmFzZTY0Q2hhclNldDtcbiAgICAvKiBiYXNlNjQgaGFzIDMzJSBvdmVyaGVhZDsgcm91bmQgbGVuZ3RoIHVwICovXG4gICAgdmFyIGxlbmd0aCA9IE1hdGgucm91bmQoKG51bUJ5dGVzICogNCkgLyAzKTtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gY2hhcnNldFtyYW5kb21Qb3NuKGNoYXJzZXQpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLnJhbmRvbVN0cmluZyA9IHJhbmRvbVN0cmluZztcbnZhciByYW5kb21IZXhTdHJpbmcgPSBmdW5jdGlvbiAobnVtQnl0ZXMpIHtcbiAgICBpZiAocGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5nZXRSYW5kb21WYWx1ZXMgJiYgdHlwZW9mIFVpbnQ4QXJyYXkgIT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIHZhciB1SW50QXJyID0gbmV3IFVpbnQ4QXJyYXkobnVtQnl0ZXMpO1xuICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmdldFJhbmRvbVZhbHVlcyh1SW50QXJyKTtcbiAgICAgICAgcmV0dXJuIHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5oZXhFbmNvZGUodUludEFycik7XG4gICAgfVxuICAgIHZhciBjaGFyc2V0ID0gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmhleENoYXJTZXQ7XG4gICAgdmFyIGxlbmd0aCA9IG51bUJ5dGVzICogMjtcbiAgICB2YXIgcmVzdWx0ID0gJyc7XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGg7IGkrKykge1xuICAgICAgICByZXN1bHQgKz0gY2hhcnNldFtyYW5kb21Qb3NuKGNoYXJzZXQpXTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn07XG5leHBvcnRzLnJhbmRvbUhleFN0cmluZyA9IHJhbmRvbUhleFN0cmluZztcbi8qIFBpY2sgbiBlbGVtZW50cyBhdCByYW5kb20gd2l0aG91dCByZXBsYWNlbWVudCBmcm9tIGFuIGFycmF5ICovXG5mdW5jdGlvbiBhcnJDaG9vc2VOKGFyciwgbikge1xuICAgIHZhciBudW1JdGVtcyA9IE1hdGgubWluKG4sIGFyci5sZW5ndGgpLCBtdXRhYmxlQXJyID0gYXJyLnNsaWNlKCksIHJlc3VsdCA9IFtdO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbnVtSXRlbXM7IGkrKykge1xuICAgICAgICByZXN1bHQucHVzaChhcnJQb3BSYW5kb21FbGVtZW50KG11dGFibGVBcnIpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmV4cG9ydHMuYXJyQ2hvb3NlTiA9IGFyckNob29zZU47XG5leHBvcnRzLnRyaW0gPSBTdHJpbmcucHJvdG90eXBlLnRyaW1cbiAgICA/IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgcmV0dXJuIHN0ci50cmltKCk7XG4gICAgfVxuICAgIDogZnVuY3Rpb24gKHN0cikge1xuICAgICAgICByZXR1cm4gc3RyLnJlcGxhY2UoL15bXFxzXFx1RkVGRlxceEEwXSt8W1xcc1xcdUZFRkZcXHhBMF0rJC9nLCAnJyk7XG4gICAgfTtcbmZ1bmN0aW9uIHByb21pc2lmeShvYiwgZm5OYW1lLCBhcmdzKSB7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlLCByZWplY3QpIHtcbiAgICAgICAgb2JbZm5OYW1lXS5hcHBseShvYiwgdHNsaWJfMS5fX3NwcmVhZEFycmF5KHRzbGliXzEuX19zcHJlYWRBcnJheShbXSwgYXJncywgZmFsc2UpLCBbZnVuY3Rpb24gKGVyciwgcmVzKSB7XG4gICAgICAgICAgICAgICAgZXJyID8gcmVqZWN0KGVycikgOiByZXNvbHZlKHJlcyk7XG4gICAgICAgICAgICB9XSwgZmFsc2UpKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMucHJvbWlzaWZ5ID0gcHJvbWlzaWZ5O1xudmFyIEZvcm1hdDtcbihmdW5jdGlvbiAoRm9ybWF0KSB7XG4gICAgRm9ybWF0W1wibXNncGFja1wiXSA9IFwibXNncGFja1wiO1xuICAgIEZvcm1hdFtcImpzb25cIl0gPSBcImpzb25cIjtcbn0pKEZvcm1hdCA9IGV4cG9ydHMuRm9ybWF0IHx8IChleHBvcnRzLkZvcm1hdCA9IHt9KSk7XG5mdW5jdGlvbiBkZWNvZGVCb2R5KGJvZHksIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXQgPT0gJ21zZ3BhY2snID8gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5tc2dwYWNrLmRlY29kZShib2R5KSA6IEpTT04ucGFyc2UoU3RyaW5nKGJvZHkpKTtcbn1cbmV4cG9ydHMuZGVjb2RlQm9keSA9IGRlY29kZUJvZHk7XG5mdW5jdGlvbiBlbmNvZGVCb2R5KGJvZHksIGZvcm1hdCkge1xuICAgIHJldHVybiBmb3JtYXQgPT0gJ21zZ3BhY2snID8gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5tc2dwYWNrLmVuY29kZShib2R5LCB0cnVlKSA6IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xufVxuZXhwb3J0cy5lbmNvZGVCb2R5ID0gZW5jb2RlQm9keTtcbmZ1bmN0aW9uIGFsbFRvTG93ZXJDYXNlKGFycikge1xuICAgIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQudG9Mb3dlckNhc2UoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuYWxsVG9Mb3dlckNhc2UgPSBhbGxUb0xvd2VyQ2FzZTtcbmZ1bmN0aW9uIGFsbFRvVXBwZXJDYXNlKGFycikge1xuICAgIHJldHVybiBhcnIubWFwKGZ1bmN0aW9uIChlbGVtZW50KSB7XG4gICAgICAgIHJldHVybiBlbGVtZW50ICYmIGVsZW1lbnQudG9VcHBlckNhc2UoKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuYWxsVG9VcHBlckNhc2UgPSBhbGxUb1VwcGVyQ2FzZTtcbmZ1bmN0aW9uIGdldEJhY2tvZmZDb2VmZmljaWVudChjb3VudCkge1xuICAgIHJldHVybiBNYXRoLm1pbigoY291bnQgKyAyKSAvIDMsIDIpO1xufVxuZXhwb3J0cy5nZXRCYWNrb2ZmQ29lZmZpY2llbnQgPSBnZXRCYWNrb2ZmQ29lZmZpY2llbnQ7XG5mdW5jdGlvbiBnZXRKaXR0ZXJDb2VmZmljaWVudCgpIHtcbiAgICByZXR1cm4gMSAtIE1hdGgucmFuZG9tKCkgKiAwLjI7XG59XG5leHBvcnRzLmdldEppdHRlckNvZWZmaWNpZW50ID0gZ2V0Sml0dGVyQ29lZmZpY2llbnQ7XG4vKipcbiAqXG4gKiBAcGFyYW0gaW5pdGlhbFRpbWVvdXQgaW5pdGlhbCB0aW1lb3V0IHZhbHVlXG4gKiBAcGFyYW0gcmV0cnlBdHRlbXB0IGludGVnZXIgaW5kaWNhdGluZyByZXRyeUF0dGVtcHRcbiAqIEByZXR1cm5zIFJldHJ5VGltZW91dCB2YWx1ZSBmb3IgZ2l2ZW4gdGltZW91dCBhbmQgcmV0cnlBdHRlbXB0LlxuICogSWYgeCBpcyB0aGUgdmFsdWUgZ2VuZXJhdGVkIHRoZW4sXG4gKiBVcHBlciBib3VuZCA9IG1pbigocmV0cnlBdHRlbXB0ICsgMikgLyAzLCAyKSAqIGluaXRpYWxUaW1lb3V0LFxuICogTG93ZXIgYm91bmQgPSAwLjggKiBVcHBlciBib3VuZCxcbiAqIExvd2VyIGJvdW5kIDwgeCA8IFVwcGVyIGJvdW5kXG4gKi9cbmZ1bmN0aW9uIGdldFJldHJ5VGltZShpbml0aWFsVGltZW91dCwgcmV0cnlBdHRlbXB0KSB7XG4gICAgcmV0dXJuIGluaXRpYWxUaW1lb3V0ICogZ2V0QmFja29mZkNvZWZmaWNpZW50KHJldHJ5QXR0ZW1wdCkgKiBnZXRKaXR0ZXJDb2VmZmljaWVudCgpO1xufVxuZXhwb3J0cy5nZXRSZXRyeVRpbWUgPSBnZXRSZXRyeVRpbWU7XG5mdW5jdGlvbiBnZXRHbG9iYWxPYmplY3QoKSB7XG4gICAgaWYgKGdsb2JhbCkge1xuICAgICAgICByZXR1cm4gZ2xvYmFsO1xuICAgIH1cbiAgICBpZiAodHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgcmV0dXJuIHdpbmRvdztcbiAgICB9XG4gICAgcmV0dXJuIHNlbGY7XG59XG5leHBvcnRzLmdldEdsb2JhbE9iamVjdCA9IGdldEdsb2JhbE9iamVjdDtcbmZ1bmN0aW9uIHNoYWxsb3dFcXVhbHMoc291cmNlLCB0YXJnZXQpIHtcbiAgICByZXR1cm4gKE9iamVjdC5rZXlzKHNvdXJjZSkuZXZlcnkoZnVuY3Rpb24gKGtleSkgeyByZXR1cm4gc291cmNlW2tleV0gPT09IHRhcmdldFtrZXldOyB9KSAmJlxuICAgICAgICBPYmplY3Qua2V5cyh0YXJnZXQpLmV2ZXJ5KGZ1bmN0aW9uIChrZXkpIHsgcmV0dXJuIHRhcmdldFtrZXldID09PSBzb3VyY2Vba2V5XTsgfSkpO1xufVxuZXhwb3J0cy5zaGFsbG93RXF1YWxzID0gc2hhbGxvd0VxdWFscztcbmZ1bmN0aW9uIG1hdGNoRGVyaXZlZENoYW5uZWwobmFtZSkge1xuICAgIC8qKlxuICAgICAqIFRoaXMgcmVnZXggY2hlY2sgaXMgdG8gcmV0YWluIGV4aXN0aW5nIGNoYW5uZWwgcGFyYW1zIGlmIGFueSBlLmcgWz9yZXdpbmQ9MV1mb28gdG9cbiAgICAgKiBbZmlsdGVyPXh5ej9yZXdpbmQ9MV1mb28uIFRoaXMgaXMgdG8ga2VlcCBjaGFubmVsIGNvbXBhdGliaWxpdHkgYXJvdW5kIHVzZSBvZlxuICAgICAqIGNoYW5uZWwgcGFyYW1zIHRoYXQgd29yayB3aXRoIGRlcml2ZWQgY2hhbm5lbHMuXG4gICAgICpcbiAgICAgKiBUaGlzIGVzbGludCB1bnNhZmUgcmVnZXggd2FybmluZyBpcyB0cmlnZ2VyZWQgYmVjYXVzZSB0aGUgUmVnRXhwIHVzZXMgbmVzdGVkIHF1YW50aWZpZXJzLFxuICAgICAqIGJ1dCBpdCBkb2VzIG5vdCBjcmVhdGUgYW55IHNpdHVhdGlvbiB3aGVyZSB0aGUgcmVnZXggZW5naW5lIGhhcyB0b1xuICAgICAqIGV4cGxvcmUgYSBsYXJnZSBudW1iZXIgb2YgcG9zc2libGUgbWF0Y2hlcyBzbyBpdOKAmXMgc2FmZSB0byBpZ25vcmVcbiAgICAgKi9cbiAgICB2YXIgcmVnZXggPSAvXihcXFsoW14/XSopKD86KC4qKSlcXF0pPyguKykkLzsgLy8gZXNsaW50LWRpc2FibGUtbGluZVxuICAgIHZhciBtYXRjaCA9IG5hbWUubWF0Y2gocmVnZXgpO1xuICAgIGlmICghbWF0Y2ggfHwgIW1hdGNoLmxlbmd0aCB8fCBtYXRjaC5sZW5ndGggPCA1KSB7XG4gICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdyZWdleCBtYXRjaCBmYWlsZWQnLCA0MDAsIDQwMDEwKTtcbiAgICB9XG4gICAgLy8gRmFpbCBpZiB0aGVyZSBpcyBhbHJlYWR5IGEgY2hhbm5lbCBxdWFsaWZpZXIsIGVnIFttZXRhXWZvbyBzaG91bGQgZmFpbCBpbnN0ZWFkIG9mIGp1c3Qgb3ZlcnJpZGluZyB3aXRoIFtmaWx0ZXI9eHl6XWZvb1xuICAgIGlmIChtYXRjaFsyXSkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChcImNhbm5vdCB1c2UgYSBkZXJpdmVkIG9wdGlvbiB3aXRoIGEgXCIuY29uY2F0KG1hdGNoWzJdLCBcIiBjaGFubmVsXCIpLCA0MDAsIDQwMDEwKTtcbiAgICB9XG4gICAgLy8gUmV0dXJuIG1hdGNoIHZhbHVlcyB0byBiZSBhZGRlZCB0byBkZXJpdmUgY2hhbm5lbCBxdWFudGlmaWVyLlxuICAgIHJldHVybiB7XG4gICAgICAgIHF1YWxpZmllclBhcmFtOiBtYXRjaFszXSB8fCAnJyxcbiAgICAgICAgY2hhbm5lbE5hbWU6IG1hdGNoWzRdLFxuICAgIH07XG59XG5leHBvcnRzLm1hdGNoRGVyaXZlZENoYW5uZWwgPSBtYXRjaERlcml2ZWRDaGFubmVsO1xuZnVuY3Rpb24gdG9CYXNlNjQoc3RyKSB7XG4gICAgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuY3JlYXRlSG1hYykge1xuICAgICAgICByZXR1cm4gQnVmZmVyLmZyb20oc3RyLCAnYXNjaWknKS50b1N0cmluZygnYmFzZTY0Jyk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgZW5jX2Jhc2U2NF8xLnN0cmluZ2lmeSkoKDAsIGVuY191dGY4XzEucGFyc2UpKHN0cikpO1xufVxuZXhwb3J0cy50b0Jhc2U2NCA9IHRvQmFzZTY0O1xuZnVuY3Rpb24gYXJyRXF1YWxzKGEsIGIpIHtcbiAgICByZXR1cm4gKGEubGVuZ3RoID09PSBiLmxlbmd0aCAmJlxuICAgICAgICAoMCwgZXhwb3J0cy5hcnJFdmVyeSkoYSwgZnVuY3Rpb24gKHZhbCwgaSkge1xuICAgICAgICAgICAgcmV0dXJuIHZhbCA9PT0gYltpXTtcbiAgICAgICAgfSkpO1xufVxuZXhwb3J0cy5hcnJFcXVhbHMgPSBhcnJFcXVhbHM7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKSkpXG5cbi8qKiovIH0pLFxuLyogMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG4vLyBXb3JrYXJvdW5kIGZvciBzYWxlc2ZvcmNlIGxpZ2h0bmluZyBsb2NrZXIgY29tcGF0aWJpbGl0eVxuLy8gVGhpcyBpcyBhIHNob3J0aGFuZCB2ZXJzaW9uIG9mIFV0aWxzLmdldEdsb2JhbE9iamVjdCAod2hpY2ggd2UgY2FuJ3QgdXNlIGhlcmUgd2l0aG91dCBjcmVhdGluZyBhIGNpcmN1bGFyIGltcG9ydClcbnZhciBnbG9iYWxPYmplY3QgPSBnbG9iYWwgfHwgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gd2luZG93IDogc2VsZik7XG52YXIgTG9nTGV2ZWxzO1xuKGZ1bmN0aW9uIChMb2dMZXZlbHMpIHtcbiAgICBMb2dMZXZlbHNbTG9nTGV2ZWxzW1wiTm9uZVwiXSA9IDBdID0gXCJOb25lXCI7XG4gICAgTG9nTGV2ZWxzW0xvZ0xldmVsc1tcIkVycm9yXCJdID0gMV0gPSBcIkVycm9yXCI7XG4gICAgTG9nTGV2ZWxzW0xvZ0xldmVsc1tcIk1ham9yXCJdID0gMl0gPSBcIk1ham9yXCI7XG4gICAgTG9nTGV2ZWxzW0xvZ0xldmVsc1tcIk1pbm9yXCJdID0gM10gPSBcIk1pbm9yXCI7XG4gICAgTG9nTGV2ZWxzW0xvZ0xldmVsc1tcIk1pY3JvXCJdID0gNF0gPSBcIk1pY3JvXCI7XG59KShMb2dMZXZlbHMgfHwgKExvZ0xldmVscyA9IHt9KSk7XG5mdW5jdGlvbiBwYWQodGltZVNlZ21lbnQsIHRocmVlKSB7XG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KHRpbWVTZWdtZW50KS5wYWRTdGFydCh0aHJlZSA/IDMgOiAyLCAnMCcpO1xufVxuZnVuY3Rpb24gZ2V0SGFuZGxlcihsb2dnZXIpIHtcbiAgICByZXR1cm4gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5sb2dUaW1lc3RhbXBzXG4gICAgICAgID8gZnVuY3Rpb24gKG1zZykge1xuICAgICAgICAgICAgdmFyIHRpbWUgPSBuZXcgRGF0ZSgpO1xuICAgICAgICAgICAgbG9nZ2VyKHBhZCh0aW1lLmdldEhvdXJzKCkpICtcbiAgICAgICAgICAgICAgICAnOicgK1xuICAgICAgICAgICAgICAgIHBhZCh0aW1lLmdldE1pbnV0ZXMoKSkgK1xuICAgICAgICAgICAgICAgICc6JyArXG4gICAgICAgICAgICAgICAgcGFkKHRpbWUuZ2V0U2Vjb25kcygpKSArXG4gICAgICAgICAgICAgICAgJy4nICtcbiAgICAgICAgICAgICAgICBwYWQodGltZS5nZXRNaWxsaXNlY29uZHMoKSwgMSkgK1xuICAgICAgICAgICAgICAgICcgJyArXG4gICAgICAgICAgICAgICAgbXNnKTtcbiAgICAgICAgfVxuICAgICAgICA6IGxvZ2dlcjtcbn1cbnZhciBnZXREZWZhdWx0TG9nZ2VycyA9IGZ1bmN0aW9uICgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHZhciBjb25zb2xlTG9nZ2VyO1xuICAgIHZhciBlcnJvckxvZ2dlcjtcbiAgICAvKiBDYW4ndCBqdXN0IGNoZWNrIGZvciBjb25zb2xlICYmIGNvbnNvbGUubG9nOyBmYWlscyBpbiBJRSA8PTkgKi9cbiAgICBpZiAoKHR5cGVvZiBXaW5kb3cgPT09ICd1bmRlZmluZWQnICYmIHR5cGVvZiBXb3JrZXJHbG9iYWxTY29wZSA9PT0gJ3VuZGVmaW5lZCcpIC8qIG5vZGUgKi8gfHxcbiAgICAgICAgdHlwZW9mICgoX2IgPSAoX2EgPSBnbG9iYWxPYmplY3QgPT09IG51bGwgfHwgZ2xvYmFsT2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnbG9iYWxPYmplY3QuY29uc29sZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmxvZykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmFwcGx5KSA9PT0gJ2Z1bmN0aW9uJyAvKiBzZW5zaWJsZSBicm93c2VycyAqLykge1xuICAgICAgICBjb25zb2xlTG9nZ2VyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY29uc29sZS5sb2cuYXBwbHkoY29uc29sZSwgYXJncyk7XG4gICAgICAgIH07XG4gICAgICAgIGVycm9yTG9nZ2VyID0gY29uc29sZS53YXJuXG4gICAgICAgICAgICA/IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc29sZS53YXJuLmFwcGx5KGNvbnNvbGUsIGFyZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgOiBjb25zb2xlTG9nZ2VyO1xuICAgIH1cbiAgICBlbHNlIGlmIChnbG9iYWxPYmplY3QgPT09IG51bGwgfHwgZ2xvYmFsT2JqZWN0ID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnbG9iYWxPYmplY3QuY29uc29sZS5sb2cpIHtcbiAgICAgICAgLyogSUUgPD0gOSB3aXRoIHRoZSBjb25zb2xlIG9wZW4gLS0gY29uc29sZS5sb2cgZG9lcyBub3RcbiAgICAgICAgICogaW5oZXJpdCBmcm9tIEZ1bmN0aW9uLCBzbyBoYXMgbm8gYXBwbHkgbWV0aG9kICovXG4gICAgICAgIGNvbnNvbGVMb2dnZXIgPSBlcnJvckxvZ2dlciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseS5jYWxsKGNvbnNvbGUubG9nLCBjb25zb2xlLCBhcmd1bWVudHMpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgLyogSUUgPD0gOSB3aGVuIGRldiB0b29scyBhcmUgY2xvc2VkIC0gd2luZG93LmNvbnNvbGUgbm90IGV2ZW4gZGVmaW5lZCAqL1xuICAgICAgICBjb25zb2xlTG9nZ2VyID0gZXJyb3JMb2dnZXIgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgfVxuICAgIHJldHVybiBbY29uc29sZUxvZ2dlciwgZXJyb3JMb2dnZXJdLm1hcChnZXRIYW5kbGVyKTtcbn07XG52YXIgTG9nZ2VyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIExvZ2dlcigpIHtcbiAgICAgICAgTG9nZ2VyLmxvZ0xldmVsID0gTG9nZ2VyLkxPR19ERUZBVUxUO1xuICAgIH1cbiAgICBMb2dnZXIuaW5pdExvZ0hhbmRsZXJzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EgPSBnZXREZWZhdWx0TG9nZ2VycygpLCBsb2dIYW5kbGVyID0gX2FbMF0sIGxvZ0Vycm9ySGFuZGxlciA9IF9hWzFdO1xuICAgICAgICB0aGlzLmxvZ0hhbmRsZXIgPSBsb2dIYW5kbGVyO1xuICAgICAgICB0aGlzLmxvZ0Vycm9ySGFuZGxlciA9IGxvZ0Vycm9ySGFuZGxlcjtcbiAgICB9O1xuICAgIExvZ2dlci5sb2dMZXZlbCA9IExvZ0xldmVscy5FcnJvcjsgLy8gZGVmYXVsdCBsb2dMZXZlbFxuICAgIC8vIHB1YmxpYyBjb25zdGFudHNcbiAgICBMb2dnZXIuTE9HX05PTkUgPSBMb2dMZXZlbHMuTm9uZTtcbiAgICBMb2dnZXIuTE9HX0VSUk9SID0gTG9nTGV2ZWxzLkVycm9yO1xuICAgIExvZ2dlci5MT0dfTUFKT1IgPSBMb2dMZXZlbHMuTWFqb3I7XG4gICAgTG9nZ2VyLkxPR19NSU5PUiA9IExvZ0xldmVscy5NaW5vcjtcbiAgICBMb2dnZXIuTE9HX01JQ1JPID0gTG9nTGV2ZWxzLk1pY3JvO1xuICAgIC8vIGFsaWFzZXNcbiAgICBMb2dnZXIuTE9HX0RFRkFVTFQgPSBMb2dMZXZlbHMuRXJyb3I7XG4gICAgTG9nZ2VyLkxPR19ERUJVRyA9IExvZ0xldmVscy5NaWNybztcbiAgICAvKiBwdWJsaWMgc3RhdGljIGZ1bmN0aW9ucyAqL1xuICAgIExvZ2dlci5sb2dBY3Rpb24gPSBmdW5jdGlvbiAobGV2ZWwsIGFjdGlvbiwgbWVzc2FnZSkge1xuICAgICAgICBpZiAoTG9nZ2VyLnNob3VsZExvZyhsZXZlbCkpIHtcbiAgICAgICAgICAgIChsZXZlbCA9PT0gTG9nTGV2ZWxzLkVycm9yID8gTG9nZ2VyLmxvZ0Vycm9ySGFuZGxlciA6IExvZ2dlci5sb2dIYW5kbGVyKSgnQWJseTogJyArIGFjdGlvbiArICc6ICcgKyBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTG9nZ2VyLmRlcHJlY2F0ZWQgPSBmdW5jdGlvbiAob3JpZ2luYWwsIHJlcGxhY2VtZW50KSB7XG4gICAgICAgIExvZ2dlci5kZXByZWNhdGVkV2l0aE1zZyhvcmlnaW5hbCwgXCJQbGVhc2UgdXNlICdcIiArIHJlcGxhY2VtZW50ICsgXCInIGluc3RlYWQuXCIpO1xuICAgIH07XG4gICAgTG9nZ2VyLmRlcHJlY2F0ZWRXaXRoTXNnID0gZnVuY3Rpb24gKGZ1bmNOYW1lLCBtc2cpIHtcbiAgICAgICAgaWYgKExvZ2dlci5zaG91bGRMb2coTG9nTGV2ZWxzLkVycm9yKSkge1xuICAgICAgICAgICAgTG9nZ2VyLmxvZ0Vycm9ySGFuZGxlcihcIkFibHk6IERlcHJlY2F0aW9uIHdhcm5pbmcgLSAnXCIgKyBmdW5jTmFtZSArIFwiJyBpcyBkZXByZWNhdGVkIGFuZCB3aWxsIGJlIHJlbW92ZWQgZnJvbSBhIGZ1dHVyZSB2ZXJzaW9uLiBcIiArIG1zZyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qIFdoZXJlIGEgbG9nZ2luZyBvcGVyYXRpb24gaXMgZXhwZW5zaXZlLCBzdWNoIGFzIHNlcmlhbGlzYXRpb24gb2YgZGF0YSwgdXNlIHNob3VsZExvZyB3aWxsIHByZXZlbnRcbiAgICAgICAgIHRoZSBvYmplY3QgYmVpbmcgc2VyaWFsaXNlZCBpZiB0aGUgbG9nIGxldmVsIHdpbGwgbm90IG91dHB1dCB0aGUgbWVzc2FnZSAqL1xuICAgIExvZ2dlci5zaG91bGRMb2cgPSBmdW5jdGlvbiAobGV2ZWwpIHtcbiAgICAgICAgcmV0dXJuIGxldmVsIDw9IExvZ2dlci5sb2dMZXZlbDtcbiAgICB9O1xuICAgIExvZ2dlci5zZXRMb2cgPSBmdW5jdGlvbiAobGV2ZWwsIGhhbmRsZXIpIHtcbiAgICAgICAgaWYgKGxldmVsICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICBMb2dnZXIubG9nTGV2ZWwgPSBsZXZlbDtcbiAgICAgICAgaWYgKGhhbmRsZXIgIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIExvZ2dlci5sb2dIYW5kbGVyID0gTG9nZ2VyLmxvZ0Vycm9ySGFuZGxlciA9IGhhbmRsZXI7XG4gICAgfTtcbiAgICByZXR1cm4gTG9nZ2VyO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IExvZ2dlcjtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTMpKSlcblxuLyoqKi8gfSksXG4vKiAzICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgUGxhdGZvcm0gPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGxhdGZvcm0oKSB7XG4gICAgfVxuICAgIHJldHVybiBQbGF0Zm9ybTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQbGF0Zm9ybTtcblxuXG4vKioqLyB9KSxcbi8qIDQgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUGFydGlhbEVycm9ySW5mbyA9IHZvaWQgMDtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbmZ1bmN0aW9uIHRvU3RyaW5nKGVycikge1xuICAgIHZhciByZXN1bHQgPSAnWycgKyBlcnIuY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAoZXJyLm1lc3NhZ2UpXG4gICAgICAgIHJlc3VsdCArPSAnOiAnICsgZXJyLm1lc3NhZ2U7XG4gICAgaWYgKGVyci5zdGF0dXNDb2RlKVxuICAgICAgICByZXN1bHQgKz0gJzsgc3RhdHVzQ29kZT0nICsgZXJyLnN0YXR1c0NvZGU7XG4gICAgaWYgKGVyci5jb2RlKVxuICAgICAgICByZXN1bHQgKz0gJzsgY29kZT0nICsgZXJyLmNvZGU7XG4gICAgaWYgKGVyci5jYXVzZSlcbiAgICAgICAgcmVzdWx0ICs9ICc7IGNhdXNlPScgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyLmNhdXNlKTtcbiAgICBpZiAoZXJyLmhyZWYgJiYgIShlcnIubWVzc2FnZSAmJiBlcnIubWVzc2FnZS5pbmRleE9mKCdoZWxwLmFibHkuaW8nKSA+IC0xKSlcbiAgICAgICAgcmVzdWx0ICs9ICc7IHNlZSAnICsgZXJyLmhyZWYgKyAnICc7XG4gICAgcmVzdWx0ICs9ICddJztcbiAgICByZXR1cm4gcmVzdWx0O1xufVxudmFyIEVycm9ySW5mbyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhFcnJvckluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gRXJyb3JJbmZvKG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUsIGNhdXNlKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XG4gICAgICAgIGlmICh0eXBlb2YgT2JqZWN0LnNldFByb3RvdHlwZU9mICE9PSAndW5kZWZpbmVkJykge1xuICAgICAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBFcnJvckluZm8ucHJvdG90eXBlKTtcbiAgICAgICAgfVxuICAgICAgICBfdGhpcy5jb2RlID0gY29kZTtcbiAgICAgICAgX3RoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG4gICAgICAgIF90aGlzLmNhdXNlID0gY2F1c2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgRXJyb3JJbmZvLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nKHRoaXMpO1xuICAgIH07XG4gICAgRXJyb3JJbmZvLmZyb21WYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHZhciBfYSA9IHZhbHVlcywgbWVzc2FnZSA9IF9hLm1lc3NhZ2UsIGNvZGUgPSBfYS5jb2RlLCBzdGF0dXNDb2RlID0gX2Euc3RhdHVzQ29kZTtcbiAgICAgICAgaWYgKHR5cGVvZiBtZXNzYWdlICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgY29kZSAhPT0gJ251bWJlcicgfHwgdHlwZW9mIHN0YXR1c0NvZGUgIT09ICdudW1iZXInKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0Vycm9ySW5mby5mcm9tVmFsdWVzKCk6IGludmFsaWQgdmFsdWVzOiAnICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KHZhbHVlcykpO1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN1bHQgPSBPYmplY3QuYXNzaWduKG5ldyBFcnJvckluZm8obWVzc2FnZSwgY29kZSwgc3RhdHVzQ29kZSksIHZhbHVlcyk7XG4gICAgICAgIGlmIChyZXN1bHQuY29kZSAmJiAhcmVzdWx0LmhyZWYpIHtcbiAgICAgICAgICAgIHJlc3VsdC5ocmVmID0gJ2h0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yLycgKyByZXN1bHQuY29kZTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIEVycm9ySW5mbztcbn0oRXJyb3IpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEVycm9ySW5mbztcbnZhciBQYXJ0aWFsRXJyb3JJbmZvID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFBhcnRpYWxFcnJvckluZm8sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUGFydGlhbEVycm9ySW5mbyhtZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlLCBjYXVzZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzLCBtZXNzYWdlKSB8fCB0aGlzO1xuICAgICAgICBpZiAodHlwZW9mIE9iamVjdC5zZXRQcm90b3R5cGVPZiAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgUGFydGlhbEVycm9ySW5mby5wcm90b3R5cGUpO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmNvZGUgPSBjb2RlO1xuICAgICAgICBfdGhpcy5zdGF0dXNDb2RlID0gc3RhdHVzQ29kZTtcbiAgICAgICAgX3RoaXMuY2F1c2UgPSBjYXVzZTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQYXJ0aWFsRXJyb3JJbmZvLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRvU3RyaW5nKHRoaXMpO1xuICAgIH07XG4gICAgcmV0dXJuIFBhcnRpYWxFcnJvckluZm87XG59KEVycm9yKSk7XG5leHBvcnRzLlBhcnRpYWxFcnJvckluZm8gPSBQYXJ0aWFsRXJyb3JJbmZvO1xuXG5cbi8qKiovIH0pLFxuLyogNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIENoZWNrIGlmIHR5cGVkIGFycmF5cyBhcmUgc3VwcG9ydGVkXG5cdCAgICBpZiAodHlwZW9mIEFycmF5QnVmZmVyICE9ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICByZXR1cm47XG5cdCAgICB9XG5cblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblxuXHQgICAgLy8gUmVmZXJlbmNlIG9yaWdpbmFsIGluaXRcblx0ICAgIHZhciBzdXBlckluaXQgPSBXb3JkQXJyYXkuaW5pdDtcblxuXHQgICAgLy8gQXVnbWVudCBXb3JkQXJyYXkuaW5pdCB0byBoYW5kbGUgdHlwZWQgYXJyYXlzXG5cdCAgICB2YXIgc3ViSW5pdCA9IFdvcmRBcnJheS5pbml0ID0gZnVuY3Rpb24gKHR5cGVkQXJyYXkpIHtcblx0ICAgICAgICAvLyBDb252ZXJ0IGJ1ZmZlcnMgdG8gdWludDhcblx0ICAgICAgICBpZiAodHlwZWRBcnJheSBpbnN0YW5jZW9mIEFycmF5QnVmZmVyKSB7XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgPSBuZXcgVWludDhBcnJheSh0eXBlZEFycmF5KTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBDb252ZXJ0IG90aGVyIGFycmF5IHZpZXdzIHRvIHVpbnQ4XG5cdCAgICAgICAgaWYgKFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50OEFycmF5IHx8XG5cdCAgICAgICAgICAgICh0eXBlb2YgVWludDhDbGFtcGVkQXJyYXkgIT09IFwidW5kZWZpbmVkXCIgJiYgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQ4Q2xhbXBlZEFycmF5KSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgSW50MTZBcnJheSB8fFxuXHQgICAgICAgICAgICB0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDE2QXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEludDMyQXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIFVpbnQzMkFycmF5IHx8XG5cdCAgICAgICAgICAgIHR5cGVkQXJyYXkgaW5zdGFuY2VvZiBGbG9hdDMyQXJyYXkgfHxcblx0ICAgICAgICAgICAgdHlwZWRBcnJheSBpbnN0YW5jZW9mIEZsb2F0NjRBcnJheVxuXHQgICAgICAgICkge1xuXHQgICAgICAgICAgICB0eXBlZEFycmF5ID0gbmV3IFVpbnQ4QXJyYXkodHlwZWRBcnJheS5idWZmZXIsIHR5cGVkQXJyYXkuYnl0ZU9mZnNldCwgdHlwZWRBcnJheS5ieXRlTGVuZ3RoKTtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBIYW5kbGUgVWludDhBcnJheVxuXHQgICAgICAgIGlmICh0eXBlZEFycmF5IGluc3RhbmNlb2YgVWludDhBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgdHlwZWRBcnJheUJ5dGVMZW5ndGggPSB0eXBlZEFycmF5LmJ5dGVMZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gRXh0cmFjdCBieXRlc1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0eXBlZEFycmF5Qnl0ZUxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAyXSB8PSB0eXBlZEFycmF5W2ldIDw8ICgyNCAtIChpICUgNCkgKiA4KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEluaXRpYWxpemUgdGhpcyB3b3JkIGFycmF5XG5cdCAgICAgICAgICAgIHN1cGVySW5pdC5jYWxsKHRoaXMsIHdvcmRzLCB0eXBlZEFycmF5Qnl0ZUxlbmd0aCk7XG5cdCAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgLy8gRWxzZSBjYWxsIG5vcm1hbCBpbml0XG5cdCAgICAgICAgICAgIHN1cGVySW5pdC5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIHN1YkluaXQucHJvdG90eXBlID0gV29yZEFycmF5O1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmxpYi5Xb3JkQXJyYXk7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiA2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHs7KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoKSB7XG5cblx0LypnbG9iYWxzIHdpbmRvdywgZ2xvYmFsLCByZXF1aXJlKi9cblxuXHQvKipcblx0ICogQ3J5cHRvSlMgY29yZSBjb21wb25lbnRzLlxuXHQgKi9cblx0dmFyIENyeXB0b0pTID0gQ3J5cHRvSlMgfHwgKGZ1bmN0aW9uIChNYXRoLCB1bmRlZmluZWQpIHtcblxuXHQgICAgdmFyIGNyeXB0bztcblxuXHQgICAgLy8gTmF0aXZlIGNyeXB0byBmcm9tIHdpbmRvdyAoQnJvd3Nlcilcblx0ICAgIGlmICh0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3cuY3J5cHRvKSB7XG5cdCAgICAgICAgY3J5cHRvID0gd2luZG93LmNyeXB0bztcblx0ICAgIH1cblxuXHQgICAgLy8gTmF0aXZlIChleHBlcmltZW50YWwgSUUgMTEpIGNyeXB0byBmcm9tIHdpbmRvdyAoQnJvd3Nlcilcblx0ICAgIGlmICghY3J5cHRvICYmIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmIHdpbmRvdy5tc0NyeXB0bykge1xuXHQgICAgICAgIGNyeXB0byA9IHdpbmRvdy5tc0NyeXB0bztcblx0ICAgIH1cblxuXHQgICAgLy8gTmF0aXZlIGNyeXB0byBmcm9tIGdsb2JhbCAoTm9kZUpTKVxuXHQgICAgaWYgKCFjcnlwdG8gJiYgdHlwZW9mIGdsb2JhbCAhPT0gJ3VuZGVmaW5lZCcgJiYgZ2xvYmFsLmNyeXB0bykge1xuXHQgICAgICAgIGNyeXB0byA9IGdsb2JhbC5jcnlwdG87XG5cdCAgICB9XG5cblx0ICAgIC8vIE5hdGl2ZSBjcnlwdG8gaW1wb3J0IHZpYSByZXF1aXJlIChOb2RlSlMpXG5cdCAgICBpZiAoIWNyeXB0byAmJiBcImZ1bmN0aW9uXCIgPT09ICdmdW5jdGlvbicpIHtcblx0ICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICBjcnlwdG8gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQ0KTtcblx0ICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICB9XG5cblx0ICAgIC8qXG5cdCAgICAgKiBDcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcHNldWRvcmFuZG9tIG51bWJlciBnZW5lcmF0b3Jcblx0ICAgICAqXG5cdCAgICAgKiBBcyBNYXRoLnJhbmRvbSgpIGlzIGNyeXB0b2dyYXBoaWNhbGx5IG5vdCBzYWZlIHRvIHVzZVxuXHQgICAgICovXG5cdCAgICB2YXIgY3J5cHRvU2VjdXJlUmFuZG9tSW50ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIGlmIChjcnlwdG8pIHtcblx0ICAgICAgICAgICAgLy8gVXNlIGdldFJhbmRvbVZhbHVlcyBtZXRob2QgKEJyb3dzZXIpXG5cdCAgICAgICAgICAgIGlmICh0eXBlb2YgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhuZXcgVWludDMyQXJyYXkoMSkpWzBdO1xuXHQgICAgICAgICAgICAgICAgfSBjYXRjaCAoZXJyKSB7fVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gVXNlIHJhbmRvbUJ5dGVzIG1ldGhvZCAoTm9kZUpTKVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNyeXB0by5yYW5kb21CeXRlcyA9PT0gJ2Z1bmN0aW9uJykge1xuXHQgICAgICAgICAgICAgICAgdHJ5IHtcblx0ICAgICAgICAgICAgICAgICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbUJ5dGVzKDQpLnJlYWRJbnQzMkxFKCk7XG5cdCAgICAgICAgICAgICAgICB9IGNhdGNoIChlcnIpIHt9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ05hdGl2ZSBjcnlwdG8gbW9kdWxlIGNvdWxkIG5vdCBiZSB1c2VkIHRvIGdldCBzZWN1cmUgcmFuZG9tIG51bWJlci4nKTtcblx0ICAgIH07XG5cblx0ICAgIC8qXG5cdCAgICAgKiBMb2NhbCBwb2x5ZmlsbCBvZiBPYmplY3QuY3JlYXRlXG5cblx0ICAgICAqL1xuXHQgICAgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUgfHwgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBGKCkge31cblxuXHQgICAgICAgIHJldHVybiBmdW5jdGlvbiAob2JqKSB7XG5cdCAgICAgICAgICAgIHZhciBzdWJ0eXBlO1xuXG5cdCAgICAgICAgICAgIEYucHJvdG90eXBlID0gb2JqO1xuXG5cdCAgICAgICAgICAgIHN1YnR5cGUgPSBuZXcgRigpO1xuXG5cdCAgICAgICAgICAgIEYucHJvdG90eXBlID0gbnVsbDtcblxuXHQgICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcblx0ICAgICAgICB9O1xuXHQgICAgfSgpKVxuXG5cdCAgICAvKipcblx0ICAgICAqIENyeXB0b0pTIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBMaWJyYXJ5IG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfbGliID0gQy5saWIgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBCYXNlIG9iamVjdCBmb3IgcHJvdG90eXBhbCBpbmhlcml0YW5jZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlID0gKGZ1bmN0aW9uICgpIHtcblxuXG5cdCAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBuZXcgb2JqZWN0IHRoYXQgaW5oZXJpdHMgZnJvbSB0aGlzIG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IG92ZXJyaWRlcyBQcm9wZXJ0aWVzIHRvIGNvcHkgaW50byB0aGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHJldHVybiB7T2JqZWN0fSBUaGUgbmV3IG9iamVjdC5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgdmFyIE15VHlwZSA9IENyeXB0b0pTLmxpYi5CYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgZmllbGQ6ICd2YWx1ZScsXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICAgICAgbWV0aG9kOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgfVxuXHQgICAgICAgICAgICAgKiAgICAgfSk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBleHRlbmQ6IGZ1bmN0aW9uIChvdmVycmlkZXMpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNwYXduXG5cdCAgICAgICAgICAgICAgICB2YXIgc3VidHlwZSA9IGNyZWF0ZSh0aGlzKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gQXVnbWVudFxuXHQgICAgICAgICAgICAgICAgaWYgKG92ZXJyaWRlcykge1xuXHQgICAgICAgICAgICAgICAgICAgIHN1YnR5cGUubWl4SW4ob3ZlcnJpZGVzKTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgaW5pdGlhbGl6ZXJcblx0ICAgICAgICAgICAgICAgIGlmICghc3VidHlwZS5oYXNPd25Qcm9wZXJ0eSgnaW5pdCcpIHx8IHRoaXMuaW5pdCA9PT0gc3VidHlwZS5pbml0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgc3VidHlwZS5pbml0ID0gZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgICAgICAgICBzdWJ0eXBlLiRzdXBlci5pbml0LmFwcGx5KHRoaXMsIGFyZ3VtZW50cyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gSW5pdGlhbGl6ZXIncyBwcm90b3R5cGUgaXMgdGhlIHN1YnR5cGUgb2JqZWN0XG5cdCAgICAgICAgICAgICAgICBzdWJ0eXBlLmluaXQucHJvdG90eXBlID0gc3VidHlwZTtcblxuXHQgICAgICAgICAgICAgICAgLy8gUmVmZXJlbmNlIHN1cGVydHlwZVxuXHQgICAgICAgICAgICAgICAgc3VidHlwZS4kc3VwZXIgPSB0aGlzO1xuXG5cdCAgICAgICAgICAgICAgICByZXR1cm4gc3VidHlwZTtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogRXh0ZW5kcyB0aGlzIG9iamVjdCBhbmQgcnVucyB0aGUgaW5pdCBtZXRob2QuXG5cdCAgICAgICAgICAgICAqIEFyZ3VtZW50cyB0byBjcmVhdGUoKSB3aWxsIGJlIHBhc3NlZCB0byBpbml0KCkuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEByZXR1cm4ge09iamVjdH0gVGhlIG5ldyBvYmplY3QuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBpbnN0YW5jZSA9IE15VHlwZS5jcmVhdGUoKTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIGNyZWF0ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgdmFyIGluc3RhbmNlID0gdGhpcy5leHRlbmQoKTtcblx0ICAgICAgICAgICAgICAgIGluc3RhbmNlLmluaXQuYXBwbHkoaW5zdGFuY2UsIGFyZ3VtZW50cyk7XG5cblx0ICAgICAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZTtcblx0ICAgICAgICAgICAgfSxcblxuXHQgICAgICAgICAgICAvKipcblx0ICAgICAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIG9iamVjdC5cblx0ICAgICAgICAgICAgICogT3ZlcnJpZGUgdGhpcyBtZXRob2QgdG8gYWRkIHNvbWUgbG9naWMgd2hlbiB5b3VyIG9iamVjdHMgYXJlIGNyZWF0ZWQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICB2YXIgTXlUeXBlID0gQ3J5cHRvSlMubGliLkJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgICogICAgICAgICBpbml0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgICAqICAgICAgICAgICAgIC8vIC4uLlxuXHQgICAgICAgICAgICAgKiAgICAgICAgIH1cblx0ICAgICAgICAgICAgICogICAgIH0pO1xuXHQgICAgICAgICAgICAgKi9cblx0ICAgICAgICAgICAgaW5pdDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgIC8qKlxuXHQgICAgICAgICAgICAgKiBDb3BpZXMgcHJvcGVydGllcyBpbnRvIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gcHJvcGVydGllcyBUaGUgcHJvcGVydGllcyB0byBtaXggaW4uXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqICAgICBNeVR5cGUubWl4SW4oe1xuXHQgICAgICAgICAgICAgKiAgICAgICAgIGZpZWxkOiAndmFsdWUnXG5cdCAgICAgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIG1peEluOiBmdW5jdGlvbiAocHJvcGVydGllcykge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgcHJvcGVydHlOYW1lIGluIHByb3BlcnRpZXMpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpZiAocHJvcGVydGllcy5oYXNPd25Qcm9wZXJ0eShwcm9wZXJ0eU5hbWUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHRoaXNbcHJvcGVydHlOYW1lXSA9IHByb3BlcnRpZXNbcHJvcGVydHlOYW1lXTtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIC8vIElFIHdvbid0IGNvcHkgdG9TdHJpbmcgdXNpbmcgdGhlIGxvb3AgYWJvdmVcblx0ICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0aWVzLmhhc093blByb3BlcnR5KCd0b1N0cmluZycpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpcy50b1N0cmluZyA9IHByb3BlcnRpZXMudG9TdHJpbmc7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0sXG5cblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIENyZWF0ZXMgYSBjb3B5IG9mIHRoaXMgb2JqZWN0LlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgICAgICpcblx0ICAgICAgICAgICAgICogICAgIHZhciBjbG9uZSA9IGluc3RhbmNlLmNsb25lKCk7XG5cdCAgICAgICAgICAgICAqL1xuXHQgICAgICAgICAgICBjbG9uZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHRoaXMuaW5pdC5wcm90b3R5cGUuZXh0ZW5kKHRoaXMpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfTtcblx0ICAgIH0oKSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQW4gYXJyYXkgb2YgMzItYml0IHdvcmRzLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7QXJyYXl9IHdvcmRzIFRoZSBhcnJheSBvZiAzMi1iaXQgd29yZHMuXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gc2lnQnl0ZXMgVGhlIG51bWJlciBvZiBzaWduaWZpY2FudCBieXRlcyBpbiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgKi9cblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXkgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSB3b3JkcyAoT3B0aW9uYWwpIEFuIGFycmF5IG9mIDMyLWJpdCB3b3Jkcy5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gc2lnQnl0ZXMgKE9wdGlvbmFsKSBUaGUgbnVtYmVyIG9mIHNpZ25pZmljYW50IGJ5dGVzIGluIHRoZSB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmxpYi5Xb3JkQXJyYXkuY3JlYXRlKCk7XG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LmNyZWF0ZShbMHgwMDAxMDIwMywgMHgwNDA1MDYwN10pO1xuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMubGliLldvcmRBcnJheS5jcmVhdGUoWzB4MDAwMTAyMDMsIDB4MDQwNTA2MDddLCA2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAod29yZHMsIHNpZ0J5dGVzKSB7XG5cdCAgICAgICAgICAgIHdvcmRzID0gdGhpcy53b3JkcyA9IHdvcmRzIHx8IFtdO1xuXG5cdCAgICAgICAgICAgIGlmIChzaWdCeXRlcyAhPSB1bmRlZmluZWQpIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSBzaWdCeXRlcztcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgPSB3b3Jkcy5sZW5ndGggKiA0O1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIHRoaXMgd29yZCBhcnJheSB0byBhIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7RW5jb2Rlcn0gZW5jb2RlciAoT3B0aW9uYWwpIFRoZSBlbmNvZGluZyBzdHJhdGVneSB0byB1c2UuIERlZmF1bHQ6IENyeXB0b0pTLmVuYy5IZXhcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIHN0cmluZ2lmaWVkIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSB3b3JkQXJyYXkgKyAnJztcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IHdvcmRBcnJheS50b1N0cmluZygpO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gd29yZEFycmF5LnRvU3RyaW5nKENyeXB0b0pTLmVuYy5VdGY4KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKGVuY29kZXIpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIChlbmNvZGVyIHx8IEhleCkuc3RyaW5naWZ5KHRoaXMpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25jYXRlbmF0ZXMgYSB3b3JkIGFycmF5IHRvIHRoaXMgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheTEuY29uY2F0KHdvcmRBcnJheTIpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbmNhdDogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHRoaXNXb3JkcyA9IHRoaXMud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB0aGF0V29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciB0aGlzU2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgdGhhdFNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIHRoaXMuY2xhbXAoKTtcblxuXHQgICAgICAgICAgICAvLyBDb25jYXRcblx0ICAgICAgICAgICAgaWYgKHRoaXNTaWdCeXRlcyAlIDQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIENvcHkgb25lIGJ5dGUgYXQgYSB0aW1lXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHRoYXRTaWdCeXRlczsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHRoYXRCeXRlID0gKHRoYXRXb3Jkc1tpID4+PiAyXSA+Pj4gKDI0IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cdCAgICAgICAgICAgICAgICAgICAgdGhpc1dvcmRzWyh0aGlzU2lnQnl0ZXMgKyBpKSA+Pj4gMl0gfD0gdGhhdEJ5dGUgPDwgKDI0IC0gKCh0aGlzU2lnQnl0ZXMgKyBpKSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAvLyBDb3B5IG9uZSB3b3JkIGF0IGEgdGltZVxuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB0aGF0U2lnQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXNXb3Jkc1sodGhpc1NpZ0J5dGVzICsgaSkgPj4+IDJdID0gdGhhdFdvcmRzW2kgPj4+IDJdO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHRoaXMuc2lnQnl0ZXMgKz0gdGhhdFNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENoYWluYWJsZVxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVtb3ZlcyBpbnNpZ25pZmljYW50IGJpdHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHdvcmRBcnJheS5jbGFtcCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsYW1wOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB0aGlzLndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB0aGlzLnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENsYW1wXG5cdCAgICAgICAgICAgIHdvcmRzW3NpZ0J5dGVzID4+PiAyXSAmPSAweGZmZmZmZmZmIDw8ICgzMiAtIChzaWdCeXRlcyAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIHdvcmRzLmxlbmd0aCA9IE1hdGguY2VpbChzaWdCeXRlcyAvIDQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgY29weSBvZiB0aGlzIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gd29yZEFycmF5LmNsb25lKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gQmFzZS5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS53b3JkcyA9IHRoaXMud29yZHMuc2xpY2UoMCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgd29yZCBhcnJheSBmaWxsZWQgd2l0aCByYW5kb20gYnl0ZXMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gbkJ5dGVzIFRoZSBudW1iZXIgb2YgcmFuZG9tIGJ5dGVzIHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcmFuZG9tIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5saWIuV29yZEFycmF5LnJhbmRvbSgxNik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmFuZG9tOiBmdW5jdGlvbiAobkJ5dGVzKSB7XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbkJ5dGVzOyBpICs9IDQpIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzLnB1c2goY3J5cHRvU2VjdXJlUmFuZG9tSW50KCkpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIG5ldyBXb3JkQXJyYXkuaW5pdCh3b3JkcywgbkJ5dGVzKTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBFbmNvZGVyIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmMgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBIZXggZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBIZXggPSBDX2VuYy5IZXggPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSB3b3JkIGFycmF5IHRvIGEgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSB3b3JkQXJyYXkgVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBoZXggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGV4U3RyaW5nID0gQ3J5cHRvSlMuZW5jLkhleC5zdHJpbmdpZnkod29yZEFycmF5KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBzdHJpbmdpZnk6IGZ1bmN0aW9uICh3b3JkQXJyYXkpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IHdvcmRBcnJheS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIHNpZ0J5dGVzID0gd29yZEFycmF5LnNpZ0J5dGVzO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnRcblx0ICAgICAgICAgICAgdmFyIGhleENoYXJzID0gW107XG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc2lnQnl0ZXM7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGJpdGUgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgaGV4Q2hhcnMucHVzaCgoYml0ZSA+Pj4gNCkudG9TdHJpbmcoMTYpKTtcblx0ICAgICAgICAgICAgICAgIGhleENoYXJzLnB1c2goKGJpdGUgJiAweDBmKS50b1N0cmluZygxNikpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhleENoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGhleCBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGhleFN0ciBUaGUgaGV4IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB3b3JkQXJyYXkgPSBDcnlwdG9KUy5lbmMuSGV4LnBhcnNlKGhleFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChoZXhTdHIpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhleFN0ckxlbmd0aCA9IGhleFN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBoZXhTdHJMZW5ndGg7IGkgKz0gMikge1xuXHQgICAgICAgICAgICAgICAgd29yZHNbaSA+Pj4gM10gfD0gcGFyc2VJbnQoaGV4U3RyLnN1YnN0cihpLCAyKSwgMTYpIDw8ICgyNCAtIChpICUgOCkgKiA0KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQod29yZHMsIGhleFN0ckxlbmd0aCAvIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogTGF0aW4xIGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgTGF0aW4xID0gQ19lbmMuTGF0aW4xID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIExhdGluMSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgTGF0aW4xIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGxhdGluMVN0cmluZyA9IENyeXB0b0pTLmVuYy5MYXRpbjEuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciBsYXRpbjFDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHZhciBiaXRlID0gKHdvcmRzW2kgPj4+IDJdID4+PiAoMjQgLSAoaSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIGxhdGluMUNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShiaXRlKSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbGF0aW4xQ2hhcnMuam9pbignJyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgTGF0aW4xIHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gbGF0aW4xU3RyIFRoZSBMYXRpbjEgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5MYXRpbjEucGFyc2UobGF0aW4xU3RyaW5nKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKGxhdGluMVN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgbGF0aW4xU3RyTGVuZ3RoID0gbGF0aW4xU3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxhdGluMVN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAyXSB8PSAobGF0aW4xU3RyLmNoYXJDb2RlQXQoaSkgJiAweGZmKSA8PCAoMjQgLSAoaSAlIDQpICogOCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gbmV3IFdvcmRBcnJheS5pbml0KHdvcmRzLCBsYXRpbjFTdHJMZW5ndGgpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogVVRGLTggZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBVdGY4ID0gQ19lbmMuVXRmOCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtOCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgdXRmOFN0cmluZyA9IENyeXB0b0pTLmVuYy5VdGY4LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICB0cnkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIGRlY29kZVVSSUNvbXBvbmVudChlc2NhcGUoTGF0aW4xLnN0cmluZ2lmeSh3b3JkQXJyYXkpKSk7XG5cdCAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcblx0ICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTWFsZm9ybWVkIFVURi04IGRhdGEnKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi04IHN0cmluZyB0byBhIHdvcmQgYXJyYXkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gdXRmOFN0ciBUaGUgVVRGLTggc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGY4LnBhcnNlKHV0ZjhTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAodXRmOFN0cikge1xuXHQgICAgICAgICAgICByZXR1cm4gTGF0aW4xLnBhcnNlKHVuZXNjYXBlKGVuY29kZVVSSUNvbXBvbmVudCh1dGY4U3RyKSkpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgYnVmZmVyZWQgYmxvY2sgYWxnb3JpdGhtIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIFRoZSBwcm9wZXJ0eSBibG9ja1NpemUgbXVzdCBiZSBpbXBsZW1lbnRlZCBpbiBhIGNvbmNyZXRlIHN1YnR5cGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9taW5CdWZmZXJTaXplIFRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgc2hvdWxkIGJlIGtlcHQgdW5wcm9jZXNzZWQgaW4gdGhlIGJ1ZmZlci4gRGVmYXVsdDogMFxuXHQgICAgICovXG5cdCAgICB2YXIgQnVmZmVyZWRCbG9ja0FsZ29yaXRobSA9IENfbGliLkJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0gPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogUmVzZXRzIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgZGF0YSBidWZmZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQoKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBJbml0aWFsIHZhbHVlc1xuXHQgICAgICAgICAgICB0aGlzLl9kYXRhID0gbmV3IFdvcmRBcnJheS5pbml0KCk7XG5cdCAgICAgICAgICAgIHRoaXMuX25EYXRhQnl0ZXMgPSAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBZGRzIG5ldyBkYXRhIHRvIHRoaXMgYmxvY2sgYWxnb3JpdGhtJ3MgYnVmZmVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhIFRoZSBkYXRhIHRvIGFwcGVuZC4gU3RyaW5ncyBhcmUgY29udmVydGVkIHRvIGEgV29yZEFycmF5IHVzaW5nIFVURi04LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9hcHBlbmQoJ2RhdGEnKTtcblx0ICAgICAgICAgKiAgICAgYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fYXBwZW5kKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2FwcGVuZDogZnVuY3Rpb24gKGRhdGEpIHtcblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gV29yZEFycmF5LCBlbHNlIGFzc3VtZSBXb3JkQXJyYXkgYWxyZWFkeVxuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGRhdGEgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIGRhdGEgPSBVdGY4LnBhcnNlKGRhdGEpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQXBwZW5kXG5cdCAgICAgICAgICAgIHRoaXMuX2RhdGEuY29uY2F0KGRhdGEpO1xuXHQgICAgICAgICAgICB0aGlzLl9uRGF0YUJ5dGVzICs9IGRhdGEuc2lnQnl0ZXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFByb2Nlc3NlcyBhdmFpbGFibGUgZGF0YSBibG9ja3MuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBUaGlzIG1ldGhvZCBpbnZva2VzIF9kb1Byb2Nlc3NCbG9jayhvZmZzZXQpLCB3aGljaCBtdXN0IGJlIGltcGxlbWVudGVkIGJ5IGEgY29uY3JldGUgc3VidHlwZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Ym9vbGVhbn0gZG9GbHVzaCBXaGV0aGVyIGFsbCBibG9ja3MgYW5kIHBhcnRpYWwgYmxvY2tzIHNob3VsZCBiZSBwcm9jZXNzZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwcm9jZXNzZWQgZGF0YS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHByb2Nlc3NlZERhdGEgPSBidWZmZXJlZEJsb2NrQWxnb3JpdGhtLl9wcm9jZXNzKCk7XG5cdCAgICAgICAgICogICAgIHZhciBwcm9jZXNzZWREYXRhID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5fcHJvY2VzcyghISdmbHVzaCcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9wcm9jZXNzOiBmdW5jdGlvbiAoZG9GbHVzaCkge1xuXHQgICAgICAgICAgICB2YXIgcHJvY2Vzc2VkV29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBkYXRhU2lnQnl0ZXMgPSBkYXRhLnNpZ0J5dGVzO1xuXHQgICAgICAgICAgICB2YXIgYmxvY2tTaXplID0gdGhpcy5ibG9ja1NpemU7XG5cdCAgICAgICAgICAgIHZhciBibG9ja1NpemVCeXRlcyA9IGJsb2NrU2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYmxvY2tzIHJlYWR5XG5cdCAgICAgICAgICAgIHZhciBuQmxvY2tzUmVhZHkgPSBkYXRhU2lnQnl0ZXMgLyBibG9ja1NpemVCeXRlcztcblx0ICAgICAgICAgICAgaWYgKGRvRmx1c2gpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFJvdW5kIHVwIHRvIGluY2x1ZGUgcGFydGlhbCBibG9ja3Ncblx0ICAgICAgICAgICAgICAgIG5CbG9ja3NSZWFkeSA9IE1hdGguY2VpbChuQmxvY2tzUmVhZHkpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgLy8gUm91bmQgZG93biB0byBpbmNsdWRlIG9ubHkgZnVsbCBibG9ja3MsXG5cdCAgICAgICAgICAgICAgICAvLyBsZXNzIHRoZSBudW1iZXIgb2YgYmxvY2tzIHRoYXQgbXVzdCByZW1haW4gaW4gdGhlIGJ1ZmZlclxuXHQgICAgICAgICAgICAgICAgbkJsb2Nrc1JlYWR5ID0gTWF0aC5tYXgoKG5CbG9ja3NSZWFkeSB8IDApIC0gdGhpcy5fbWluQnVmZmVyU2l6ZSwgMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb3VudCB3b3JkcyByZWFkeVxuXHQgICAgICAgICAgICB2YXIgbldvcmRzUmVhZHkgPSBuQmxvY2tzUmVhZHkgKiBibG9ja1NpemU7XG5cblx0ICAgICAgICAgICAgLy8gQ291bnQgYnl0ZXMgcmVhZHlcblx0ICAgICAgICAgICAgdmFyIG5CeXRlc1JlYWR5ID0gTWF0aC5taW4obldvcmRzUmVhZHkgKiA0LCBkYXRhU2lnQnl0ZXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgYmxvY2tzXG5cdCAgICAgICAgICAgIGlmIChuV29yZHNSZWFkeSkge1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgb2Zmc2V0ID0gMDsgb2Zmc2V0IDwgbldvcmRzUmVhZHk7IG9mZnNldCArPSBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWFsZ29yaXRobSBsb2dpY1xuXHQgICAgICAgICAgICAgICAgICAgIHRoaXMuX2RvUHJvY2Vzc0Jsb2NrKGRhdGFXb3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgLy8gUmVtb3ZlIHByb2Nlc3NlZCB3b3Jkc1xuXHQgICAgICAgICAgICAgICAgcHJvY2Vzc2VkV29yZHMgPSBkYXRhV29yZHMuc3BsaWNlKDAsIG5Xb3Jkc1JlYWR5KTtcblx0ICAgICAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgLT0gbkJ5dGVzUmVhZHk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gcHJvY2Vzc2VkIHdvcmRzXG5cdCAgICAgICAgICAgIHJldHVybiBuZXcgV29yZEFycmF5LmluaXQocHJvY2Vzc2VkV29yZHMsIG5CeXRlc1JlYWR5KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIGNvcHkgb2YgdGhpcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IFRoZSBjbG9uZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNsb25lID0gYnVmZmVyZWRCbG9ja0FsZ29yaXRobS5jbG9uZSgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEJhc2UuY2xvbmUuY2FsbCh0aGlzKTtcblx0ICAgICAgICAgICAgY2xvbmUuX2RhdGEgPSB0aGlzLl9kYXRhLmNsb25lKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGNsb25lO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfbWluQnVmZmVyU2l6ZTogMFxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQWJzdHJhY3QgaGFzaGVyIHRlbXBsYXRlLlxuXHQgICAgICpcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBibG9ja1NpemUgVGhlIG51bWJlciBvZiAzMi1iaXQgd29yZHMgdGhpcyBoYXNoZXIgb3BlcmF0ZXMgb24uIERlZmF1bHQ6IDE2ICg1MTIgYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlciA9IEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0uZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY2ZnOiBCYXNlLmV4dGVuZCgpLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogSW5pdGlhbGl6ZXMgYSBuZXdseSBjcmVhdGVkIGhhc2hlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBoYXNoIGNvbXB1dGF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaGVyID0gQ3J5cHRvSlMuYWxnby5TSEEyNTYuY3JlYXRlKCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgdGhpcy5jZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBoYXNoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG5cdCAgICAgICAgICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWhhc2hlciBsb2dpY1xuXHQgICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIFVwZGF0ZXMgdGhpcyBoYXNoZXIgd2l0aCBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7SGFzaGVyfSBUaGlzIGhhc2hlci5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgaGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICBoYXNoZXIudXBkYXRlKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgdXBkYXRlOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBBcHBlbmRcblx0ICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuXG5cdCAgICAgICAgICAgIC8vIFVwZGF0ZSB0aGUgaGFzaFxuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ2hhaW5hYmxlXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBGaW5hbGl6ZXMgdGhlIGhhc2ggY29tcHV0YXRpb24uXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZVVwZGF0ZSAoT3B0aW9uYWwpIEEgZmluYWwgbWVzc2FnZSB1cGRhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICB2YXIgaGFzaCA9IGhhc2hlci5maW5hbGl6ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGZpbmFsaXplOiBmdW5jdGlvbiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAvLyBGaW5hbCBtZXNzYWdlIHVwZGF0ZVxuXHQgICAgICAgICAgICBpZiAobWVzc2FnZVVwZGF0ZSkge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fYXBwZW5kKG1lc3NhZ2VVcGRhdGUpO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gUGVyZm9ybSBjb25jcmV0ZS1oYXNoZXIgbG9naWNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9kb0ZpbmFsaXplKCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGhhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogNTEyLzMyLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBhIHNob3J0Y3V0IGZ1bmN0aW9uIHRvIGEgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7SGFzaGVyfSBoYXNoZXIgVGhlIGhhc2hlciB0byBjcmVhdGUgYSBoZWxwZXIgZm9yLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIFNIQTI1NiA9IENyeXB0b0pTLmxpYi5IYXNoZXIuX2NyZWF0ZUhlbHBlcihDcnlwdG9KUy5hbGdvLlNIQTI1Nik7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgX2NyZWF0ZUhlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGNmZykge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBoYXNoZXIuaW5pdChjZmcpLmZpbmFsaXplKG1lc3NhZ2UpO1xuXHQgICAgICAgICAgICB9O1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIGEgc2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaGVyIHRvIHVzZSBpbiB0aGlzIEhNQUMgaGVscGVyLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7RnVuY3Rpb259IFRoZSBzaG9ydGN1dCBmdW5jdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIEhtYWNTSEEyNTYgPSBDcnlwdG9KUy5saWIuSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKENyeXB0b0pTLmFsZ28uU0hBMjU2KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSG1hY0hlbHBlcjogZnVuY3Rpb24gKGhhc2hlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKG1lc3NhZ2UsIGtleSkge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIG5ldyBDX2FsZ28uSE1BQy5pbml0KGhhc2hlciwga2V5KS5maW5hbGl6ZShtZXNzYWdlKTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBbGdvcml0aG0gbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvID0ge307XG5cblx0ICAgIHJldHVybiBDO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUztcblxufSkpO1xuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTMpKSlcblxuLyoqKi8gfSksXG4vKiA3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbi8qIENhbGwgdGhlIGxpc3RlbmVyLCBjYXRjaCBhbnkgZXhjZXB0aW9ucyBhbmQgbG9nLCBidXQgY29udGludWUgb3BlcmF0aW9uKi9cbmZ1bmN0aW9uIGNhbGxMaXN0ZW5lcihldmVudFRoaXMsIGxpc3RlbmVyLCBhcmdzKSB7XG4gICAgdHJ5IHtcbiAgICAgICAgbGlzdGVuZXIuYXBwbHkoZXZlbnRUaGlzLCBhcmdzKTtcbiAgICB9XG4gICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdFdmVudEVtaXR0ZXIuZW1pdCgpJywgJ1VuZXhwZWN0ZWQgbGlzdGVuZXIgZXhjZXB0aW9uOiAnICsgZSArICc7IHN0YWNrID0gJyArIChlICYmIGUuc3RhY2spKTtcbiAgICB9XG59XG4vKipcbiAqIFJlbW92ZSBsaXN0ZW5lcnMgdGhhdCBtYXRjaCBsaXN0ZW5lclxuICogQHBhcmFtIHRhcmdldExpc3RlbmVycyBpcyBhbiBhcnJheSBvZiBsaXN0ZW5lciBhcnJheXMgb3IgZXZlbnQgb2JqZWN0cyB3aXRoIGFycmF5cyBvZiBsaXN0ZW5lcnNcbiAqIEBwYXJhbSBsaXN0ZW5lciB0aGUgbGlzdGVuZXIgY2FsbGJhY2sgdG8gcmVtb3ZlXG4gKiBAcGFyYW0gZXZlbnRGaWx0ZXIgKG9wdGlvbmFsKSBldmVudCBuYW1lIGluc3RydWN0aW5nIHRoZSBmdW5jdGlvbiB0byBvbmx5IHJlbW92ZSBsaXN0ZW5lcnMgZm9yIHRoZSBzcGVjaWZpZWQgZXZlbnRcbiAqL1xuZnVuY3Rpb24gcmVtb3ZlTGlzdGVuZXIodGFyZ2V0TGlzdGVuZXJzLCBsaXN0ZW5lciwgZXZlbnRGaWx0ZXIpIHtcbiAgICB2YXIgbGlzdGVuZXJzO1xuICAgIHZhciBpbmRleDtcbiAgICB2YXIgZXZlbnROYW1lO1xuICAgIGZvciAodmFyIHRhcmdldExpc3RlbmVyc0luZGV4ID0gMDsgdGFyZ2V0TGlzdGVuZXJzSW5kZXggPCB0YXJnZXRMaXN0ZW5lcnMubGVuZ3RoOyB0YXJnZXRMaXN0ZW5lcnNJbmRleCsrKSB7XG4gICAgICAgIGxpc3RlbmVycyA9IHRhcmdldExpc3RlbmVyc1t0YXJnZXRMaXN0ZW5lcnNJbmRleF07XG4gICAgICAgIGlmIChldmVudEZpbHRlcikge1xuICAgICAgICAgICAgbGlzdGVuZXJzID0gbGlzdGVuZXJzW2V2ZW50RmlsdGVyXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVXRpbHMuaXNBcnJheShsaXN0ZW5lcnMpKSB7XG4gICAgICAgICAgICB3aGlsZSAoKGluZGV4ID0gVXRpbHMuYXJySW5kZXhPZihsaXN0ZW5lcnMsIGxpc3RlbmVyKSkgIT09IC0xKSB7XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBJZiBldmVudHMgb2JqZWN0IGhhcyBhbiBldmVudCBuYW1lIGtleSB3aXRoIG5vIGxpc3RlbmVycyB0aGVuXG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlbW92ZSB0aGUga2V5IHRvIHN0b3AgdGhlIGxpc3QgZ3Jvd2luZyBpbmRlZmluaXRlbHkgKi9cbiAgICAgICAgICAgIGlmIChldmVudEZpbHRlciAmJiBsaXN0ZW5lcnMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgZGVsZXRlIHRhcmdldExpc3RlbmVyc1t0YXJnZXRMaXN0ZW5lcnNJbmRleF1bZXZlbnRGaWx0ZXJdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFV0aWxzLmlzT2JqZWN0KGxpc3RlbmVycykpIHtcbiAgICAgICAgICAgIC8qIGV2ZW50cyAqL1xuICAgICAgICAgICAgZm9yIChldmVudE5hbWUgaW4gbGlzdGVuZXJzKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChsaXN0ZW5lcnMsIGV2ZW50TmFtZSkgJiYgVXRpbHMuaXNBcnJheShsaXN0ZW5lcnNbZXZlbnROYW1lXSkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoW2xpc3RlbmVyc10sIGxpc3RlbmVyLCBldmVudE5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbn1cbnZhciBFdmVudEVtaXR0ZXIgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gRXZlbnRFbWl0dGVyKCkge1xuICAgICAgICB0aGlzLmFueSA9IFtdO1xuICAgICAgICB0aGlzLmV2ZW50cyA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIHRoaXMuYW55T25jZSA9IFtdO1xuICAgICAgICB0aGlzLmV2ZW50c09uY2UgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIH1cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgdmFyIGxpc3RlbmVyID0gYXJnc1swXTtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgbGlzdGVuZXIgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmFueS5wdXNoKGxpc3RlbmVyKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnRMaXN0ZW5lci5vbigpOiBJbnZhbGlkIGFyZ3VtZW50czogJyArIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICAgICAgICB2YXIgZXZlbnRfMSA9IGFyZ3NbMF0sIGxpc3RlbmVyXzEgPSBhcmdzWzFdO1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lcl8xICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudExpc3RlbmVyLm9uKCk6IEludmFsaWQgYXJndW1lbnRzOiAnICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChVdGlscy5pc0VtcHR5QXJnKGV2ZW50XzEpKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5hbnkucHVzaChsaXN0ZW5lcl8xKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKFV0aWxzLmlzQXJyYXkoZXZlbnRfMSkpIHtcbiAgICAgICAgICAgICAgICBldmVudF8xLmZvckVhY2goZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vbihldmVudE5hbWUsIGxpc3RlbmVyXzEpO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBldmVudF8xICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50TGlzdGVuZXIub24oKTogSW52YWxpZCBhcmd1bWVudHM6ICcgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5ldmVudHNbZXZlbnRfMV0gfHwgKHRoaXMuZXZlbnRzW2V2ZW50XzFdID0gW10pO1xuICAgICAgICAgICAgICAgIGxpc3RlbmVycy5wdXNoKGxpc3RlbmVyXzEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLm9mZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAwIHx8IChVdGlscy5pc0VtcHR5QXJnKGFyZ3NbMF0pICYmIFV0aWxzLmlzRW1wdHlBcmcoYXJnc1sxXSkpKSB7XG4gICAgICAgICAgICB0aGlzLmFueSA9IFtdO1xuICAgICAgICAgICAgdGhpcy5ldmVudHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgdGhpcy5hbnlPbmNlID0gW107XG4gICAgICAgICAgICB0aGlzLmV2ZW50c09uY2UgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmaXJzdEFyZyA9IGFyZ3NbMF0sIHNlY29uZEFyZyA9IGFyZ3NbMV07XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IG51bGw7XG4gICAgICAgIHZhciBldmVudCA9IG51bGw7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PT0gMSB8fCAhc2Vjb25kQXJnKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIGZpcnN0QXJnID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgLyogd2UgdGFrZSB0aGlzIHRvIGJlIHRoZSBsaXN0ZW5lciBhbmQgdHJlYXQgdGhlIGV2ZW50IGFzIFwiYW55XCIgLi4gKi9cbiAgICAgICAgICAgICAgICBsaXN0ZW5lciA9IGZpcnN0QXJnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgZXZlbnQgPSBmaXJzdEFyZztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIC4uLiBvciB3ZSB0YWtlIGV2ZW50IHRvIGJlIHRoZSBhY3R1YWwgZXZlbnQgbmFtZSBhbmQgbGlzdGVuZXIgdG8gYmUgYWxsICovXG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlY29uZEFyZyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnRFbWl0dGVyLm9mZigpOiBpbnZhbGlkIGFyZ3VtZW50czonICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9hID0gW2ZpcnN0QXJnLCBzZWNvbmRBcmddLCBldmVudCA9IF9hWzBdLCBsaXN0ZW5lciA9IF9hWzFdO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsaXN0ZW5lciAmJiBVdGlscy5pc0VtcHR5QXJnKGV2ZW50KSkge1xuICAgICAgICAgICAgcmVtb3ZlTGlzdGVuZXIoW3RoaXMuYW55LCB0aGlzLmV2ZW50cywgdGhpcy5hbnlPbmNlLCB0aGlzLmV2ZW50c09uY2VdLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWxzLmlzQXJyYXkoZXZlbnQpKSB7XG4gICAgICAgICAgICBldmVudC5mb3JFYWNoKGZ1bmN0aW9uIChldmVudE5hbWUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcik7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiBcIm5vcm1hbFwiIGNhc2Ugd2hlcmUgZXZlbnQgaXMgYW4gYWN0dWFsIGV2ZW50ICovXG4gICAgICAgIGlmICh0eXBlb2YgZXZlbnQgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50RW1pdHRlci5vZmYoKTogaW52YWxpZCBhcmd1bWVudHM6JyArIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICByZW1vdmVMaXN0ZW5lcihbdGhpcy5ldmVudHMsIHRoaXMuZXZlbnRzT25jZV0sIGxpc3RlbmVyLCBldmVudCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBkZWxldGUgdGhpcy5ldmVudHNbZXZlbnRdO1xuICAgICAgICAgICAgZGVsZXRlIHRoaXMuZXZlbnRzT25jZVtldmVudF07XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIEdldCB0aGUgYXJyYXkgb2YgbGlzdGVuZXJzIGZvciBhIGdpdmVuIGV2ZW50OyBleGNsdWRlcyBvbmNlIGV2ZW50c1xuICAgICAqIEBwYXJhbSBldmVudCAob3B0aW9uYWwpIHRoZSBuYW1lIG9mIHRoZSBldmVudCwgb3Igbm9uZSBmb3IgJ2FueSdcbiAgICAgKiBAcmV0dXJuIGFycmF5IG9mIGV2ZW50cywgb3IgbnVsbCBpZiBub25lXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5saXN0ZW5lcnMgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgaWYgKGV2ZW50KSB7XG4gICAgICAgICAgICB2YXIgbGlzdGVuZXJzID0gdGhpcy5ldmVudHNbZXZlbnRdIHx8IFtdO1xuICAgICAgICAgICAgaWYgKHRoaXMuZXZlbnRzT25jZVtldmVudF0pXG4gICAgICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCB0aGlzLmV2ZW50c09uY2VbZXZlbnRdKTtcbiAgICAgICAgICAgIHJldHVybiBsaXN0ZW5lcnMubGVuZ3RoID8gbGlzdGVuZXJzIDogbnVsbDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5hbnkubGVuZ3RoID8gdGhpcy5hbnkgOiBudWxsO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogRW1pdCBhbiBldmVudFxuICAgICAqIEBwYXJhbSBldmVudCB0aGUgZXZlbnQgbmFtZVxuICAgICAqIEBwYXJhbSBhcmdzIHRoZSBhcmd1bWVudHMgdG8gcGFzcyB0byB0aGUgbGlzdGVuZXJcbiAgICAgKi9cbiAgICBFdmVudEVtaXR0ZXIucHJvdG90eXBlLmVtaXQgPSBmdW5jdGlvbiAoZXZlbnQpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTsgLyogLCBhcmdzLi4uICovXG4gICAgICAgIGZvciAodmFyIF9pID0gMSAvKiAsIGFyZ3MuLi4gKi87IF9pIDwgYXJndW1lbnRzLmxlbmd0aCAvKiAsIGFyZ3MuLi4gKi87IF9pKysgLyogLCBhcmdzLi4uICovKSB7XG4gICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldOyAvKiAsIGFyZ3MuLi4gKi9cbiAgICAgICAgfVxuICAgICAgICB2YXIgZXZlbnRUaGlzID0geyBldmVudDogZXZlbnQgfTtcbiAgICAgICAgdmFyIGxpc3RlbmVycyA9IFtdO1xuICAgICAgICBpZiAodGhpcy5hbnlPbmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCB0aGlzLmFueU9uY2UpO1xuICAgICAgICAgICAgdGhpcy5hbnlPbmNlID0gW107XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuYW55Lmxlbmd0aCkge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCB0aGlzLmFueSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGV2ZW50c09uY2VMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c09uY2VbZXZlbnRdO1xuICAgICAgICBpZiAoZXZlbnRzT25jZUxpc3RlbmVycykge1xuICAgICAgICAgICAgQXJyYXkucHJvdG90eXBlLnB1c2guYXBwbHkobGlzdGVuZXJzLCBldmVudHNPbmNlTGlzdGVuZXJzKTtcbiAgICAgICAgICAgIGRlbGV0ZSB0aGlzLmV2ZW50c09uY2VbZXZlbnRdO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudHNMaXN0ZW5lcnMgPSB0aGlzLmV2ZW50c1tldmVudF07XG4gICAgICAgIGlmIChldmVudHNMaXN0ZW5lcnMpIHtcbiAgICAgICAgICAgIEFycmF5LnByb3RvdHlwZS5wdXNoLmFwcGx5KGxpc3RlbmVycywgZXZlbnRzTGlzdGVuZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBVdGlscy5hcnJGb3JFYWNoKGxpc3RlbmVycywgZnVuY3Rpb24gKGxpc3RlbmVyKSB7XG4gICAgICAgICAgICBjYWxsTGlzdGVuZXIoZXZlbnRUaGlzLCBsaXN0ZW5lciwgYXJncyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS5vbmNlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcmdDb3VudCA9IGFyZ3MubGVuZ3RoO1xuICAgICAgICBpZiAoKGFyZ0NvdW50ID09PSAwIHx8IChhcmdDb3VudCA9PT0gMSAmJiB0eXBlb2YgYXJnc1swXSAhPT0gJ2Z1bmN0aW9uJykpICYmIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuUHJvbWlzZSkge1xuICAgICAgICAgICAgdmFyIGV2ZW50XzIgPSBhcmdzWzBdO1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLlByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbmNlKGV2ZW50XzIsIHJlc29sdmUpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGZpcnN0QXJnID0gYXJnc1swXSwgc2Vjb25kQXJnID0gYXJnc1sxXTtcbiAgICAgICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxICYmIHR5cGVvZiBmaXJzdEFyZyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgdGhpcy5hbnlPbmNlLnB1c2goZmlyc3RBcmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFV0aWxzLmlzRW1wdHlBcmcoZmlyc3RBcmcpKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHNlY29uZEFyZyAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRXZlbnRFbWl0dGVyLm9uY2UoKTogSW52YWxpZCBhcmd1bWVudHM6JyArIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuaW5zcGVjdChhcmdzKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLmFueU9uY2UucHVzaChzZWNvbmRBcmcpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKFV0aWxzLmlzQXJyYXkoZmlyc3RBcmcpKSB7XG4gICAgICAgICAgICB2YXIgc2VsZl8xID0gdGhpcztcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcldyYXBwZXJfMSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICB2YXIgaW5uZXJBcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJndW1lbnRzKTtcbiAgICAgICAgICAgICAgICBVdGlscy5hcnJGb3JFYWNoKGZpcnN0QXJnLCBmdW5jdGlvbiAoZXZlbnROYW1lKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGZfMS5vZmYoZXZlbnROYW1lLCBsaXN0ZW5lcldyYXBwZXJfMSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRBcmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudEVtaXR0ZXIub25jZSgpOiBJbnZhbGlkIGFyZ3VtZW50czonICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc2Vjb25kQXJnLmFwcGx5KHRoaXMsIGlubmVyQXJncyk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgVXRpbHMuYXJyRm9yRWFjaChmaXJzdEFyZywgZnVuY3Rpb24gKGV2ZW50TmFtZSkge1xuICAgICAgICAgICAgICAgIHNlbGZfMS5vbihldmVudE5hbWUsIGxpc3RlbmVyV3JhcHBlcl8xKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBmaXJzdEFyZyAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0V2ZW50RW1pdHRlci5vbmNlKCk6IEludmFsaWQgYXJndW1lbnRzOicgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QoYXJncykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGxpc3RlbmVycyA9IHRoaXMuZXZlbnRzT25jZVtmaXJzdEFyZ10gfHwgKHRoaXMuZXZlbnRzT25jZVtmaXJzdEFyZ10gPSBbXSk7XG4gICAgICAgICAgICBpZiAoc2Vjb25kQXJnKSB7XG4gICAgICAgICAgICAgICAgaWYgKHR5cGVvZiBzZWNvbmRBcmcgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFdmVudEVtaXR0ZXIub25jZSgpOiBJbnZhbGlkIGFyZ3VtZW50czonICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KGFyZ3MpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgbGlzdGVuZXJzLnB1c2goc2Vjb25kQXJnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogUHJpdmF0ZSBBUElcbiAgICAgKlxuICAgICAqIExpc3RlbiBmb3IgYSBzaW5nbGUgb2NjdXJyZW5jZSBvZiBhIHN0YXRlIGV2ZW50IGFuZCBmaXJlIGltbWVkaWF0ZWx5IGlmIGN1cnJlbnRTdGF0ZSBtYXRjaGVzIHRhcmdldFN0YXRlXG4gICAgICogQHBhcmFtIHRhcmdldFN0YXRlIHRoZSBuYW1lIG9mIHRoZSBzdGF0ZSBldmVudCB0byBsaXN0ZW4gdG9cbiAgICAgKiBAcGFyYW0gY3VycmVudFN0YXRlIHRoZSBuYW1lIG9mIHRoZSBjdXJyZW50IHN0YXRlIG9mIHRoaXMgb2JqZWN0XG4gICAgICogQHBhcmFtIGxpc3RlbmVyIHRoZSBsaXN0ZW5lciB0byBiZSBjYWxsZWRcbiAgICAgKiBAcGFyYW0gbGlzdGVuZXJBcmdzXG4gICAgICovXG4gICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS53aGVuU3RhdGUgPSBmdW5jdGlvbiAodGFyZ2V0U3RhdGUsIGN1cnJlbnRTdGF0ZSwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGxpc3RlbmVyQXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDM7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgbGlzdGVuZXJBcmdzW19pIC0gM10gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIHZhciBldmVudFRoaXMgPSB7IGV2ZW50OiB0YXJnZXRTdGF0ZSB9O1xuICAgICAgICBpZiAodHlwZW9mIHRhcmdldFN0YXRlICE9PSAnc3RyaW5nJyB8fCB0eXBlb2YgY3VycmVudFN0YXRlICE9PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgdGhyb3cgJ3doZW5TdGF0ZSByZXF1aXJlcyBhIHZhbGlkIGV2ZW50IFN0cmluZyBhcmd1bWVudCc7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBsaXN0ZW5lciAhPT0gJ2Z1bmN0aW9uJyAmJiBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLlByb21pc2UpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5Qcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XG4gICAgICAgICAgICAgICAgRXZlbnRFbWl0dGVyLnByb3RvdHlwZS53aGVuU3RhdGUuYXBwbHkoX3RoaXMsIFt0YXJnZXRTdGF0ZSwgY3VycmVudFN0YXRlLCByZXNvbHZlXS5jb25jYXQobGlzdGVuZXJBcmdzKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGFyZ2V0U3RhdGUgPT09IGN1cnJlbnRTdGF0ZSkge1xuICAgICAgICAgICAgY2FsbExpc3RlbmVyKGV2ZW50VGhpcywgbGlzdGVuZXIsIGxpc3RlbmVyQXJncyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLm9uY2UodGFyZ2V0U3RhdGUsIGxpc3RlbmVyKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIEV2ZW50RW1pdHRlcjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBFdmVudEVtaXR0ZXI7XG5cblxuLyoqKi8gfSksXG4vKiA4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmdldERlZmF1bHRzID0gZXhwb3J0cy5ub3JtYWxpc2VPcHRpb25zID0gZXhwb3J0cy5vYmplY3RpZnlPcHRpb25zID0gZXhwb3J0cy5nZXRBZ2VudFN0cmluZyA9IGV4cG9ydHMuZ2V0SG9zdHMgPSBleHBvcnRzLmdldEZhbGxiYWNrSG9zdHMgPSBleHBvcnRzLmVudmlyb25tZW50RmFsbGJhY2tIb3N0cyA9IGV4cG9ydHMuZ2V0SHR0cFNjaGVtZSA9IGV4cG9ydHMuZ2V0UG9ydCA9IGV4cG9ydHMuZ2V0SG9zdCA9IHZvaWQgMDtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgcGFja2FnZV9qc29uXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQzKTtcbnZhciBhZ2VudCA9ICdhYmx5LWpzLycgKyBwYWNrYWdlX2pzb25fMS52ZXJzaW9uO1xudmFyIERlZmF1bHRzID0ge1xuICAgIEVOVklST05NRU5UOiAnJyxcbiAgICBSRVNUX0hPU1Q6ICdyZXN0LmFibHkuaW8nLFxuICAgIFJFQUxUSU1FX0hPU1Q6ICdyZWFsdGltZS5hYmx5LmlvJyxcbiAgICBGQUxMQkFDS19IT1NUUzogW1xuICAgICAgICAnQS5hYmx5LXJlYWx0aW1lLmNvbScsXG4gICAgICAgICdCLmFibHktcmVhbHRpbWUuY29tJyxcbiAgICAgICAgJ0MuYWJseS1yZWFsdGltZS5jb20nLFxuICAgICAgICAnRC5hYmx5LXJlYWx0aW1lLmNvbScsXG4gICAgICAgICdFLmFibHktcmVhbHRpbWUuY29tJyxcbiAgICBdLFxuICAgIFBPUlQ6IDgwLFxuICAgIFRMU19QT1JUOiA0NDMsXG4gICAgVElNRU9VVFM6IHtcbiAgICAgICAgLyogRG9jdW1lbnRlZCBhcyBvcHRpb25zIHBhcmFtczogKi9cbiAgICAgICAgZGlzY29ubmVjdGVkUmV0cnlUaW1lb3V0OiAxNTAwMCxcbiAgICAgICAgc3VzcGVuZGVkUmV0cnlUaW1lb3V0OiAzMDAwMCxcbiAgICAgICAgLyogVW5kb2N1bWVudGVkLCBidXQgcGFydCBvZiB0aGUgYXBpIGFuZCBjYW4gYmUgdXNlZCBieSBjdXN0b21lcnM6ICovXG4gICAgICAgIGh0dHBSZXF1ZXN0VGltZW91dDogMTUwMDAsXG4gICAgICAgIGNoYW5uZWxSZXRyeVRpbWVvdXQ6IDE1MDAwLFxuICAgICAgICBmYWxsYmFja1JldHJ5VGltZW91dDogNjAwMDAwLFxuICAgICAgICAvKiBGb3IgaW50ZXJuYWwgLyB0ZXN0IHVzZSBvbmx5OiAqL1xuICAgICAgICBjb25uZWN0aW9uU3RhdGVUdGw6IDEyMDAwMCxcbiAgICAgICAgcmVhbHRpbWVSZXF1ZXN0VGltZW91dDogMTAwMDAsXG4gICAgICAgIHJlY3ZUaW1lb3V0OiA5MDAwMCxcbiAgICAgICAgcHJlZmVyZW5jZUNvbm5lY3RUaW1lb3V0OiA2MDAwLFxuICAgICAgICBwYXJhbGxlbFVwZ3JhZGVEZWxheTogNjAwMCxcbiAgICB9LFxuICAgIGh0dHBNYXhSZXRyeUNvdW50OiAzLFxuICAgIG1heE1lc3NhZ2VTaXplOiA2NTUzNixcbiAgICB2ZXJzaW9uOiBwYWNrYWdlX2pzb25fMS52ZXJzaW9uLFxuICAgIHByb3RvY29sVmVyc2lvbjogMixcbiAgICBhZ2VudDogYWdlbnQsXG4gICAgZ2V0SG9zdDogZ2V0SG9zdCxcbiAgICBnZXRQb3J0OiBnZXRQb3J0LFxuICAgIGdldEh0dHBTY2hlbWU6IGdldEh0dHBTY2hlbWUsXG4gICAgZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzOiBlbnZpcm9ubWVudEZhbGxiYWNrSG9zdHMsXG4gICAgZ2V0RmFsbGJhY2tIb3N0czogZ2V0RmFsbGJhY2tIb3N0cyxcbiAgICBnZXRIb3N0czogZ2V0SG9zdHMsXG4gICAgY2hlY2tIb3N0OiBjaGVja0hvc3QsXG4gICAgb2JqZWN0aWZ5T3B0aW9uczogb2JqZWN0aWZ5T3B0aW9ucyxcbiAgICBub3JtYWxpc2VPcHRpb25zOiBub3JtYWxpc2VPcHRpb25zLFxufTtcbmZ1bmN0aW9uIGdldEhvc3Qob3B0aW9ucywgaG9zdCwgd3MpIHtcbiAgICBpZiAod3MpXG4gICAgICAgIGhvc3QgPSAoaG9zdCA9PSBvcHRpb25zLnJlc3RIb3N0ICYmIG9wdGlvbnMucmVhbHRpbWVIb3N0KSB8fCBob3N0IHx8IG9wdGlvbnMucmVhbHRpbWVIb3N0O1xuICAgIGVsc2VcbiAgICAgICAgaG9zdCA9IGhvc3QgfHwgb3B0aW9ucy5yZXN0SG9zdDtcbiAgICByZXR1cm4gaG9zdDtcbn1cbmV4cG9ydHMuZ2V0SG9zdCA9IGdldEhvc3Q7XG5mdW5jdGlvbiBnZXRQb3J0KG9wdGlvbnMsIHRscykge1xuICAgIHJldHVybiB0bHMgfHwgb3B0aW9ucy50bHMgPyBvcHRpb25zLnRsc1BvcnQgOiBvcHRpb25zLnBvcnQ7XG59XG5leHBvcnRzLmdldFBvcnQgPSBnZXRQb3J0O1xuZnVuY3Rpb24gZ2V0SHR0cFNjaGVtZShvcHRpb25zKSB7XG4gICAgcmV0dXJuIG9wdGlvbnMudGxzID8gJ2h0dHBzOi8vJyA6ICdodHRwOi8vJztcbn1cbmV4cG9ydHMuZ2V0SHR0cFNjaGVtZSA9IGdldEh0dHBTY2hlbWU7XG4vLyBjb25zdHJ1Y3QgZW52aXJvbm1lbnQgZmFsbGJhY2sgaG9zdHMgYXMgcGVyIFJTQzE1aVxuZnVuY3Rpb24gZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzKGVudmlyb25tZW50KSB7XG4gICAgcmV0dXJuIFtcbiAgICAgICAgZW52aXJvbm1lbnQgKyAnLWEtZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb20nLFxuICAgICAgICBlbnZpcm9ubWVudCArICctYi1mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbScsXG4gICAgICAgIGVudmlyb25tZW50ICsgJy1jLWZhbGxiYWNrLmFibHktcmVhbHRpbWUuY29tJyxcbiAgICAgICAgZW52aXJvbm1lbnQgKyAnLWQtZmFsbGJhY2suYWJseS1yZWFsdGltZS5jb20nLFxuICAgICAgICBlbnZpcm9ubWVudCArICctZS1mYWxsYmFjay5hYmx5LXJlYWx0aW1lLmNvbScsXG4gICAgXTtcbn1cbmV4cG9ydHMuZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzID0gZW52aXJvbm1lbnRGYWxsYmFja0hvc3RzO1xuZnVuY3Rpb24gZ2V0RmFsbGJhY2tIb3N0cyhvcHRpb25zKSB7XG4gICAgdmFyIGZhbGxiYWNrSG9zdHMgPSBvcHRpb25zLmZhbGxiYWNrSG9zdHMsIGh0dHBNYXhSZXRyeUNvdW50ID0gdHlwZW9mIG9wdGlvbnMuaHR0cE1heFJldHJ5Q291bnQgIT09ICd1bmRlZmluZWQnID8gb3B0aW9ucy5odHRwTWF4UmV0cnlDb3VudCA6IERlZmF1bHRzLmh0dHBNYXhSZXRyeUNvdW50O1xuICAgIHJldHVybiBmYWxsYmFja0hvc3RzID8gVXRpbHMuYXJyQ2hvb3NlTihmYWxsYmFja0hvc3RzLCBodHRwTWF4UmV0cnlDb3VudCkgOiBbXTtcbn1cbmV4cG9ydHMuZ2V0RmFsbGJhY2tIb3N0cyA9IGdldEZhbGxiYWNrSG9zdHM7XG5mdW5jdGlvbiBnZXRIb3N0cyhvcHRpb25zKSB7XG4gICAgcmV0dXJuIFtvcHRpb25zLnJlc3RIb3N0XS5jb25jYXQoZ2V0RmFsbGJhY2tIb3N0cyhvcHRpb25zKSk7XG59XG5leHBvcnRzLmdldEhvc3RzID0gZ2V0SG9zdHM7XG5mdW5jdGlvbiBjaGVja0hvc3QoaG9zdCkge1xuICAgIGlmICh0eXBlb2YgaG9zdCAhPT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ2hvc3QgbXVzdCBiZSBhIHN0cmluZzsgd2FzIGEgJyArIHR5cGVvZiBob3N0LCA0MDAwMCwgNDAwKTtcbiAgICB9XG4gICAgaWYgKCFob3N0Lmxlbmd0aCkge1xuICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnaG9zdCBtdXN0IG5vdCBiZSB6ZXJvLWxlbmd0aCcsIDQwMDAwLCA0MDApO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGdldFJlYWx0aW1lSG9zdChvcHRpb25zLCBwcm9kdWN0aW9uLCBlbnZpcm9ubWVudCkge1xuICAgIGlmIChvcHRpb25zLnJlYWx0aW1lSG9zdClcbiAgICAgICAgcmV0dXJuIG9wdGlvbnMucmVhbHRpbWVIb3N0O1xuICAgIC8qIHByZWZlciBzZXR0aW5nIHJlYWx0aW1lSG9zdCB0byByZXN0SG9zdCBhcyBhIGN1c3RvbSByZXN0SG9zdCB0eXBpY2FsbHkgaW5kaWNhdGVzXG4gICAgICogYSBkZXZlbG9wbWVudCBlbnZpcm9ubWVudCBpcyBiZWluZyB1c2VkIHRoYXQgY2FuJ3QgYmUgaW5mZXJyZWQgYnkgdGhlIGxpYnJhcnkgKi9cbiAgICBpZiAob3B0aW9ucy5yZXN0SG9zdCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0RlZmF1bHRzLm5vcm1hbGlzZU9wdGlvbnMnLCAncmVzdEhvc3QgaXMgc2V0IHRvIFwiJyArXG4gICAgICAgICAgICBvcHRpb25zLnJlc3RIb3N0ICtcbiAgICAgICAgICAgICdcIiBidXQgcmVhbHRpbWVIb3N0IGlzIG5vdCBzZXQsIHNvIHNldHRpbmcgcmVhbHRpbWVIb3N0IHRvIFwiJyArXG4gICAgICAgICAgICBvcHRpb25zLnJlc3RIb3N0ICtcbiAgICAgICAgICAgICdcIiB0b28uIElmIHRoaXMgaXMgbm90IHdoYXQgeW91IHdhbnQsIHBsZWFzZSBzZXQgcmVhbHRpbWVIb3N0IGV4cGxpY2l0bHkuJyk7XG4gICAgICAgIHJldHVybiBvcHRpb25zLnJlc3RIb3N0O1xuICAgIH1cbiAgICByZXR1cm4gcHJvZHVjdGlvbiA/IERlZmF1bHRzLlJFQUxUSU1FX0hPU1QgOiBlbnZpcm9ubWVudCArICctJyArIERlZmF1bHRzLlJFQUxUSU1FX0hPU1Q7XG59XG5mdW5jdGlvbiBnZXRUaW1lb3V0cyhvcHRpb25zKSB7XG4gICAgLyogQWxsb3cgdmFsdWVzIHBhc3NlZCBpbiBvcHRpb25zIHRvIG92ZXJyaWRlIGRlZmF1bHQgdGltZW91dHMgKi9cbiAgICB2YXIgdGltZW91dHMgPSB7fTtcbiAgICBmb3IgKHZhciBwcm9wIGluIERlZmF1bHRzLlRJTUVPVVRTKSB7XG4gICAgICAgIHRpbWVvdXRzW3Byb3BdID0gb3B0aW9uc1twcm9wXSB8fCBEZWZhdWx0cy5USU1FT1VUU1twcm9wXTtcbiAgICB9XG4gICAgcmV0dXJuIHRpbWVvdXRzO1xufVxuZnVuY3Rpb24gZ2V0QWdlbnRTdHJpbmcob3B0aW9ucykge1xuICAgIHZhciBhZ2VudFN0ciA9IERlZmF1bHRzLmFnZW50O1xuICAgIGlmIChvcHRpb25zLmFnZW50cykge1xuICAgICAgICBmb3IgKHZhciBhZ2VudCBpbiBvcHRpb25zLmFnZW50cykge1xuICAgICAgICAgICAgYWdlbnRTdHIgKz0gJyAnICsgYWdlbnQgKyAnLycgKyBvcHRpb25zLmFnZW50c1thZ2VudF07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGFnZW50U3RyO1xufVxuZXhwb3J0cy5nZXRBZ2VudFN0cmluZyA9IGdldEFnZW50U3RyaW5nO1xuZnVuY3Rpb24gb2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zID09ICdzdHJpbmcnKSB7XG4gICAgICAgIHJldHVybiBvcHRpb25zLmluZGV4T2YoJzonKSA9PSAtMSA/IHsgdG9rZW46IG9wdGlvbnMgfSA6IHsga2V5OiBvcHRpb25zIH07XG4gICAgfVxuICAgIHJldHVybiBvcHRpb25zO1xufVxuZXhwb3J0cy5vYmplY3RpZnlPcHRpb25zID0gb2JqZWN0aWZ5T3B0aW9ucztcbmZ1bmN0aW9uIG5vcm1hbGlzZU9wdGlvbnMob3B0aW9ucykge1xuICAgIC8qIERlcHJlY2F0ZWQgb3B0aW9ucyAqL1xuICAgIGlmIChvcHRpb25zLmhvc3QpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZXByZWNhdGVkKCdob3N0JywgJ3Jlc3RIb3N0Jyk7XG4gICAgICAgIG9wdGlvbnMucmVzdEhvc3QgPSBvcHRpb25zLmhvc3Q7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLndzSG9zdCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlcHJlY2F0ZWQoJ3dzSG9zdCcsICdyZWFsdGltZUhvc3QnKTtcbiAgICAgICAgb3B0aW9ucy5yZWFsdGltZUhvc3QgPSBvcHRpb25zLndzSG9zdDtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMucXVldWVFdmVudHMpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZXByZWNhdGVkKCdxdWV1ZUV2ZW50cycsICdxdWV1ZU1lc3NhZ2VzJyk7XG4gICAgICAgIG9wdGlvbnMucXVldWVNZXNzYWdlcyA9IG9wdGlvbnMucXVldWVFdmVudHM7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLmZhbGxiYWNrSG9zdHNVc2VEZWZhdWx0KSB7XG4gICAgICAgIC8qIGZhbGxiYWNrSG9zdHNVc2VEZWZhdWx0IGFuZCBmYWxsYmFja0hvc3RzIGFyZSBtdXR1YWxseSBleGNsdXNpdmUgYXMgcGVyIFRPM2s3ICovXG4gICAgICAgIGlmIChvcHRpb25zLmZhbGxiYWNrSG9zdHMpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnZmFsbGJhY2tIb3N0cyBhbmQgZmFsbGJhY2tIb3N0c1VzZURlZmF1bHQgY2Fubm90IGJvdGggYmUgc2V0JztcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9ucycsIG1zZyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDQwMDAwLCA0MDApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGRlZmF1bHQgZmFsbGJhY2tzIGNhbid0IGJlIHVzZWQgd2l0aCBjdXN0b20gcG9ydHMgKi9cbiAgICAgICAgaWYgKG9wdGlvbnMucG9ydCB8fCBvcHRpb25zLnRsc1BvcnQpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnZmFsbGJhY2tIb3N0c1VzZURlZmF1bHQgY2Fubm90IGJlIHNldCB3aGVuIHBvcnQgb3IgdGxzUG9ydCBhcmUgc2V0JztcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9ucycsIG1zZyk7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDQwMDAwLCA0MDApO1xuICAgICAgICB9XG4gICAgICAgIC8qIGVtaXQgYW4gYXBwcm9wcmlhdGUgZGVwcmVjYXRpb24gd2FybmluZyAqL1xuICAgICAgICBpZiAob3B0aW9ucy5lbnZpcm9ubWVudCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZXByZWNhdGVkV2l0aE1zZygnZmFsbGJhY2tIb3N0c1VzZURlZmF1bHQnLCAnVGhlcmUgaXMgbm8gbG9uZ2VyIGEgbmVlZCB0byBzZXQgdGhpcyB3aGVuIHRoZSBlbnZpcm9ubWVudCBvcHRpb24gaXMgYWxzbyBzZXQgc2luY2UgdGhlIGxpYnJhcnkgd2lsbCBub3cgZ2VuZXJhdGUgdGhlIGNvcnJlY3QgZmFsbGJhY2sgaG9zdHMgdXNpbmcgdGhlIGVudmlyb25tZW50IG9wdGlvbi4nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZGVwcmVjYXRlZCgnZmFsbGJhY2tIb3N0c1VzZURlZmF1bHQnLCAnZmFsbGJhY2tIb3N0czogQWJseS5EZWZhdWx0cy5GQUxMQkFDS19IT1NUUycpO1xuICAgICAgICB9XG4gICAgICAgIC8qIHVzZSB0aGUgZGVmYXVsdCBmYWxsYmFjayBob3N0cyBhcyByZXF1ZXN0ZWQgKi9cbiAgICAgICAgb3B0aW9ucy5mYWxsYmFja0hvc3RzID0gRGVmYXVsdHMuRkFMTEJBQ0tfSE9TVFM7XG4gICAgfVxuICAgIC8qIG9wdGlvbnMucmVjb3ZlciBhcyBhIGJvb2xlYW4gaXMgZGVwcmVjYXRlZCwgYW5kIHRoZXJlZm9yZSBpcyBub3QgcGFydCBvZiB0aGUgcHVibGljIHR5cGluZyAqL1xuICAgIGlmIChvcHRpb25zLnJlY292ZXIgPT09IHRydWUpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZXByZWNhdGVkKCd7cmVjb3ZlcjogdHJ1ZX0nLCAne3JlY292ZXI6IGZ1bmN0aW9uKGxhc3RDb25uZWN0aW9uRGV0YWlscywgY2IpIHsgY2IodHJ1ZSk7IH19Jyk7XG4gICAgICAgIG9wdGlvbnMucmVjb3ZlciA9IGZ1bmN0aW9uIChsYXN0Q29ubmVjdGlvbkRldGFpbHMsIGNiKSB7XG4gICAgICAgICAgICBjYih0cnVlKTtcbiAgICAgICAgfTtcbiAgICB9XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLnJlY292ZXIgPT09ICdmdW5jdGlvbicgJiYgb3B0aW9ucy5jbG9zZU9uVW5sb2FkID09PSB0cnVlKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnRGVmYXVsdHMubm9ybWFsaXNlT3B0aW9ucycsICdjbG9zZU9uVW5sb2FkIHdhcyB0cnVlIGFuZCBhIHNlc3Npb24gcmVjb3ZlcnkgZnVuY3Rpb24gd2FzIHNldCAtIHRoZXNlIGFyZSBtdXR1YWxseSBleGNsdXNpdmUsIHNvIHVuc2V0dGluZyB0aGUgbGF0dGVyJyk7XG4gICAgICAgIG9wdGlvbnMucmVjb3ZlciA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgaWYgKCEoJ2Nsb3NlT25VbmxvYWQnIGluIG9wdGlvbnMpKSB7XG4gICAgICAgIC8qIEhhdmUgY2xvc2VPblVubG9hZCBkZWZhdWx0IHRvIHRydWUgdW5sZXNzIHdlIGhhdmUgYW55IGluZGljYXRpb24gdGhhdFxuICAgICAgICAgKiB0aGUgdXNlciBtYXkgd2FudCB0byByZWNvdmVyIHRoZSBjb25uZWN0aW9uICovXG4gICAgICAgIG9wdGlvbnMuY2xvc2VPblVubG9hZCA9ICFvcHRpb25zLnJlY292ZXI7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnRyYW5zcG9ydHMgJiYgVXRpbHMuYXJySW4ob3B0aW9ucy50cmFuc3BvcnRzLCAneGhyJykpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZXByZWNhdGVkKCd0cmFuc3BvcnRzOiBbXCJ4aHJcIl0nLCAndHJhbnNwb3J0czogW1wieGhyX3N0cmVhbWluZ1wiXScpO1xuICAgICAgICBVdGlscy5hcnJEZWxldGVWYWx1ZShvcHRpb25zLnRyYW5zcG9ydHMsICd4aHInKTtcbiAgICAgICAgb3B0aW9ucy50cmFuc3BvcnRzLnB1c2goJ3hocl9zdHJlYW1pbmcnKTtcbiAgICB9XG4gICAgaWYgKCEoJ3F1ZXVlTWVzc2FnZXMnIGluIG9wdGlvbnMpKVxuICAgICAgICBvcHRpb25zLnF1ZXVlTWVzc2FnZXMgPSB0cnVlO1xuICAgIC8qIGluZmVyIGhvc3RzIGFuZCBmYWxsYmFja3MgYmFzZWQgb24gdGhlIGNvbmZpZ3VyZWQgZW52aXJvbm1lbnQgKi9cbiAgICB2YXIgZW52aXJvbm1lbnQgPSAob3B0aW9ucy5lbnZpcm9ubWVudCAmJiBTdHJpbmcob3B0aW9ucy5lbnZpcm9ubWVudCkudG9Mb3dlckNhc2UoKSkgfHwgRGVmYXVsdHMuRU5WSVJPTk1FTlQ7XG4gICAgdmFyIHByb2R1Y3Rpb24gPSAhZW52aXJvbm1lbnQgfHwgZW52aXJvbm1lbnQgPT09ICdwcm9kdWN0aW9uJztcbiAgICBpZiAoIW9wdGlvbnMuZmFsbGJhY2tIb3N0cyAmJiAhb3B0aW9ucy5yZXN0SG9zdCAmJiAhb3B0aW9ucy5yZWFsdGltZUhvc3QgJiYgIW9wdGlvbnMucG9ydCAmJiAhb3B0aW9ucy50bHNQb3J0KSB7XG4gICAgICAgIG9wdGlvbnMuZmFsbGJhY2tIb3N0cyA9IHByb2R1Y3Rpb24gPyBEZWZhdWx0cy5GQUxMQkFDS19IT1NUUyA6IGVudmlyb25tZW50RmFsbGJhY2tIb3N0cyhlbnZpcm9ubWVudCk7XG4gICAgfVxuICAgIHZhciByZXN0SG9zdCA9IG9wdGlvbnMucmVzdEhvc3QgfHwgKHByb2R1Y3Rpb24gPyBEZWZhdWx0cy5SRVNUX0hPU1QgOiBlbnZpcm9ubWVudCArICctJyArIERlZmF1bHRzLlJFU1RfSE9TVCk7XG4gICAgdmFyIHJlYWx0aW1lSG9zdCA9IGdldFJlYWx0aW1lSG9zdChvcHRpb25zLCBwcm9kdWN0aW9uLCBlbnZpcm9ubWVudCk7XG4gICAgVXRpbHMuYXJyRm9yRWFjaCgob3B0aW9ucy5mYWxsYmFja0hvc3RzIHx8IFtdKS5jb25jYXQocmVzdEhvc3QsIHJlYWx0aW1lSG9zdCksIGNoZWNrSG9zdCk7XG4gICAgb3B0aW9ucy5wb3J0ID0gb3B0aW9ucy5wb3J0IHx8IERlZmF1bHRzLlBPUlQ7XG4gICAgb3B0aW9ucy50bHNQb3J0ID0gb3B0aW9ucy50bHNQb3J0IHx8IERlZmF1bHRzLlRMU19QT1JUO1xuICAgIGlmICghKCd0bHMnIGluIG9wdGlvbnMpKVxuICAgICAgICBvcHRpb25zLnRscyA9IHRydWU7XG4gICAgdmFyIHRpbWVvdXRzID0gZ2V0VGltZW91dHMob3B0aW9ucyk7XG4gICAgaWYgKCd1c2VCaW5hcnlQcm90b2NvbCcgaW4gb3B0aW9ucykge1xuICAgICAgICBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID0gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5zdXBwb3J0c0JpbmFyeSAmJiBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgb3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA9IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcucHJlZmVyQmluYXJ5O1xuICAgIH1cbiAgICBpZiAob3B0aW9ucy5jbGllbnRJZCkge1xuICAgICAgICB2YXIgaGVhZGVycyA9IChvcHRpb25zLmhlYWRlcnMgPSBvcHRpb25zLmhlYWRlcnMgfHwge30pO1xuICAgICAgICBoZWFkZXJzWydYLUFibHktQ2xpZW50SWQnXSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUocGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUob3B0aW9ucy5jbGllbnRJZCkpO1xuICAgIH1cbiAgICBpZiAoISgnaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nJyBpbiBvcHRpb25zKSkge1xuICAgICAgICBvcHRpb25zLmlkZW1wb3RlbnRSZXN0UHVibGlzaGluZyA9IHRydWU7XG4gICAgfVxuICAgIGlmIChvcHRpb25zLnByb21pc2VzICYmICFwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLlByb21pc2UpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdEZWZhdWx0cy5ub3JtYWxpc2VPcHRpb25zJywgJ3twcm9taXNlczogdHJ1ZX0gd2FzIHNwZWNpZmllZCwgYnV0IG5vIFByb21pc2UgY29uc3RydWN0b3IgZm91bmQ7IGRpc2FibGluZyBwcm9taXNlcycpO1xuICAgICAgICBvcHRpb25zLnByb21pc2VzID0gZmFsc2U7XG4gICAgfVxuICAgIHZhciBjb25uZWN0aXZpdHlDaGVja1BhcmFtcyA9IG51bGw7XG4gICAgdmFyIGNvbm5lY3Rpdml0eUNoZWNrVXJsID0gb3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybDtcbiAgICBpZiAob3B0aW9ucy5jb25uZWN0aXZpdHlDaGVja1VybCkge1xuICAgICAgICB2YXIgX2EgPSBvcHRpb25zLmNvbm5lY3Rpdml0eUNoZWNrVXJsLnNwbGl0KCc/JyksIHVyaSA9IF9hWzBdLCBxcyA9IF9hWzFdO1xuICAgICAgICBjb25uZWN0aXZpdHlDaGVja1BhcmFtcyA9IHFzID8gVXRpbHMucGFyc2VRdWVyeVN0cmluZyhxcykgOiB7fTtcbiAgICAgICAgaWYgKHVyaS5pbmRleE9mKCc6Ly8nKSA9PT0gLTEpIHtcbiAgICAgICAgICAgIHVyaSA9ICdodHRwczovLycgKyB1cmk7XG4gICAgICAgIH1cbiAgICAgICAgY29ubmVjdGl2aXR5Q2hlY2tVcmwgPSB1cmk7XG4gICAgfVxuICAgIHJldHVybiB0c2xpYl8xLl9fYXNzaWduKHRzbGliXzEuX19hc3NpZ24oe30sIG9wdGlvbnMpLCB7IHVzZUJpbmFyeVByb3RvY29sOiAndXNlQmluYXJ5UHJvdG9jb2wnIGluIG9wdGlvbnNcbiAgICAgICAgICAgID8gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5zdXBwb3J0c0JpbmFyeSAmJiBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sXG4gICAgICAgICAgICA6IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcucHJlZmVyQmluYXJ5LCByZWFsdGltZUhvc3Q6IHJlYWx0aW1lSG9zdCwgcmVzdEhvc3Q6IHJlc3RIb3N0LCBtYXhNZXNzYWdlU2l6ZTogb3B0aW9ucy5tYXhNZXNzYWdlU2l6ZSB8fCBEZWZhdWx0cy5tYXhNZXNzYWdlU2l6ZSwgdGltZW91dHM6IHRpbWVvdXRzLCBjb25uZWN0aXZpdHlDaGVja1BhcmFtczogY29ubmVjdGl2aXR5Q2hlY2tQYXJhbXMsIGNvbm5lY3Rpdml0eUNoZWNrVXJsOiBjb25uZWN0aXZpdHlDaGVja1VybCB9KTtcbn1cbmV4cG9ydHMubm9ybWFsaXNlT3B0aW9ucyA9IG5vcm1hbGlzZU9wdGlvbnM7XG5leHBvcnRzLmRlZmF1bHQgPSBEZWZhdWx0cztcbmZ1bmN0aW9uIGdldERlZmF1bHRzKHBsYXRmb3JtRGVmYXVsdHMpIHtcbiAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihEZWZhdWx0cywgcGxhdGZvcm1EZWZhdWx0cyk7XG59XG5leHBvcnRzLmdldERlZmF1bHRzID0gZ2V0RGVmYXVsdHM7XG5cblxuLyoqKi8gfSksXG4vKiA5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xuZnVuY3Rpb24gbm9ybWFsaXNlQ29udGV4dChjb250ZXh0KSB7XG4gICAgaWYgKCFjb250ZXh0IHx8ICFjb250ZXh0LmNoYW5uZWxPcHRpb25zKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjaGFubmVsT3B0aW9uczogY29udGV4dCxcbiAgICAgICAgICAgIHBsdWdpbnM6IHt9LFxuICAgICAgICAgICAgYmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQ6IHVuZGVmaW5lZCxcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIGNvbnRleHQ7XG59XG5mdW5jdGlvbiBub3JtYWxpemVDaXBoZXJPcHRpb25zKG9wdGlvbnMpIHtcbiAgICBpZiAob3B0aW9ucyAmJiBvcHRpb25zLmNpcGhlcikge1xuICAgICAgICBpZiAoIXBsYXRmb3JtXzEuZGVmYXVsdC5DcnlwdG8pXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0VuY3J5cHRpb24gbm90IGVuYWJsZWQ7IHVzZSBhYmx5LmVuY3J5cHRpb24uanMgaW5zdGVhZCcpO1xuICAgICAgICB2YXIgY2lwaGVyID0gcGxhdGZvcm1fMS5kZWZhdWx0LkNyeXB0by5nZXRDaXBoZXIob3B0aW9ucy5jaXBoZXIpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgY2lwaGVyOiBjaXBoZXIuY2lwaGVyUGFyYW1zLFxuICAgICAgICAgICAgY2hhbm5lbENpcGhlcjogY2lwaGVyLmNpcGhlcixcbiAgICAgICAgfTtcbiAgICB9XG4gICAgcmV0dXJuIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9O1xufVxuZnVuY3Rpb24gZ2V0TWVzc2FnZVNpemUobXNnKSB7XG4gICAgdmFyIHNpemUgPSAwO1xuICAgIGlmIChtc2cubmFtZSkge1xuICAgICAgICBzaXplICs9IG1zZy5uYW1lLmxlbmd0aDtcbiAgICB9XG4gICAgaWYgKG1zZy5jbGllbnRJZCkge1xuICAgICAgICBzaXplICs9IG1zZy5jbGllbnRJZC5sZW5ndGg7XG4gICAgfVxuICAgIGlmIChtc2cuZXh0cmFzKSB7XG4gICAgICAgIHNpemUgKz0gSlNPTi5zdHJpbmdpZnkobXNnLmV4dHJhcykubGVuZ3RoO1xuICAgIH1cbiAgICBpZiAobXNnLmRhdGEpIHtcbiAgICAgICAgc2l6ZSArPSBVdGlscy5kYXRhU2l6ZUJ5dGVzKG1zZy5kYXRhKTtcbiAgICB9XG4gICAgcmV0dXJuIHNpemU7XG59XG52YXIgTWVzc2FnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXNzYWdlKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVybG9hZCB0b0pTT04oKSB0byBpbnRlcmNlcHQgSlNPTi5zdHJpbmdpZnkoKVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG4gICAgTWVzc2FnZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiBlbmNvZGUgZGF0YSB0byBiYXNlNjQgaWYgcHJlc2VudCBhbmQgd2UncmUgcmV0dXJuaW5nIHJlYWwgSlNPTjtcbiAgICAgICAgICogYWx0aG91Z2ggbXNncGFjayBjYWxscyB0b0pTT04oKSwgd2Uga25vdyBpdCBpcyBhIHN0cmluZ2lmeSgpXG4gICAgICAgICAqIGNhbGwgaWYgaXQgaGFzIGEgbm9uLWVtcHR5IGFyZ3VtZW50cyBsaXN0ICovXG4gICAgICAgIHZhciBlbmNvZGluZyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgICAgIHZhciBkYXRhID0gdGhpcy5kYXRhO1xuICAgICAgICBpZiAoZGF0YSAmJiBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuaXNCdWZmZXIoZGF0YSkpIHtcbiAgICAgICAgICAgIGlmIChhcmd1bWVudHMubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIC8qIHN0cmluZ2lmeSBjYWxsICovXG4gICAgICAgICAgICAgICAgZW5jb2RpbmcgPSBlbmNvZGluZyA/IGVuY29kaW5nICsgJy9iYXNlNjQnIDogJ2Jhc2U2NCc7XG4gICAgICAgICAgICAgICAgZGF0YSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5iYXNlNjRFbmNvZGUoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAvKiBDYWxsZWQgYnkgbXNncGFjay4gdG9CdWZmZXIgcmV0dXJucyBhIGRhdGF0eXBlIHVuZGVyc3RhbmRhYmxlIGJ5XG4gICAgICAgICAgICAgICAgICogdGhhdCBwbGF0Zm9ybSdzIG1zZ3BhY2sgaW1wbGVtZW50YXRpb24gKEJ1ZmZlciBpbiBub2RlLCBVaW50OEFycmF5XG4gICAgICAgICAgICAgICAgICogaW4gYnJvd3NlcnMpICovXG4gICAgICAgICAgICAgICAgZGF0YSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy50b0J1ZmZlcihkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgbmFtZTogdGhpcy5uYW1lLFxuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcbiAgICAgICAgICAgIGNvbm5lY3Rpb25JZDogdGhpcy5jb25uZWN0aW9uSWQsXG4gICAgICAgICAgICBjb25uZWN0aW9uS2V5OiB0aGlzLmNvbm5lY3Rpb25LZXksXG4gICAgICAgICAgICBleHRyYXM6IHRoaXMuZXh0cmFzLFxuICAgICAgICAgICAgZW5jb2Rpbmc6IGVuY29kaW5nLFxuICAgICAgICAgICAgZGF0YTogZGF0YSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIE1lc3NhZ2UucHJvdG90eXBlLnRvU3RyaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gJ1tNZXNzYWdlJztcbiAgICAgICAgaWYgKHRoaXMubmFtZSlcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBuYW1lPScgKyB0aGlzLm5hbWU7XG4gICAgICAgIGlmICh0aGlzLmlkKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGlkPScgKyB0aGlzLmlkO1xuICAgICAgICBpZiAodGhpcy50aW1lc3RhbXApXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgdGltZXN0YW1wPScgKyB0aGlzLnRpbWVzdGFtcDtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50SWQpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgY2xpZW50SWQ9JyArIHRoaXMuY2xpZW50SWQ7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25JZClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBjb25uZWN0aW9uSWQ9JyArIHRoaXMuY29ubmVjdGlvbklkO1xuICAgICAgICBpZiAodGhpcy5lbmNvZGluZylcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBlbmNvZGluZz0nICsgdGhpcy5lbmNvZGluZztcbiAgICAgICAgaWYgKHRoaXMuZXh0cmFzKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGV4dHJhcyA9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZXh0cmFzKTtcbiAgICAgICAgaWYgKHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRhdGEgPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGRhdGE9JyArIHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5pc0J1ZmZlcih0aGlzLmRhdGEpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnOyBkYXRhIChidWZmZXIpPScgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKHRoaXMuZGF0YSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGRhdGEgKGpzb24pPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4dHJhcylcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBleHRyYXM9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMuZXh0cmFzKTtcbiAgICAgICAgcmVzdWx0ICs9ICddJztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIE1lc3NhZ2UuZW5jcnlwdCA9IGZ1bmN0aW9uIChtc2csIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkYXRhID0gbXNnLmRhdGEsIGVuY29kaW5nID0gbXNnLmVuY29kaW5nLCBjaXBoZXIgPSBvcHRpb25zLmNoYW5uZWxDaXBoZXI7XG4gICAgICAgIGVuY29kaW5nID0gZW5jb2RpbmcgPyBlbmNvZGluZyArICcvJyA6ICcnO1xuICAgICAgICBpZiAoIXBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgZGF0YSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy51dGY4RW5jb2RlKFN0cmluZyhkYXRhKSk7XG4gICAgICAgICAgICBlbmNvZGluZyA9IGVuY29kaW5nICsgJ3V0Zi04Lyc7XG4gICAgICAgIH1cbiAgICAgICAgY2lwaGVyLmVuY3J5cHQoZGF0YSwgZnVuY3Rpb24gKGVyciwgZGF0YSkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgbXNnLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgbXNnLmVuY29kaW5nID0gZW5jb2RpbmcgKyAnY2lwaGVyKycgKyBjaXBoZXIuYWxnb3JpdGhtO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbXNnKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBNZXNzYWdlLmVuY29kZSA9IGZ1bmN0aW9uIChtc2csIG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBkYXRhID0gbXNnLmRhdGE7XG4gICAgICAgIHZhciBuYXRpdmVEYXRhVHlwZSA9IHR5cGVvZiBkYXRhID09ICdzdHJpbmcnIHx8IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5pc0J1ZmZlcihkYXRhKSB8fCBkYXRhID09PSBudWxsIHx8IGRhdGEgPT09IHVuZGVmaW5lZDtcbiAgICAgICAgaWYgKCFuYXRpdmVEYXRhVHlwZSkge1xuICAgICAgICAgICAgaWYgKFV0aWxzLmlzT2JqZWN0KGRhdGEpIHx8IFV0aWxzLmlzQXJyYXkoZGF0YSkpIHtcbiAgICAgICAgICAgICAgICBtc2cuZGF0YSA9IEpTT04uc3RyaW5naWZ5KGRhdGEpO1xuICAgICAgICAgICAgICAgIG1zZy5lbmNvZGluZyA9IG1zZy5lbmNvZGluZyA/IG1zZy5lbmNvZGluZyArICcvanNvbicgOiAnanNvbic7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnRGF0YSB0eXBlIGlzIHVuc3VwcG9ydGVkJywgNDAwMTMsIDQwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgIT0gbnVsbCAmJiBvcHRpb25zLmNpcGhlcikge1xuICAgICAgICAgICAgTWVzc2FnZS5lbmNyeXB0KG1zZywgb3B0aW9ucywgY2FsbGJhY2spO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbXNnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVzc2FnZS5lbmNvZGVBcnJheSA9IGZ1bmN0aW9uIChtZXNzYWdlcywgb3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHByb2Nlc3NlZCA9IDA7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIE1lc3NhZ2UuZW5jb2RlKG1lc3NhZ2VzW2ldLCBvcHRpb25zLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHByb2Nlc3NlZCsrO1xuICAgICAgICAgICAgICAgIGlmIChwcm9jZXNzZWQgPT0gbWVzc2FnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG1lc3NhZ2VzKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVzc2FnZS5kZWNvZGUgPSBmdW5jdGlvbiAobWVzc2FnZSwgaW5wdXRDb250ZXh0KSB7XG4gICAgICAgIHZhciBjb250ZXh0ID0gbm9ybWFsaXNlQ29udGV4dChpbnB1dENvbnRleHQpO1xuICAgICAgICB2YXIgbGFzdFBheWxvYWQgPSBtZXNzYWdlLmRhdGE7XG4gICAgICAgIHZhciBlbmNvZGluZyA9IG1lc3NhZ2UuZW5jb2Rpbmc7XG4gICAgICAgIGlmIChlbmNvZGluZykge1xuICAgICAgICAgICAgdmFyIHhmb3JtcyA9IGVuY29kaW5nLnNwbGl0KCcvJyk7XG4gICAgICAgICAgICB2YXIgbGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXggPSB2b2lkIDAsIGVuY29kaW5nc1RvUHJvY2VzcyA9IHhmb3Jtcy5sZW5ndGgsIGRhdGEgPSBtZXNzYWdlLmRhdGE7XG4gICAgICAgICAgICB2YXIgeGZvcm0gPSAnJztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgd2hpbGUgKChsYXN0UHJvY2Vzc2VkRW5jb2RpbmdJbmRleCA9IGVuY29kaW5nc1RvUHJvY2VzcykgPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBzZWN1cml0eS9kZXRlY3QtdW5zYWZlLXJlZ2V4XG4gICAgICAgICAgICAgICAgICAgIHZhciBtYXRjaCA9IHhmb3Jtc1stLWVuY29kaW5nc1RvUHJvY2Vzc10ubWF0Y2goLyhbLVxcd10rKShcXCsoW1xcdy1dKykpPy8pO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIW1hdGNoKVxuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIHhmb3JtID0gbWF0Y2hbMV07XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoeGZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Jhc2U2NCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5iYXNlNjREZWNvZGUoU3RyaW5nKGRhdGEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAobGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXggPT0geGZvcm1zLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UGF5bG9hZCA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndXRmLTgnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMudXRmOERlY29kZShkYXRhKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2pzb24nOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBKU09OLnBhcnNlKGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2lwaGVyJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoY29udGV4dC5jaGFubmVsT3B0aW9ucyAhPSBudWxsICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2hhbm5lbE9wdGlvbnMuY2lwaGVyICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRleHQuY2hhbm5lbE9wdGlvbnMuY2hhbm5lbENpcGhlcikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgeGZvcm1BbGdvcml0aG0gPSBtYXRjaFszXSwgY2lwaGVyID0gY29udGV4dC5jaGFubmVsT3B0aW9ucy5jaGFubmVsQ2lwaGVyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBkb24ndCBhdHRlbXB0IHRvIGRlY3J5cHQgdW5sZXNzIHRoZSBjaXBoZXIgcGFyYW1zIGFyZSBjb21wYXRpYmxlICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh4Zm9ybUFsZ29yaXRobSAhPSBjaXBoZXIuYWxnb3JpdGhtKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1VuYWJsZSB0byBkZWNyeXB0IG1lc3NhZ2Ugd2l0aCBnaXZlbiBjaXBoZXI7IGluY29tcGF0aWJsZSBjaXBoZXIgcGFyYW1zJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGF0YSA9IGNpcGhlci5kZWNyeXB0KGRhdGEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5hYmxlIHRvIGRlY3J5cHQgbWVzc2FnZTsgbm90IGFuIGVuY3J5cHRlZCBjaGFubmVsJyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAndmNkaWZmJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRleHQucGx1Z2lucyB8fCAhY29udGV4dC5wbHVnaW5zLnZjZGlmZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnTWlzc2luZyBWY2RpZmYgZGVjb2RlciAoaHR0cHM6Ly9naXRodWIuY29tL2FibHktZm9ya3MvdmNkaWZmLWRlY29kZXIpJywgNDAwMTksIDQwMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgVWludDhBcnJheSA9PT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0RlbHRhIGRlY29kaW5nIG5vdCBzdXBwb3J0ZWQgb24gdGhpcyBicm93c2VyIChuZWVkIEFycmF5QnVmZmVyICYgVWludDhBcnJheSknLCA0MDAyMCwgNDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIGRlbHRhQmFzZSA9IGNvbnRleHQuYmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQ7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZGVsdGFCYXNlID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFCYXNlID0gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLnV0ZjhFbmNvZGUoZGVsdGFCYXNlKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiB2Y2RpZmYgZXhwZWN0cyBVaW50OEFycmF5cywgY2FuJ3QgY29weSB3aXRoIEFycmF5QnVmZmVycy4gKGFsc28sIGlmIHdlXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAqIGRvbid0IGhhdmUgYSBUZXh0RGVjb2RlciwgZGVsdGFCYXNlIG1pZ2h0IGJlIGEgV29yZEFycmF5IGhlcmUsIHNvIG5lZWRcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICogdG8gcHJvY2VzcyBpdCBpbnRvIGEgYnVmZmVyIGFueXdheSkgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZGVsdGFCYXNlID0gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLnRvQnVmZmVyKGRlbHRhQmFzZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMudG9CdWZmZXIoZGF0YSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRhdGEgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMudHlwZWRBcnJheVRvQnVmZmVyKGNvbnRleHQucGx1Z2lucy52Y2RpZmYuZGVjb2RlKGRhdGEsIGRlbHRhQmFzZSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBsYXN0UGF5bG9hZCA9IGRhdGE7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdWY2RpZmYgZGVsdGEgZGVjb2RlIGZhaWxlZCB3aXRoICcgKyBlLCA0MDAxOCwgNDAwKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBlbmNvZGluZycpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gZTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnRXJyb3IgcHJvY2Vzc2luZyB0aGUgJyArIHhmb3JtICsgJyBlbmNvZGluZywgZGVjb2RlciByZXR1cm5lZCDigJgnICsgZXJyLm1lc3NhZ2UgKyAn4oCZJywgZXJyLmNvZGUgfHwgNDAwMTMsIDQwMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBmaW5hbGx5IHtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmVuY29kaW5nID1cbiAgICAgICAgICAgICAgICAgICAgbGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXggPD0gMCA/IG51bGwgOiB4Zm9ybXMuc2xpY2UoMCwgbGFzdFByb2Nlc3NlZEVuY29kaW5nSW5kZXgpLmpvaW4oJy8nKTtcbiAgICAgICAgICAgICAgICBtZXNzYWdlLmRhdGEgPSBkYXRhO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRleHQuYmFzZUVuY29kZWRQcmV2aW91c1BheWxvYWQgPSBsYXN0UGF5bG9hZDtcbiAgICB9O1xuICAgIE1lc3NhZ2UuZnJvbVJlc3BvbnNlQm9keSA9IGZ1bmN0aW9uIChib2R5LCBvcHRpb25zLCBmb3JtYXQpIHtcbiAgICAgICAgaWYgKGZvcm1hdCkge1xuICAgICAgICAgICAgYm9keSA9IFV0aWxzLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAoYm9keVtpXSA9IE1lc3NhZ2UuZnJvbVZhbHVlcyhib2R5W2ldKSk7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIE1lc3NhZ2UuZGVjb2RlKG1zZywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnTWVzc2FnZS5mcm9tUmVzcG9uc2VCb2R5KCknLCBlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBib2R5O1xuICAgIH07XG4gICAgTWVzc2FnZS5mcm9tVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgTWVzc2FnZSgpLCB2YWx1ZXMpO1xuICAgIH07XG4gICAgTWVzc2FnZS5mcm9tVmFsdWVzQXJyYXkgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IE1lc3NhZ2UuZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgTWVzc2FnZS5mcm9tRW5jb2RlZCA9IGZ1bmN0aW9uIChlbmNvZGVkLCBpbnB1dE9wdGlvbnMpIHtcbiAgICAgICAgdmFyIG1zZyA9IE1lc3NhZ2UuZnJvbVZhbHVlcyhlbmNvZGVkKTtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVDaXBoZXJPcHRpb25zKGlucHV0T3B0aW9ucyAhPT0gbnVsbCAmJiBpbnB1dE9wdGlvbnMgIT09IHZvaWQgMCA/IGlucHV0T3B0aW9ucyA6IG51bGwpO1xuICAgICAgICAvKiBpZiBkZWNvZGluZyBmYWlscyBhdCBhbnkgcG9pbnQsIGNhdGNoIGFuZCByZXR1cm4gdGhlIG1lc3NhZ2UgZGVjb2RlZCB0b1xuICAgICAgICAgKiB0aGUgZnVsbGVzdCBleHRlbnQgcG9zc2libGUgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIE1lc3NhZ2UuZGVjb2RlKG1zZywgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnTWVzc2FnZS5mcm9tRW5jb2RlZCgpJywgZS50b1N0cmluZygpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gbXNnO1xuICAgIH07XG4gICAgTWVzc2FnZS5mcm9tRW5jb2RlZEFycmF5ID0gZnVuY3Rpb24gKGVuY29kZWRBcnJheSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZW5jb2RlZEFycmF5Lm1hcChmdW5jdGlvbiAoZW5jb2RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIE1lc3NhZ2UuZnJvbUVuY29kZWQoZW5jb2RlZCwgb3B0aW9ucyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyogVGhpcyBzaG91bGQgYmUgY2FsbGVkIG9uIGVuY29kZSgpZCAoYW5kIGVuY3J5cHQoKWQpIE1lc3NhZ2VzIChhcyBpdFxuICAgICAqIGFzc3VtZXMgdGhlIGRhdGEgaXMgYSBzdHJpbmcgb3IgYnVmZmVyKSAqL1xuICAgIE1lc3NhZ2UuZ2V0TWVzc2FnZXNTaXplID0gZnVuY3Rpb24gKG1lc3NhZ2VzKSB7XG4gICAgICAgIHZhciBtc2csIHRvdGFsID0gMDtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgbXNnID0gbWVzc2FnZXNbaV07XG4gICAgICAgICAgICB0b3RhbCArPSBtc2cuc2l6ZSB8fCAobXNnLnNpemUgPSBnZXRNZXNzYWdlU2l6ZShtc2cpKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdG90YWw7XG4gICAgfTtcbiAgICBNZXNzYWdlLnNlcmlhbGl6ZSA9IFV0aWxzLmVuY29kZUJvZHk7XG4gICAgcmV0dXJuIE1lc3NhZ2U7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTWVzc2FnZTtcblxuXG4vKioqLyB9KSxcbi8qIDEwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIG1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOSkpO1xudmFyIHByZXNlbmNlbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNSkpO1xudmFyIGFjdGlvbnMgPSB7XG4gICAgSEVBUlRCRUFUOiAwLFxuICAgIEFDSzogMSxcbiAgICBOQUNLOiAyLFxuICAgIENPTk5FQ1Q6IDMsXG4gICAgQ09OTkVDVEVEOiA0LFxuICAgIERJU0NPTk5FQ1Q6IDUsXG4gICAgRElTQ09OTkVDVEVEOiA2LFxuICAgIENMT1NFOiA3LFxuICAgIENMT1NFRDogOCxcbiAgICBFUlJPUjogOSxcbiAgICBBVFRBQ0g6IDEwLFxuICAgIEFUVEFDSEVEOiAxMSxcbiAgICBERVRBQ0g6IDEyLFxuICAgIERFVEFDSEVEOiAxMyxcbiAgICBQUkVTRU5DRTogMTQsXG4gICAgTUVTU0FHRTogMTUsXG4gICAgU1lOQzogMTYsXG4gICAgQVVUSDogMTcsXG4gICAgQUNUSVZBVEU6IDE4LFxufTtcbnZhciBBY3Rpb25OYW1lID0gW107XG5PYmplY3Qua2V5cyhhY3Rpb25zKS5mb3JFYWNoKGZ1bmN0aW9uIChuYW1lKSB7XG4gICAgQWN0aW9uTmFtZVthY3Rpb25zW25hbWVdXSA9IG5hbWU7XG59KTtcbnZhciBmbGFncyA9IHtcbiAgICAvKiBDaGFubmVsIGF0dGFjaCBzdGF0ZSBmbGFncyAqL1xuICAgIEhBU19QUkVTRU5DRTogMSA8PCAwLFxuICAgIEhBU19CQUNLTE9HOiAxIDw8IDEsXG4gICAgUkVTVU1FRDogMSA8PCAyLFxuICAgIFRSQU5TSUVOVDogMSA8PCA0LFxuICAgIEFUVEFDSF9SRVNVTUU6IDEgPDwgNSxcbiAgICAvKiBDaGFubmVsIG1vZGUgZmxhZ3MgKi9cbiAgICBQUkVTRU5DRTogMSA8PCAxNixcbiAgICBQVUJMSVNIOiAxIDw8IDE3LFxuICAgIFNVQlNDUklCRTogMSA8PCAxOCxcbiAgICBQUkVTRU5DRV9TVUJTQ1JJQkU6IDEgPDwgMTksXG59O1xudmFyIGZsYWdOYW1lcyA9IE9iamVjdC5rZXlzKGZsYWdzKTtcbmZsYWdzLk1PREVfQUxMID0gZmxhZ3MuUFJFU0VOQ0UgfCBmbGFncy5QVUJMSVNIIHwgZmxhZ3MuU1VCU0NSSUJFIHwgZmxhZ3MuUFJFU0VOQ0VfU1VCU0NSSUJFO1xuZnVuY3Rpb24gdG9TdHJpbmdBcnJheShhcnJheSkge1xuICAgIHZhciByZXN1bHQgPSBbXTtcbiAgICBpZiAoYXJyYXkpIHtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhcnJheS5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goYXJyYXlbaV0udG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuICdbICcgKyByZXN1bHQuam9pbignLCAnKSArICcgXSc7XG59XG52YXIgc2ltcGxlQXR0cmlidXRlcyA9ICdpZCBjaGFubmVsIGNoYW5uZWxTZXJpYWwgY29ubmVjdGlvbklkIGNvdW50IG1zZ1NlcmlhbCB0aW1lc3RhbXAnLnNwbGl0KCcgJyk7XG52YXIgUHJvdG9jb2xNZXNzYWdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByb3RvY29sTWVzc2FnZSgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5oYXNGbGFnID0gZnVuY3Rpb24gKGZsYWcpIHtcbiAgICAgICAgICAgIHJldHVybiAoX3RoaXMuZmxhZ3MgJiBmbGFnc1tmbGFnXSkgPiAwO1xuICAgICAgICB9O1xuICAgIH1cbiAgICBQcm90b2NvbE1lc3NhZ2UucHJvdG90eXBlLnNldEZsYWcgPSBmdW5jdGlvbiAoZmxhZykge1xuICAgICAgICByZXR1cm4gKHRoaXMuZmxhZ3MgPSB0aGlzLmZsYWdzIHwgZmxhZ3NbZmxhZ10pO1xuICAgIH07XG4gICAgUHJvdG9jb2xNZXNzYWdlLnByb3RvdHlwZS5nZXRNb2RlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5mbGFncyAmJiB0aGlzLmZsYWdzICYgZmxhZ3MuTU9ERV9BTEw7XG4gICAgfTtcbiAgICBQcm90b2NvbE1lc3NhZ2UucHJvdG90eXBlLmVuY29kZU1vZGVzVG9GbGFncyA9IGZ1bmN0aW9uIChtb2Rlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBtb2Rlcy5mb3JFYWNoKGZ1bmN0aW9uIChtb2RlKSB7IHJldHVybiBfdGhpcy5zZXRGbGFnKG1vZGUpOyB9KTtcbiAgICB9O1xuICAgIFByb3RvY29sTWVzc2FnZS5wcm90b3R5cGUuZGVjb2RlTW9kZXNGcm9tRmxhZ3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtb2RlcyA9IFtdO1xuICAgICAgICBQcm90b2NvbE1lc3NhZ2UuY2hhbm5lbE1vZGVzLmZvckVhY2goZnVuY3Rpb24gKG1vZGUpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5oYXNGbGFnKG1vZGUpKSB7XG4gICAgICAgICAgICAgICAgbW9kZXMucHVzaChtb2RlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBtb2Rlcy5sZW5ndGggPiAwID8gbW9kZXMgOiB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBQcm90b2NvbE1lc3NhZ2UuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFByb3RvY29sTWVzc2FnZSgpLCB2YWx1ZXMpO1xuICAgIH07XG4gICAgUHJvdG9jb2xNZXNzYWdlLkFjdGlvbiA9IGFjdGlvbnM7XG4gICAgUHJvdG9jb2xNZXNzYWdlLmNoYW5uZWxNb2RlcyA9IFsnUFJFU0VOQ0UnLCAnUFVCTElTSCcsICdTVUJTQ1JJQkUnLCAnUFJFU0VOQ0VfU1VCU0NSSUJFJ107XG4gICAgUHJvdG9jb2xNZXNzYWdlLkFjdGlvbk5hbWUgPSBBY3Rpb25OYW1lO1xuICAgIFByb3RvY29sTWVzc2FnZS5zZXJpYWxpemUgPSBVdGlscy5lbmNvZGVCb2R5O1xuICAgIFByb3RvY29sTWVzc2FnZS5kZXNlcmlhbGl6ZSA9IGZ1bmN0aW9uIChzZXJpYWxpemVkLCBmb3JtYXQpIHtcbiAgICAgICAgdmFyIGRlc2VyaWFsaXplZCA9IFV0aWxzLmRlY29kZUJvZHkoc2VyaWFsaXplZCwgZm9ybWF0KTtcbiAgICAgICAgcmV0dXJuIFByb3RvY29sTWVzc2FnZS5mcm9tRGVzZXJpYWxpemVkKGRlc2VyaWFsaXplZCk7XG4gICAgfTtcbiAgICBQcm90b2NvbE1lc3NhZ2UuZnJvbURlc2VyaWFsaXplZCA9IGZ1bmN0aW9uIChkZXNlcmlhbGl6ZWQpIHtcbiAgICAgICAgdmFyIGVycm9yID0gZGVzZXJpYWxpemVkLmVycm9yO1xuICAgICAgICBpZiAoZXJyb3IpXG4gICAgICAgICAgICBkZXNlcmlhbGl6ZWQuZXJyb3IgPSBlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMoZXJyb3IpO1xuICAgICAgICB2YXIgbWVzc2FnZXMgPSBkZXNlcmlhbGl6ZWQubWVzc2FnZXM7XG4gICAgICAgIGlmIChtZXNzYWdlcylcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgbWVzc2FnZXNbaV0gPSBtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKG1lc3NhZ2VzW2ldKTtcbiAgICAgICAgdmFyIHByZXNlbmNlID0gZGVzZXJpYWxpemVkLnByZXNlbmNlO1xuICAgICAgICBpZiAocHJlc2VuY2UpXG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXNlbmNlLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgIHByZXNlbmNlW2ldID0gcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHByZXNlbmNlW2ldLCB0cnVlKTtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFByb3RvY29sTWVzc2FnZSgpLCBkZXNlcmlhbGl6ZWQpO1xuICAgIH07XG4gICAgUHJvdG9jb2xNZXNzYWdlLnN0cmluZ2lmeSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICdbUHJvdG9jb2xNZXNzYWdlJztcbiAgICAgICAgaWYgKG1zZy5hY3Rpb24gIT09IHVuZGVmaW5lZClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBhY3Rpb249JyArIFByb3RvY29sTWVzc2FnZS5BY3Rpb25OYW1lW21zZy5hY3Rpb25dIHx8IGZhbHNlO1xuICAgICAgICB2YXIgYXR0cmlidXRlO1xuICAgICAgICBmb3IgKHZhciBhdHRyaWJJbmRleCA9IDA7IGF0dHJpYkluZGV4IDwgc2ltcGxlQXR0cmlidXRlcy5sZW5ndGg7IGF0dHJpYkluZGV4KyspIHtcbiAgICAgICAgICAgIGF0dHJpYnV0ZSA9IHNpbXBsZUF0dHJpYnV0ZXNbYXR0cmliSW5kZXhdO1xuICAgICAgICAgICAgaWYgKG1zZ1thdHRyaWJ1dGVdICE9PSB1bmRlZmluZWQpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICc7ICcgKyBhdHRyaWJ1dGUgKyAnPScgKyBtc2dbYXR0cmlidXRlXTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobXNnLm1lc3NhZ2VzKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IG1lc3NhZ2VzPScgKyB0b1N0cmluZ0FycmF5KG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXNBcnJheShtc2cubWVzc2FnZXMpKTtcbiAgICAgICAgaWYgKG1zZy5wcmVzZW5jZSlcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBwcmVzZW5jZT0nICsgdG9TdHJpbmdBcnJheShwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXNBcnJheShtc2cucHJlc2VuY2UpKTtcbiAgICAgICAgaWYgKG1zZy5lcnJvcilcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBlcnJvcj0nICsgZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKG1zZy5lcnJvcikudG9TdHJpbmcoKTtcbiAgICAgICAgaWYgKG1zZy5hdXRoICYmIG1zZy5hdXRoLmFjY2Vzc1Rva2VuKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IHRva2VuPScgKyBtc2cuYXV0aC5hY2Nlc3NUb2tlbjtcbiAgICAgICAgaWYgKG1zZy5mbGFncylcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBmbGFncz0nICsgZmxhZ05hbWVzLmZpbHRlcihtc2cuaGFzRmxhZykuam9pbignLCcpO1xuICAgICAgICBpZiAobXNnLnBhcmFtcykge1xuICAgICAgICAgICAgdmFyIHN0cmluZ2lmaWVkUGFyYW1zXzEgPSAnJztcbiAgICAgICAgICAgIFV0aWxzLmZvckluT3duTm9uTnVsbFByb3BlcnRpZXMobXNnLnBhcmFtcywgZnVuY3Rpb24gKHByb3ApIHtcbiAgICAgICAgICAgICAgICBpZiAoc3RyaW5naWZpZWRQYXJhbXNfMS5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgICAgIHN0cmluZ2lmaWVkUGFyYW1zXzEgKz0gJzsgJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgc3RyaW5naWZpZWRQYXJhbXNfMSArPSBwcm9wICsgJz0nICsgbXNnLnBhcmFtc1twcm9wXTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHN0cmluZ2lmaWVkUGFyYW1zXzEubGVuZ3RoID4gMCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnOyBwYXJhbXM9WycgKyBzdHJpbmdpZmllZFBhcmFtc18xICsgJ10nO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnXSc7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvdG9jb2xNZXNzYWdlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFByb3RvY29sTWVzc2FnZTtcblxuXG4vKioqLyB9KSxcbi8qIDExICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQmFzZTY0IGVuY29kaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgQmFzZTY0ID0gQ19lbmMuQmFzZTY0ID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgQmFzZTY0IHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGJhc2U2NFN0cmluZyA9IENyeXB0b0pTLmVuYy5CYXNlNjQuc3RyaW5naWZ5KHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAod29yZEFycmF5KSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSB3b3JkQXJyYXkud29yZHM7XG5cdCAgICAgICAgICAgIHZhciBzaWdCeXRlcyA9IHdvcmRBcnJheS5zaWdCeXRlcztcblx0ICAgICAgICAgICAgdmFyIG1hcCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cblx0ICAgICAgICAgICAgLy8gQ2xhbXAgZXhjZXNzIGJpdHNcblx0ICAgICAgICAgICAgd29yZEFycmF5LmNsYW1wKCk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgYmFzZTY0Q2hhcnMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzaWdCeXRlczsgaSArPSAzKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgYnl0ZTEgPSAod29yZHNbaSA+Pj4gMl0gICAgICAgPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgICAgICAgJiAweGZmO1xuXHQgICAgICAgICAgICAgICAgdmFyIGJ5dGUyID0gKHdvcmRzWyhpICsgMSkgPj4+IDJdID4+PiAoMjQgLSAoKGkgKyAxKSAlIDQpICogOCkpICYgMHhmZjtcblx0ICAgICAgICAgICAgICAgIHZhciBieXRlMyA9ICh3b3Jkc1soaSArIDIpID4+PiAyXSA+Pj4gKDI0IC0gKChpICsgMikgJSA0KSAqIDgpKSAmIDB4ZmY7XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0cmlwbGV0ID0gKGJ5dGUxIDw8IDE2KSB8IChieXRlMiA8PCA4KSB8IGJ5dGUzO1xuXG5cdCAgICAgICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgKGogPCA0KSAmJiAoaSArIGogKiAwLjc1IDwgc2lnQnl0ZXMpOyBqKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRDaGFycy5wdXNoKG1hcC5jaGFyQXQoKHRyaXBsZXQgPj4+ICg2ICogKDMgLSBqKSkpICYgMHgzZikpO1xuXHQgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdDaGFyID0gbWFwLmNoYXJBdCg2NCk7XG5cdCAgICAgICAgICAgIGlmIChwYWRkaW5nQ2hhcikge1xuXHQgICAgICAgICAgICAgICAgd2hpbGUgKGJhc2U2NENoYXJzLmxlbmd0aCAlIDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRDaGFycy5wdXNoKHBhZGRpbmdDaGFyKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBiYXNlNjRDaGFycy5qb2luKCcnKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBCYXNlNjQgc3RyaW5nIHRvIGEgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7c3RyaW5nfSBiYXNlNjRTdHIgVGhlIEJhc2U2NCBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgd29yZEFycmF5ID0gQ3J5cHRvSlMuZW5jLkJhc2U2NC5wYXJzZShiYXNlNjRTdHJpbmcpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHBhcnNlOiBmdW5jdGlvbiAoYmFzZTY0U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgYmFzZTY0U3RyTGVuZ3RoID0gYmFzZTY0U3RyLmxlbmd0aDtcblx0ICAgICAgICAgICAgdmFyIG1hcCA9ICdBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvPSc7XG5cdCAgICAgICAgICAgIHZhciByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcDtcblxuXHQgICAgICAgICAgICBpZiAoIXJldmVyc2VNYXApIHtcblx0ICAgICAgICAgICAgICAgICAgICByZXZlcnNlTWFwID0gdGhpcy5fcmV2ZXJzZU1hcCA9IFtdO1xuXHQgICAgICAgICAgICAgICAgICAgIGZvciAodmFyIGogPSAwOyBqIDwgbWFwLmxlbmd0aDsgaisrKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldmVyc2VNYXBbbWFwLmNoYXJDb2RlQXQoaildID0gajtcblx0ICAgICAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBJZ25vcmUgcGFkZGluZ1xuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ0NoYXIgPSBtYXAuY2hhckF0KDY0KTtcblx0ICAgICAgICAgICAgaWYgKHBhZGRpbmdDaGFyKSB7XG5cdCAgICAgICAgICAgICAgICB2YXIgcGFkZGluZ0luZGV4ID0gYmFzZTY0U3RyLmluZGV4T2YocGFkZGluZ0NoYXIpO1xuXHQgICAgICAgICAgICAgICAgaWYgKHBhZGRpbmdJbmRleCAhPT0gLTEpIHtcblx0ICAgICAgICAgICAgICAgICAgICBiYXNlNjRTdHJMZW5ndGggPSBwYWRkaW5nSW5kZXg7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHJldHVybiBwYXJzZUxvb3AoYmFzZTY0U3RyLCBiYXNlNjRTdHJMZW5ndGgsIHJldmVyc2VNYXApO1xuXG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgZnVuY3Rpb24gcGFyc2VMb29wKGJhc2U2NFN0ciwgYmFzZTY0U3RyTGVuZ3RoLCByZXZlcnNlTWFwKSB7XG5cdCAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICB2YXIgbkJ5dGVzID0gMDtcblx0ICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBiYXNlNjRTdHJMZW5ndGg7IGkrKykge1xuXHQgICAgICAgICAgaWYgKGkgJSA0KSB7XG5cdCAgICAgICAgICAgICAgdmFyIGJpdHMxID0gcmV2ZXJzZU1hcFtiYXNlNjRTdHIuY2hhckNvZGVBdChpIC0gMSldIDw8ICgoaSAlIDQpICogMik7XG5cdCAgICAgICAgICAgICAgdmFyIGJpdHMyID0gcmV2ZXJzZU1hcFtiYXNlNjRTdHIuY2hhckNvZGVBdChpKV0gPj4+ICg2IC0gKGkgJSA0KSAqIDIpO1xuXHQgICAgICAgICAgICAgIHZhciBiaXRzQ29tYmluZWQgPSBiaXRzMSB8IGJpdHMyO1xuXHQgICAgICAgICAgICAgIHdvcmRzW25CeXRlcyA+Pj4gMl0gfD0gYml0c0NvbWJpbmVkIDw8ICgyNCAtIChuQnl0ZXMgJSA0KSAqIDgpO1xuXHQgICAgICAgICAgICAgIG5CeXRlcysrO1xuXHQgICAgICAgICAgfVxuXHQgICAgICB9XG5cdCAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCBuQnl0ZXMpO1xuXHQgICAgfVxuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmVuYy5CYXNlNjQ7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAxMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgcHJvdG9jb2xtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDEwKSk7XG52YXIgdHJhbnNwb3J0XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDI2KSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBkZWZhdWx0c18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg4KSk7XG52YXIgY29ubmVjdGlvbmVycm9yc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyMCkpO1xudmFyIGF1dGhfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTcpKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIFhIUlN0YXRlc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyMSkpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbi8qIFRPRE86IGNhbiByZW1vdmUgb25jZSByZWFsdGltZSBzZW5kcyBwcm90b2NvbCBtZXNzYWdlIHJlc3BvbnNlcyBmb3IgY29tZXQgZXJyb3JzICovXG5mdW5jdGlvbiBzaG91bGRCZUVycm9yQWN0aW9uKGVycikge1xuICAgIHZhciBVTlJFU09MVkFCTEVfRVJST1JfQ09ERVMgPSBbODAwMTUsIDgwMDE3LCA4MDAzMF07XG4gICAgaWYgKGVyci5jb2RlKSB7XG4gICAgICAgIGlmIChhdXRoXzEuZGVmYXVsdC5pc1Rva2VuRXJyKGVycikpXG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIGlmIChVdGlscy5hcnJJbihVTlJFU09MVkFCTEVfRVJST1JfQ09ERVMsIGVyci5jb2RlKSlcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICByZXR1cm4gZXJyLmNvZGUgPj0gNDAwMDAgJiYgZXJyLmNvZGUgPCA1MDAwMDtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIC8qIExpa2VseSBhIG5ldHdvcmsgb3IgdHJhbnNwb3J0IGVycm9yIG9mIHNvbWUga2luZC4gQ2VydGFpbmx5IG5vdCBmYXRhbCB0byB0aGUgY29ubmVjdGlvbiAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxufVxuZnVuY3Rpb24gcHJvdG9jb2xNZXNzYWdlRnJvbVJhd0Vycm9yKGVycikge1xuICAgIC8qIGVyciB3aWxsIGJlIGVpdGhlciBhIGxlZ2FjeSAobm9uLXByb3RvY29sbWVzc2FnZSkgY29tZXQgZXJyb3IgcmVzcG9uc2VcbiAgICAgKiAod2hpY2ggd2lsbCBoYXZlIGFuIGVyci5jb2RlKSwgb3IgYSB4aHIvbmV0d29yayBlcnJvciAod2hpY2ggd29uJ3QpLiAqL1xuICAgIGlmIChzaG91bGRCZUVycm9yQWN0aW9uKGVycikpIHtcbiAgICAgICAgcmV0dXJuIFtwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoeyBhY3Rpb246IHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuQWN0aW9uLkVSUk9SLCBlcnJvcjogZXJyIH0pXTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBbcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHsgYWN0aW9uOiBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LkFjdGlvbi5ESVNDT05ORUNURUQsIGVycm9yOiBlcnIgfSldO1xuICAgIH1cbn1cbi8qXG4gKiBBIGJhc2UgY29tZXQgdHJhbnNwb3J0IGNsYXNzXG4gKi9cbnZhciBDb21ldFRyYW5zcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDb21ldFRyYW5zcG9ydCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb21ldFRyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMsIC8qIGJpbmFyeSBub3Qgc3VwcG9ydGVkIGZvciBjb21ldCBzbyBmb3JjZSBKU09OIHByb3RvY29sICovIHRydWUpIHx8IHRoaXM7XG4gICAgICAgIC8qIEZvciBjb21ldCwgd2UgY291bGQgZG8gdGhlIGF1dGggdXBkYXRlIGJ5IGFib3J0aW5nIHRoZSBjdXJyZW50IHJlY3YgYW5kXG4gICAgICAgICAqIHN0YXJ0aW5nIGEgbmV3IG9uZSB3aXRoIHRoZSBuZXcgdG9rZW4sIHRoYXQnZCBiZSBzdWZmaWNpZW50IGZvciByZWFsdGltZS5cbiAgICAgICAgICogUHJvYmxlbSBpcyBKU09OUCAtIHlvdSBjYW4ndCBjYW5jZWwgdHJ1bHkgYWJvcnQgYSByZWN2IG9uY2Ugc3RhcnRlZC4gU29cbiAgICAgICAgICogd2UgbmVlZCB0byBzZW5kIGFuIEFVVEggZm9yIGpzb25wLiBJbiB3aGljaCBjYXNlIGl0J3Mgc2ltcGxlciB0byBrZWVwIGFsbFxuICAgICAgICAgKiBjb21ldCB0cmFuc3BvcnRzIHRoZSBzYW1lIGFuZCBkbyBpdCBmb3IgYWxsIG9mIHRoZW0uIFNvIHdlIHNlbmQgdGhlIEFVVEhcbiAgICAgICAgICogaW5zdGVhZCwgYW5kIGRvbid0IG5lZWQgdG8gYWJvcnQgdGhlIHJlY3YgKi9cbiAgICAgICAgX3RoaXMub25BdXRoVXBkYXRlZCA9IGZ1bmN0aW9uICh0b2tlbkRldGFpbHMpIHtcbiAgICAgICAgICAgIF90aGlzLmF1dGhQYXJhbXMgPSB7IGFjY2Vzc190b2tlbjogdG9rZW5EZXRhaWxzLnRva2VuIH07XG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnN0cmVhbSA9ICdzdHJlYW0nIGluIHBhcmFtcyA/IHBhcmFtcy5zdHJlYW0gOiB0cnVlO1xuICAgICAgICBfdGhpcy5zZW5kUmVxdWVzdCA9IG51bGw7XG4gICAgICAgIF90aGlzLnJlY3ZSZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgX3RoaXMucGVuZGluZ0NhbGxiYWNrID0gbnVsbDtcbiAgICAgICAgX3RoaXMucGVuZGluZ0l0ZW1zID0gbnVsbDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5jb25uZWN0KCknLCAnc3RhcnRpbmcnKTtcbiAgICAgICAgdHJhbnNwb3J0XzEuZGVmYXVsdC5wcm90b3R5cGUuY29ubmVjdC5jYWxsKHRoaXMpO1xuICAgICAgICB2YXIgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgICAgIHZhciBvcHRpb25zID0gcGFyYW1zLm9wdGlvbnM7XG4gICAgICAgIHZhciBob3N0ID0gZGVmYXVsdHNfMS5kZWZhdWx0LmdldEhvc3Qob3B0aW9ucywgcGFyYW1zLmhvc3QpO1xuICAgICAgICB2YXIgcG9ydCA9IGRlZmF1bHRzXzEuZGVmYXVsdC5nZXRQb3J0KG9wdGlvbnMpO1xuICAgICAgICB2YXIgY29tZXRTY2hlbWUgPSBvcHRpb25zLnRscyA/ICdodHRwczovLycgOiAnaHR0cDovLyc7XG4gICAgICAgIHRoaXMuYmFzZVVyaSA9IGNvbWV0U2NoZW1lICsgaG9zdCArICc6JyArIHBvcnQgKyAnL2NvbWV0Lyc7XG4gICAgICAgIHZhciBjb25uZWN0VXJpID0gdGhpcy5iYXNlVXJpICsgJ2Nvbm5lY3QnO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LmNvbm5lY3QoKScsICd1cmk6ICcgKyBjb25uZWN0VXJpKTtcbiAgICAgICAgdGhpcy5hdXRoLmdldEF1dGhQYXJhbXMoZnVuY3Rpb24gKGVyciwgYXV0aFBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIF90aGlzLmRpc2Nvbm5lY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmF1dGhQYXJhbXMgPSBhdXRoUGFyYW1zO1xuICAgICAgICAgICAgdmFyIGNvbm5lY3RQYXJhbXMgPSBfdGhpcy5wYXJhbXMuZ2V0Q29ubmVjdFBhcmFtcyhhdXRoUGFyYW1zKTtcbiAgICAgICAgICAgIGlmICgnc3RyZWFtJyBpbiBjb25uZWN0UGFyYW1zKVxuICAgICAgICAgICAgICAgIF90aGlzLnN0cmVhbSA9IGNvbm5lY3RQYXJhbXMuc3RyZWFtO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5jb25uZWN0KCknLCAnY29ubmVjdFBhcmFtczonICsgVXRpbHMudG9RdWVyeVN0cmluZyhjb25uZWN0UGFyYW1zKSk7XG4gICAgICAgICAgICAvKiB0aGlzIHdpbGwgYmUgdGhlICdyZWN2UmVxdWVzdCcgc28gdGhpcyBjb25uZWN0aW9uIGNhbiBzdHJlYW0gbWVzc2FnZXMgKi9cbiAgICAgICAgICAgIHZhciBwcmVjb25uZWN0ZWQgPSBmYWxzZTtcbiAgICAgICAgICAgIHZhciBjb25uZWN0UmVxdWVzdCA9IChfdGhpcy5yZWN2UmVxdWVzdCA9IF90aGlzLmNyZWF0ZVJlcXVlc3QoY29ubmVjdFVyaSwgbnVsbCwgY29ubmVjdFBhcmFtcywgbnVsbCwgX3RoaXMuc3RyZWFtID8gWEhSU3RhdGVzXzEuZGVmYXVsdC5SRVFfUkVDVl9TVFJFQU0gOiBYSFJTdGF0ZXNfMS5kZWZhdWx0LlJFUV9SRUNWKSk7XG4gICAgICAgICAgICBjb25uZWN0UmVxdWVzdC5vbignZGF0YScsIGZ1bmN0aW9uIChkYXRhKSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfdGhpcy5yZWN2UmVxdWVzdCkge1xuICAgICAgICAgICAgICAgICAgICAvKiB0aGUgdHJhbnNwb3J0IHdhcyBkaXNwb3NlZCBiZWZvcmUgd2UgY29ubmVjdGVkICovXG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFwcmVjb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgncHJlY29ubmVjdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5vbkRhdGEoZGF0YSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbm5lY3RSZXF1ZXN0Lm9uKCdjb21wbGV0ZScsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnJlY3ZSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIHRoZSB0cmFuc3BvcnQgd2FzIGRpc3Bvc2VkIGJlZm9yZSB3ZSBjb25uZWN0ZWQgKi9cbiAgICAgICAgICAgICAgICAgICAgZXJyID0gZXJyIHx8IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdSZXF1ZXN0IGNhbmNlbGxlZCcsIDgwMDAzLCA0MDApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5yZWN2UmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICAgICAgLyogQ29ubmVjdCByZXF1ZXN0IG1heSBjb21wbGV0ZSB3aXRob3V0IGEgZW1pdHRpbmcgJ2RhdGEnIGV2ZW50IHNpbmNlIHRoYXQgaXMgbm90XG4gICAgICAgICAgICAgICAgICogZW1pdHRlZCBmb3IgZS5nLiBhIG5vbi1zdHJlYW1lZCBlcnJvciByZXNwb25zZS4gU3RpbGwgaW1wbGllcyBwcmVjb25uZWN0LiAqL1xuICAgICAgICAgICAgICAgIGlmICghcHJlY29ubmVjdGVkICYmICFlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgcHJlY29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZW1pdCgncHJlY29ubmVjdCcpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIEEgcHJvdG9jb2wgZXJyb3IgcmVjZWl2ZWQgZnJvbSByZWFsdGltZS4gVE9ETzogb25jZSByZWFsdGltZVxuICAgICAgICAgICAgICAgICAgICAgICAgICogY29uc2lzdGVuZGx5IHNlbmRzIGVycm9ycyB3cmFwcGVkIGluIHByb3RvY29sIG1lc3NhZ2VzLCBzaG91bGQgYmVcbiAgICAgICAgICAgICAgICAgICAgICAgICAqIGFibGUgdG8gcmVtb3ZlIHRoaXMgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLm9uRGF0YShwcm90b2NvbE1lc3NhZ2VGcm9tUmF3RXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBBIG5ldHdvcmsveGhyIGVycm9yLiBEb24ndCBib3RoZXIgd3JhcHBpbmcgaW4gYSBwcm90b2NvbCBtZXNzYWdlLFxuICAgICAgICAgICAgICAgICAgICAgICAgICoganVzdCBkaXNjb25uZWN0IHRoZSB0cmFuc3BvcnQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc2Nvbm5lY3QoZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZWN2KCk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGNvbm5lY3RSZXF1ZXN0LmV4ZWMoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUucmVxdWVzdENsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LnJlcXVlc3RDbG9zZSgpJyk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RDbG9zZU9yRGlzY29ubmVjdCh0cnVlKTtcbiAgICB9O1xuICAgIENvbWV0VHJhbnNwb3J0LnByb3RvdHlwZS5yZXF1ZXN0RGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5yZXF1ZXN0RGlzY29ubmVjdCgpJyk7XG4gICAgICAgIHRoaXMuX3JlcXVlc3RDbG9zZU9yRGlzY29ubmVjdChmYWxzZSk7XG4gICAgfTtcbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuX3JlcXVlc3RDbG9zZU9yRGlzY29ubmVjdCA9IGZ1bmN0aW9uIChjbG9zaW5nKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBjbG9zZU9yRGlzY29ubmVjdFVyaSA9IGNsb3NpbmcgPyB0aGlzLmNsb3NlVXJpIDogdGhpcy5kaXNjb25uZWN0VXJpO1xuICAgICAgICBpZiAoY2xvc2VPckRpc2Nvbm5lY3RVcmkpIHtcbiAgICAgICAgICAgIHZhciByZXF1ZXN0ID0gdGhpcy5jcmVhdGVSZXF1ZXN0KGNsb3NlT3JEaXNjb25uZWN0VXJpLCBudWxsLCB0aGlzLmF1dGhQYXJhbXMsIG51bGwsIFhIUlN0YXRlc18xLmRlZmF1bHQuUkVRX1NFTkQpO1xuICAgICAgICAgICAgcmVxdWVzdC5vbignY29tcGxldGUnLCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0NvbWV0VHJhbnNwb3J0LnJlcXVlc3QnICsgKGNsb3NpbmcgPyAnQ2xvc2UoKScgOiAnRGlzY29ubmVjdCgpJyksICdyZXF1ZXN0IHJldHVybmVkIGVyciA9ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHJlcXVlc3QuZXhlYygpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb21ldFRyYW5zcG9ydC5kaXNwb3NlKCknLCAnJyk7XG4gICAgICAgIGlmICghdGhpcy5pc0Rpc3Bvc2VkKSB7XG4gICAgICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHRoaXMucmVjdlJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0NvbWV0VHJhbnNwb3J0LmRpc3Bvc2UoKScsICdhYm9ydGluZyByZWN2IHJlcXVlc3QnKTtcbiAgICAgICAgICAgICAgICB0aGlzLnJlY3ZSZXF1ZXN0LmFib3J0KCk7XG4gICAgICAgICAgICAgICAgdGhpcy5yZWN2UmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBJbiBhbG1vc3QgYWxsIGNhc2VzIHRoZSB0cmFuc3BvcnQgd2lsbCBiZSBmaW5pc2hlZCBiZWZvcmUgaXQnc1xuICAgICAgICAgICAgICogZGlzcG9zZWQuIEZpbmlzaCBoZXJlIGp1c3QgdG8gbWFrZSBzdXJlLiAqL1xuICAgICAgICAgICAgdGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGNvbm5lY3Rpb25lcnJvcnNfMS5kZWZhdWx0LmRpc2Nvbm5lY3RlZCgpKTtcbiAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ2Rpc3Bvc2VkJyk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29tZXRUcmFuc3BvcnQucHJvdG90eXBlLm9uQ29ubmVjdCA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgLyogaWYgdGhpcyB0cmFuc3BvcnQgaGFzIGJlZW4gZGlzcG9zZWQgd2hpbHN0IGF3YWl0aW5nIGNvbm5lY3Rpb24sIGRvIG5vdGhpbmcgKi9cbiAgICAgICAgaWYgKHRoaXMuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIHRoZSBjb25uZWN0aW9uS2V5IGluIGEgY29tZXQgY29ubmVjdGVkIHJlc3BvbnNlIGlzIHJlYWxseVxuICAgICAgICAgKiA8aW5zdElkPi08Y29ubmVjdGlvbktleT4gKi9cbiAgICAgICAgdmFyIGNvbm5lY3Rpb25TdHIgPSAoX2EgPSBtZXNzYWdlLmNvbm5lY3Rpb25EZXRhaWxzKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY29ubmVjdGlvbktleTtcbiAgICAgICAgdHJhbnNwb3J0XzEuZGVmYXVsdC5wcm90b3R5cGUub25Db25uZWN0LmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgICAgIHZhciBiYXNlQ29ubmVjdGlvblVyaSA9IHRoaXMuYmFzZVVyaSArIGNvbm5lY3Rpb25TdHI7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29tZXRUcmFuc3BvcnQub25Db25uZWN0KCknLCAnYmFzZVVyaSA9ICcgKyBiYXNlQ29ubmVjdGlvblVyaSk7XG4gICAgICAgIHRoaXMuc2VuZFVyaSA9IGJhc2VDb25uZWN0aW9uVXJpICsgJy9zZW5kJztcbiAgICAgICAgdGhpcy5yZWN2VXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyAnL3JlY3YnO1xuICAgICAgICB0aGlzLmNsb3NlVXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyAnL2Nsb3NlJztcbiAgICAgICAgdGhpcy5kaXNjb25uZWN0VXJpID0gYmFzZUNvbm5lY3Rpb25VcmkgKyAnL2Rpc2Nvbm5lY3QnO1xuICAgIH07XG4gICAgQ29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICBpZiAodGhpcy5zZW5kUmVxdWVzdCkge1xuICAgICAgICAgICAgLyogdGhlcmUgaXMgYSBwZW5kaW5nIHNlbmQsIHNvIHF1ZXVlIHRoaXMgbWVzc2FnZSAqL1xuICAgICAgICAgICAgdGhpcy5wZW5kaW5nSXRlbXMgPSB0aGlzLnBlbmRpbmdJdGVtcyB8fCBbXTtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ0l0ZW1zLnB1c2gobWVzc2FnZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyogc2VuZCB0aGlzLCBwbHVzIGFueSBwZW5kaW5nLCBub3cgKi9cbiAgICAgICAgdmFyIHBlbmRpbmdJdGVtcyA9IHRoaXMucGVuZGluZ0l0ZW1zIHx8IFtdO1xuICAgICAgICBwZW5kaW5nSXRlbXMucHVzaChtZXNzYWdlKTtcbiAgICAgICAgdGhpcy5wZW5kaW5nSXRlbXMgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbmRJdGVtcyhwZW5kaW5nSXRlbXMpO1xuICAgIH07XG4gICAgQ29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmRBbnlQZW5kaW5nID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgcGVuZGluZ0l0ZW1zID0gdGhpcy5wZW5kaW5nSXRlbXM7XG4gICAgICAgIGlmICghcGVuZGluZ0l0ZW1zKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZW5kaW5nSXRlbXMgPSBudWxsO1xuICAgICAgICB0aGlzLnNlbmRJdGVtcyhwZW5kaW5nSXRlbXMpO1xuICAgIH07XG4gICAgQ29tZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmRJdGVtcyA9IGZ1bmN0aW9uIChpdGVtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgc2VuZFJlcXVlc3QgPSAodGhpcy5zZW5kUmVxdWVzdCA9IHRoaXMuY3JlYXRlUmVxdWVzdCh0aGlzLnNlbmRVcmksIG51bGwsIHRoaXMuYXV0aFBhcmFtcywgdGhpcy5lbmNvZGVSZXF1ZXN0KGl0ZW1zKSwgWEhSU3RhdGVzXzEuZGVmYXVsdC5SRVFfU0VORCkpO1xuICAgICAgICBzZW5kUmVxdWVzdC5vbignY29tcGxldGUnLCBmdW5jdGlvbiAoZXJyLCBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQ29tZXRUcmFuc3BvcnQuc2VuZEl0ZW1zKCknLCAnb24gY29tcGxldGU6IGVyciA9ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgICAgICAgICBfdGhpcy5zZW5kUmVxdWVzdCA9IG51bGw7XG4gICAgICAgICAgICAvKiB0aGUgcmVzdWx0IG9mIHRoZSByZXF1ZXN0LCBldmVuIGlmIGEgbmFjaywgaXMgdXN1YWxseSBhIHByb3RvY29sIHJlc3BvbnNlXG4gICAgICAgICAgICAgKiBjb250YWluZWQgaW4gdGhlIGRhdGEuIEFuIGVyciBpcyBhbm9tb2xvdXMsIGFuZCBpbmRpY2F0ZXMgc29tZSBpc3N1ZSB3aXRoIHRoZVxuICAgICAgICAgICAgICogbmV0d29yayx0cmFuc3BvcnQsIG9yIGNvbm5lY3Rpb24gKi9cbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogQSBwcm90b2NvbCBlcnJvciByZWNlaXZlZCBmcm9tIHJlYWx0aW1lLiBUT0RPOiBvbmNlIHJlYWx0aW1lXG4gICAgICAgICAgICAgICAgICAgICAqIGNvbnNpc3RlbmRseSBzZW5kcyBlcnJvcnMgd3JhcHBlZCBpbiBwcm90b2NvbCBtZXNzYWdlcywgc2hvdWxkIGJlXG4gICAgICAgICAgICAgICAgICAgICAqIGFibGUgdG8gcmVtb3ZlIHRoaXMgKi9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25EYXRhKHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIEEgbmV0d29yay94aHIgZXJyb3IuIERvbid0IGJvdGhlciB3cmFwcGluZyBpbiBhIHByb3RvY29sIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAqIGp1c3QgZGlzY29ubmVjdCB0aGUgdHJhbnNwb3J0ICovXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc2Nvbm5lY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGRhdGEpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkRhdGEoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoX3RoaXMucGVuZGluZ0l0ZW1zKSB7XG4gICAgICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIElmIHRoZXJlJ3MgYSBuZXcgc2VuZCByZXF1ZXN0IGJ5IG5vdywgYW55IHBlbmRpbmcgaXRlbXMgd2lsbCBoYXZlXG4gICAgICAgICAgICAgICAgICAgICAqIGJlZW4gcGlja2VkIHVwIGJ5IHRoYXQ7IGFueSBuZXcgb25lcyBhZGRlZCBzaW5jZSB0aGVuIHdpbGwgYmVcbiAgICAgICAgICAgICAgICAgICAgICogcGlja2VkIHVwIGFmdGVyIHRoYXQgb25lIGNvbXBsZXRlcyAqL1xuICAgICAgICAgICAgICAgICAgICBpZiAoIV90aGlzLnNlbmRSZXF1ZXN0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5zZW5kQW55UGVuZGluZygpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzZW5kUmVxdWVzdC5leGVjKCk7XG4gICAgfTtcbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUucmVjdiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyogZG8gbm90aGluZyBpZiB0aGVyZSBpcyBhbiBhY3RpdmUgcmVxdWVzdCwgd2hpY2ggbWlnaHQgYmUgc3RyZWFtaW5nICovXG4gICAgICAgIGlmICh0aGlzLnJlY3ZSZXF1ZXN0KVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKiBJZiB3ZSdyZSBubyBsb25nZXIgY29ubmVjdGVkLCBkbyBub3RoaW5nICovXG4gICAgICAgIGlmICghdGhpcy5pc0Nvbm5lY3RlZClcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgdmFyIHJlY3ZSZXF1ZXN0ID0gKHRoaXMucmVjdlJlcXVlc3QgPSB0aGlzLmNyZWF0ZVJlcXVlc3QodGhpcy5yZWN2VXJpLCBudWxsLCB0aGlzLmF1dGhQYXJhbXMsIG51bGwsIHRoaXMuc3RyZWFtID8gWEhSU3RhdGVzXzEuZGVmYXVsdC5SRVFfUkVDVl9TVFJFQU0gOiBYSFJTdGF0ZXNfMS5kZWZhdWx0LlJFUV9SRUNWX1BPTEwpKTtcbiAgICAgICAgcmVjdlJlcXVlc3Qub24oJ2RhdGEnLCBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICAgICAgX3RoaXMub25EYXRhKGRhdGEpO1xuICAgICAgICB9KTtcbiAgICAgICAgcmVjdlJlcXVlc3Qub24oJ2NvbXBsZXRlJywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgX3RoaXMucmVjdlJlcXVlc3QgPSBudWxsO1xuICAgICAgICAgICAgLyogQSByZXF1ZXN0IGNvbXBsZXRpbmcgbXVzdCBiZSBjb25zaWRlcmVkIGFjdGl2aXR5LCBhcyByZWFsdGltZSBzZW5kc1xuICAgICAgICAgICAgICogaGVhcnRiZWF0cyBldmVyeSAxNXMgc2luY2UgYSByZXF1ZXN0IGJlZ2FuLCBub3QgZXZlcnkgMTVzIGFic29sdXRlbHkgKi9cbiAgICAgICAgICAgIF90aGlzLm9uQWN0aXZpdHkoKTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyLmNvZGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogQSBwcm90b2NvbCBlcnJvciByZWNlaXZlZCBmcm9tIHJlYWx0aW1lLiBUT0RPOiBvbmNlIHJlYWx0aW1lXG4gICAgICAgICAgICAgICAgICAgICAqIGNvbnNpc3RlbnRseSBzZW5kcyBlcnJvcnMgd3JhcHBlZCBpbiBwcm90b2NvbCBtZXNzYWdlcywgc2hvdWxkIGJlXG4gICAgICAgICAgICAgICAgICAgICAqIGFibGUgdG8gcmVtb3ZlIHRoaXMgKi9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub25EYXRhKHByb3RvY29sTWVzc2FnZUZyb21SYXdFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIEEgbmV0d29yay94aHIgZXJyb3IuIERvbid0IGJvdGhlciB3cmFwcGluZyBpbiBhIHByb3RvY29sIG1lc3NhZ2UsXG4gICAgICAgICAgICAgICAgICAgICAqIGp1c3QgZGlzY29ubmVjdCB0aGUgdHJhbnNwb3J0ICovXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc2Nvbm5lY3QoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVjdigpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH0pO1xuICAgICAgICByZWN2UmVxdWVzdC5leGVjKCk7XG4gICAgfTtcbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUub25EYXRhID0gZnVuY3Rpb24gKHJlc3BvbnNlRGF0YSkge1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdmFyIGl0ZW1zID0gdGhpcy5kZWNvZGVSZXNwb25zZShyZXNwb25zZURhdGEpO1xuICAgICAgICAgICAgaWYgKGl0ZW1zICYmIGl0ZW1zLmxlbmd0aClcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGl0ZW1zLmxlbmd0aDsgaSsrKVxuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uUHJvdG9jb2xNZXNzYWdlKHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuZnJvbURlc2VyaWFsaXplZChpdGVtc1tpXSkpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0NvbWV0VHJhbnNwb3J0Lm9uRGF0YSgpJywgJ1VuZXhwZWN0ZWQgZXhjZXB0aW9uIGhhbmRpbmcgY2hhbm5lbCBldmVudDogJyArIGUuc3RhY2spO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuZW5jb2RlUmVxdWVzdCA9IGZ1bmN0aW9uIChyZXF1ZXN0SXRlbXMpIHtcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KHJlcXVlc3RJdGVtcyk7XG4gICAgfTtcbiAgICBDb21ldFRyYW5zcG9ydC5wcm90b3R5cGUuZGVjb2RlUmVzcG9uc2UgPSBmdW5jdGlvbiAocmVzcG9uc2VEYXRhKSB7XG4gICAgICAgIGlmICh0eXBlb2YgcmVzcG9uc2VEYXRhID09ICdzdHJpbmcnKVxuICAgICAgICAgICAgcmV0dXJuIEpTT04ucGFyc2UocmVzcG9uc2VEYXRhKTtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlRGF0YTtcbiAgICB9O1xuICAgIHJldHVybiBDb21ldFRyYW5zcG9ydDtcbn0odHJhbnNwb3J0XzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ29tZXRUcmFuc3BvcnQ7XG5cblxuLyoqKi8gfSksXG4vKiAxMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG52YXIgZztcblxuLy8gVGhpcyB3b3JrcyBpbiBub24tc3RyaWN0IG1vZGVcbmcgPSAoZnVuY3Rpb24oKSB7XG5cdHJldHVybiB0aGlzO1xufSkoKTtcblxudHJ5IHtcblx0Ly8gVGhpcyB3b3JrcyBpZiBldmFsIGlzIGFsbG93ZWQgKHNlZSBDU1ApXG5cdGcgPSBnIHx8IG5ldyBGdW5jdGlvbihcInJldHVybiB0aGlzXCIpKCk7XG59IGNhdGNoIChlKSB7XG5cdC8vIFRoaXMgd29ya3MgaWYgdGhlIHdpbmRvdyByZWZlcmVuY2UgaXMgYXZhaWxhYmxlXG5cdGlmICh0eXBlb2Ygd2luZG93ID09PSBcIm9iamVjdFwiKSBnID0gd2luZG93O1xufVxuXG4vLyBnIGNhbiBzdGlsbCBiZSB1bmRlZmluZWQsIGJ1dCBub3RoaW5nIHRvIGRvIGFib3V0IGl0Li4uXG4vLyBXZSByZXR1cm4gdW5kZWZpbmVkLCBpbnN0ZWFkIG9mIG5vdGhpbmcgaGVyZSwgc28gaXQnc1xuLy8gZWFzaWVyIHRvIGhhbmRsZSB0aGlzIGNhc2UuIGlmKCFnbG9iYWwpIHsgLi4ufVxuXG5tb2R1bGUuZXhwb3J0cyA9IGc7XG5cblxuLyoqKi8gfSksXG4vKiAxNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgYXV0aF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNykpO1xudmFyIEh0dHBNZXRob2RzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE4KSk7XG52YXIgZXJyb3JpbmZvXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xuZnVuY3Rpb24gd2l0aEF1dGhEZXRhaWxzKHJlc3QsIGhlYWRlcnMsIHBhcmFtcywgZXJyQ2FsbGJhY2ssIG9wQ2FsbGJhY2spIHtcbiAgICBpZiAocmVzdC5odHRwLnN1cHBvcnRzQXV0aEhlYWRlcnMpIHtcbiAgICAgICAgcmVzdC5hdXRoLmdldEF1dGhIZWFkZXJzKGZ1bmN0aW9uIChlcnIsIGF1dGhIZWFkZXJzKSB7XG4gICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgIGVyckNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgb3BDYWxsYmFjayhVdGlscy5taXhpbihhdXRoSGVhZGVycywgaGVhZGVycyksIHBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmVzdC5hdXRoLmdldEF1dGhQYXJhbXMoZnVuY3Rpb24gKGVyciwgYXV0aFBhcmFtcykge1xuICAgICAgICAgICAgaWYgKGVycilcbiAgICAgICAgICAgICAgICBlcnJDYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgIG9wQ2FsbGJhY2soaGVhZGVycywgVXRpbHMubWl4aW4oYXV0aFBhcmFtcywgcGFyYW1zKSk7XG4gICAgICAgIH0pO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHVuZW52ZWxvcGUoY2FsbGJhY2ssIGZvcm1hdCkge1xuICAgIHJldHVybiBmdW5jdGlvbiAoZXJyLCBib2R5LCBvdXRlckhlYWRlcnMsIHVucGFja2VkLCBvdXRlclN0YXR1c0NvZGUpIHtcbiAgICAgICAgaWYgKGVyciAmJiAhYm9keSkge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoIXVucGFja2VkKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGJvZHkgPSBVdGlscy5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGlmIChVdGlscy5pc0Vycm9ySW5mb09yUGFydGlhbEVycm9ySW5mbyhlKSkge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKFV0aWxzLmluc3BlY3RFcnJvcihlKSwgbnVsbCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFib2R5KSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygndW5lbnZlbG9wZSgpOiBSZXNwb25zZSBib2R5IGlzIG1pc3NpbmcnLCBudWxsKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9hID0gYm9keSwgd3JhcHBlZFN0YXR1c0NvZGUgPSBfYS5zdGF0dXNDb2RlLCByZXNwb25zZSA9IF9hLnJlc3BvbnNlLCB3cmFwcGVkSGVhZGVycyA9IF9hLmhlYWRlcnM7XG4gICAgICAgIGlmICh3cmFwcGVkU3RhdHVzQ29kZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAvKiBFbnZlbG9wZSBhbHJlYWR5IHVud3JhcHBlZCBieSB0aGUgdHJhbnNwb3J0ICovXG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsIGJvZHksIG91dGVySGVhZGVycywgdHJ1ZSwgb3V0ZXJTdGF0dXNDb2RlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAod3JhcHBlZFN0YXR1c0NvZGUgPCAyMDAgfHwgd3JhcHBlZFN0YXR1c0NvZGUgPj0gMzAwKSB7XG4gICAgICAgICAgICAvKiBoYW5kbGUgd3JhcHBlZCBlcnJvcnMgKi9cbiAgICAgICAgICAgIHZhciB3cmFwcGVkRXJyID0gKHJlc3BvbnNlICYmIHJlc3BvbnNlLmVycm9yKSB8fCBlcnI7XG4gICAgICAgICAgICBpZiAoIXdyYXBwZWRFcnIpIHtcbiAgICAgICAgICAgICAgICB3cmFwcGVkRXJyID0gbmV3IEVycm9yKCdFcnJvciBpbiB1bmVudmVsb3BpbmcgJyArIGJvZHkpO1xuICAgICAgICAgICAgICAgIHdyYXBwZWRFcnIuc3RhdHVzQ29kZSA9IHdyYXBwZWRTdGF0dXNDb2RlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sod3JhcHBlZEVyciwgcmVzcG9uc2UsIHdyYXBwZWRIZWFkZXJzLCB0cnVlLCB3cmFwcGVkU3RhdHVzQ29kZSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZSwgd3JhcHBlZEhlYWRlcnMsIHRydWUsIHdyYXBwZWRTdGF0dXNDb2RlKTtcbiAgICB9O1xufVxuZnVuY3Rpb24gcGFyYW1TdHJpbmcocGFyYW1zKSB7XG4gICAgdmFyIHBhcmFtUGFpcnMgPSBbXTtcbiAgICBpZiAocGFyYW1zKSB7XG4gICAgICAgIGZvciAodmFyIG5lZWRsZSBpbiBwYXJhbXMpIHtcbiAgICAgICAgICAgIHBhcmFtUGFpcnMucHVzaChuZWVkbGUgKyAnPScgKyBwYXJhbXNbbmVlZGxlXSk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtUGFpcnMuam9pbignJicpO1xufVxuZnVuY3Rpb24gdXJsRnJvbVBhdGhBbmRQYXJhbXMocGF0aCwgcGFyYW1zKSB7XG4gICAgcmV0dXJuIHBhdGggKyAocGFyYW1zID8gJz8nIDogJycpICsgcGFyYW1TdHJpbmcocGFyYW1zKTtcbn1cbmZ1bmN0aW9uIGxvZ1Jlc3BvbnNlSGFuZGxlcihjYWxsYmFjaywgbWV0aG9kLCBwYXRoLCBwYXJhbXMpIHtcbiAgICByZXR1cm4gZnVuY3Rpb24gKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZXNvdXJjZS4nICsgbWV0aG9kICsgJygpJywgJ1JlY2VpdmVkIEVycm9yOyAnICsgdXJsRnJvbVBhdGhBbmRQYXJhbXMocGF0aCwgcGFyYW1zKSArICc7IEVycm9yOiAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGVycikpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZXNvdXJjZS4nICsgbWV0aG9kICsgJygpJywgJ1JlY2VpdmVkOyAnICtcbiAgICAgICAgICAgICAgICB1cmxGcm9tUGF0aEFuZFBhcmFtcyhwYXRoLCBwYXJhbXMpICtcbiAgICAgICAgICAgICAgICAnOyBIZWFkZXJzOiAnICtcbiAgICAgICAgICAgICAgICBwYXJhbVN0cmluZyhoZWFkZXJzKSArXG4gICAgICAgICAgICAgICAgJzsgU3RhdHVzQ29kZTogJyArXG4gICAgICAgICAgICAgICAgc3RhdHVzQ29kZSArXG4gICAgICAgICAgICAgICAgJzsgQm9keTogJyArXG4gICAgICAgICAgICAgICAgKHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5pc0J1ZmZlcihib2R5KSA/IGJvZHkudG9TdHJpbmcoKSA6IGJvZHkpKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbnZhciBSZXNvdXJjZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXNvdXJjZSgpIHtcbiAgICB9XG4gICAgUmVzb3VyY2UuZ2V0ID0gZnVuY3Rpb24gKHJlc3QsIHBhdGgsIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIFJlc291cmNlLmRvKEh0dHBNZXRob2RzXzEuZGVmYXVsdC5HZXQsIHJlc3QsIHBhdGgsIG51bGwsIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlc291cmNlLmRlbGV0ZSA9IGZ1bmN0aW9uIChyZXN0LCBwYXRoLCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjaykge1xuICAgICAgICBSZXNvdXJjZS5kbyhIdHRwTWV0aG9kc18xLmRlZmF1bHQuRGVsZXRlLCByZXN0LCBwYXRoLCBudWxsLCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZXNvdXJjZS5wb3N0ID0gZnVuY3Rpb24gKHJlc3QsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIFJlc291cmNlLmRvKEh0dHBNZXRob2RzXzEuZGVmYXVsdC5Qb3N0LCByZXN0LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZXNvdXJjZS5wYXRjaCA9IGZ1bmN0aW9uIChyZXN0LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjaykge1xuICAgICAgICBSZXNvdXJjZS5kbyhIdHRwTWV0aG9kc18xLmRlZmF1bHQuUGF0Y2gsIHJlc3QsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlc291cmNlLnB1dCA9IGZ1bmN0aW9uIChyZXN0LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjaykge1xuICAgICAgICBSZXNvdXJjZS5kbyhIdHRwTWV0aG9kc18xLmRlZmF1bHQuUHV0LCByZXN0LCBwYXRoLCBib2R5LCBoZWFkZXJzLCBwYXJhbXMsIGVudmVsb3BlLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZXNvdXJjZS5kbyA9IGZ1bmN0aW9uIChtZXRob2QsIHJlc3QsIHBhdGgsIGJvZHksIGhlYWRlcnMsIHBhcmFtcywgZW52ZWxvcGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChsb2dnZXJfMS5kZWZhdWx0LnNob3VsZExvZyhsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gbG9nUmVzcG9uc2VIYW5kbGVyKGNhbGxiYWNrLCBtZXRob2QsIHBhdGgsIHBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGVudmVsb3BlKSB7XG4gICAgICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrICYmIHVuZW52ZWxvcGUoY2FsbGJhY2ssIGVudmVsb3BlKTtcbiAgICAgICAgICAgIChwYXJhbXMgPSBwYXJhbXMgfHwge30pWydlbnZlbG9wZSddID0gZW52ZWxvcGU7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gZG9SZXF1ZXN0KGhlYWRlcnMsIHBhcmFtcykge1xuICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgaWYgKGxvZ2dlcl8xLmRlZmF1bHQuc2hvdWxkTG9nKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVzb3VyY2UuJyArIG1ldGhvZCArICcoKScsICdTZW5kaW5nOyAnICsgdXJsRnJvbVBhdGhBbmRQYXJhbXMocGF0aCwgcGFyYW1zKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAobG9nZ2VyXzEuZGVmYXVsdC5zaG91bGRMb2cobG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8pKSB7XG4gICAgICAgICAgICAgICAgdmFyIGRlY29kZWRCb2R5ID0gYm9keTtcbiAgICAgICAgICAgICAgICBpZiAoKChfYSA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuaW5kZXhPZignbXNncGFjaycpKSA+IDApIHtcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGRlY29kZWRCb2R5ID0gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5tc2dwYWNrLmRlY29kZShib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZGVjb2RlRXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1Jlc291cmNlLicgKyBtZXRob2QgKyAnKCknLCAnU2VuZGluZyBNc2dQYWNrIERlY29kaW5nIEVycm9yOiAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGRlY29kZUVycikpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVzb3VyY2UuJyArIG1ldGhvZCArICcoKScsICdTZW5kaW5nOyAnICsgdXJsRnJvbVBhdGhBbmRQYXJhbXMocGF0aCwgcGFyYW1zKSArICc7IEJvZHk6ICcgKyBkZWNvZGVkQm9keSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXN0Lmh0dHAuZG8obWV0aG9kLCByZXN0LCBwYXRoLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGZ1bmN0aW9uIChlcnIsIHJlcywgcmVzSGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGF1dGhfMS5kZWZhdWx0LmlzVG9rZW5FcnIoZXJyKSkge1xuICAgICAgICAgICAgICAgICAgICAvKiB0b2tlbiBoYXMgZXhwaXJlZCwgc28gZ2V0IGEgbmV3IG9uZSAqL1xuICAgICAgICAgICAgICAgICAgICByZXN0LmF1dGguYXV0aG9yaXplKG51bGwsIG51bGwsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIHJldHJ5IC4uLiAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgd2l0aEF1dGhEZXRhaWxzKHJlc3QsIGhlYWRlcnMsIHBhcmFtcywgY2FsbGJhY2ssIGRvUmVxdWVzdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgcmVzLCByZXNIZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICB3aXRoQXV0aERldGFpbHMocmVzdCwgaGVhZGVycywgcGFyYW1zLCBjYWxsYmFjaywgZG9SZXF1ZXN0KTtcbiAgICB9O1xuICAgIHJldHVybiBSZXNvdXJjZTtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBSZXNvdXJjZTtcblxuXG4vKioqLyB9KSxcbi8qIDE1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg5KSk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbmZ1bmN0aW9uIHRvQWN0aW9uVmFsdWUoYWN0aW9uU3RyaW5nKSB7XG4gICAgcmV0dXJuIFByZXNlbmNlTWVzc2FnZS5BY3Rpb25zLmluZGV4T2YoYWN0aW9uU3RyaW5nKTtcbn1cbnZhciBQcmVzZW5jZU1lc3NhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHJlc2VuY2VNZXNzYWdlKCkge1xuICAgIH1cbiAgICAvKiBSZXR1cm5zIHdoZXRoZXIgdGhpcyBwcmVzZW5jZU1lc3NhZ2UgaXMgc3ludGhlc2l6ZWQsIGkuZS4gd2FzIG5vdCBhY3R1YWxseVxuICAgICAqIHNlbnQgYnkgdGhlIGNvbm5lY3Rpb24gKHVzdWFsbHkgbWVhbnMgYSBsZWF2ZSBldmVudCBzZW50IDE1cyBhZnRlciBhXG4gICAgICogZGlzY29ubmVjdGlvbikuIFRoaXMgaXMgdXNlZnVsIGJlY2F1c2Ugc3ludGhlc2l6ZWQgbWVzc2FnZXMgY2Fubm90IGJlXG4gICAgICogY29tcGFyZWQgZm9yIG5ld25lc3MgYnkgaWQgbGV4aWNvZ3JhcGhpY2FsbHkgLSBSVFAyYjFcbiAgICAgKi9cbiAgICBQcmVzZW5jZU1lc3NhZ2UucHJvdG90eXBlLmlzU3ludGhlc2l6ZWQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5pZCB8fCAhdGhpcy5jb25uZWN0aW9uSWQpIHtcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLmlkLnN1YnN0cmluZyh0aGlzLmNvbm5lY3Rpb25JZC5sZW5ndGgsIDApICE9PSB0aGlzLmNvbm5lY3Rpb25JZDtcbiAgICB9O1xuICAgIC8qIFJUUDJiMiAqL1xuICAgIFByZXNlbmNlTWVzc2FnZS5wcm90b3R5cGUucGFyc2VJZCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgaWYgKCF0aGlzLmlkKVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdwYXJzZUlkKCk6IFByZXNlbmNlIG1lc3NhZ2UgZG9lcyBub3QgY29udGFpbiBhbiBpZCcpO1xuICAgICAgICB2YXIgcGFydHMgPSB0aGlzLmlkLnNwbGl0KCc6Jyk7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBjb25uZWN0aW9uSWQ6IHBhcnRzWzBdLFxuICAgICAgICAgICAgbXNnU2VyaWFsOiBwYXJzZUludChwYXJ0c1sxXSwgMTApLFxuICAgICAgICAgICAgaW5kZXg6IHBhcnNlSW50KHBhcnRzWzJdLCAxMCksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBPdmVybG9hZCB0b0pTT04oKSB0byBpbnRlcmNlcHQgSlNPTi5zdHJpbmdpZnkoKVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG4gICAgUHJlc2VuY2VNZXNzYWdlLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIC8qIGVuY29kZSBkYXRhIHRvIGJhc2U2NCBpZiBwcmVzZW50IGFuZCB3ZSdyZSByZXR1cm5pbmcgcmVhbCBKU09OO1xuICAgICAgICAgKiBhbHRob3VnaCBtc2dwYWNrIGNhbGxzIHRvSlNPTigpLCB3ZSBrbm93IGl0IGlzIGEgc3RyaW5naWZ5KClcbiAgICAgICAgICogY2FsbCBpZiBpdCBoYXMgYSBub24tZW1wdHkgYXJndW1lbnRzIGxpc3QgKi9cbiAgICAgICAgdmFyIGRhdGEgPSB0aGlzLmRhdGE7XG4gICAgICAgIHZhciBlbmNvZGluZyA9IHRoaXMuZW5jb2Rpbmc7XG4gICAgICAgIGlmIChkYXRhICYmIHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5pc0J1ZmZlcihkYXRhKSkge1xuICAgICAgICAgICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPiAwKSB7XG4gICAgICAgICAgICAgICAgLyogc3RyaW5naWZ5IGNhbGwgKi9cbiAgICAgICAgICAgICAgICBlbmNvZGluZyA9IGVuY29kaW5nID8gZW5jb2RpbmcgKyAnL2Jhc2U2NCcgOiAnYmFzZTY0JztcbiAgICAgICAgICAgICAgICBkYXRhID0gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLmJhc2U2NEVuY29kZShkYXRhKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIC8qIENhbGxlZCBieSBtc2dwYWNrLiB0b0J1ZmZlciByZXR1cm5zIGEgZGF0YXR5cGUgdW5kZXJzdGFuZGFibGUgYnlcbiAgICAgICAgICAgICAgICAgKiB0aGF0IHBsYXRmb3JtJ3MgbXNncGFjayBpbXBsZW1lbnRhdGlvbiAoQnVmZmVyIGluIG5vZGUsIFVpbnQ4QXJyYXlcbiAgICAgICAgICAgICAgICAgKiBpbiBicm93c2VycykgKi9cbiAgICAgICAgICAgICAgICBkYXRhID0gcGxhdGZvcm1fMS5kZWZhdWx0LkJ1ZmZlclV0aWxzLnRvQnVmZmVyKGRhdGEpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBpZDogdGhpcy5pZCxcbiAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLmNsaWVudElkLFxuICAgICAgICAgICAgLyogQ29udmVydCBwcmVzZW5jZSBhY3Rpb24gYmFjayB0byBhbiBpbnQgZm9yIHNlbmRpbmcgdG8gQWJseSAqL1xuICAgICAgICAgICAgYWN0aW9uOiB0b0FjdGlvblZhbHVlKHRoaXMuYWN0aW9uKSxcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgICAgICBlbmNvZGluZzogZW5jb2RpbmcsXG4gICAgICAgICAgICBleHRyYXM6IHRoaXMuZXh0cmFzLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgUHJlc2VuY2VNZXNzYWdlLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICdbUHJlc2VuY2VNZXNzYWdlJztcbiAgICAgICAgcmVzdWx0ICs9ICc7IGFjdGlvbj0nICsgdGhpcy5hY3Rpb247XG4gICAgICAgIGlmICh0aGlzLmlkKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGlkPScgKyB0aGlzLmlkO1xuICAgICAgICBpZiAodGhpcy50aW1lc3RhbXApXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgdGltZXN0YW1wPScgKyB0aGlzLnRpbWVzdGFtcDtcbiAgICAgICAgaWYgKHRoaXMuY2xpZW50SWQpXG4gICAgICAgICAgICByZXN1bHQgKz0gJzsgY2xpZW50SWQ9JyArIHRoaXMuY2xpZW50SWQ7XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25JZClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBjb25uZWN0aW9uSWQ9JyArIHRoaXMuY29ubmVjdGlvbklkO1xuICAgICAgICBpZiAodGhpcy5lbmNvZGluZylcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBlbmNvZGluZz0nICsgdGhpcy5lbmNvZGluZztcbiAgICAgICAgaWYgKHRoaXMuZGF0YSkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiB0aGlzLmRhdGEgPT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGRhdGE9JyArIHRoaXMuZGF0YTtcbiAgICAgICAgICAgIGVsc2UgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscy5pc0J1ZmZlcih0aGlzLmRhdGEpKVxuICAgICAgICAgICAgICAgIHJlc3VsdCArPSAnOyBkYXRhIChidWZmZXIpPScgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuYmFzZTY0RW5jb2RlKHRoaXMuZGF0YSk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGRhdGEgKGpzb24pPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmRhdGEpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmV4dHJhcykge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGV4dHJhcz0nICsgSlNPTi5zdHJpbmdpZnkodGhpcy5leHRyYXMpO1xuICAgICAgICB9XG4gICAgICAgIHJlc3VsdCArPSAnXSc7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1lc3NhZ2UuZnJvbVJlc3BvbnNlQm9keSA9IGZ1bmN0aW9uIChib2R5LCBvcHRpb25zLCBmb3JtYXQpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2VzID0gW107XG4gICAgICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGJvZHkgPSBVdGlscy5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBib2R5Lmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gKG1lc3NhZ2VzW2ldID0gUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMoYm9keVtpXSwgdHJ1ZSkpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICBQcmVzZW5jZU1lc3NhZ2UuZGVjb2RlKG1zZywgb3B0aW9ucyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnUHJlc2VuY2VNZXNzYWdlLmZyb21SZXNwb25zZUJvZHkoKScsIGUudG9TdHJpbmcoKSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lc3NhZ2VzO1xuICAgIH07XG4gICAgUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMgPSBmdW5jdGlvbiAodmFsdWVzLCBzdHJpbmdpZnlBY3Rpb24pIHtcbiAgICAgICAgaWYgKHN0cmluZ2lmeUFjdGlvbikge1xuICAgICAgICAgICAgdmFsdWVzLmFjdGlvbiA9IFByZXNlbmNlTWVzc2FnZS5BY3Rpb25zW3ZhbHVlcy5hY3Rpb25dO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKG5ldyBQcmVzZW5jZU1lc3NhZ2UoKSwgdmFsdWVzKTtcbiAgICB9O1xuICAgIFByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzQXJyYXkgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IFByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzKHZhbHVlc1tpXSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1lc3NhZ2UuZnJvbUVuY29kZWQgPSBmdW5jdGlvbiAoZW5jb2RlZCwgb3B0aW9ucykge1xuICAgICAgICB2YXIgbXNnID0gUHJlc2VuY2VNZXNzYWdlLmZyb21WYWx1ZXMoZW5jb2RlZCwgdHJ1ZSk7XG4gICAgICAgIC8qIGlmIGRlY29kaW5nIGZhaWxzIGF0IGFueSBwb2ludCwgY2F0Y2ggYW5kIHJldHVybiB0aGUgbWVzc2FnZSBkZWNvZGVkIHRvXG4gICAgICAgICAqIHRoZSBmdWxsZXN0IGV4dGVudCBwb3NzaWJsZSAqL1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgUHJlc2VuY2VNZXNzYWdlLmRlY29kZShtc2csIG9wdGlvbnMgIT09IG51bGwgJiYgb3B0aW9ucyAhPT0gdm9pZCAwID8gb3B0aW9ucyA6IHt9KTtcbiAgICAgICAgfVxuICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdQcmVzZW5jZU1lc3NhZ2UuZnJvbUVuY29kZWQoKScsIGUudG9TdHJpbmcoKSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1zZztcbiAgICB9O1xuICAgIFByZXNlbmNlTWVzc2FnZS5mcm9tRW5jb2RlZEFycmF5ID0gZnVuY3Rpb24gKGVuY29kZWRBcnJheSwgb3B0aW9ucykge1xuICAgICAgICByZXR1cm4gZW5jb2RlZEFycmF5Lm1hcChmdW5jdGlvbiAoZW5jb2RlZCkge1xuICAgICAgICAgICAgcmV0dXJuIFByZXNlbmNlTWVzc2FnZS5mcm9tRW5jb2RlZChlbmNvZGVkLCBvcHRpb25zKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1lc3NhZ2UuZnJvbURhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIFByZXNlbmNlTWVzc2FnZSkge1xuICAgICAgICAgICAgcmV0dXJuIGRhdGE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIFByZXNlbmNlTWVzc2FnZS5mcm9tVmFsdWVzKHtcbiAgICAgICAgICAgIGRhdGE6IGRhdGEsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUHJlc2VuY2VNZXNzYWdlLkFjdGlvbnMgPSBbJ2Fic2VudCcsICdwcmVzZW50JywgJ2VudGVyJywgJ2xlYXZlJywgJ3VwZGF0ZSddO1xuICAgIFByZXNlbmNlTWVzc2FnZS5lbmNvZGUgPSBtZXNzYWdlXzEuZGVmYXVsdC5lbmNvZGU7XG4gICAgUHJlc2VuY2VNZXNzYWdlLmRlY29kZSA9IG1lc3NhZ2VfMS5kZWZhdWx0LmRlY29kZTtcbiAgICBQcmVzZW5jZU1lc3NhZ2UuZ2V0TWVzc2FnZXNTaXplID0gbWVzc2FnZV8xLmRlZmF1bHQuZ2V0TWVzc2FnZXNTaXplO1xuICAgIHJldHVybiBQcmVzZW5jZU1lc3NhZ2U7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUHJlc2VuY2VNZXNzYWdlO1xuXG5cbi8qKiovIH0pLFxuLyogMTYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBldmVudGVtaXR0ZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNykpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBkZWZhdWx0c18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg4KSk7XG52YXIgWEhSU3RhdGVzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIxKSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xuZnVuY3Rpb24gaXNBYmx5RXJyb3IocmVzcG9uc2VCb2R5LCBoZWFkZXJzKSB7XG4gICAgcmV0dXJuIFV0aWxzLmFyckluKFV0aWxzLmFsbFRvTG93ZXJDYXNlKFV0aWxzLmtleXNBcnJheShoZWFkZXJzKSksICd4LWFibHktZXJyb3Jjb2RlJyk7XG59XG5mdW5jdGlvbiBnZXRBYmx5RXJyb3IocmVzcG9uc2VCb2R5LCBoZWFkZXJzKSB7XG4gICAgaWYgKGlzQWJseUVycm9yKHJlc3BvbnNlQm9keSwgaGVhZGVycykpIHtcbiAgICAgICAgcmV0dXJuIHJlc3BvbnNlQm9keS5lcnJvciAmJiBlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMocmVzcG9uc2VCb2R5LmVycm9yKTtcbiAgICB9XG59XG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcbnZhciBpZENvdW50ZXIgPSAwO1xudmFyIHBlbmRpbmdSZXF1ZXN0cyA9IHt9O1xudmFyIGlzSUUgPSB0eXBlb2YgZ2xvYmFsICE9PSAndW5kZWZpbmVkJyAmJiBnbG9iYWwuWERvbWFpblJlcXVlc3Q7XG5mdW5jdGlvbiBpZVZlcnNpb24oKSB7XG4gICAgdmFyIG1hdGNoID0gbmF2aWdhdG9yLnVzZXJBZ2VudC50b1N0cmluZygpLm1hdGNoKC9NU0lFXFxzKFtcXGQuXSspLyk7XG4gICAgcmV0dXJuIG1hdGNoICYmIE51bWJlcihtYXRjaFsxXSk7XG59XG5mdW5jdGlvbiBuZWVkSnNvbkVudmVsb3BlKCkge1xuICAgIC8qIElFIDEwIHhociBidWc6IGh0dHA6Ly9zdGFja292ZXJmbG93LmNvbS9hLzE2MzIwMzM5ICovXG4gICAgdmFyIHZlcnNpb247XG4gICAgcmV0dXJuIGlzSUUgJiYgKHZlcnNpb24gPSBpZVZlcnNpb24oKSkgJiYgdmVyc2lvbiA9PT0gMTA7XG59XG5mdW5jdGlvbiBnZXRIZWFkZXIoeGhyLCBoZWFkZXIpIHtcbiAgICByZXR1cm4geGhyLmdldFJlc3BvbnNlSGVhZGVyICYmIHhoci5nZXRSZXNwb25zZUhlYWRlcihoZWFkZXIpO1xufVxuLyogU2FmYXJpIG15c3RlcmlvdXNseSByZXR1cm5zICdJZGVudGl0eScgZm9yIHRyYW5zZmVyLWVuY29kaW5nIHdoZW4gaW4gZmFjdFxuICogaXQgaXMgJ2NodW5rZWQnLiBTbyBpbnN0ZWFkLCBkZWNpZGUgdGhhdCBpdCBpcyBjaHVua2VkIHdoZW5cbiAqIHRyYW5zZmVyLWVuY29kaW5nIGlzIHByZXNlbnQgb3IgY29udGVudC1sZW5ndGggaXMgYWJzZW50LiAgKCdvcicgYmVjYXVzZVxuICogd2hlbiB1c2luZyBodHRwMiBzdHJlYW1pbmcsIHRoZXJlJ3Mgbm8gdHJhbnNmZXItZW5jb2RpbmcgaGVhZGVyLCBidXQgY2FuXG4gKiBzdGlsbCBkZWR1Y2Ugc3RyZWFtaW5nIGZyb20gbGFjayBvZiBjb250ZW50LWxlbmd0aCkgKi9cbmZ1bmN0aW9uIGlzRW5jb2RpbmdDaHVua2VkKHhocikge1xuICAgIHJldHVybiAoeGhyLmdldFJlc3BvbnNlSGVhZGVyICYmICh4aHIuZ2V0UmVzcG9uc2VIZWFkZXIoJ3RyYW5zZmVyLWVuY29kaW5nJykgfHwgIXhoci5nZXRSZXNwb25zZUhlYWRlcignY29udGVudC1sZW5ndGgnKSkpO1xufVxuZnVuY3Rpb24gZ2V0SGVhZGVyc0FzT2JqZWN0KHhocikge1xuICAgIHZhciBoZWFkZXJQYWlycyA9IFV0aWxzLnRyaW0oeGhyLmdldEFsbFJlc3BvbnNlSGVhZGVycygpKS5zcGxpdCgnXFxyXFxuJyk7XG4gICAgdmFyIGhlYWRlcnMgPSB7fTtcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhlYWRlclBhaXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBwYXJ0cyA9IGhlYWRlclBhaXJzW2ldLnNwbGl0KCc6JykubWFwKFV0aWxzLnRyaW0pO1xuICAgICAgICBoZWFkZXJzW3BhcnRzWzBdLnRvTG93ZXJDYXNlKCldID0gcGFydHNbMV07XG4gICAgfVxuICAgIHJldHVybiBoZWFkZXJzO1xufVxudmFyIFhIUlJlcXVlc3QgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoWEhSUmVxdWVzdCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBYSFJSZXF1ZXN0KHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMsIG1ldGhvZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBwYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgIHBhcmFtcy5ybmQgPSBVdGlscy5jaGVhcFJhbmRTdHIoKTtcbiAgICAgICAgaWYgKG5lZWRKc29uRW52ZWxvcGUoKSAmJiAhcGFyYW1zLmVudmVsb3BlKVxuICAgICAgICAgICAgcGFyYW1zLmVudmVsb3BlID0gJ2pzb24nO1xuICAgICAgICBfdGhpcy51cmkgPSB1cmkgKyBVdGlscy50b1F1ZXJ5U3RyaW5nKHBhcmFtcyk7XG4gICAgICAgIF90aGlzLmhlYWRlcnMgPSBoZWFkZXJzIHx8IHt9O1xuICAgICAgICBfdGhpcy5ib2R5ID0gYm9keTtcbiAgICAgICAgX3RoaXMubWV0aG9kID0gbWV0aG9kID8gbWV0aG9kLnRvVXBwZXJDYXNlKCkgOiBVdGlscy5pc0VtcHR5QXJnKGJvZHkpID8gJ0dFVCcgOiAnUE9TVCc7XG4gICAgICAgIF90aGlzLnJlcXVlc3RNb2RlID0gcmVxdWVzdE1vZGU7XG4gICAgICAgIF90aGlzLnRpbWVvdXRzID0gdGltZW91dHM7XG4gICAgICAgIF90aGlzLnRpbWVkT3V0ID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnJlcXVlc3RDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5pZCA9IFN0cmluZygrK2lkQ291bnRlcik7XG4gICAgICAgIHBlbmRpbmdSZXF1ZXN0c1tfdGhpcy5pZF0gPSBfdGhpcztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBYSFJSZXF1ZXN0LmNyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbiAodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbWV0aG9kKSB7XG4gICAgICAgIC8qIFhIUiByZXF1ZXN0cyBhcmUgdXNlZCBlaXRoZXIgd2l0aCB0aGUgY29udGV4dCBiZWluZyBhIHJlYWx0aW1lXG4gICAgICAgICAqIHRyYW5zcG9ydCwgb3Igd2l0aCB0aW1lb3V0cyBwYXNzZWQgaW4gKGZvciB3aGVuIHVzZWQgYnkgYSByZXN0IGNsaWVudCksXG4gICAgICAgICAqIG9yIGNvbXBsZXRlbHkgc3RhbmRhbG9uZS4gIFVzZSB0aGUgYXBwcm9wcmlhdGUgdGltZW91dHMgaW4gZWFjaCBjYXNlICovXG4gICAgICAgIHZhciBfdGltZW91dHMgPSB0aW1lb3V0cyB8fCBkZWZhdWx0c18xLmRlZmF1bHQuVElNRU9VVFM7XG4gICAgICAgIHJldHVybiBuZXcgWEhSUmVxdWVzdCh1cmksIGhlYWRlcnMsIFV0aWxzLmNvcHkocGFyYW1zKSwgYm9keSwgcmVxdWVzdE1vZGUsIF90aW1lb3V0cywgbWV0aG9kKTtcbiAgICB9O1xuICAgIFhIUlJlcXVlc3QucHJvdG90eXBlLmNvbXBsZXRlID0gZnVuY3Rpb24gKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgaWYgKCF0aGlzLnJlcXVlc3RDb21wbGV0ZSkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Q29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgaWYgKCFlcnIgJiYgYm9keSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdjb21wbGV0ZScsIGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFhIUlJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIFhIUlJlcXVlc3QucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBoZWFkZXJzID0gdGhpcy5oZWFkZXJzO1xuICAgICAgICB2YXIgdGltZW91dCA9IHRoaXMucmVxdWVzdE1vZGUgPT0gWEhSU3RhdGVzXzEuZGVmYXVsdC5SRVFfU0VORCA/IHRoaXMudGltZW91dHMuaHR0cFJlcXVlc3RUaW1lb3V0IDogdGhpcy50aW1lb3V0cy5yZWN2VGltZW91dCwgdGltZXIgPSAodGhpcy50aW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMudGltZWRPdXQgPSB0cnVlO1xuICAgICAgICAgICAgeGhyLmFib3J0KCk7XG4gICAgICAgIH0sIHRpbWVvdXQpKSwgbWV0aG9kID0gdGhpcy5tZXRob2QsIHhociA9ICh0aGlzLnhociA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpKSwgYWNjZXB0ID0gaGVhZGVyc1snYWNjZXB0J107XG4gICAgICAgIHZhciBib2R5ID0gdGhpcy5ib2R5O1xuICAgICAgICB2YXIgcmVzcG9uc2VUeXBlID0gJ3RleHQnO1xuICAgICAgICBpZiAoIWFjY2VwdCkge1xuICAgICAgICAgICAgLy8gRGVmYXVsdCB0byBKU09OXG4gICAgICAgICAgICBoZWFkZXJzWydhY2NlcHQnXSA9ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChhY2NlcHQuaW5kZXhPZignYXBwbGljYXRpb24veC1tc2dwYWNrJykgPT09IDApIHtcbiAgICAgICAgICAgIC8vIE1zZ3BhY2sgcmVzcG9uc2VzIHdpbGwgYmUgdHlwZWQgYXMgQXJyYXlCdWZmZXJcbiAgICAgICAgICAgIHJlc3BvbnNlVHlwZSA9ICdhcnJheWJ1ZmZlcic7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGJvZHkpIHtcbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddIHx8IChoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9ICdhcHBsaWNhdGlvbi9qc29uJyk7XG4gICAgICAgICAgICBpZiAoY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID4gLTEgJiYgdHlwZW9mIGJvZHkgIT0gJ3N0cmluZycpXG4gICAgICAgICAgICAgICAgYm9keSA9IEpTT04uc3RyaW5naWZ5KGJvZHkpO1xuICAgICAgICB9XG4gICAgICAgIC8vIENhbiBwcm9iYWJseSByZW1vdmUgdGhpcyBkaXJlY3RpdmUgaWYgaHR0cHM6Ly9naXRodWIuY29tL25vZGVzZWN1cml0eS9lc2xpbnQtcGx1Z2luLXNlY3VyaXR5L2lzc3Vlcy8yNiBpcyByZXNvbHZlZFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgc2VjdXJpdHkvZGV0ZWN0LW5vbi1saXRlcmFsLWZzLWZpbGVuYW1lXG4gICAgICAgIHhoci5vcGVuKG1ldGhvZCwgdGhpcy51cmksIHRydWUpO1xuICAgICAgICB4aHIucmVzcG9uc2VUeXBlID0gcmVzcG9uc2VUeXBlO1xuICAgICAgICBpZiAoJ2F1dGhvcml6YXRpb24nIGluIGhlYWRlcnMpIHtcbiAgICAgICAgICAgIHhoci53aXRoQ3JlZGVudGlhbHMgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGggaW4gaGVhZGVycylcbiAgICAgICAgICAgIHhoci5zZXRSZXF1ZXN0SGVhZGVyKGgsIGhlYWRlcnNbaF0pO1xuICAgICAgICB2YXIgZXJyb3JIYW5kbGVyID0gZnVuY3Rpb24gKGVycm9yRXZlbnQsIG1lc3NhZ2UsIGNvZGUsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgIHZhciBlcnJvck1lc3NhZ2UgPSBtZXNzYWdlICsgJyAoZXZlbnQgdHlwZTogJyArIGVycm9yRXZlbnQudHlwZSArICcpJztcbiAgICAgICAgICAgIGlmICgoX2EgPSBfdGhpcyA9PT0gbnVsbCB8fCBfdGhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3RoaXMueGhyKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc3RhdHVzVGV4dClcbiAgICAgICAgICAgICAgICBlcnJvck1lc3NhZ2UgKz0gJywgY3VycmVudCBzdGF0dXNUZXh0IGlzICcgKyBfdGhpcy54aHIuc3RhdHVzVGV4dDtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnUmVxdWVzdC5vbicgKyBlcnJvckV2ZW50LnR5cGUgKyAnKCknLCBlcnJvck1lc3NhZ2UpO1xuICAgICAgICAgICAgX3RoaXMuY29tcGxldGUobmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oZXJyb3JNZXNzYWdlLCBjb2RlLCBzdGF0dXNDb2RlKSk7XG4gICAgICAgIH07XG4gICAgICAgIHhoci5vbmVycm9yID0gZnVuY3Rpb24gKGVycm9yRXZlbnQpIHtcbiAgICAgICAgICAgIGVycm9ySGFuZGxlcihlcnJvckV2ZW50LCAnWEhSIGVycm9yIG9jY3VycmVkJywgbnVsbCwgNDAwKTtcbiAgICAgICAgfTtcbiAgICAgICAgeGhyLm9uYWJvcnQgPSBmdW5jdGlvbiAoZXJyb3JFdmVudCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnRpbWVkT3V0KSB7XG4gICAgICAgICAgICAgICAgZXJyb3JIYW5kbGVyKGVycm9yRXZlbnQsICdSZXF1ZXN0IGFib3J0ZWQgZHVlIHRvIHJlcXVlc3QgdGltZW91dCBleHBpcmluZycsIG51bGwsIDQwOCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBlcnJvckhhbmRsZXIoZXJyb3JFdmVudCwgJ1JlcXVlc3QgY2FuY2VsbGVkJywgbnVsbCwgNDAwKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgeGhyLm9udGltZW91dCA9IGZ1bmN0aW9uIChlcnJvckV2ZW50KSB7XG4gICAgICAgICAgICBlcnJvckhhbmRsZXIoZXJyb3JFdmVudCwgJ1JlcXVlc3QgdGltZWQgb3V0JywgbnVsbCwgNDA4KTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIHN0cmVhbWluZztcbiAgICAgICAgdmFyIHN0YXR1c0NvZGU7XG4gICAgICAgIHZhciBzdWNjZXNzUmVzcG9uc2U7XG4gICAgICAgIHZhciBzdHJlYW1Qb3MgPSAwO1xuICAgICAgICB2YXIgdW5wYWNrZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIG9uUmVzcG9uc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXIpO1xuICAgICAgICAgICAgc3VjY2Vzc1Jlc3BvbnNlID0gc3RhdHVzQ29kZSA8IDQwMDtcbiAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID09IDIwNCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlKG51bGwsIG51bGwsIG51bGwsIG51bGwsIHN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN0cmVhbWluZyA9IF90aGlzLnJlcXVlc3RNb2RlID09IFhIUlN0YXRlc18xLmRlZmF1bHQuUkVRX1JFQ1ZfU1RSRUFNICYmIHN1Y2Nlc3NSZXNwb25zZSAmJiBpc0VuY29kaW5nQ2h1bmtlZCh4aHIpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgb25FbmQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkUmVzcG9uc2U7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IGdldEhlYWRlcih4aHIsICdjb250ZW50LXR5cGUnKTtcbiAgICAgICAgICAgICAgICAvKiBCZSBsaWJlcmFsIGluIHdoYXQgd2UgYWNjZXB0OyBidWdneSBhdXRoIHNlcnZlcnMgbWF5IHJlc3BvbmRcbiAgICAgICAgICAgICAgICAgKiB3aXRob3V0IHRoZSBjb3JyZWN0IGNvbnRlbnR0eXBlLCBidXQgYXNzdW1lIHRoZXkncmUgc3RpbGxcbiAgICAgICAgICAgICAgICAgKiByZXNwb25kaW5nIHdpdGgganNvbiAqL1xuICAgICAgICAgICAgICAgIHZhciBqc29uID0gY29udGVudFR5cGUgPyBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi9qc29uJykgPj0gMCA6IHhoci5yZXNwb25zZVR5cGUgPT0gJ3RleHQnO1xuICAgICAgICAgICAgICAgIGlmIChqc29uKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIElmIHdlIHJlcXVlc3RlZCBtc2dwYWNrIGJ1dCBzZXJ2ZXIgcmVzcG9uZGVkIHdpdGgganNvbiwgdGhlbiBzaW5jZVxuICAgICAgICAgICAgICAgICAgICAgKiB3ZSBzZXQgdGhlIHJlc3BvbnNlVHlwZSBleHBlY3RpbmcgbXNncGFjaywgdGhlIHJlc3BvbnNlIHdpbGwgYmVcbiAgICAgICAgICAgICAgICAgICAgICogYW4gQXJyYXlCdWZmZXIgY29udGFpbmluZyBqc29uICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBqc29uUmVzcG9uc2VCb2R5ID0geGhyLnJlc3BvbnNlVHlwZSA9PT0gJ2FycmF5YnVmZmVyJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMudXRmOERlY29kZSh4aHIucmVzcG9uc2UpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IFN0cmluZyh4aHIucmVzcG9uc2VUZXh0KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGpzb25SZXNwb25zZUJvZHkubGVuZ3RoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRSZXNwb25zZSA9IEpTT04ucGFyc2UoanNvblJlc3BvbnNlQm9keSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwYXJzZWRSZXNwb25zZSA9IGpzb25SZXNwb25zZUJvZHk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdW5wYWNrZWQgPSB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmVzcG9uc2UgPSB4aHIucmVzcG9uc2U7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmIChwYXJzZWRSZXNwb25zZS5yZXNwb25zZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIHVud3JhcCBKU09OIGVudmVsb3BlICovXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgPSBwYXJzZWRSZXNwb25zZS5zdGF0dXNDb2RlO1xuICAgICAgICAgICAgICAgICAgICBzdWNjZXNzUmVzcG9uc2UgPSBzdGF0dXNDb2RlIDwgNDAwO1xuICAgICAgICAgICAgICAgICAgICBoZWFkZXJzID0gcGFyc2VkUmVzcG9uc2UuaGVhZGVycztcbiAgICAgICAgICAgICAgICAgICAgcGFyc2VkUmVzcG9uc2UgPSBwYXJzZWRSZXNwb25zZS5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnMgPSBnZXRIZWFkZXJzQXNPYmplY3QoeGhyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlKG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCdNYWxmb3JtZWQgcmVzcG9uc2UgYm9keSBmcm9tIHNlcnZlcjogJyArIGUubWVzc2FnZSwgbnVsbCwgNDAwKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogSWYgcmVzcG9uc2UgaXMgYW4gYXJyYXksIGl0J3MgYW4gYXJyYXkgb2YgcHJvdG9jb2wgbWVzc2FnZXMgLS0gZXZlbiBpZlxuICAgICAgICAgICAgICogaXMgY29udGFpbnMgYW4gZXJyb3IgYWN0aW9uIChoZW5jZSB0aGUgbm9uc3VjY2VzcyBzdGF0dXNjb2RlKSwgd2UgY2FuXG4gICAgICAgICAgICAgKiBjb25zaWRlciB0aGUgcmVxdWVzdCB0byBoYXZlIHN1Y2NlZWRlZCwganVzdCBwYXNzIGl0IG9uIHRvXG4gICAgICAgICAgICAgKiBvblByb3RvY29sTWVzc2FnZSB0byBkZWNpZGUgd2hhdCB0byBkbyAqL1xuICAgICAgICAgICAgaWYgKHN1Y2Nlc3NSZXNwb25zZSB8fCBVdGlscy5pc0FycmF5KHBhcnNlZFJlc3BvbnNlKSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlKG51bGwsIHBhcnNlZFJlc3BvbnNlLCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGVyciA9IGdldEFibHlFcnJvcihwYXJzZWRSZXNwb25zZSwgaGVhZGVycyk7XG4gICAgICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgICAgIGVyciA9IG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCdFcnJvciByZXNwb25zZSByZWNlaXZlZCBmcm9tIHNlcnZlcjogJyArXG4gICAgICAgICAgICAgICAgICAgIHN0YXR1c0NvZGUgK1xuICAgICAgICAgICAgICAgICAgICAnIGJvZHkgd2FzOiAnICtcbiAgICAgICAgICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KHBhcnNlZFJlc3BvbnNlKSwgbnVsbCwgc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jb21wbGV0ZShlcnIsIHBhcnNlZFJlc3BvbnNlLCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSk7XG4gICAgICAgIH07XG4gICAgICAgIGZ1bmN0aW9uIG9uUHJvZ3Jlc3MoKSB7XG4gICAgICAgICAgICB2YXIgcmVzcG9uc2VUZXh0ID0geGhyLnJlc3BvbnNlVGV4dDtcbiAgICAgICAgICAgIHZhciBib2R5RW5kID0gcmVzcG9uc2VUZXh0Lmxlbmd0aCAtIDE7XG4gICAgICAgICAgICB2YXIgaWR4LCBjaHVuaztcbiAgICAgICAgICAgIHdoaWxlIChzdHJlYW1Qb3MgPCBib2R5RW5kICYmIChpZHggPSByZXNwb25zZVRleHQuaW5kZXhPZignXFxuJywgc3RyZWFtUG9zKSkgPiAtMSkge1xuICAgICAgICAgICAgICAgIGNodW5rID0gcmVzcG9uc2VUZXh0LnNsaWNlKHN0cmVhbVBvcywgaWR4KTtcbiAgICAgICAgICAgICAgICBzdHJlYW1Qb3MgPSBpZHggKyAxO1xuICAgICAgICAgICAgICAgIG9uQ2h1bmsoY2h1bmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHZhciBvbkNodW5rID0gZnVuY3Rpb24gKGNodW5rKSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgIGNodW5rID0gSlNPTi5wYXJzZShjaHVuayk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlKG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCdNYWxmb3JtZWQgcmVzcG9uc2UgYm9keSBmcm9tIHNlcnZlcjogJyArIGUubWVzc2FnZSwgbnVsbCwgNDAwKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuZW1pdCgnZGF0YScsIGNodW5rKTtcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIG9uU3RyZWFtRW5kID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgb25Qcm9ncmVzcygpO1xuICAgICAgICAgICAgX3RoaXMuc3RyZWFtQ29tcGxldGUgPSB0cnVlO1xuICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuY29tcGxldGUoKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdmFyIHJlYWR5U3RhdGUgPSB4aHIucmVhZHlTdGF0ZTtcbiAgICAgICAgICAgIGlmIChyZWFkeVN0YXRlIDwgMylcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBpZiAoeGhyLnN0YXR1cyAhPT0gMCkge1xuICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZSA9IHhoci5zdGF0dXM7XG4gICAgICAgICAgICAgICAgICAgIC8qIElFIHJldHVybnMgMTIyMyBmb3IgMjA0OiBodHRwOi8vYnVncy5qcXVlcnkuY29tL3RpY2tldC8xNDUwICovXG4gICAgICAgICAgICAgICAgICAgIGlmIChzdGF0dXNDb2RlID09PSAxMjIzKVxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhdHVzQ29kZSA9IDIwNDtcbiAgICAgICAgICAgICAgICAgICAgb25SZXNwb25zZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVhZHlTdGF0ZSA9PSAzICYmIHN0cmVhbWluZykge1xuICAgICAgICAgICAgICAgICAgICBvblByb2dyZXNzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHJlYWR5U3RhdGUgPT0gNCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoc3RyZWFtaW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgb25TdHJlYW1FbmQoKTtcbiAgICAgICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICAgICAgb25FbmQoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHhoci5zZW5kKGJvZHkpO1xuICAgIH07XG4gICAgWEhSUmVxdWVzdC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHhociA9IHRoaXMueGhyO1xuICAgICAgICBpZiAoeGhyKSB7XG4gICAgICAgICAgICB4aHIub25yZWFkeXN0YXRlY2hhbmdlID0geGhyLm9uZXJyb3IgPSB4aHIub25hYm9ydCA9IHhoci5vbnRpbWVvdXQgPSBub29wO1xuICAgICAgICAgICAgdGhpcy54aHIgPSBudWxsO1xuICAgICAgICAgICAgdmFyIHRpbWVyID0gdGhpcy50aW1lcjtcbiAgICAgICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICAgICAgdGhpcy50aW1lciA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIXRoaXMucmVxdWVzdENvbXBsZXRlKVxuICAgICAgICAgICAgICAgIHhoci5hYm9ydCgpO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSBwZW5kaW5nUmVxdWVzdHNbdGhpcy5pZF07XG4gICAgfTtcbiAgICByZXR1cm4gWEhSUmVxdWVzdDtcbn0oZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gWEhSUmVxdWVzdDtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTMpKSlcblxuLyoqKi8gfSksXG4vKiAxNyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBtdWx0aWNhc3Rlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyMykpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgaG1hY19zaGEyNTZfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNDUpKTtcbnZhciBlbmNfYmFzZTY0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKTtcbnZhciBIdHRwTWV0aG9kc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxOCkpO1xudmFyIEh0dHBTdGF0dXNDb2Rlc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyNSkpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciByZXNvdXJjZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNCkpO1xudmFyIE1BWF9UT0tFTl9MRU5HVEggPSBNYXRoLnBvdygyLCAxNyk7XG5mdW5jdGlvbiBub29wKCkgeyB9XG5mdW5jdGlvbiByYW5kb20oKSB7XG4gICAgcmV0dXJuICgnMDAwMDAwJyArIE1hdGguZmxvb3IoTWF0aC5yYW5kb20oKSAqIDFlMTYpKS5zbGljZSgtMTYpO1xufVxuZnVuY3Rpb24gaXNSZWFsdGltZShjbGllbnQpIHtcbiAgICByZXR1cm4gISFjbGllbnQuY29ubmVjdGlvbjtcbn1cbi8qIEEgY2xpZW50IGF1dGggY2FsbGJhY2sgbWF5IGdpdmUgZXJyb3JzIGluIGFueSBudW1iZXIgb2YgZm9ybWF0czsgbm9ybWFsaXNlIHRvIGFuIEVycm9ySW5mbyBvciBQYXJ0aWFsRXJyb3JJbmZvICovXG5mdW5jdGlvbiBub3JtYWxpc2VBdXRoY2FsbGJhY2tFcnJvcihlcnIpIHtcbiAgICBpZiAoIVV0aWxzLmlzRXJyb3JJbmZvT3JQYXJ0aWFsRXJyb3JJbmZvKGVycikpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KFV0aWxzLmluc3BlY3RFcnJvcihlcnIpLCBlcnIuY29kZSB8fCA0MDE3MCwgZXJyLnN0YXR1c0NvZGUgfHwgNDAxKTtcbiAgICB9XG4gICAgLyogbmV0d29yayBlcnJvcnMgd2lsbCBub3QgaGF2ZSBhbiBpbmhlcmVudCBlcnJvciBjb2RlICovXG4gICAgaWYgKCFlcnIuY29kZSkge1xuICAgICAgICBpZiAoZXJyLnN0YXR1c0NvZGUgPT09IDQwMykge1xuICAgICAgICAgICAgZXJyLmNvZGUgPSA0MDMwMDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGVyci5jb2RlID0gNDAxNzA7XG4gICAgICAgICAgICAvKiBub3JtYWxpc2Ugc3RhdHVzQ29kZSB0byA0MDEgcGVyIFJTQTRlICovXG4gICAgICAgICAgICBlcnIuc3RhdHVzQ29kZSA9IDQwMTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZXJyO1xufVxudmFyIGhtYWMgPSBmdW5jdGlvbiAodGV4dCwga2V5KSB7XG4gICAgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuY3JlYXRlSG1hYykge1xuICAgICAgICB2YXIgaW5zdCA9IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuY3JlYXRlSG1hYygnU0hBMjU2Jywga2V5KTtcbiAgICAgICAgaW5zdC51cGRhdGUodGV4dCk7XG4gICAgICAgIHJldHVybiBpbnN0LmRpZ2VzdCgnYmFzZTY0Jyk7XG4gICAgfVxuICAgIHJldHVybiAoMCwgZW5jX2Jhc2U2NF8xLnN0cmluZ2lmeSkoKDAsIGhtYWNfc2hhMjU2XzEuZGVmYXVsdCkodGV4dCwga2V5KSk7XG59O1xuZnVuY3Rpb24gYzE0bihjYXBhYmlsaXR5KSB7XG4gICAgaWYgKCFjYXBhYmlsaXR5KVxuICAgICAgICByZXR1cm4gJyc7XG4gICAgaWYgKHR5cGVvZiBjYXBhYmlsaXR5ID09ICdzdHJpbmcnKVxuICAgICAgICBjYXBhYmlsaXR5ID0gSlNPTi5wYXJzZShjYXBhYmlsaXR5KTtcbiAgICB2YXIgYzE0bkNhcGFiaWxpdHkgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHZhciBrZXlzID0gVXRpbHMua2V5c0FycmF5KGNhcGFiaWxpdHksIHRydWUpO1xuICAgIGlmICgha2V5cylcbiAgICAgICAgcmV0dXJuICcnO1xuICAgIGtleXMuc29ydCgpO1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7IGkrKykge1xuICAgICAgICBjMTRuQ2FwYWJpbGl0eVtrZXlzW2ldXSA9IGNhcGFiaWxpdHlba2V5c1tpXV0uc29ydCgpO1xuICAgIH1cbiAgICByZXR1cm4gSlNPTi5zdHJpbmdpZnkoYzE0bkNhcGFiaWxpdHkpO1xufVxuZnVuY3Rpb24gbG9nQW5kVmFsaWRhdGVUb2tlbkF1dGhNZXRob2QoYXV0aE9wdGlvbnMpIHtcbiAgICBpZiAoYXV0aE9wdGlvbnMuYXV0aENhbGxiYWNrKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQXV0aCgpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoQ2FsbGJhY2snKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXV0aE9wdGlvbnMuYXV0aFVybCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0F1dGgoKScsICd1c2luZyB0b2tlbiBhdXRoIHdpdGggYXV0aFVybCcpO1xuICAgIH1cbiAgICBlbHNlIGlmIChhdXRoT3B0aW9ucy5rZXkpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdBdXRoKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGNsaWVudC1zaWRlIHNpZ25pbmcnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQXV0aCgpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBzdXBwbGllZCB0b2tlbiBvbmx5Jyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgICB2YXIgbXNnID0gJ2F1dGhPcHRpb25zIG11c3QgaW5jbHVkZSB2YWxpZCBhdXRoZW50aWNhdGlvbiBwYXJhbWV0ZXJzJztcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdBdXRoKCknLCBtc2cpO1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICB9XG59XG5mdW5jdGlvbiBiYXNpY0F1dGhGb3JjZWQob3B0aW9ucykge1xuICAgIHJldHVybiAndXNlVG9rZW5BdXRoJyBpbiBvcHRpb25zICYmICFvcHRpb25zLnVzZVRva2VuQXV0aDtcbn1cbi8qIFJTQTQgKi9cbmZ1bmN0aW9uIHVzZVRva2VuQXV0aChvcHRpb25zKSB7XG4gICAgcmV0dXJuIChvcHRpb25zLnVzZVRva2VuQXV0aCB8fFxuICAgICAgICAoIWJhc2ljQXV0aEZvcmNlZChvcHRpb25zKSAmJiAob3B0aW9ucy5hdXRoQ2FsbGJhY2sgfHwgb3B0aW9ucy5hdXRoVXJsIHx8IG9wdGlvbnMudG9rZW4gfHwgb3B0aW9ucy50b2tlbkRldGFpbHMpKSk7XG59XG4vKiBSU0E0YSAqL1xuZnVuY3Rpb24gbm9XYXlUb1JlbmV3KG9wdGlvbnMpIHtcbiAgICByZXR1cm4gIW9wdGlvbnMua2V5ICYmICFvcHRpb25zLmF1dGhDYWxsYmFjayAmJiAhb3B0aW9ucy5hdXRoVXJsO1xufVxudmFyIHRySWQgPSAwO1xuZnVuY3Rpb24gZ2V0VG9rZW5SZXF1ZXN0SWQoKSB7XG4gICAgcmV0dXJuIHRySWQrKztcbn1cbnZhciBBdXRoID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEF1dGgoY2xpZW50LCBvcHRpb25zKSB7XG4gICAgICAgIC8vIFRoaXMgaW5pdGlhbGl6YXRpb24gaXMgYWx3YXlzIG92ZXJ3cml0dGVuIGFuZCBvbmx5IHVzZWQgdG8gcHJldmVudCBhIFR5cGVTY3JpcHQgY29tcGlsZXIgZXJyb3JcbiAgICAgICAgdGhpcy5hdXRoT3B0aW9ucyA9IHt9O1xuICAgICAgICB0aGlzLmNsaWVudCA9IGNsaWVudDtcbiAgICAgICAgdGhpcy50b2tlblBhcmFtcyA9IG9wdGlvbnMuZGVmYXVsdFRva2VuUGFyYW1zIHx8IHt9O1xuICAgICAgICAvKiBUaGUgaWQgb2YgdGhlIGN1cnJlbnQgdG9rZW4gcmVxdWVzdCBpZiBvbmUgaXMgaW4gcHJvZ3Jlc3MsIGVsc2UgbnVsbCAqL1xuICAgICAgICB0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA9IG51bGw7XG4gICAgICAgIHRoaXMud2FpdGluZ0ZvclRva2VuUmVxdWVzdCA9IG51bGw7XG4gICAgICAgIGlmICh1c2VUb2tlbkF1dGgob3B0aW9ucykpIHtcbiAgICAgICAgICAgIC8qIFRva2VuIGF1dGggKi9cbiAgICAgICAgICAgIGlmIChvcHRpb25zLmtleSAmJiAhaG1hYykge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnY2xpZW50LXNpZGUgdG9rZW4gcmVxdWVzdCBzaWduaW5nIG5vdCBzdXBwb3J0ZWQnO1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQXV0aCgpJywgbXNnKTtcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IobXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChub1dheVRvUmVuZXcob3B0aW9ucykpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0F1dGgoKScsICdXYXJuaW5nOiBsaWJyYXJ5IGluaXRpYWxpemVkIHdpdGggYSB0b2tlbiBsaXRlcmFsIHdpdGhvdXQgYW55IHdheSB0byByZW5ldyB0aGUgdG9rZW4gd2hlbiBpdCBleHBpcmVzIChubyBhdXRoVXJsLCBhdXRoQ2FsbGJhY2ssIG9yIGtleSkuIFNlZSBodHRwczovL2hlbHAuYWJseS5pby9lcnJvci80MDE3MSBmb3IgaGVscCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5fc2F2ZVRva2VuT3B0aW9ucyhvcHRpb25zLmRlZmF1bHRUb2tlblBhcmFtcywgb3B0aW9ucyk7XG4gICAgICAgICAgICBsb2dBbmRWYWxpZGF0ZVRva2VuQXV0aE1ldGhvZCh0aGlzLmF1dGhPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIEJhc2ljIGF1dGggKi9cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZXkpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ05vIGF1dGhlbnRpY2F0aW9uIG9wdGlvbnMgcHJvdmlkZWQ7IG5lZWQgb25lIG9mOiBrZXksIGF1dGhVcmwsIG9yIGF1dGhDYWxsYmFjayAob3IgZm9yIHRlc3Rpbmcgb25seSwgdG9rZW4gb3IgdG9rZW5EZXRhaWxzKSc7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdBdXRoKCknLCBtc2cpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgNDAxNjAsIDQwMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0F1dGgoKScsICdhbm9ueW1vdXMsIHVzaW5nIGJhc2ljIGF1dGgnKTtcbiAgICAgICAgICAgIHRoaXMuX3NhdmVCYXNpY09wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9XG4gICAgQXV0aC5wcm90b3R5cGUuYXV0aG9yaXplID0gZnVuY3Rpb24gKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hdXRoT3B0aW9ucztcbiAgICAgICAgLyogc2h1ZmZsZSBhbmQgbm9ybWFsaXNlIGFyZ3VtZW50cyBhcyBuZWNlc3NhcnkgKi9cbiAgICAgICAgaWYgKHR5cGVvZiB0b2tlblBhcmFtcyA9PSAnZnVuY3Rpb24nICYmICFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSB0b2tlblBhcmFtcztcbiAgICAgICAgICAgIF9hdXRoT3B0aW9ucyA9IHRva2VuUGFyYW1zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXV0aE9wdGlvbnMgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYXV0aE9wdGlvbnM7XG4gICAgICAgICAgICBfYXV0aE9wdGlvbnMgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2F1dGhPcHRpb25zID0gYXV0aE9wdGlvbnM7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2xpZW50Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdhdXRob3JpemUnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIFJTQTEwYTogYXV0aG9yaXplKCkgY2FsbCBpbXBsaWVzIHRva2VuIGF1dGguIElmIGEga2V5IGlzIHBhc3NlZCBpdCwgd2VcbiAgICAgICAgICoganVzdCBjaGVjayBpZiBpdCBkb2Vzbid0IGNsYXNoIGFuZCBhc3N1bWUgd2UncmUgZ2VuZXJhdGluZyBhIHRva2VuIGZyb20gaXQgKi9cbiAgICAgICAgaWYgKF9hdXRoT3B0aW9ucyAmJiBfYXV0aE9wdGlvbnMua2V5ICYmIHRoaXMuYXV0aE9wdGlvbnMua2V5ICE9PSBfYXV0aE9wdGlvbnMua2V5KSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVW5hYmxlIHRvIHVwZGF0ZSBhdXRoIG9wdGlvbnMgd2l0aCBpbmNvbXBhdGlibGUga2V5JywgNDAxMDIsIDQwMSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKF9hdXRoT3B0aW9ucyAmJiAnZm9yY2UnIGluIF9hdXRoT3B0aW9ucykge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdBdXRoLmF1dGhvcml6ZScsICdEZXByZWNhdGlvbiB3YXJuaW5nOiBzcGVjaWZ5aW5nIHtmb3JjZTogdHJ1ZX0gaW4gYXV0aE9wdGlvbnMgaXMgbm8gbG9uZ2VyIG5lY2Vzc2FyeSwgYXV0aG9yaXplKCkgbm93IGFsd2F5cyBnZXRzIGEgbmV3IHRva2VuLiBQbGVhc2UgcmVtb3ZlIHRoaXMsIGFzIGluIHZlcnNpb24gMS4wIGFuZCBsYXRlciwgaGF2aW5nIGEgbm9uLW51bGwgYXV0aE9wdGlvbnMgd2lsbCBvdmVyd3JpdGUgc3RvcmVkIGxpYnJhcnkgYXV0aE9wdGlvbnMsIHdoaWNoIG1heSBub3QgYmUgd2hhdCB5b3Ugd2FudCcpO1xuICAgICAgICAgICAgLyogRW11bGF0ZSB0aGUgb2xkIGJlaGF2aW91cjogaWYgJ2ZvcmNlJyB3YXMgdGhlIG9ubHkgbWVtYmVyIG9mIGF1dGhPcHRpb25zLFxuICAgICAgICAgICAgICogc2V0IGl0IHRvIG51bGwgc28gaXQgZG9lc24ndCBvdmVyd3JpdGUgc3RvcmVkLiBUT0RPOiByZW1vdmUgaW4gdmVyc2lvbiAxLjAgKi9cbiAgICAgICAgICAgIGlmIChVdGlscy5pc09ubHlQcm9wSW4oX2F1dGhPcHRpb25zLCAnZm9yY2UnKSkge1xuICAgICAgICAgICAgICAgIF9hdXRoT3B0aW9ucyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5fZm9yY2VOZXdUb2tlbih0b2tlblBhcmFtcywgX2F1dGhPcHRpb25zLCBmdW5jdGlvbiAoZXJyLCB0b2tlbkRldGFpbHMpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoX3RoaXMuY2xpZW50LmNvbm5lY3Rpb24gJiYgZXJyLnN0YXR1c0NvZGUgPT09IEh0dHBTdGF0dXNDb2Rlc18xLmRlZmF1bHQuRm9yYmlkZGVuKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIFBlciBSU0E0ZCAmIFJTQTRkMSwgaWYgdGhlIGF1dGggc2VydmVyIGV4cGxpY2l0bHkgcmVwdWRpYXRlcyBvdXIgcmlnaHQgdG9cbiAgICAgICAgICAgICAgICAgICAgICogc3RheSBjb25uZWN0aWNlZCBieSByZXR1cm5pbmcgYSA0MDMsIHdlIGFjdGl2ZWx5IGRpc2Nvbm5lY3QgdGhlIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAgICAgICAgICogZXZlbiB0aG91Z2ggd2UgbWF5IHdlbGwgc3RpbGwgaGF2ZSB0aW1lIGxlZnQgaW4gdGhlIG9sZCB0b2tlbi4gKi9cbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY2xpZW50LmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIuYWN0T25FcnJvckZyb21BdXRob3JpemUoZXJyKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogUlRDOFxuICAgICAgICAgICAgICogLSBXaGVuIGF1dGhvcml6ZSBjYWxsZWQgYnkgYW4gZW5kIHVzZXIgYW5kIGhhdmUgYSByZWFsdGltZSBjb25uZWN0aW9uLFxuICAgICAgICAgICAgICogZG9uJ3QgY2FsbCBiYWNrIHRpbGwgbmV3IHRva2VuIGhhcyB0YWtlbiBlZmZlY3QuXG4gICAgICAgICAgICAgKiAtIFVzZSB0aGlzLmNsaWVudC5jb25uZWN0aW9uIGFzIGEgcHJveHkgZm9yICh0aGlzLmNsaWVudCBpbnN0YW5jZW9mIFJlYWx0aW1lKSxcbiAgICAgICAgICAgICAqIHdoaWNoIGRvZXNuJ3Qgd29yayBpbiBub2RlIGFzIFJlYWx0aW1lIGlzbid0IHBhcnQgb2YgdGhlIHZtIGNvbnRleHQgZm9yIFJlc3QgY2xpZW50cyAqL1xuICAgICAgICAgICAgaWYgKGlzUmVhbHRpbWUoX3RoaXMuY2xpZW50KSkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNsaWVudC5jb25uZWN0aW9uLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQodG9rZW5EZXRhaWxzLCBjYWxsYmFjayB8fCBub29wKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhudWxsLCB0b2tlbkRldGFpbHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEF1dGgucHJvdG90eXBlLmF1dGhvcmlzZSA9IGZ1bmN0aW9uICh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZGVwcmVjYXRlZCgnQXV0aC5hdXRob3Jpc2UnLCAnQXV0aC5hdXRob3JpemUnKTtcbiAgICAgICAgdGhpcy5hdXRob3JpemUodG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICAvKiBGb3IgaW50ZXJuYWwgdXNlLCBlZyBieSBjb25uZWN0aW9uTWFuYWdlciAtIHVzZWZ1bCB3aGVuIHdhbnQgdG8gY2FsbCBiYWNrXG4gICAgICogYXMgc29vbiBhcyB3ZSBoYXZlIHRoZSBuZXcgdG9rZW4sIHJhdGhlciB0aGFuIHdhaXRpbmcgZm9yIGl0IHRvIHRha2VcbiAgICAgKiBlZmZlY3Qgb24gdGhlIGNvbm5lY3Rpb24gYXMgI2F1dGhvcml6ZSBkb2VzICovXG4gICAgQXV0aC5wcm90b3R5cGUuX2ZvcmNlTmV3VG9rZW4gPSBmdW5jdGlvbiAodG9rZW5QYXJhbXMsIGF1dGhPcHRpb25zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiBnZXQgcmlkIG9mIGN1cnJlbnQgdG9rZW4gZXZlbiBpZiBzdGlsbCB2YWxpZCAqL1xuICAgICAgICB0aGlzLnRva2VuRGV0YWlscyA9IG51bGw7XG4gICAgICAgIC8qIF9zYXZlIG5vcm1hbGlzZXMgdGhlIHRva2VuUGFyYW1zIGFuZCBhdXRoT3B0aW9ucyBhbmQgdXBkYXRlcyB0aGUgYXV0aFxuICAgICAgICAgKiBvYmplY3QuIEFsbCBzdWJzZXF1ZW50IG9wZXJhdGlvbnMgc2hvdWxkIHVzZSB0aGUgdmFsdWVzIG9uIGB0aGlzYCxcbiAgICAgICAgICogbm90IHRoZSBwYXNzZWQgaW4gb25lcy4gKi9cbiAgICAgICAgdGhpcy5fc2F2ZVRva2VuT3B0aW9ucyh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMpO1xuICAgICAgICBsb2dBbmRWYWxpZGF0ZVRva2VuQXV0aE1ldGhvZCh0aGlzLmF1dGhPcHRpb25zKTtcbiAgICAgICAgdGhpcy5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHModHJ1ZSwgZnVuY3Rpb24gKGVyciwgdG9rZW5EZXRhaWxzKSB7XG4gICAgICAgICAgICAvKiBSU0ExMGcgKi9cbiAgICAgICAgICAgIGRlbGV0ZSBfdGhpcy50b2tlblBhcmFtcy50aW1lc3RhbXA7XG4gICAgICAgICAgICBkZWxldGUgX3RoaXMuYXV0aE9wdGlvbnMucXVlcnlUaW1lO1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCB0b2tlbkRldGFpbHMpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIEF1dGgucHJvdG90eXBlLnJlcXVlc3RUb2tlbiA9IGZ1bmN0aW9uICh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qIHNodWZmbGUgYW5kIG5vcm1hbGlzZSBhcmd1bWVudHMgYXMgbmVjZXNzYXJ5ICovXG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW5QYXJhbXMgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdG9rZW5QYXJhbXM7XG4gICAgICAgICAgICBhdXRoT3B0aW9ucyA9IHRva2VuUGFyYW1zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXV0aE9wdGlvbnMgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYXV0aE9wdGlvbnM7XG4gICAgICAgICAgICBhdXRoT3B0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYWxsYmFjayAmJiB0aGlzLmNsaWVudC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdyZXF1ZXN0VG9rZW4nLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qIFJTQThlOiBpZiBhdXRoT3B0aW9ucyBwYXNzZWQgaW4sIHRoZXkncmUgdXNlZCBpbnN0ZWFkIG9mIHN0b3JlZCwgZG9uJ3QgbWVyZ2UgdGhlbSAqL1xuICAgICAgICBhdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zIHx8IHRoaXMuYXV0aE9wdGlvbnM7XG4gICAgICAgIHRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXMgfHwgVXRpbHMuY29weSh0aGlzLnRva2VuUGFyYW1zKTtcbiAgICAgICAgdmFyIF9jYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gICAgICAgIC8qIGZpcnN0IHNldCB1cCB3aGF0ZXZlciBjYWxsYmFjayB3aWxsIGJlIHVzZWQgdG8gZ2V0IHNpZ25lZFxuICAgICAgICAgKiB0b2tlbiByZXF1ZXN0cyAqL1xuICAgICAgICB2YXIgdG9rZW5SZXF1ZXN0Q2FsbGJhY2ssIGNsaWVudCA9IHRoaXMuY2xpZW50O1xuICAgICAgICBpZiAoYXV0aE9wdGlvbnMuYXV0aENhbGxiYWNrKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGF1dGhDYWxsYmFjaycpO1xuICAgICAgICAgICAgdG9rZW5SZXF1ZXN0Q2FsbGJhY2sgPSBhdXRoT3B0aW9ucy5hdXRoQ2FsbGJhY2s7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXV0aE9wdGlvbnMuYXV0aFVybCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgJ3VzaW5nIHRva2VuIGF1dGggd2l0aCBhdXRoVXJsJyk7XG4gICAgICAgICAgICB0b2tlblJlcXVlc3RDYWxsYmFjayA9IGZ1bmN0aW9uIChwYXJhbXMsIGNiKSB7XG4gICAgICAgICAgICAgICAgdmFyIGF1dGhIZWFkZXJzID0gVXRpbHMubWl4aW4oeyBhY2NlcHQ6ICdhcHBsaWNhdGlvbi9qc29uLCB0ZXh0L3BsYWluJyB9LCBhdXRoT3B0aW9ucy5hdXRoSGVhZGVycyk7XG4gICAgICAgICAgICAgICAgdmFyIHVzZVBvc3QgPSBhdXRoT3B0aW9ucy5hdXRoTWV0aG9kICYmIGF1dGhPcHRpb25zLmF1dGhNZXRob2QudG9Mb3dlckNhc2UoKSA9PT0gJ3Bvc3QnO1xuICAgICAgICAgICAgICAgIHZhciBwcm92aWRlZFFzUGFyYW1zO1xuICAgICAgICAgICAgICAgIC8qIENvbWJpbmUgYXV0aFBhcmFtcyB3aXRoIGFueSBxcyBwYXJhbXMgZ2l2ZW4gaW4gdGhlIGF1dGhVcmwgKi9cbiAgICAgICAgICAgICAgICB2YXIgcXVlcnlJZHggPSBhdXRoT3B0aW9ucy5hdXRoVXJsLmluZGV4T2YoJz8nKTtcbiAgICAgICAgICAgICAgICBpZiAocXVlcnlJZHggPiAtMSkge1xuICAgICAgICAgICAgICAgICAgICBwcm92aWRlZFFzUGFyYW1zID0gVXRpbHMucGFyc2VRdWVyeVN0cmluZyhhdXRoT3B0aW9ucy5hdXRoVXJsLnNsaWNlKHF1ZXJ5SWR4KSk7XG4gICAgICAgICAgICAgICAgICAgIGF1dGhPcHRpb25zLmF1dGhVcmwgPSBhdXRoT3B0aW9ucy5hdXRoVXJsLnNsaWNlKDAsIHF1ZXJ5SWR4KTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCF1c2VQb3N0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBJbiBjYXNlIG9mIGNvbmZsaWN0LCBhdXRoUGFyYW1zIHRha2UgcHJlY2VkZW5jZSBvdmVyIHFzIHBhcmFtcyBpbiB0aGUgYXV0aFVybCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgYXV0aE9wdGlvbnMuYXV0aFBhcmFtcyA9IFV0aWxzLm1peGluKHByb3ZpZGVkUXNQYXJhbXMsIGF1dGhPcHRpb25zLmF1dGhQYXJhbXMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIFJTQThjMiAqL1xuICAgICAgICAgICAgICAgIHZhciBhdXRoUGFyYW1zID0gVXRpbHMubWl4aW4oe30sIGF1dGhPcHRpb25zLmF1dGhQYXJhbXMgfHwge30sIHBhcmFtcyk7XG4gICAgICAgICAgICAgICAgdmFyIGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgY29udGVudFR5cGU7XG4gICAgICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKS50b2tlblJlcXVlc3RDYWxsYmFjaycsICdSZWNlaXZlZCBFcnJvcjogJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlID0gaGVhZGVyc1snY29udGVudC10eXBlJ107XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0F1dGgucmVxdWVzdFRva2VuKCkudG9rZW5SZXF1ZXN0Q2FsbGJhY2snLCAnUmVjZWl2ZWQ7IGNvbnRlbnQtdHlwZTogJyArIGNvbnRlbnRUeXBlICsgJzsgYm9keTogJyArIFV0aWxzLmluc3BlY3RCb2R5KGJvZHkpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyIHx8IHVucGFja2VkKVxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGNiKGVyciwgYm9keSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChwbGF0Zm9ybV8xLmRlZmF1bHQuQnVmZmVyVXRpbHMuaXNCdWZmZXIoYm9keSkpXG4gICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gYm9keS50b1N0cmluZygpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYihuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnYXV0aFVybCByZXNwb25zZSBpcyBtaXNzaW5nIGEgY29udGVudC10eXBlIGhlYWRlcicsIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB2YXIganNvbiA9IGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2pzb24nKSA+IC0xLCB0ZXh0ID0gY29udGVudFR5cGUuaW5kZXhPZigndGV4dC9wbGFpbicpID4gLTEgfHwgY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vand0JykgPiAtMTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFqc29uICYmICF0ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYihuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnYXV0aFVybCByZXNwb25kZWQgd2l0aCB1bmFjY2VwdGFibGUgY29udGVudC10eXBlICcgK1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRlbnRUeXBlICtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAnLCBzaG91bGQgYmUgZWl0aGVyIHRleHQvcGxhaW4sIGFwcGxpY2F0aW9uL2p3dCBvciBhcHBsaWNhdGlvbi9qc29uJywgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChqc29uKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoYm9keS5sZW5ndGggPiBNQVhfVE9LRU5fTEVOR1RIKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ2F1dGhVcmwgcmVzcG9uc2UgZXhjZWVkZWQgbWF4IHBlcm1pdHRlZCBsZW5ndGgnLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBib2R5ID0gSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2IobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1VuZXhwZWN0ZWQgZXJyb3IgcHJvY2Vzc2luZyBhdXRoVVJMIHJlc3BvbnNlOyBlcnIgPSAnICsgZS5tZXNzYWdlLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNiKG51bGwsIGJvZHksIGNvbnRlbnRUeXBlKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKS50b2tlblJlcXVlc3RDYWxsYmFjaycsICdSZXF1ZXN0aW5nIHRva2VuIGZyb20gJyArXG4gICAgICAgICAgICAgICAgICAgIGF1dGhPcHRpb25zLmF1dGhVcmwgK1xuICAgICAgICAgICAgICAgICAgICAnOyBQYXJhbXM6ICcgK1xuICAgICAgICAgICAgICAgICAgICBKU09OLnN0cmluZ2lmeShhdXRoUGFyYW1zKSArXG4gICAgICAgICAgICAgICAgICAgICc7IG1ldGhvZDogJyArXG4gICAgICAgICAgICAgICAgICAgICh1c2VQb3N0ID8gJ1BPU1QnIDogJ0dFVCcpKTtcbiAgICAgICAgICAgICAgICBpZiAodXNlUG9zdCkge1xuICAgICAgICAgICAgICAgICAgICAvKiBzZW5kIGJvZHkgZm9ybS1lbmNvZGVkICovXG4gICAgICAgICAgICAgICAgICAgIHZhciBoZWFkZXJzID0gYXV0aEhlYWRlcnMgfHwge307XG4gICAgICAgICAgICAgICAgICAgIGhlYWRlcnNbJ2NvbnRlbnQtdHlwZSddID0gJ2FwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCc7XG4gICAgICAgICAgICAgICAgICAgIHZhciBib2R5ID0gVXRpbHMudG9RdWVyeVN0cmluZyhhdXRoUGFyYW1zKS5zbGljZSgxKTsgLyogc2xpY2UgaXMgdG8gcmVtb3ZlIHRoZSBpbml0aWFsICc/JyAqL1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jbGllbnQuaHR0cC5kb1VyaShIdHRwTWV0aG9kc18xLmRlZmF1bHQuUG9zdCwgY2xpZW50LCBhdXRoT3B0aW9ucy5hdXRoVXJsLCBoZWFkZXJzLCBib2R5LCBwcm92aWRlZFFzUGFyYW1zLCBhdXRoVXJsUmVxdWVzdENhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNsaWVudC5odHRwLmRvVXJpKEh0dHBNZXRob2RzXzEuZGVmYXVsdC5HZXQsIGNsaWVudCwgYXV0aE9wdGlvbnMuYXV0aFVybCwgYXV0aEhlYWRlcnMgfHwge30sIG51bGwsIGF1dGhQYXJhbXMsIGF1dGhVcmxSZXF1ZXN0Q2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoYXV0aE9wdGlvbnMua2V5KSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCAndXNpbmcgdG9rZW4gYXV0aCB3aXRoIGNsaWVudC1zaWRlIHNpZ25pbmcnKTtcbiAgICAgICAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrID0gZnVuY3Rpb24gKHBhcmFtcywgY2IpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5jcmVhdGVUb2tlblJlcXVlc3QocGFyYW1zLCBhdXRoT3B0aW9ucywgY2IpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnTmVlZCBhIG5ldyB0b2tlbiwgYnV0IGF1dGhPcHRpb25zIGRvZXMgbm90IGluY2x1ZGUgYW55IHdheSB0byByZXF1ZXN0IG9uZSAobm8gYXV0aFVybCwgYXV0aENhbGxiYWNrLCBvciBrZXkpJztcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQXV0aCgpJywgJ2xpYnJhcnkgaW5pdGlhbGl6ZWQgd2l0aCBhIHRva2VuIGxpdGVyYWwgd2l0aG91dCBhbnkgd2F5IHRvIHJlbmV3IHRoZSB0b2tlbiB3aGVuIGl0IGV4cGlyZXMgKG5vIGF1dGhVcmwsIGF1dGhDYWxsYmFjaywgb3Iga2V5KS4gU2VlIGh0dHBzOi8vaGVscC5hYmx5LmlvL2Vycm9yLzQwMTcxIGZvciBoZWxwJyk7XG4gICAgICAgICAgICBfY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQobXNnLCA0MDE3MSwgNDAzKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyogbm9ybWFsaXNlIHRva2VuIHBhcmFtcyAqL1xuICAgICAgICBpZiAoJ2NhcGFiaWxpdHknIGluIHRva2VuUGFyYW1zKVxuICAgICAgICAgICAgdG9rZW5QYXJhbXMuY2FwYWJpbGl0eSA9IGMxNG4odG9rZW5QYXJhbXMuY2FwYWJpbGl0eSk7XG4gICAgICAgIHZhciB0b2tlblJlcXVlc3QgPSBmdW5jdGlvbiAoc2lnbmVkVG9rZW5QYXJhbXMsIHRva2VuQ2IpIHtcbiAgICAgICAgICAgIHZhciBrZXlOYW1lID0gc2lnbmVkVG9rZW5QYXJhbXMua2V5TmFtZSwgcGF0aCA9ICcva2V5cy8nICsga2V5TmFtZSArICcvcmVxdWVzdFRva2VuJywgdG9rZW5VcmkgPSBmdW5jdGlvbiAoaG9zdCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBjbGllbnQuYmFzZVVyaShob3N0KSArIHBhdGg7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gVXRpbHMuZGVmYXVsdFBvc3RIZWFkZXJzKF90aGlzLmNsaWVudC5vcHRpb25zKTtcbiAgICAgICAgICAgIGlmIChhdXRoT3B0aW9ucy5yZXF1ZXN0SGVhZGVycylcbiAgICAgICAgICAgICAgICBVdGlscy5taXhpbihyZXF1ZXN0SGVhZGVycywgYXV0aE9wdGlvbnMucmVxdWVzdEhlYWRlcnMpO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdBdXRoLnJlcXVlc3RUb2tlbigpLnJlcXVlc3RUb2tlbicsICdTZW5kaW5nIFBPU1QgdG8gJyArIHBhdGggKyAnOyBUb2tlbiBwYXJhbXM6ICcgKyBKU09OLnN0cmluZ2lmeShzaWduZWRUb2tlblBhcmFtcykpO1xuICAgICAgICAgICAgX3RoaXMuY2xpZW50Lmh0dHAuZG8oSHR0cE1ldGhvZHNfMS5kZWZhdWx0LlBvc3QsIGNsaWVudCwgdG9rZW5VcmksIHJlcXVlc3RIZWFkZXJzLCBKU09OLnN0cmluZ2lmeShzaWduZWRUb2tlblBhcmFtcyksIG51bGwsIHRva2VuQ2IpO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgdG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0RXhwaXJlZCA9IGZhbHNlLCB0aW1lb3V0TGVuZ3RoID0gdGhpcy5jbGllbnQub3B0aW9ucy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0LCB0b2tlblJlcXVlc3RDYWxsYmFja1RpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrVGltZW91dEV4cGlyZWQgPSB0cnVlO1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdUb2tlbiByZXF1ZXN0IGNhbGxiYWNrIHRpbWVkIG91dCBhZnRlciAnICsgdGltZW91dExlbmd0aCAvIDEwMDAgKyAnIHNlY29uZHMnO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgbXNnKTtcbiAgICAgICAgICAgIF9jYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgfSwgdGltZW91dExlbmd0aCk7XG4gICAgICAgIHRva2VuUmVxdWVzdENhbGxiYWNrKHRva2VuUGFyYW1zLCBmdW5jdGlvbiAoZXJyLCB0b2tlblJlcXVlc3RPckRldGFpbHMsIGNvbnRlbnRUeXBlKSB7XG4gICAgICAgICAgICBpZiAodG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0RXhwaXJlZClcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodG9rZW5SZXF1ZXN0Q2FsbGJhY2tUaW1lb3V0KTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCAndG9rZW4gcmVxdWVzdCBzaWduaW5nIGNhbGwgcmV0dXJuZWQgZXJyb3I7IGVyciA9ICcgKyBVdGlscy5pbnNwZWN0RXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgX2NhbGxiYWNrKG5vcm1hbGlzZUF1dGhjYWxsYmFja0Vycm9yKGVycikpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIHRoZSByZXNwb25zZSBmcm9tIHRoZSBjYWxsYmFjayBtaWdodCBiZSBhIHRva2VuIHN0cmluZywgYSBzaWduZWQgcmVxdWVzdCBvciBhIHRva2VuIGRldGFpbHMgKi9cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzID09PSAnc3RyaW5nJykge1xuICAgICAgICAgICAgICAgIGlmICh0b2tlblJlcXVlc3RPckRldGFpbHMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVG9rZW4gc3RyaW5nIGlzIGVtcHR5JywgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlblJlcXVlc3RPckRldGFpbHMubGVuZ3RoID4gTUFYX1RPS0VOX0xFTkdUSCkge1xuICAgICAgICAgICAgICAgICAgICBfY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1Rva2VuIHN0cmluZyBleGNlZWRlZCBtYXggcGVybWl0dGVkIGxlbmd0aCAod2FzICcgKyB0b2tlblJlcXVlc3RPckRldGFpbHMubGVuZ3RoICsgJyBieXRlcyknLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHRva2VuUmVxdWVzdE9yRGV0YWlscyA9PT0gJ3VuZGVmaW5lZCcgfHwgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzID09PSAnbnVsbCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogY29tbW9uIGZhaWx1cmUgbW9kZSB3aXRoIHBvb3JseS1pbXBsZW1lbnRlZCBhdXRoQ2FsbGJhY2tzICovXG4gICAgICAgICAgICAgICAgICAgIF9jYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVG9rZW4gc3RyaW5nIHdhcyBsaXRlcmFsIG51bGwvdW5kZWZpbmVkJywgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0b2tlblJlcXVlc3RPckRldGFpbHNbMF0gPT09ICd7JyAmJiAhKGNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL2p3dCcpID4gLTEpKSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChcIlRva2VuIHdhcyBkb3VibGUtZW5jb2RlZDsgbWFrZSBzdXJlIHlvdSdyZSBub3QgSlNPTi1lbmNvZGluZyBhbiBhbHJlYWR5IGVuY29kZWQgdG9rZW4gcmVxdWVzdCBvciBkZXRhaWxzXCIsIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIF9jYWxsYmFjayhudWxsLCB7IHRva2VuOiB0b2tlblJlcXVlc3RPckRldGFpbHMgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICh0eXBlb2YgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzICE9PSAnb2JqZWN0Jykge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnRXhwZWN0ZWQgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayB0byBjYWxsIGJhY2sgd2l0aCBhIHRva2VuIHN0cmluZyBvciB0b2tlbiByZXF1ZXN0L2RldGFpbHMgb2JqZWN0LCBidXQgZ290IGEgJyArXG4gICAgICAgICAgICAgICAgICAgIHR5cGVvZiB0b2tlblJlcXVlc3RPckRldGFpbHM7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdBdXRoLnJlcXVlc3RUb2tlbigpJywgbXNnKTtcbiAgICAgICAgICAgICAgICBfY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQobXNnLCA0MDE3MCwgNDAxKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIG9iamVjdFNpemUgPSBKU09OLnN0cmluZ2lmeSh0b2tlblJlcXVlc3RPckRldGFpbHMpLmxlbmd0aDtcbiAgICAgICAgICAgIGlmIChvYmplY3RTaXplID4gTUFYX1RPS0VOX0xFTkdUSCAmJiAhYXV0aE9wdGlvbnMuc3VwcHJlc3NNYXhMZW5ndGhDaGVjaykge1xuICAgICAgICAgICAgICAgIF9jYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVG9rZW4gcmVxdWVzdC9kZXRhaWxzIG9iamVjdCBleGNlZWRlZCBtYXggcGVybWl0dGVkIHN0cmluZ2lmaWVkIHNpemUgKHdhcyAnICsgb2JqZWN0U2l6ZSArICcgYnl0ZXMpJywgNDAxNzAsIDQwMSkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICgnaXNzdWVkJyBpbiB0b2tlblJlcXVlc3RPckRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAvKiBhIHRva2VuRGV0YWlscyBvYmplY3QgKi9cbiAgICAgICAgICAgICAgICBfY2FsbGJhY2sobnVsbCwgdG9rZW5SZXF1ZXN0T3JEZXRhaWxzKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoISgna2V5TmFtZScgaW4gdG9rZW5SZXF1ZXN0T3JEZXRhaWxzKSkge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnRXhwZWN0ZWQgdG9rZW4gcmVxdWVzdCBjYWxsYmFjayB0byBjYWxsIGJhY2sgd2l0aCBhIHRva2VuIHN0cmluZywgdG9rZW4gcmVxdWVzdCBvYmplY3QsIG9yIHRva2VuIGRldGFpbHMgb2JqZWN0JztcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0F1dGgucmVxdWVzdFRva2VuKCknLCBtc2cpO1xuICAgICAgICAgICAgICAgIF9jYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDQwMTcwLCA0MDEpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBpdCdzIGEgdG9rZW4gcmVxdWVzdCwgc28gbWFrZSB0aGUgcmVxdWVzdCAqL1xuICAgICAgICAgICAgdG9rZW5SZXF1ZXN0KHRva2VuUmVxdWVzdE9yRGV0YWlscywgZnVuY3Rpb24gKGVyciwgdG9rZW5SZXNwb25zZSwgaGVhZGVycywgdW5wYWNrZWQpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQXV0aC5yZXF1ZXN0VG9rZW4oKScsICd0b2tlbiByZXF1ZXN0IEFQSSBjYWxsIHJldHVybmVkIGVycm9yOyBlcnIgPSAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGVycikpO1xuICAgICAgICAgICAgICAgICAgICBfY2FsbGJhY2sobm9ybWFsaXNlQXV0aGNhbGxiYWNrRXJyb3IoZXJyKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF1bnBhY2tlZClcbiAgICAgICAgICAgICAgICAgICAgdG9rZW5SZXNwb25zZSA9IEpTT04ucGFyc2UodG9rZW5SZXNwb25zZSk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdBdXRoLmdldFRva2VuKCknLCAndG9rZW4gcmVjZWl2ZWQnKTtcbiAgICAgICAgICAgICAgICBfY2FsbGJhY2sobnVsbCwgdG9rZW5SZXNwb25zZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDcmVhdGUgYW5kIHNpZ24gYSB0b2tlbiByZXF1ZXN0IGJhc2VkIG9uIHRoZSBnaXZlbiBvcHRpb25zLlxuICAgICAqIE5PVEUgdGhpcyBjYW4gb25seSBiZSB1c2VkIHdoZW4gdGhlIGtleSB2YWx1ZSBpcyBhdmFpbGFibGUgbG9jYWxseS5cbiAgICAgKiBPdGhlcndpc2UsIHNpZ25lZCB0b2tlbiByZXF1ZXN0cyBtdXN0IGJlIG9idGFpbmVkIGZyb20gdGhlIGtleVxuICAgICAqIG93bmVyIChlaXRoZXIgdXNpbmcgdGhlIHRva2VuIHJlcXVlc3QgY2FsbGJhY2sgb3IgdXJsKS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBhdXRoT3B0aW9uc1xuICAgICAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSByZXF1ZXN0IG9wdGlvbnM6XG4gICAgICogLSBrZXk6ICAgICAgICAgICB0aGUga2V5IHRvIHVzZS4gSWYgbm90IHNwZWNpZmllZCwgYSBrZXkgcGFzc2VkIGluIGNvbnN0cnVjdGluZ1xuICAgICAqICAgICAgICAgICAgICAgICAgdGhlIFJlc3QgaW50ZXJmYWNlIHdpbGwgYmUgdXNlZFxuICAgICAqXG4gICAgICogLSBxdWVyeVRpbWUgICAgICAob3B0aW9uYWwpIGJvb2xlYW4gaW5kaWNhdGluZyB0aGF0IHRoZSBhYmx5IHN5c3RlbSBzaG91bGQgYmVcbiAgICAgKiAgICAgICAgICAgICAgICAgIHF1ZXJpZWQgZm9yIHRoZSBjdXJyZW50IHRpbWUgd2hlbiBub25lIGlzIHNwZWNpZmllZCBleHBsaWNpdGx5XG4gICAgICpcbiAgICAgKiAtIHJlcXVlc3RIZWFkZXJzIChvcHRpb25hbCwgdW5zdXBwb3J0ZWQsIGZvciB0ZXN0aW5nIG9ubHkpIGV4dHJhIGhlYWRlcnMgdG8gYWRkIHRvIHRoZVxuICAgICAqICAgICAgICAgICAgICAgICAgcmVxdWVzdFRva2VuIHJlcXVlc3RcbiAgICAgKlxuICAgICAqIEBwYXJhbSB0b2tlblBhcmFtc1xuICAgICAqIGFuIG9iamVjdCBjb250YWluaW5nIHRoZSBwYXJhbWV0ZXJzIGZvciB0aGUgcmVxdWVzdGVkIHRva2VuOlxuICAgICAqIC0gdHRsOiAgICAgICAob3B0aW9uYWwpIHRoZSByZXF1ZXN0ZWQgbGlmZSBvZiB0aGUgdG9rZW4gaW4gbXMuIElmIG5vbmUgaXMgc3BlY2lmaWVkXG4gICAgICogICAgICAgICAgICAgICAgICBhIGRlZmF1bHQgb2YgMSBob3VyIGlzIHByb3ZpZGVkLiBUaGUgbWF4aW11bSBsaWZldGltZSBpcyAyNGhvdXJzOyBhbnkgcmVxdWVzdFxuICAgICAqICAgICAgICAgICAgICAgICAgZXhjZWVkaW5nIHRoYXQgbGlmZXRpbWUgd2lsbCBiZSByZWplY3RlZCB3aXRoIGFuIGVycm9yLlxuICAgICAqXG4gICAgICogLSBjYXBhYmlsaXR5OiAgICAob3B0aW9uYWwpIHRoZSBjYXBhYmlsaXR5IHRvIGFzc29jaWF0ZSB3aXRoIHRoZSBhY2Nlc3MgdG9rZW4uXG4gICAgICogICAgICAgICAgICAgICAgICBJZiBub25lIGlzIHNwZWNpZmllZCwgYSB0b2tlbiB3aWxsIGJlIHJlcXVlc3RlZCB3aXRoIGFsbCBvZiB0aGVcbiAgICAgKiAgICAgICAgICAgICAgICAgIGNhcGFiaWxpdGllcyBvZiB0aGUgc3BlY2lmaWVkIGtleS5cbiAgICAgKlxuICAgICAqIC0gY2xpZW50SWQ6ICAgICAgKG9wdGlvbmFsKSBhIGNsaWVudCBJRCB0byBhc3NvY2lhdGUgd2l0aCB0aGUgdG9rZW47IGlmIG5vdFxuICAgICAqICAgICAgICAgICAgICAgICAgc3BlY2lmaWVkLCBhIGNsaWVudElkIHBhc3NlZCBpbiBjb25zdHJ1Y3RpbmcgdGhlIFJlc3QgaW50ZXJmYWNlIHdpbGwgYmUgdXNlZFxuICAgICAqXG4gICAgICogLSB0aW1lc3RhbXA6ICAgICAob3B0aW9uYWwpIHRoZSB0aW1lIGluIG1zIHNpbmNlIHRoZSBlcG9jaC4gSWYgbm9uZSBpcyBzcGVjaWZpZWQsXG4gICAgICogICAgICAgICAgICAgICAgICB0aGUgc3lzdGVtIHdpbGwgYmUgcXVlcmllZCBmb3IgYSB0aW1lIHZhbHVlIHRvIHVzZS5cbiAgICAgKlxuICAgICAqIEBwYXJhbSBjYWxsYmFja1xuICAgICAqL1xuICAgIEF1dGgucHJvdG90eXBlLmNyZWF0ZVRva2VuUmVxdWVzdCA9IGZ1bmN0aW9uICh0b2tlblBhcmFtcywgYXV0aE9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIC8qIHNodWZmbGUgYW5kIG5vcm1hbGlzZSBhcmd1bWVudHMgYXMgbmVjZXNzYXJ5ICovXG4gICAgICAgIGlmICh0eXBlb2YgdG9rZW5QYXJhbXMgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gdG9rZW5QYXJhbXM7XG4gICAgICAgICAgICBhdXRoT3B0aW9ucyA9IHRva2VuUGFyYW1zID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0eXBlb2YgYXV0aE9wdGlvbnMgPT0gJ2Z1bmN0aW9uJyAmJiAhY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gYXV0aE9wdGlvbnM7XG4gICAgICAgICAgICBhdXRoT3B0aW9ucyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYWxsYmFjayAmJiB0aGlzLmNsaWVudC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdjcmVhdGVUb2tlblJlcXVlc3QnLCBhcmd1bWVudHMpO1xuICAgICAgICB9XG4gICAgICAgIC8qIFJTQTloOiBpZiBhdXRoT3B0aW9ucyBwYXNzZWQgaW4sIHRoZXkncmUgdXNlZCBpbnN0ZWFkIG9mIHN0b3JlZCwgZG9uJ3QgbWVyZ2UgdGhlbSAqL1xuICAgICAgICBhdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zIHx8IHRoaXMuYXV0aE9wdGlvbnM7XG4gICAgICAgIHRva2VuUGFyYW1zID0gdG9rZW5QYXJhbXMgfHwgVXRpbHMuY29weSh0aGlzLnRva2VuUGFyYW1zKTtcbiAgICAgICAgdmFyIGtleSA9IGF1dGhPcHRpb25zLmtleTtcbiAgICAgICAgaWYgKCFrZXkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdObyBrZXkgc3BlY2lmaWVkJywgNDAxMDEsIDQwMykpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBrZXlQYXJ0cyA9IGtleS5zcGxpdCgnOicpLCBrZXlOYW1lID0ga2V5UGFydHNbMF0sIGtleVNlY3JldCA9IGtleVBhcnRzWzFdO1xuICAgICAgICBpZiAoIWtleVNlY3JldCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0ludmFsaWQga2V5IHNwZWNpZmllZCcsIDQwMTAxLCA0MDMpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodG9rZW5QYXJhbXMuY2xpZW50SWQgPT09ICcnKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnY2xpZW50SWQgY2Fu4oCZdCBiZSBhbiBlbXB0eSBzdHJpbmcnLCA0MDAxMiwgNDAwKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdjYXBhYmlsaXR5JyBpbiB0b2tlblBhcmFtcykge1xuICAgICAgICAgICAgdG9rZW5QYXJhbXMuY2FwYWJpbGl0eSA9IGMxNG4odG9rZW5QYXJhbXMuY2FwYWJpbGl0eSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHJlcXVlc3QgPSBVdGlscy5taXhpbih7IGtleU5hbWU6IGtleU5hbWUgfSwgdG9rZW5QYXJhbXMpLCBjbGllbnRJZCA9IHRva2VuUGFyYW1zLmNsaWVudElkIHx8ICcnLCB0dGwgPSB0b2tlblBhcmFtcy50dGwgfHwgJycsIGNhcGFiaWxpdHkgPSB0b2tlblBhcmFtcy5jYXBhYmlsaXR5IHx8ICcnO1xuICAgICAgICAoZnVuY3Rpb24gKGF1dGhvcmlzZUNiKSB7XG4gICAgICAgICAgICBpZiAocmVxdWVzdC50aW1lc3RhbXApIHtcbiAgICAgICAgICAgICAgICBhdXRob3Jpc2VDYigpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLmdldFRpbWVzdGFtcChhdXRoT3B0aW9ucyAmJiBhdXRoT3B0aW9ucy5xdWVyeVRpbWUsIGZ1bmN0aW9uIChlcnIsIHRpbWUpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmVxdWVzdC50aW1lc3RhbXAgPSB0aW1lO1xuICAgICAgICAgICAgICAgIGF1dGhvcmlzZUNiKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSkoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLyogbm9uY2UgKi9cbiAgICAgICAgICAgIC8qIE5PVEU6IHRoZXJlIGlzIG5vIGV4cGVjdGF0aW9uIHRoYXQgdGhlIGNsaWVudFxuICAgICAgICAgICAgICogc3BlY2lmaWVzIHRoZSBub25jZTsgdGhpcyBpcyBkb25lIGJ5IHRoZSBsaWJyYXJ5XG4gICAgICAgICAgICAgKiBIb3dldmVyLCB0aGlzIGNhbiBiZSBvdmVycmlkZGVuIGJ5IHRoZSBjbGllbnRcbiAgICAgICAgICAgICAqIHNpbXBseSBmb3IgdGVzdGluZyBwdXJwb3Nlcy4gKi9cbiAgICAgICAgICAgIHZhciBub25jZSA9IHJlcXVlc3Qubm9uY2UgfHwgKHJlcXVlc3Qubm9uY2UgPSByYW5kb20oKSksIHRpbWVzdGFtcCA9IHJlcXVlc3QudGltZXN0YW1wO1xuICAgICAgICAgICAgdmFyIHNpZ25UZXh0ID0gcmVxdWVzdC5rZXlOYW1lICsgJ1xcbicgKyB0dGwgKyAnXFxuJyArIGNhcGFiaWxpdHkgKyAnXFxuJyArIGNsaWVudElkICsgJ1xcbicgKyB0aW1lc3RhbXAgKyAnXFxuJyArIG5vbmNlICsgJ1xcbic7XG4gICAgICAgICAgICAvKiBtYWMgKi9cbiAgICAgICAgICAgIC8qIE5PVEU6IHRoZXJlIGlzIG5vIGV4cGVjdGF0aW9uIHRoYXQgdGhlIGNsaWVudFxuICAgICAgICAgICAgICogc3BlY2lmaWVzIHRoZSBtYWM7IHRoaXMgaXMgZG9uZSBieSB0aGUgbGlicmFyeVxuICAgICAgICAgICAgICogSG93ZXZlciwgdGhpcyBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgY2xpZW50XG4gICAgICAgICAgICAgKiBzaW1wbHkgZm9yIHRlc3RpbmcgcHVycG9zZXMuICovXG4gICAgICAgICAgICByZXF1ZXN0Lm1hYyA9IHJlcXVlc3QubWFjIHx8IGhtYWMoc2lnblRleHQsIGtleVNlY3JldCk7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0F1dGguZ2V0VG9rZW5SZXF1ZXN0KCknLCAnZ2VuZXJhdGVkIHNpZ25lZCByZXF1ZXN0Jyk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXF1ZXN0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBHZXQgdGhlIGF1dGggcXVlcnkgcGFyYW1zIHRvIHVzZSBmb3IgYSB3ZWJzb2NrZXQgY29ubmVjdGlvbixcbiAgICAgKiBiYXNlZCBvbiB0aGUgY3VycmVudCBhdXRoIHBhcmFtZXRlcnNcbiAgICAgKi9cbiAgICBBdXRoLnByb3RvdHlwZS5nZXRBdXRoUGFyYW1zID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLm1ldGhvZCA9PSAnYmFzaWMnKVxuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeyBrZXk6IHRoaXMua2V5IH0pO1xuICAgICAgICBlbHNlXG4gICAgICAgICAgICB0aGlzLl9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyhmYWxzZSwgZnVuY3Rpb24gKGVyciwgdG9rZW5EZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICghdG9rZW5EZXRhaWxzKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignQXV0aC5nZXRBdXRoUGFyYW1zKCk6IF9lbnN1cmVWYWxpZEF1dGhDcmVkZW50aWFscyByZXR1cm5lZCBubyBlcnJvciBvciB0b2tlbkRldGFpbHMnKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgeyBhY2Nlc3NfdG9rZW46IHRva2VuRGV0YWlscy50b2tlbiB9KTtcbiAgICAgICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBhdXRob3JpemF0aW9uIGhlYWRlciB0byB1c2UgZm9yIGEgUkVTVCBvciBjb21ldCByZXF1ZXN0LFxuICAgICAqIGJhc2VkIG9uIHRoZSBjdXJyZW50IGF1dGggcGFyYW1ldGVyc1xuICAgICAqL1xuICAgIEF1dGgucHJvdG90eXBlLmdldEF1dGhIZWFkZXJzID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICh0aGlzLm1ldGhvZCA9PSAnYmFzaWMnKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7IGF1dGhvcml6YXRpb246ICdCYXNpYyAnICsgdGhpcy5iYXNpY0tleSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKGZhbHNlLCBmdW5jdGlvbiAoZXJyLCB0b2tlbkRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0b2tlbkRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdBdXRoLmdldEF1dGhQYXJhbXMoKTogX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzIHJldHVybmVkIG5vIGVycm9yIG9yIHRva2VuRGV0YWlscycpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCB7IGF1dGhvcml6YXRpb246ICdCZWFyZXIgJyArIFV0aWxzLnRvQmFzZTY0KHRva2VuRGV0YWlscy50b2tlbikgfSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogR2V0IHRoZSBjdXJyZW50IHRpbWUgYmFzZWQgb24gdGhlIGxvY2FsIGNsb2NrLFxuICAgICAqIG9yIGlmIHRoZSBvcHRpb24gcXVlcnlUaW1lIGlzIHRydWUsIHJldHVybiB0aGUgc2VydmVyIHRpbWUuXG4gICAgICogVGhlIHNlcnZlciB0aW1lIG9mZnNldCBmcm9tIHRoZSBsb2NhbCB0aW1lIGlzIHN0b3JlZCBzbyB0aGF0XG4gICAgICogb25seSBvbmUgcmVxdWVzdCB0byB0aGUgc2VydmVyIHRvIGdldCB0aGUgdGltZSBpcyBldmVyIG5lZWRlZFxuICAgICAqL1xuICAgIEF1dGgucHJvdG90eXBlLmdldFRpbWVzdGFtcCA9IGZ1bmN0aW9uIChxdWVyeVRpbWUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmICghdGhpcy5pc1RpbWVPZmZzZXRTZXQoKSAmJiAocXVlcnlUaW1lIHx8IHRoaXMuYXV0aE9wdGlvbnMucXVlcnlUaW1lKSkge1xuICAgICAgICAgICAgdGhpcy5jbGllbnQudGltZShjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCB0aGlzLmdldFRpbWVzdGFtcFVzaW5nT2Zmc2V0KCkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBBdXRoLnByb3RvdHlwZS5nZXRUaW1lc3RhbXBVc2luZ09mZnNldCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIFV0aWxzLm5vdygpICsgKHRoaXMuY2xpZW50LnNlcnZlclRpbWVPZmZzZXQgfHwgMCk7XG4gICAgfTtcbiAgICBBdXRoLnByb3RvdHlwZS5pc1RpbWVPZmZzZXRTZXQgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmNsaWVudC5zZXJ2ZXJUaW1lT2Zmc2V0ICE9PSBudWxsO1xuICAgIH07XG4gICAgQXV0aC5wcm90b3R5cGUuX3NhdmVCYXNpY09wdGlvbnMgPSBmdW5jdGlvbiAoYXV0aE9wdGlvbnMpIHtcbiAgICAgICAgdGhpcy5tZXRob2QgPSAnYmFzaWMnO1xuICAgICAgICB0aGlzLmtleSA9IGF1dGhPcHRpb25zLmtleTtcbiAgICAgICAgdGhpcy5iYXNpY0tleSA9IFV0aWxzLnRvQmFzZTY0KGF1dGhPcHRpb25zLmtleSk7XG4gICAgICAgIHRoaXMuYXV0aE9wdGlvbnMgPSBhdXRoT3B0aW9ucyB8fCB7fTtcbiAgICAgICAgaWYgKCdjbGllbnRJZCcgaW4gYXV0aE9wdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuX3VzZXJTZXRDbGllbnRJZChhdXRoT3B0aW9ucy5jbGllbnRJZCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1dGgucHJvdG90eXBlLl9zYXZlVG9rZW5PcHRpb25zID0gZnVuY3Rpb24gKHRva2VuUGFyYW1zLCBhdXRoT3B0aW9ucykge1xuICAgICAgICB0aGlzLm1ldGhvZCA9ICd0b2tlbic7XG4gICAgICAgIGlmICh0b2tlblBhcmFtcykge1xuICAgICAgICAgICAgLyogV2UgdGVtcG9yYXJpbHkgcGVyc2lzdCB0b2tlblBhcmFtcy50aW1lc3RhbXAgaW4gY2FzZSBhIG5ldyB0b2tlbiBuZWVkc1xuICAgICAgICAgICAgICogdG8gYmUgcmVxdWVzdGVkLCB0aGVuIG51bGwgaXQgb3V0IGluIHRoZSBjYWxsYmFjayBvZlxuICAgICAgICAgICAgICogX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzIGZvciBSU0ExMGcgY29tcGxpYW5jZSAqL1xuICAgICAgICAgICAgdGhpcy50b2tlblBhcmFtcyA9IHRva2VuUGFyYW1zO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhdXRoT3B0aW9ucykge1xuICAgICAgICAgICAgLyogbm9ybWFsaXNlICovXG4gICAgICAgICAgICBpZiAoYXV0aE9wdGlvbnMudG9rZW4pIHtcbiAgICAgICAgICAgICAgICAvKiBvcHRpb25zLnRva2VuIG1heSBjb250YWluIGEgdG9rZW4gc3RyaW5nIG9yLCBmb3IgY29udmVuaWVuY2UsIGEgVG9rZW5EZXRhaWxzICovXG4gICAgICAgICAgICAgICAgYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzID1cbiAgICAgICAgICAgICAgICAgICAgdHlwZW9mIGF1dGhPcHRpb25zLnRva2VuID09PSAnc3RyaW5nJ1xuICAgICAgICAgICAgICAgICAgICAgICAgPyB7IHRva2VuOiBhdXRoT3B0aW9ucy50b2tlbiB9XG4gICAgICAgICAgICAgICAgICAgICAgICA6IGF1dGhPcHRpb25zLnRva2VuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKGF1dGhPcHRpb25zLnRva2VuRGV0YWlscykge1xuICAgICAgICAgICAgICAgIHRoaXMudG9rZW5EZXRhaWxzID0gYXV0aE9wdGlvbnMudG9rZW5EZXRhaWxzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdjbGllbnRJZCcgaW4gYXV0aE9wdGlvbnMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLl91c2VyU2V0Q2xpZW50SWQoYXV0aE9wdGlvbnMuY2xpZW50SWQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5hdXRoT3B0aW9ucyA9IGF1dGhPcHRpb25zO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiBAcGFyYW0gZm9yY2VTdXBlcnNlZGU6IGZvcmNlIGEgbmV3IHRva2VuIHJlcXVlc3QgZXZlbiBpZiB0aGVyZSdzIG9uZSBpblxuICAgICAqIHByb2dyZXNzLCBtYWtpbmcgYWxsIHBlbmRpbmcgY2FsbGJhY2tzIHdhaXQgZm9yIHRoZSBuZXcgb25lICovXG4gICAgQXV0aC5wcm90b3R5cGUuX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzID0gZnVuY3Rpb24gKGZvcmNlU3VwZXJzZWRlLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdG9rZW4gPSB0aGlzLnRva2VuRGV0YWlscztcbiAgICAgICAgaWYgKHRva2VuKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5fdG9rZW5DbGllbnRJZE1pc21hdGNoKHRva2VuLmNsaWVudElkKSkge1xuICAgICAgICAgICAgICAgIC8qIDQwMyB0byB0cmlnZ2VyIGEgcGVybWFuZW50bHkgZmFpbGVkIGNsaWVudCAtIFJTQTE1YyAqL1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdNaXNtYXRjaCBiZXR3ZWVuIGNsaWVudElkIGluIHRva2VuICgnICsgdG9rZW4uY2xpZW50SWQgKyAnKSBhbmQgY3VycmVudCBjbGllbnRJZCAoJyArIHRoaXMuY2xpZW50SWQgKyAnKScsIDQwMTAyLCA0MDMpKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBSU0E0YjEgLS0gaWYgd2UgaGF2ZSBhIHNlcnZlciB0aW1lIG9mZnNldCBzZXQgYWxyZWFkeSwgd2UgY2FuXG4gICAgICAgICAgICAgKiBhdXRvbWF0aWNhbGx5IHJlbW92ZSBleHBpcmVkIHRva2Vucy4gRWxzZSBqdXN0IHVzZSB0aGUgY2FjaGVkIHRva2VuLiBJZiBpdCBpc1xuICAgICAgICAgICAgICogZXhwaXJlZCBBYmx5IHdpbGwgdGVsbCB1cyBhbmQgd2UnbGwgZGlzY2FyZCBpdCB0aGVuLiAqL1xuICAgICAgICAgICAgaWYgKCF0aGlzLmlzVGltZU9mZnNldFNldCgpIHx8ICF0b2tlbi5leHBpcmVzIHx8IHRva2VuLmV4cGlyZXMgPj0gdGhpcy5nZXRUaW1lc3RhbXBVc2luZ09mZnNldCgpKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdBdXRoLmdldFRva2VuKCknLCAndXNpbmcgY2FjaGVkIHRva2VuOyBleHBpcmVzID0gJyArIHRva2VuLmV4cGlyZXMpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRva2VuKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBleHBpcmVkLCBzbyByZW1vdmUgYW5kIGZhbGx0aHJvdWdoIHRvIGdldHRpbmcgYSBuZXcgb25lICovXG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0F1dGguZ2V0VG9rZW4oKScsICdkZWxldGluZyBleHBpcmVkIHRva2VuJyk7XG4gICAgICAgICAgICB0aGlzLnRva2VuRGV0YWlscyA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgKHRoaXMud2FpdGluZ0ZvclRva2VuUmVxdWVzdCB8fCAodGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0ID0gbXVsdGljYXN0ZXJfMS5kZWZhdWx0LmNyZWF0ZSgpKSkucHVzaChjYWxsYmFjayk7XG4gICAgICAgIGlmICh0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCAhPT0gbnVsbCAmJiAhZm9yY2VTdXBlcnNlZGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvKiBSZXF1ZXN0IGEgbmV3IHRva2VuICovXG4gICAgICAgIHZhciB0b2tlblJlcXVlc3RJZCA9ICh0aGlzLmN1cnJlbnRUb2tlblJlcXVlc3RJZCA9IGdldFRva2VuUmVxdWVzdElkKCkpO1xuICAgICAgICB0aGlzLnJlcXVlc3RUb2tlbih0aGlzLnRva2VuUGFyYW1zLCB0aGlzLmF1dGhPcHRpb25zLCBmdW5jdGlvbiAoZXJyLCB0b2tlblJlc3BvbnNlKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMuY3VycmVudFRva2VuUmVxdWVzdElkID4gdG9rZW5SZXF1ZXN0SWQpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0F1dGguX2Vuc3VyZVZhbGlkQXV0aENyZWRlbnRpYWxzKCknLCAnRGlzY2FyZGluZyB0b2tlbiByZXF1ZXN0IHJlc3BvbnNlOyBvdmVydGFrZW4gYnkgbmV3ZXIgb25lJyk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuY3VycmVudFRva2VuUmVxdWVzdElkID0gbnVsbDtcbiAgICAgICAgICAgIHZhciBjYWxsYmFja3MgPSBfdGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0IHx8IG5vb3A7XG4gICAgICAgICAgICBfdGhpcy53YWl0aW5nRm9yVG9rZW5SZXF1ZXN0ID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFja3MoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFja3MobnVsbCwgKF90aGlzLnRva2VuRGV0YWlscyA9IHRva2VuUmVzcG9uc2UpKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKiBVc2VyLXNldDogY2hlY2sgdHlwZXMsICcqJyBpcyBkaXNhbGxvd2VkLCB0aHJvdyBhbnkgZXJyb3JzICovXG4gICAgQXV0aC5wcm90b3R5cGUuX3VzZXJTZXRDbGllbnRJZCA9IGZ1bmN0aW9uIChjbGllbnRJZCkge1xuICAgICAgICBpZiAoISh0eXBlb2YgY2xpZW50SWQgPT09ICdzdHJpbmcnIHx8IGNsaWVudElkID09PSBudWxsKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ2NsaWVudElkIG11c3QgYmUgZWl0aGVyIGEgc3RyaW5nIG9yIG51bGwnLCA0MDAxMiwgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChjbGllbnRJZCA9PT0gJyonKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnQ2Fu4oCZdCB1c2UgXCIqXCIgYXMgYSBjbGllbnRJZCBhcyB0aGF0IHN0cmluZyBpcyByZXNlcnZlZC4gKFRvIGNoYW5nZSB0aGUgZGVmYXVsdCB0b2tlbiByZXF1ZXN0IGJlaGF2aW91ciB0byB1c2UgYSB3aWxkY2FyZCBjbGllbnRJZCwgaW5zdGFudGlhdGUgdGhlIGxpYnJhcnkgd2l0aCB7ZGVmYXVsdFRva2VuUGFyYW1zOiB7Y2xpZW50SWQ6IFwiKlwifX0pLCBvciBpZiBjYWxsaW5nIGF1dGhvcml6ZSgpLCBwYXNzIGl0IGluIGFzIGEgdG9rZW5QYXJhbTogYXV0aG9yaXplKHtjbGllbnRJZDogXCIqXCJ9LCBhdXRoT3B0aW9ucyknLCA0MDAxMiwgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBlcnIgPSB0aGlzLl91bmNoZWNrZWRTZXRDbGllbnRJZChjbGllbnRJZCk7XG4gICAgICAgICAgICBpZiAoZXJyKVxuICAgICAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyogQWJseS1zZXQ6IG5vIHR5cGVjaGVja2luZywgJyonIGlzIGFsbG93ZWQgYnV0IG5vdCBzZXQgb24gdGhpcy5jbGllbnRJZCksIHJldHVybiBlcnJvcnMgdG8gdGhlIGNhbGxlciAqL1xuICAgIEF1dGgucHJvdG90eXBlLl91bmNoZWNrZWRTZXRDbGllbnRJZCA9IGZ1bmN0aW9uIChjbGllbnRJZCkge1xuICAgICAgICBpZiAodGhpcy5fdG9rZW5DbGllbnRJZE1pc21hdGNoKGNsaWVudElkKSkge1xuICAgICAgICAgICAgLyogU2hvdWxkIG5ldmVyIGhhcHBlbiBpbiBub3JtYWwgY2lyY3Vtc3RhbmNlcyBhcyByZWFsdGltZSBzaG91bGRcbiAgICAgICAgICAgICAqIHJlY29nbmlzZSBtaXNtYXRjaCBhbmQgcmV0dXJuIGFuIGVycm9yICovXG4gICAgICAgICAgICB2YXIgbXNnID0gJ1VuZXhwZWN0ZWQgY2xpZW50SWQgbWlzbWF0Y2g6IGNsaWVudCBoYXMgJyArIHRoaXMuY2xpZW50SWQgKyAnLCByZXF1ZXN0ZWQgJyArIGNsaWVudElkO1xuICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgNDAxMDIsIDQwMSk7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0F1dGguX3VuY2hlY2tlZFNldENsaWVudElkKCknLCBtc2cpO1xuICAgICAgICAgICAgcmV0dXJuIGVycjtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIFJTQTdhNDogaWYgb3B0aW9ucy5jbGllbnRJZCBpcyBwcm92aWRlZCBhbmQgaXMgbm90XG4gICAgICAgICAgICAgKiBudWxsLCBpdCBvdmVycmlkZXMgZGVmYXVsdFRva2VuUGFyYW1zLmNsaWVudElkICovXG4gICAgICAgICAgICB0aGlzLmNsaWVudElkID0gdGhpcy50b2tlblBhcmFtcy5jbGllbnRJZCA9IGNsaWVudElkO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIEF1dGgucHJvdG90eXBlLl90b2tlbkNsaWVudElkTWlzbWF0Y2ggPSBmdW5jdGlvbiAodG9rZW5DbGllbnRJZCkge1xuICAgICAgICByZXR1cm4gISEodGhpcy5jbGllbnRJZCAmJlxuICAgICAgICAgICAgdGhpcy5jbGllbnRJZCAhPT0gJyonICYmXG4gICAgICAgICAgICB0b2tlbkNsaWVudElkICYmXG4gICAgICAgICAgICB0b2tlbkNsaWVudElkICE9PSAnKicgJiZcbiAgICAgICAgICAgIHRoaXMuY2xpZW50SWQgIT09IHRva2VuQ2xpZW50SWQpO1xuICAgIH07XG4gICAgQXV0aC5pc1Rva2VuRXJyID0gZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgIHJldHVybiBlcnJvci5jb2RlICYmIGVycm9yLmNvZGUgPj0gNDAxNDAgJiYgZXJyb3IuY29kZSA8IDQwMTUwO1xuICAgIH07XG4gICAgQXV0aC5wcm90b3R5cGUucmV2b2tlVG9rZW5zID0gZnVuY3Rpb24gKHNwZWNpZmllcnMsIG9wdGlvbnNPckNhbGxiYWNrQXJnLCBjYWxsYmFja0FyZykge1xuICAgICAgICBpZiAodXNlVG9rZW5BdXRoKHRoaXMuY2xpZW50Lm9wdGlvbnMpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnQ2Fubm90IHJldm9rZSB0b2tlbnMgd2hlbiB1c2luZyB0b2tlbiBhdXRoJywgNDAxNjIsIDQwMSk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGtleU5hbWUgPSB0aGlzLmNsaWVudC5vcHRpb25zLmtleU5hbWU7XG4gICAgICAgIHZhciByZXNvbHZlZE9wdGlvbnM7XG4gICAgICAgIGlmICh0eXBlb2Ygb3B0aW9uc09yQ2FsbGJhY2tBcmcgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrQXJnID0gb3B0aW9uc09yQ2FsbGJhY2tBcmc7XG4gICAgICAgICAgICByZXNvbHZlZE9wdGlvbnMgPSB7fTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlc29sdmVkT3B0aW9ucyA9IG9wdGlvbnNPckNhbGxiYWNrQXJnICE9PSBudWxsICYmIG9wdGlvbnNPckNhbGxiYWNrQXJnICE9PSB2b2lkIDAgPyBvcHRpb25zT3JDYWxsYmFja0FyZyA6IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChjYWxsYmFja0FyZyA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3Jldm9rZVRva2VucycsIFtzcGVjaWZpZXJzLCByZXNvbHZlZE9wdGlvbnNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrQXJnID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY2FsbGJhY2sgPSBjYWxsYmFja0FyZztcbiAgICAgICAgdmFyIHJlcXVlc3RCb2R5RFRPID0gdHNsaWJfMS5fX2Fzc2lnbih7IHRhcmdldHM6IHNwZWNpZmllcnMubWFwKGZ1bmN0aW9uIChzcGVjaWZpZXIpIHsgcmV0dXJuIFwiXCIuY29uY2F0KHNwZWNpZmllci50eXBlLCBcIjpcIikuY29uY2F0KHNwZWNpZmllci52YWx1ZSk7IH0pIH0sIHJlc29sdmVkT3B0aW9ucyk7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLmNsaWVudC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLmNsaWVudC5vcHRpb25zLCBmb3JtYXQpO1xuICAgICAgICBpZiAodGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgdGhpcy5jbGllbnQub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgdmFyIHJlcXVlc3RCb2R5ID0gVXRpbHMuZW5jb2RlQm9keShyZXF1ZXN0Qm9keURUTywgZm9ybWF0KTtcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LnBvc3QodGhpcy5jbGllbnQsIFwiL2tleXMvXCIuY29uY2F0KGtleU5hbWUsIFwiL3Jldm9rZVRva2Vuc1wiKSwgcmVxdWVzdEJvZHksIGhlYWRlcnMsIHsgbmV3QmF0Y2hSZXNwb25zZTogJ3RydWUnIH0sIG51bGwsIGZ1bmN0aW9uIChlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyByZW1vdmUgdGhpcyB0eXBlIGFzc2VydGlvbiBhZnRlciBmaXhpbmcgaHR0cHM6Ly9naXRodWIuY29tL2FibHkvYWJseS1qcy9pc3N1ZXMvMTQwNVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJhdGNoUmVzdWx0ID0gKHVucGFja2VkID8gYm9keSA6IFV0aWxzLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KSk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBiYXRjaFJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEF1dGg7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQXV0aDtcblxuXG4vKioqLyB9KSxcbi8qIDE4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgSHR0cE1ldGhvZHM7XG4oZnVuY3Rpb24gKEh0dHBNZXRob2RzKSB7XG4gICAgSHR0cE1ldGhvZHNbXCJHZXRcIl0gPSBcImdldFwiO1xuICAgIEh0dHBNZXRob2RzW1wiRGVsZXRlXCJdID0gXCJkZWxldGVcIjtcbiAgICBIdHRwTWV0aG9kc1tcIlBvc3RcIl0gPSBcInBvc3RcIjtcbiAgICBIdHRwTWV0aG9kc1tcIlB1dFwiXSA9IFwicHV0XCI7XG4gICAgSHR0cE1ldGhvZHNbXCJQYXRjaFwiXSA9IFwicGF0Y2hcIjtcbn0pKEh0dHBNZXRob2RzIHx8IChIdHRwTWV0aG9kcyA9IHt9KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBIdHRwTWV0aG9kcztcblxuXG4vKioqLyB9KSxcbi8qIDE5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLkh0dHBQYWdpbmF0ZWRSZXNwb25zZSA9IGV4cG9ydHMuUGFnaW5hdGVkUmVzdWx0ID0gdm9pZCAwO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciByZXNvdXJjZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNCkpO1xuZnVuY3Rpb24gZ2V0UmVsUGFyYW1zKGxpbmtVcmwpIHtcbiAgICB2YXIgdXJsTWF0Y2ggPSBsaW5rVXJsLm1hdGNoKC9eXFwuXFwvKFxcdyspXFw/KC4qKSQvKTtcbiAgICByZXR1cm4gdXJsTWF0Y2ggJiYgdXJsTWF0Y2hbMl0gJiYgVXRpbHMucGFyc2VRdWVyeVN0cmluZyh1cmxNYXRjaFsyXSk7XG59XG5mdW5jdGlvbiBwYXJzZVJlbExpbmtzKGxpbmtIZWFkZXIpIHtcbiAgICBpZiAodHlwZW9mIGxpbmtIZWFkZXIgPT0gJ3N0cmluZycpXG4gICAgICAgIGxpbmtIZWFkZXIgPSBsaW5rSGVhZGVyLnNwbGl0KCcsJyk7XG4gICAgdmFyIHJlbFBhcmFtcyA9IHt9O1xuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGlua0hlYWRlci5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgbGlua01hdGNoID0gbGlua0hlYWRlcltpXS5tYXRjaCgvXlxccyo8KC4rKT47XFxzKnJlbD1cIihcXHcrKVwiJC8pO1xuICAgICAgICBpZiAobGlua01hdGNoKSB7XG4gICAgICAgICAgICB2YXIgcGFyYW1zID0gZ2V0UmVsUGFyYW1zKGxpbmtNYXRjaFsxXSk7XG4gICAgICAgICAgICBpZiAocGFyYW1zKVxuICAgICAgICAgICAgICAgIHJlbFBhcmFtc1tsaW5rTWF0Y2hbMl1dID0gcGFyYW1zO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiByZWxQYXJhbXM7XG59XG5mdW5jdGlvbiByZXR1cm5FcnJPbmx5KGVyciwgYm9keSwgdXNlSFBSKSB7XG4gICAgLyogSWYgdXNpbmcgaHR0cFBhZ2luYXRlZFJlc3BvbnNlLCBlcnJvcnMgZnJvbSBBYmx5IGFyZSByZXR1cm5lZCBhcyBwYXJ0IG9mXG4gICAgICogdGhlIEhQUiwgb25seSBkbyBjYWxsYmFjayhlcnIpIGZvciBuZXR3b3JrIGVycm9ycyBldGMuIHdoaWNoIGRvbid0XG4gICAgICogcmV0dXJuIGEgYm9keSBhbmQvb3IgaGF2ZSBubyBhYmx5LW9yaWdpbmF0ZWQgZXJyb3IgY29kZSAobm9uLW51bWVyaWNcbiAgICAgKiBlcnJvciBjb2RlcyBvcmlnaW5hdGUgZnJvbSBub2RlKSAqL1xuICAgIHJldHVybiAhKHVzZUhQUiAmJiAoYm9keSB8fCB0eXBlb2YgZXJyLmNvZGUgPT09ICdudW1iZXInKSk7XG59XG52YXIgUGFnaW5hdGVkUmVzb3VyY2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUGFnaW5hdGVkUmVzb3VyY2UocmVzdCwgcGF0aCwgaGVhZGVycywgZW52ZWxvcGUsIGJvZHlIYW5kbGVyLCB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UpIHtcbiAgICAgICAgdGhpcy5yZXN0ID0gcmVzdDtcbiAgICAgICAgdGhpcy5wYXRoID0gcGF0aDtcbiAgICAgICAgdGhpcy5oZWFkZXJzID0gaGVhZGVycztcbiAgICAgICAgdGhpcy5lbnZlbG9wZSA9IGVudmVsb3BlICE9PSBudWxsICYmIGVudmVsb3BlICE9PSB2b2lkIDAgPyBlbnZlbG9wZSA6IG51bGw7XG4gICAgICAgIHRoaXMuYm9keUhhbmRsZXIgPSBib2R5SGFuZGxlcjtcbiAgICAgICAgdGhpcy51c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UgPSB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2UgfHwgZmFsc2U7XG4gICAgfVxuICAgIFBhZ2luYXRlZFJlc291cmNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQuZ2V0KHRoaXMucmVzdCwgdGhpcy5wYXRoLCB0aGlzLmhlYWRlcnMsIHBhcmFtcywgdGhpcy5lbnZlbG9wZSwgZnVuY3Rpb24gKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZVBhZ2UoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBhZ2luYXRlZFJlc291cmNlLnByb3RvdHlwZS5kZWxldGUgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQuZGVsZXRlKHRoaXMucmVzdCwgdGhpcy5wYXRoLCB0aGlzLmhlYWRlcnMsIHBhcmFtcywgdGhpcy5lbnZlbG9wZSwgZnVuY3Rpb24gKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIF90aGlzLmhhbmRsZVBhZ2UoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBhZ2luYXRlZFJlc291cmNlLnByb3RvdHlwZS5wb3N0ID0gZnVuY3Rpb24gKHBhcmFtcywgYm9keSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LnBvc3QodGhpcy5yZXN0LCB0aGlzLnBhdGgsIGJvZHksIHRoaXMuaGVhZGVycywgcGFyYW1zLCB0aGlzLmVudmVsb3BlLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZUJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVQYWdlKGVyciwgcmVzcG9uc2VCb2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBhZ2luYXRlZFJlc291cmNlLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAocGFyYW1zLCBib2R5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQucHV0KHRoaXMucmVzdCwgdGhpcy5wYXRoLCBib2R5LCB0aGlzLmhlYWRlcnMsIHBhcmFtcywgdGhpcy5lbnZlbG9wZSwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2VCb2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSkge1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuaGFuZGxlUGFnZShlcnIsIHJlc3BvbnNlQm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBQYWdpbmF0ZWRSZXNvdXJjZS5wcm90b3R5cGUucGF0Y2ggPSBmdW5jdGlvbiAocGFyYW1zLCBib2R5LCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQucGF0Y2godGhpcy5yZXN0LCB0aGlzLnBhdGgsIGJvZHksIHRoaXMuaGVhZGVycywgcGFyYW1zLCB0aGlzLmVudmVsb3BlLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZUJvZHksIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICBpZiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5oYW5kbGVQYWdlKGVyciwgcmVzcG9uc2VCb2R5LCBoZWFkZXJzLCB1bnBhY2tlZCwgc3RhdHVzQ29kZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFBhZ2luYXRlZFJlc291cmNlLnByb3RvdHlwZS5oYW5kbGVQYWdlID0gZnVuY3Rpb24gKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChlcnIgJiYgcmV0dXJuRXJyT25seShlcnIsIGJvZHksIHRoaXMudXNlSHR0cFBhZ2luYXRlZFJlc3BvbnNlKSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdQYWdpbmF0ZWRSZXNvdXJjZS5oYW5kbGVQYWdlKCknLCAnVW5leHBlY3RlZCBlcnJvciBnZXR0aW5nIHJlc291cmNlOiBlcnIgPSAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGVycikpO1xuICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGl0ZW1zLCBsaW5rSGVhZGVyLCByZWxQYXJhbXM7XG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgICBpdGVtcyA9IHRoaXMuYm9keUhhbmRsZXIoYm9keSwgaGVhZGVycyB8fCB7fSwgdW5wYWNrZWQpO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAvKiBJZiB3ZSBnb3QgYW4gZXJyb3IsIHRoZSBmYWlsdXJlIHRvIHBhcnNlIHRoZSBib2R5IGlzIGFsbW9zdCBjZXJ0YWlubHlcbiAgICAgICAgICAgICAqIGR1ZSB0byB0aGF0LCBzbyBjYWxsYmFjayB3aXRoIHRoYXQgaW4gcHJlZmVyZW5jZSBvdmVyIHRoZSBwYXJzZSBlcnJvciAqL1xuICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKGVyciB8fCBlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaGVhZGVycyAmJiAobGlua0hlYWRlciA9IGhlYWRlcnNbJ0xpbmsnXSB8fCBoZWFkZXJzWydsaW5rJ10pKSB7XG4gICAgICAgICAgICByZWxQYXJhbXMgPSBwYXJzZVJlbExpbmtzKGxpbmtIZWFkZXIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnVzZUh0dHBQYWdpbmF0ZWRSZXNwb25zZSkge1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgbmV3IEh0dHBQYWdpbmF0ZWRSZXNwb25zZSh0aGlzLCBpdGVtcywgaGVhZGVycyB8fCB7fSwgc3RhdHVzQ29kZSwgcmVsUGFyYW1zLCBlcnIpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG5ldyBQYWdpbmF0ZWRSZXN1bHQodGhpcywgaXRlbXMsIHJlbFBhcmFtcykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICByZXR1cm4gUGFnaW5hdGVkUmVzb3VyY2U7XG59KCkpO1xudmFyIFBhZ2luYXRlZFJlc3VsdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQYWdpbmF0ZWRSZXN1bHQocmVzb3VyY2UsIGl0ZW1zLCByZWxQYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXNvdXJjZSA9IHJlc291cmNlO1xuICAgICAgICB0aGlzLml0ZW1zID0gaXRlbXM7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgaWYgKHJlbFBhcmFtcykge1xuICAgICAgICAgICAgaWYgKCdmaXJzdCcgaW4gcmVsUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgdGhpcy5maXJzdCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrICYmIHNlbGYucmVzb3VyY2UucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHNlbGYsICdmaXJzdCcsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmdldChyZWxQYXJhbXMuZmlyc3QsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCdjdXJyZW50JyBpbiByZWxQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICB0aGlzLmN1cnJlbnQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFjYWxsYmFjayAmJiBzZWxmLnJlc291cmNlLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeShzZWxmLCAnY3VycmVudCcsIFtdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBzZWxmLmdldChyZWxQYXJhbXMuY3VycmVudCwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aGlzLm5leHQgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICBpZiAoIWNhbGxiYWNrICYmIHNlbGYucmVzb3VyY2UucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkoc2VsZiwgJ25leHQnLCBbXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGlmICgnbmV4dCcgaW4gcmVsUGFyYW1zKSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYuZ2V0KHJlbFBhcmFtcy5uZXh0LCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCBudWxsKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdGhpcy5oYXNOZXh0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAnbmV4dCcgaW4gcmVsUGFyYW1zO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIHRoaXMuaXNMYXN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHZhciBfYTtcbiAgICAgICAgICAgICAgICByZXR1cm4gISgoX2EgPSBfdGhpcy5oYXNOZXh0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuY2FsbChfdGhpcykpO1xuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICAvKiBXZSBhc3N1bWUgdGhhdCBvbmx5IHRoZSBpbml0aWFsIHJlcXVlc3QgY2FuIGJlIGEgUE9TVCwgYW5kIHRoYXQgYWNjZXNzaW5nXG4gICAgICogdGhlIHJlc3Qgb2YgYSBtdWx0aXBhZ2Ugc2V0IG9mIHJlc3VsdHMgY2FuIGFsd2F5cyBiZSBkb25lIHdpdGggR0VUICovXG4gICAgUGFnaW5hdGVkUmVzdWx0LnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzID0gdGhpcy5yZXNvdXJjZTtcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LmdldChyZXMucmVzdCwgcmVzLnBhdGgsIHJlcy5oZWFkZXJzLCBwYXJhbXMsIHJlcy5lbnZlbG9wZSwgZnVuY3Rpb24gKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgIHJlcy5oYW5kbGVQYWdlKGVyciwgYm9keSwgaGVhZGVycywgdW5wYWNrZWQsIHN0YXR1c0NvZGUsIGNhbGxiYWNrKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUGFnaW5hdGVkUmVzdWx0O1xufSgpKTtcbmV4cG9ydHMuUGFnaW5hdGVkUmVzdWx0ID0gUGFnaW5hdGVkUmVzdWx0O1xudmFyIEh0dHBQYWdpbmF0ZWRSZXNwb25zZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhIdHRwUGFnaW5hdGVkUmVzcG9uc2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gSHR0cFBhZ2luYXRlZFJlc3BvbnNlKHJlc291cmNlLCBpdGVtcywgaGVhZGVycywgc3RhdHVzQ29kZSwgcmVsUGFyYW1zLCBlcnIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgcmVzb3VyY2UsIGl0ZW1zLCByZWxQYXJhbXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuICAgICAgICBfdGhpcy5zdWNjZXNzID0gc3RhdHVzQ29kZSA8IDMwMCAmJiBzdGF0dXNDb2RlID49IDIwMDtcbiAgICAgICAgX3RoaXMuaGVhZGVycyA9IGhlYWRlcnM7XG4gICAgICAgIF90aGlzLmVycm9yQ29kZSA9IGVyciAmJiBlcnIuY29kZTtcbiAgICAgICAgX3RoaXMuZXJyb3JNZXNzYWdlID0gZXJyICYmIGVyci5tZXNzYWdlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIEh0dHBQYWdpbmF0ZWRSZXNwb25zZS5wcm90b3R5cGUudG9KU09OID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaXRlbXM6IHRoaXMuaXRlbXMsXG4gICAgICAgICAgICBzdGF0dXNDb2RlOiB0aGlzLnN0YXR1c0NvZGUsXG4gICAgICAgICAgICBzdWNjZXNzOiB0aGlzLnN1Y2Nlc3MsXG4gICAgICAgICAgICBoZWFkZXJzOiB0aGlzLmhlYWRlcnMsXG4gICAgICAgICAgICBlcnJvckNvZGU6IHRoaXMuZXJyb3JDb2RlLFxuICAgICAgICAgICAgZXJyb3JNZXNzYWdlOiB0aGlzLmVycm9yTWVzc2FnZSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIHJldHVybiBIdHRwUGFnaW5hdGVkUmVzcG9uc2U7XG59KFBhZ2luYXRlZFJlc3VsdCkpO1xuZXhwb3J0cy5IdHRwUGFnaW5hdGVkUmVzcG9uc2UgPSBIdHRwUGFnaW5hdGVkUmVzcG9uc2U7XG5leHBvcnRzLmRlZmF1bHQgPSBQYWdpbmF0ZWRSZXNvdXJjZTtcblxuXG4vKioqLyB9KSxcbi8qIDIwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG5leHBvcnRzLmlzUmV0cmlhYmxlID0gdm9pZCAwO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgQ29ubmVjdGlvbkVycm9yQ29kZXMgPSB7XG4gICAgRElTQ09OTkVDVEVEOiA4MDAwMyxcbiAgICBTVVNQRU5ERUQ6IDgwMDAyLFxuICAgIEZBSUxFRDogODAwMDAsXG4gICAgQ0xPU0lORzogODAwMTcsXG4gICAgQ0xPU0VEOiA4MDAxNyxcbiAgICBVTktOT1dOX0NPTk5FQ1RJT05fRVJSOiA1MDAwMixcbiAgICBVTktOT1dOX0NIQU5ORUxfRVJSOiA1MDAwMSxcbn07XG52YXIgQ29ubmVjdGlvbkVycm9ycyA9IHtcbiAgICBkaXNjb25uZWN0ZWQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgICAgICAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5ESVNDT05ORUNURUQsXG4gICAgICAgICAgICBtZXNzYWdlOiAnQ29ubmVjdGlvbiB0byBzZXJ2ZXIgdGVtcG9yYXJpbHkgdW5hdmFpbGFibGUnLFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIHN1c3BlbmRlZDogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IDQwMCxcbiAgICAgICAgICAgIGNvZGU6IENvbm5lY3Rpb25FcnJvckNvZGVzLlNVU1BFTkRFRCxcbiAgICAgICAgICAgIG1lc3NhZ2U6ICdDb25uZWN0aW9uIHRvIHNlcnZlciB1bmF2YWlsYWJsZScsXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgZmFpbGVkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogNDAwLFxuICAgICAgICAgICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuRkFJTEVELFxuICAgICAgICAgICAgbWVzc2FnZTogJ0Nvbm5lY3Rpb24gZmFpbGVkIG9yIGRpc2Nvbm5lY3RlZCBieSBzZXJ2ZXInLFxuICAgICAgICB9KTtcbiAgICB9LFxuICAgIGNsb3Npbmc6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgICAgICAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5DTE9TSU5HLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0Nvbm5lY3Rpb24gY2xvc2luZycsXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgY2xvc2VkOiBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgc3RhdHVzQ29kZTogNDAwLFxuICAgICAgICAgICAgY29kZTogQ29ubmVjdGlvbkVycm9yQ29kZXMuQ0xPU0VELFxuICAgICAgICAgICAgbWVzc2FnZTogJ0Nvbm5lY3Rpb24gY2xvc2VkJyxcbiAgICAgICAgfSk7XG4gICAgfSxcbiAgICB1bmtub3duQ29ubmVjdGlvbkVycjogZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHtcbiAgICAgICAgICAgIHN0YXR1c0NvZGU6IDUwMCxcbiAgICAgICAgICAgIGNvZGU6IENvbm5lY3Rpb25FcnJvckNvZGVzLlVOS05PV05fQ09OTkVDVElPTl9FUlIsXG4gICAgICAgICAgICBtZXNzYWdlOiAnSW50ZXJuYWwgY29ubmVjdGlvbiBlcnJvcicsXG4gICAgICAgIH0pO1xuICAgIH0sXG4gICAgdW5rbm93bkNoYW5uZWxFcnI6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICBzdGF0dXNDb2RlOiA1MDAsXG4gICAgICAgICAgICBjb2RlOiBDb25uZWN0aW9uRXJyb3JDb2Rlcy5VTktOT1dOX0NPTk5FQ1RJT05fRVJSLFxuICAgICAgICAgICAgbWVzc2FnZTogJ0ludGVybmFsIGNoYW5uZWwgZXJyb3InLFxuICAgICAgICB9KTtcbiAgICB9LFxufTtcbmZ1bmN0aW9uIGlzUmV0cmlhYmxlKGVycikge1xuICAgIGlmICghZXJyLnN0YXR1c0NvZGUgfHwgIWVyci5jb2RlIHx8IGVyci5zdGF0dXNDb2RlID49IDUwMCkge1xuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gICAgcmV0dXJuIE9iamVjdC52YWx1ZXMoQ29ubmVjdGlvbkVycm9yQ29kZXMpLmluY2x1ZGVzKGVyci5jb2RlKTtcbn1cbmV4cG9ydHMuaXNSZXRyaWFibGUgPSBpc1JldHJpYWJsZTtcbmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb25FcnJvcnM7XG5cblxuLyoqKi8gfSksXG4vKiAyMSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIFhIUlN0YXRlcztcbihmdW5jdGlvbiAoWEhSU3RhdGVzKSB7XG4gICAgWEhSU3RhdGVzW1hIUlN0YXRlc1tcIlJFUV9TRU5EXCJdID0gMF0gPSBcIlJFUV9TRU5EXCI7XG4gICAgWEhSU3RhdGVzW1hIUlN0YXRlc1tcIlJFUV9SRUNWXCJdID0gMV0gPSBcIlJFUV9SRUNWXCI7XG4gICAgWEhSU3RhdGVzW1hIUlN0YXRlc1tcIlJFUV9SRUNWX1BPTExcIl0gPSAyXSA9IFwiUkVRX1JFQ1ZfUE9MTFwiO1xuICAgIFhIUlN0YXRlc1tYSFJTdGF0ZXNbXCJSRVFfUkVDVl9TVFJFQU1cIl0gPSAzXSA9IFwiUkVRX1JFQ1ZfU1RSRUFNXCI7XG59KShYSFJTdGF0ZXMgfHwgKFhIUlN0YXRlcyA9IHt9KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBYSFJTdGF0ZXM7XG5cblxuLyoqKi8gfSksXG4vKiAyMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNiksIF9fd2VicGFja19yZXF1aXJlX18oNSksIF9fd2VicGFja19yZXF1aXJlX18oNTgpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDExKSwgX193ZWJwYWNrX3JlcXVpcmVfXyg0MCksIF9fd2VicGFja19yZXF1aXJlX18oMzIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KSwgX193ZWJwYWNrX3JlcXVpcmVfXygyNyksIF9fd2VicGFja19yZXF1aXJlX18oMjgpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDU5KSwgX193ZWJwYWNrX3JlcXVpcmVfXyg2MCkpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0cmV0dXJuIENyeXB0b0pTO1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMjMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIE11bHRpY2FzdGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIC8vIFByaXZhdGUgY29uc3RydWN0b3I7IHVzZSBzdGF0aWMgTXVsdGljYXN0ZXIuY3JlYXRlIGluc3RlYWRcbiAgICBmdW5jdGlvbiBNdWx0aWNhc3RlcihtZW1iZXJzKSB7XG4gICAgICAgIHRoaXMubWVtYmVycyA9IG1lbWJlcnMgfHwgW107XG4gICAgfVxuICAgIE11bHRpY2FzdGVyLnByb3RvdHlwZS5jYWxsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIF9hID0gMCwgX2IgPSB0aGlzLm1lbWJlcnM7IF9hIDwgX2IubGVuZ3RoOyBfYSsrKSB7XG4gICAgICAgICAgICB2YXIgbWVtYmVyID0gX2JbX2FdO1xuICAgICAgICAgICAgaWYgKG1lbWJlcikge1xuICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgIG1lbWJlci5hcHBseSh2b2lkIDAsIGFyZ3MpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ011bHRpY2FzdGVyIG11bHRpcGxlIGNhbGxiYWNrIGhhbmRsZXInLCAnVW5leHBlY3RlZCBleGNlcHRpb246ICcgKyBlICsgJzsgc3RhY2sgPSAnICsgZS5zdGFjayk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBNdWx0aWNhc3Rlci5wcm90b3R5cGUucHVzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICB9XG4gICAgICAgIChfYSA9IHRoaXMubWVtYmVycykucHVzaC5hcHBseShfYSwgYXJncyk7XG4gICAgfTtcbiAgICBNdWx0aWNhc3Rlci5jcmVhdGUgPSBmdW5jdGlvbiAobWVtYmVycykge1xuICAgICAgICB2YXIgaW5zdGFuY2UgPSBuZXcgTXVsdGljYXN0ZXIobWVtYmVycyk7XG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgICAgICBmb3IgKHZhciBfaSA9IDA7IF9pIDwgYXJndW1lbnRzLmxlbmd0aDsgX2krKykge1xuICAgICAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHJldHVybiBpbnN0YW5jZS5jYWxsLmFwcGx5KGluc3RhbmNlLCBhcmdzKTtcbiAgICAgICAgfSwge1xuICAgICAgICAgICAgcHVzaDogZnVuY3Rpb24gKGZuKSB7IHJldHVybiBpbnN0YW5jZS5wdXNoKGZuKTsgfSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gTXVsdGljYXN0ZXI7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gTXVsdGljYXN0ZXI7XG5cblxuLyoqKi8gfSksXG4vKiAyNCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIENfZW5jID0gQy5lbmM7XG5cdCAgICB2YXIgVXRmOCA9IENfZW5jLlV0Zjg7XG5cdCAgICB2YXIgQ19hbGdvID0gQy5hbGdvO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEhNQUMgYWxnb3JpdGhtLlxuXHQgICAgICovXG5cdCAgICB2YXIgSE1BQyA9IENfYWxnby5ITUFDID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBITUFDLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30ga2V5IFRoZSBzZWNyZXQga2V5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgaG1hY0hhc2hlciA9IENyeXB0b0pTLmFsZ28uSE1BQy5jcmVhdGUoQ3J5cHRvSlMuYWxnby5TSEEyNTYsIGtleSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKGhhc2hlciwga2V5KSB7XG5cdCAgICAgICAgICAgIC8vIEluaXQgaGFzaGVyXG5cdCAgICAgICAgICAgIGhhc2hlciA9IHRoaXMuX2hhc2hlciA9IG5ldyBoYXNoZXIuaW5pdCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENvbnZlcnQgc3RyaW5nIHRvIFdvcmRBcnJheSwgZWxzZSBhc3N1bWUgV29yZEFycmF5IGFscmVhZHlcblx0ICAgICAgICAgICAgaWYgKHR5cGVvZiBrZXkgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIGtleSA9IFV0ZjgucGFyc2Uoa2V5KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgaGFzaGVyQmxvY2tTaXplID0gaGFzaGVyLmJsb2NrU2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGhhc2hlckJsb2NrU2l6ZUJ5dGVzID0gaGFzaGVyQmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBBbGxvdyBhcmJpdHJhcnkgbGVuZ3RoIGtleXNcblx0ICAgICAgICAgICAgaWYgKGtleS5zaWdCeXRlcyA+IGhhc2hlckJsb2NrU2l6ZUJ5dGVzKSB7XG5cdCAgICAgICAgICAgICAgICBrZXkgPSBoYXNoZXIuZmluYWxpemUoa2V5KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIENsYW1wIGV4Y2VzcyBiaXRzXG5cdCAgICAgICAgICAgIGtleS5jbGFtcCgpO1xuXG5cdCAgICAgICAgICAgIC8vIENsb25lIGtleSBmb3IgaW5uZXIgYW5kIG91dGVyIHBhZHNcblx0ICAgICAgICAgICAgdmFyIG9LZXkgPSB0aGlzLl9vS2V5ID0ga2V5LmNsb25lKCk7XG5cdCAgICAgICAgICAgIHZhciBpS2V5ID0gdGhpcy5faUtleSA9IGtleS5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgb0tleVdvcmRzID0gb0tleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGlLZXlXb3JkcyA9IGlLZXkud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gWE9SIGtleXMgd2l0aCBwYWQgY29uc3RhbnRzXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgaGFzaGVyQmxvY2tTaXplOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIG9LZXlXb3Jkc1tpXSBePSAweDVjNWM1YzVjO1xuXHQgICAgICAgICAgICAgICAgaUtleVdvcmRzW2ldIF49IDB4MzYzNjM2MzY7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgb0tleS5zaWdCeXRlcyA9IGlLZXkuc2lnQnl0ZXMgPSBoYXNoZXJCbG9ja1NpemVCeXRlcztcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBITUFDIHRvIGl0cyBpbml0aWFsIHN0YXRlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGhhc2hlciA9IHRoaXMuX2hhc2hlcjtcblxuXHQgICAgICAgICAgICAvLyBSZXNldFxuXHQgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblx0ICAgICAgICAgICAgaGFzaGVyLnVwZGF0ZSh0aGlzLl9pS2V5KTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogVXBkYXRlcyB0aGlzIEhNQUMgd2l0aCBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2VVcGRhdGUgVGhlIG1lc3NhZ2UgdG8gYXBwZW5kLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7SE1BQ30gVGhpcyBITUFDIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnVwZGF0ZSgnbWVzc2FnZScpO1xuXHQgICAgICAgICAqICAgICBobWFjSGFzaGVyLnVwZGF0ZSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVwZGF0ZTogZnVuY3Rpb24gKG1lc3NhZ2VVcGRhdGUpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaGVyLnVwZGF0ZShtZXNzYWdlVXBkYXRlKTtcblxuXHQgICAgICAgICAgICAvLyBDaGFpbmFibGVcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXM7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgSE1BQyBjb21wdXRhdGlvbi5cblx0ICAgICAgICAgKiBOb3RlIHRoYXQgdGhlIGZpbmFsaXplIG9wZXJhdGlvbiBpcyBlZmZlY3RpdmVseSBhIGRlc3RydWN0aXZlLCByZWFkLW9uY2Ugb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlVXBkYXRlIChPcHRpb25hbCkgQSBmaW5hbCBtZXNzYWdlIHVwZGF0ZS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIEhNQUMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBobWFjID0gaG1hY0hhc2hlci5maW5hbGl6ZSgpO1xuXHQgICAgICAgICAqICAgICB2YXIgaG1hYyA9IGhtYWNIYXNoZXIuZmluYWxpemUoJ21lc3NhZ2UnKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGhtYWMgPSBobWFjSGFzaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChtZXNzYWdlVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSB0aGlzLl9oYXNoZXI7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBITUFDXG5cdCAgICAgICAgICAgIHZhciBpbm5lckhhc2ggPSBoYXNoZXIuZmluYWxpemUobWVzc2FnZVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIGhhc2hlci5yZXNldCgpO1xuXHQgICAgICAgICAgICB2YXIgaG1hYyA9IGhhc2hlci5maW5hbGl6ZSh0aGlzLl9vS2V5LmNsb25lKCkuY29uY2F0KGlubmVySGFzaCkpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBobWFjO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXHR9KCkpO1xuXG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAyNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5pc1N1Y2Nlc3NDb2RlID0gdm9pZCAwO1xudmFyIEh0dHBTdGF0dXNDb2RlcztcbihmdW5jdGlvbiAoSHR0cFN0YXR1c0NvZGVzKSB7XG4gICAgSHR0cFN0YXR1c0NvZGVzW0h0dHBTdGF0dXNDb2Rlc1tcIlN1Y2Nlc3NcIl0gPSAyMDBdID0gXCJTdWNjZXNzXCI7XG4gICAgSHR0cFN0YXR1c0NvZGVzW0h0dHBTdGF0dXNDb2Rlc1tcIk5vQ29udGVudFwiXSA9IDIwNF0gPSBcIk5vQ29udGVudFwiO1xuICAgIEh0dHBTdGF0dXNDb2Rlc1tIdHRwU3RhdHVzQ29kZXNbXCJCYWRSZXF1ZXN0XCJdID0gNDAwXSA9IFwiQmFkUmVxdWVzdFwiO1xuICAgIEh0dHBTdGF0dXNDb2Rlc1tIdHRwU3RhdHVzQ29kZXNbXCJVbmF1dGhvcml6ZWRcIl0gPSA0MDFdID0gXCJVbmF1dGhvcml6ZWRcIjtcbiAgICBIdHRwU3RhdHVzQ29kZXNbSHR0cFN0YXR1c0NvZGVzW1wiRm9yYmlkZGVuXCJdID0gNDAzXSA9IFwiRm9yYmlkZGVuXCI7XG4gICAgSHR0cFN0YXR1c0NvZGVzW0h0dHBTdGF0dXNDb2Rlc1tcIlJlcXVlc3RUaW1lb3V0XCJdID0gNDA4XSA9IFwiUmVxdWVzdFRpbWVvdXRcIjtcbiAgICBIdHRwU3RhdHVzQ29kZXNbSHR0cFN0YXR1c0NvZGVzW1wiSW50ZXJuYWxTZXJ2ZXJFcnJvclwiXSA9IDUwMF0gPSBcIkludGVybmFsU2VydmVyRXJyb3JcIjtcbn0pKEh0dHBTdGF0dXNDb2RlcyB8fCAoSHR0cFN0YXR1c0NvZGVzID0ge30pKTtcbmZ1bmN0aW9uIGlzU3VjY2Vzc0NvZGUoc3RhdHVzQ29kZSkge1xuICAgIHJldHVybiBzdGF0dXNDb2RlID49IEh0dHBTdGF0dXNDb2Rlcy5TdWNjZXNzICYmIHN0YXR1c0NvZGUgPCBIdHRwU3RhdHVzQ29kZXMuQmFkUmVxdWVzdDtcbn1cbmV4cG9ydHMuaXNTdWNjZXNzQ29kZSA9IGlzU3VjY2Vzc0NvZGU7XG5leHBvcnRzLmRlZmF1bHQgPSBIdHRwU3RhdHVzQ29kZXM7XG5cblxuLyoqKi8gfSksXG4vKiAyNiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHByb3RvY29sbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxMCkpO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgZXZlbnRlbWl0dGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIGNvbm5lY3Rpb25lcnJvcnNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjApKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciBhY3Rpb25zID0gcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5BY3Rpb247XG52YXIgY2xvc2VNZXNzYWdlID0gcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHsgYWN0aW9uOiBhY3Rpb25zLkNMT1NFIH0pO1xudmFyIGRpc2Nvbm5lY3RNZXNzYWdlID0gcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHsgYWN0aW9uOiBhY3Rpb25zLkRJU0NPTk5FQ1QgfSk7XG4vKlxuICogVHJhbnNwb3J0IGluc3RhbmNlcyBpbmhlcml0IGZyb20gRXZlbnRFbWl0dGVyIGFuZCBlbWl0IHRoZSBmb2xsb3dpbmcgZXZlbnRzOlxuICpcbiAqIGV2ZW50IG5hbWUgICAgICAgZGF0YVxuICogY2xvc2VkICAgICAgICAgICBlcnJvclxuICogZmFpbGVkICAgICAgICAgICBlcnJvclxuICogZGlzcG9zZWRcbiAqIGNvbm5lY3RlZCAgICAgICAgbnVsbCBlcnJvciwgY29ubmVjdGlvblNlcmlhbCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlsc1xuICogZXZlbnQgICAgICAgICAgICBjaGFubmVsIG1lc3NhZ2Ugb2JqZWN0XG4gKi9cbnZhciBUcmFuc3BvcnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoVHJhbnNwb3J0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFRyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zLCBmb3JjZUpzb25Qcm90b2NvbCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBpZiAoZm9yY2VKc29uUHJvdG9jb2wpIHtcbiAgICAgICAgICAgIHBhcmFtcy5mb3JtYXQgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICBwYXJhbXMuaGVhcnRiZWF0cyA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgX3RoaXMuY29ubmVjdGlvbk1hbmFnZXIgPSBjb25uZWN0aW9uTWFuYWdlcjtcbiAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIucmVnaXN0ZXJQcm9wb3NlZFRyYW5zcG9ydChfdGhpcyk7XG4gICAgICAgIF90aGlzLmF1dGggPSBhdXRoO1xuICAgICAgICBfdGhpcy5wYXJhbXMgPSBwYXJhbXM7XG4gICAgICAgIF90aGlzLnRpbWVvdXRzID0gcGFyYW1zLm9wdGlvbnMudGltZW91dHM7XG4gICAgICAgIF90aGlzLmZvcm1hdCA9IHBhcmFtcy5mb3JtYXQ7XG4gICAgICAgIF90aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIF90aGlzLmlzRmluaXNoZWQgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuaXNEaXNwb3NlZCA9IGZhbHNlO1xuICAgICAgICBfdGhpcy5tYXhJZGxlSW50ZXJ2YWwgPSBudWxsO1xuICAgICAgICBfdGhpcy5pZGxlVGltZXIgPSBudWxsO1xuICAgICAgICBfdGhpcy5sYXN0QWN0aXZpdHkgPSBudWxsO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuY29ubmVjdCA9IGZ1bmN0aW9uICgpIHsgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLmNsb3NlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0Q2xvc2UoKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmZpbmlzaCgnY2xvc2VkJywgY29ubmVjdGlvbmVycm9yc18xLmRlZmF1bHQuY2xvc2VkKCkpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5kaXNjb25uZWN0ID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAvKiBVc2VkIGZvciBuZXR3b3JrL3RyYW5zcG9ydCBpc3N1ZXMgdGhhdCBuZWVkIHRvIHJlc3VsdCBpbiB0aGUgdHJhbnNwb3J0XG4gICAgICAgICAqIGJlaW5nIGRpc2Nvbm5lY3RlZCwgYnV0IHNob3VsZCBub3QgdHJhbnNpdGlvbiB0aGUgY29ubmVjdGlvbiB0byAnZmFpbGVkJyAqL1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0RGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmluaXNoKCdkaXNjb25uZWN0ZWQnLCBlcnIgfHwgY29ubmVjdGlvbmVycm9yc18xLmRlZmF1bHQuZGlzY29ubmVjdGVkKCkpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5mYWlsID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAvKiBVc2VkIGZvciBjbGllbnQtc2lkZS1kZXRlY3RlZCBmYXRhbCBjb25uZWN0aW9uIGlzc3VlcyAqL1xuICAgICAgICBpZiAodGhpcy5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0RGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZmluaXNoKCdmYWlsZWQnLCBlcnIgfHwgY29ubmVjdGlvbmVycm9yc18xLmRlZmF1bHQuZmFpbGVkKCkpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5maW5pc2ggPSBmdW5jdGlvbiAoZXZlbnQsIGVycikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICh0aGlzLmlzRmluaXNoZWQpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmlzRmluaXNoZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMubWF4SWRsZUludGVydmFsID0gbnVsbDtcbiAgICAgICAgY2xlYXJUaW1lb3V0KChfYSA9IHRoaXMuaWRsZVRpbWVyKSAhPT0gbnVsbCAmJiBfYSAhPT0gdm9pZCAwID8gX2EgOiB1bmRlZmluZWQpO1xuICAgICAgICB0aGlzLmlkbGVUaW1lciA9IG51bGw7XG4gICAgICAgIHRoaXMuZW1pdChldmVudCwgZXJyKTtcbiAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uUHJvdG9jb2xNZXNzYWdlID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgaWYgKGxvZ2dlcl8xLmRlZmF1bHQuc2hvdWxkTG9nKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdUcmFuc3BvcnQub25Qcm90b2NvbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBvbiAnICtcbiAgICAgICAgICAgICAgICB0aGlzLnNob3J0TmFtZSArXG4gICAgICAgICAgICAgICAgJzogJyArXG4gICAgICAgICAgICAgICAgcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5zdHJpbmdpZnkobWVzc2FnZSkgK1xuICAgICAgICAgICAgICAgICc7IGNvbm5lY3Rpb25JZCA9ICcgK1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm9uQWN0aXZpdHkoKTtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLmFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLkhFQVJUQkVBVDpcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1RyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpJywgdGhpcy5zaG9ydE5hbWUgKyAnIGhlYXJ0YmVhdDsgY29ubmVjdGlvbklkID0gJyArIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2hlYXJ0YmVhdCcsIG1lc3NhZ2UuaWQpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLkNPTk5FQ1RFRDpcbiAgICAgICAgICAgICAgICB0aGlzLm9uQ29ubmVjdChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2Nvbm5lY3RlZCcsIG1lc3NhZ2UuZXJyb3IsIG1lc3NhZ2UuY29ubmVjdGlvbklkLCBtZXNzYWdlLmNvbm5lY3Rpb25EZXRhaWxzLCBtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5DTE9TRUQ6XG4gICAgICAgICAgICAgICAgdGhpcy5vbkNsb3NlKG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLkRJU0NPTk5FQ1RFRDpcbiAgICAgICAgICAgICAgICB0aGlzLm9uRGlzY29ubmVjdChtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5BQ0s6XG4gICAgICAgICAgICAgICAgdGhpcy5lbWl0KCdhY2snLCBtZXNzYWdlLm1zZ1NlcmlhbCwgbWVzc2FnZS5jb3VudCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGFjdGlvbnMuTkFDSzpcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ25hY2snLCBtZXNzYWdlLm1zZ1NlcmlhbCwgbWVzc2FnZS5jb3VudCwgbWVzc2FnZS5lcnJvcik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGFjdGlvbnMuU1lOQzpcbiAgICAgICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uQ2hhbm5lbE1lc3NhZ2UobWVzc2FnZSwgdGhpcyk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlIGFjdGlvbnMuQUNUSVZBVEU6XG4gICAgICAgICAgICAgICAgLy8gSWdub3JlZC5cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5BVVRIOlxuICAgICAgICAgICAgICAgIHRoaXMuYXV0aC5hdXRob3JpemUoZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1RyYW5zcG9ydC5vblByb3RvY29sTWVzc2FnZSgpJywgJ0FibHkgcmVxdWVzdGVkIHJlLWF1dGhlbnRpY2F0aW9uLCBidXQgdW5hYmxlIHRvIG9idGFpbiBhIG5ldyB0b2tlbjogJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLkVSUk9SOlxuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnVHJhbnNwb3J0Lm9uUHJvdG9jb2xNZXNzYWdlKCknLCAncmVjZWl2ZWQgZXJyb3IgYWN0aW9uOyBjb25uZWN0aW9uSWQgPSAnICtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jb25uZWN0aW9uSWQgK1xuICAgICAgICAgICAgICAgICAgICAnOyBlcnIgPSAnICtcbiAgICAgICAgICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KG1lc3NhZ2UuZXJyb3IpICtcbiAgICAgICAgICAgICAgICAgICAgKG1lc3NhZ2UuY2hhbm5lbCA/ICcsIGNoYW5uZWw6ICcgKyBtZXNzYWdlLmNoYW5uZWwgOiAnJykpO1xuICAgICAgICAgICAgICAgIGlmIChtZXNzYWdlLmNoYW5uZWwgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm9uRmF0YWxFcnJvcihtZXNzYWdlKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIG90aGVyd2lzZSBpdCdzIGEgY2hhbm5lbC1zcGVjaWZpYyBlcnJvciwgc28gaGFuZGxlIGl0IGluIHRoZSBjaGFubmVsICovXG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UsIHRoaXMpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAvKiBhbGwgb3RoZXIgYWN0aW9ucyBhcmUgY2hhbm5lbC1zcGVjaWZpYyAqL1xuICAgICAgICAgICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIub25DaGFubmVsTWVzc2FnZShtZXNzYWdlLCB0aGlzKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkNvbm5lY3QgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB0aGlzLmlzQ29ubmVjdGVkID0gdHJ1ZTtcbiAgICAgICAgaWYgKCFtZXNzYWdlLmNvbm5lY3Rpb25EZXRhaWxzKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1RyYW5zcG9ydC5vbkNvbm5lY3QoKTogQ29ubmVjdCBtZXNzYWdlIHJlY2lldmVkIHdpdGhvdXQgY29ubmVjdGlvbkRldGFpbHMnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWF4UHJvbWlzZWRJZGxlID0gbWVzc2FnZS5jb25uZWN0aW9uRGV0YWlscy5tYXhJZGxlSW50ZXJ2YWw7XG4gICAgICAgIGlmIChtYXhQcm9taXNlZElkbGUpIHtcbiAgICAgICAgICAgIHRoaXMubWF4SWRsZUludGVydmFsID0gbWF4UHJvbWlzZWRJZGxlICsgdGhpcy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0O1xuICAgICAgICAgICAgdGhpcy5vbkFjdGl2aXR5KCk7XG4gICAgICAgIH1cbiAgICAgICAgLyogZWxzZSBSZWFsdGltZSBkZWNsaW5lcyB0byBndWFyYW50ZWUgYW55IG1heGltdW0gaWRsZSBpbnRlcnZhbCAtIENEMmggKi9cbiAgICB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUub25EaXNjb25uZWN0ID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgLyogVXNlZCBmb3Igd2hlbiB0aGUgc2VydmVyIGhhcyBkaXNjb25uZWN0ZWQgdGhlIGNsaWVudCAodXN1YWxseSB3aXRoIGFcbiAgICAgICAgICogRElTQ09OTkVDVEVEIGFjdGlvbikgKi9cbiAgICAgICAgdmFyIGVyciA9IG1lc3NhZ2UgJiYgbWVzc2FnZS5lcnJvcjtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdUcmFuc3BvcnQub25EaXNjb25uZWN0KCknLCAnZXJyID0gJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgdGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVycik7XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uRmF0YWxFcnJvciA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIC8qIE9uIHJlY2VpcHQgb2YgYSBmYXRhbCBjb25uZWN0aW9uIGVycm9yLCB3ZSBjYW4gYXNzdW1lIHRoYXQgdGhlIHNlcnZlclxuICAgICAgICAgKiB3aWxsIGNsb3NlIHRoZSBjb25uZWN0aW9uIGFuZCB0aGUgdHJhbnNwb3J0LCBhbmQgZG8gbm90IG5lZWQgdG8gcmVxdWVzdFxuICAgICAgICAgKiBhIGRpc2Nvbm5lY3Rpb24gLSBSVE4xNWkgKi9cbiAgICAgICAgdmFyIGVyciA9IG1lc3NhZ2UgJiYgbWVzc2FnZS5lcnJvcjtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdUcmFuc3BvcnQub25GYXRhbEVycm9yKCknLCAnZXJyID0gJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgdGhpcy5maW5pc2goJ2ZhaWxlZCcsIGVycik7XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uQ2xvc2UgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgZXJyID0gbWVzc2FnZSAmJiBtZXNzYWdlLmVycm9yO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1RyYW5zcG9ydC5vbkNsb3NlKCknLCAnZXJyID0gJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgdGhpcy5maW5pc2goJ2Nsb3NlZCcsIGVycik7XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLnJlcXVlc3RDbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdUcmFuc3BvcnQucmVxdWVzdENsb3NlKCknLCAnJyk7XG4gICAgICAgIHRoaXMuc2VuZChjbG9zZU1lc3NhZ2UpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5yZXF1ZXN0RGlzY29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdUcmFuc3BvcnQucmVxdWVzdERpc2Nvbm5lY3QoKScsICcnKTtcbiAgICAgICAgdGhpcy5zZW5kKGRpc2Nvbm5lY3RNZXNzYWdlKTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUucGluZyA9IGZ1bmN0aW9uIChpZCkge1xuICAgICAgICB2YXIgbXNnID0geyBhY3Rpb246IHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuQWN0aW9uLkhFQVJUQkVBVCB9O1xuICAgICAgICBpZiAoaWQpXG4gICAgICAgICAgICBtc2cuaWQgPSBpZDtcbiAgICAgICAgdGhpcy5zZW5kKHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyhtc2cpKTtcbiAgICB9O1xuICAgIFRyYW5zcG9ydC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdUcmFuc3BvcnQuZGlzcG9zZSgpJywgJycpO1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLm9mZigpO1xuICAgIH07XG4gICAgVHJhbnNwb3J0LnByb3RvdHlwZS5vbkFjdGl2aXR5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMubWF4SWRsZUludGVydmFsKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5sYXN0QWN0aXZpdHkgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmxhc3RBY3Rpdml0eSA9IFV0aWxzLm5vdygpO1xuICAgICAgICB0aGlzLnNldElkbGVUaW1lcih0aGlzLm1heElkbGVJbnRlcnZhbCArIDEwMCk7XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLnNldElkbGVUaW1lciA9IGZ1bmN0aW9uICh0aW1lb3V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5pZGxlVGltZXIpIHtcbiAgICAgICAgICAgIHRoaXMuaWRsZVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMub25JZGxlVGltZXJFeHBpcmUoKTtcbiAgICAgICAgICAgIH0sIHRpbWVvdXQpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmFuc3BvcnQucHJvdG90eXBlLm9uSWRsZVRpbWVyRXhwaXJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBpZiAoIXRoaXMubGFzdEFjdGl2aXR5IHx8ICF0aGlzLm1heElkbGVJbnRlcnZhbCkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdUcmFuc3BvcnQub25JZGxlVGltZXJFeHBpcmUoKTogbGFzdEFjdGl2aXR5L21heElkbGVJbnRlcnZhbCBub3Qgc2V0Jyk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5pZGxlVGltZXIgPSBudWxsO1xuICAgICAgICB2YXIgc2luY2VMYXN0ID0gVXRpbHMubm93KCkgLSB0aGlzLmxhc3RBY3Rpdml0eTtcbiAgICAgICAgdmFyIHRpbWVSZW1haW5pbmcgPSB0aGlzLm1heElkbGVJbnRlcnZhbCAtIHNpbmNlTGFzdDtcbiAgICAgICAgaWYgKHRpbWVSZW1haW5pbmcgPD0gMCkge1xuICAgICAgICAgICAgdmFyIG1zZyA9ICdObyBhY3Rpdml0eSBzZWVuIGZyb20gcmVhbHRpbWUgaW4gJyArIHNpbmNlTGFzdCArICdtczsgYXNzdW1pbmcgY29ubmVjdGlvbiBoYXMgZHJvcHBlZCc7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1RyYW5zcG9ydC5vbklkbGVUaW1lckV4cGlyZSgpJywgbXNnKTtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdChuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdChtc2csIDgwMDAzLCA0MDgpKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMuc2V0SWRsZVRpbWVyKHRpbWVSZW1haW5pbmcgKyAxMDApO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBUcmFuc3BvcnQudHJ5Q29ubmVjdCA9IGZ1bmN0aW9uICh0cmFuc3BvcnRDdG9yLCBjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgdHJhbnNwb3J0UGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgdHJhbnNwb3J0ID0gbmV3IHRyYW5zcG9ydEN0b3IoY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHRyYW5zcG9ydFBhcmFtcyk7XG4gICAgICAgIHZhciB0cmFuc3BvcnRBdHRlbXB0VGltZXI7XG4gICAgICAgIHZhciBlcnJvckNiID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRyYW5zcG9ydEF0dGVtcHRUaW1lcik7XG4gICAgICAgICAgICBjYWxsYmFjayh7IGV2ZW50OiB0aGlzLmV2ZW50LCBlcnJvcjogZXJyIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgcmVhbHRpbWVSZXF1ZXN0VGltZW91dCA9IGNvbm5lY3Rpb25NYW5hZ2VyLm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dDtcbiAgICAgICAgdHJhbnNwb3J0QXR0ZW1wdFRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0cmFuc3BvcnQub2ZmKFsncHJlY29ubmVjdCcsICdkaXNjb25uZWN0ZWQnLCAnZmFpbGVkJ10pO1xuICAgICAgICAgICAgdHJhbnNwb3J0LmRpc3Bvc2UoKTtcbiAgICAgICAgICAgIGVycm9yQ2IuY2FsbCh7IGV2ZW50OiAnZGlzY29ubmVjdGVkJyB9LCBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVGltZW91dCB3YWl0aW5nIGZvciB0cmFuc3BvcnQgdG8gaW5kaWNhdGUgaXRzZWxmIHZpYWJsZScsIDUwMDAwLCA1MDApKTtcbiAgICAgICAgfSwgcmVhbHRpbWVSZXF1ZXN0VGltZW91dCk7XG4gICAgICAgIHRyYW5zcG9ydC5vbihbJ2ZhaWxlZCcsICdkaXNjb25uZWN0ZWQnXSwgZXJyb3JDYik7XG4gICAgICAgIHRyYW5zcG9ydC5vbigncHJlY29ubmVjdCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnVHJhbnNwb3J0LnRyeUNvbm5lY3QoKScsICd2aWFibGUgdHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRyYW5zcG9ydEF0dGVtcHRUaW1lcik7XG4gICAgICAgICAgICB0cmFuc3BvcnQub2ZmKFsnZmFpbGVkJywgJ2Rpc2Nvbm5lY3RlZCddLCBlcnJvckNiKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRyYW5zcG9ydCk7XG4gICAgICAgIH0pO1xuICAgICAgICB0cmFuc3BvcnQuY29ubmVjdCgpO1xuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zcG9ydDtcbn0oZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gVHJhbnNwb3J0O1xuXG5cbi8qKiovIH0pLFxuLyogMjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDQwKSwgX193ZWJwYWNrX3JlcXVpcmVfXygyNCkpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uICgpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cdCAgICB2YXIgTUQ1ID0gQ19hbGdvLk1ENTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBUaGlzIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIGlzIG1lYW50IHRvIGNvbmZvcm0gd2l0aCBFVlBfQnl0ZXNUb0tleS5cblx0ICAgICAqIHd3dy5vcGVuc3NsLm9yZy9kb2NzL2NyeXB0by9FVlBfQnl0ZXNUb0tleS5odG1sXG5cdCAgICAgKi9cblx0ICAgIHZhciBFdnBLREYgPSBDX2FsZ28uRXZwS0RGID0gQmFzZS5leHRlbmQoe1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbmZpZ3VyYXRpb24gb3B0aW9ucy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBrZXlTaXplIFRoZSBrZXkgc2l6ZSBpbiB3b3JkcyB0byBnZW5lcmF0ZS4gRGVmYXVsdDogNCAoMTI4IGJpdHMpXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtIYXNoZXJ9IGhhc2hlciBUaGUgaGFzaCBhbGdvcml0aG0gdG8gdXNlLiBEZWZhdWx0OiBNRDVcblx0ICAgICAgICAgKiBAcHJvcGVydHkge251bWJlcn0gaXRlcmF0aW9ucyBUaGUgbnVtYmVyIG9mIGl0ZXJhdGlvbnMgdG8gcGVyZm9ybS4gRGVmYXVsdDogMVxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoe1xuXHQgICAgICAgICAgICBrZXlTaXplOiAxMjgvMzIsXG5cdCAgICAgICAgICAgIGhhc2hlcjogTUQ1LFxuXHQgICAgICAgICAgICBpdGVyYXRpb25zOiAxXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQga2V5IGRlcml2YXRpb24gZnVuY3Rpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoZSBkZXJpdmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKCk7XG5cdCAgICAgICAgICogICAgIHZhciBrZGYgPSBDcnlwdG9KUy5hbGdvLkV2cEtERi5jcmVhdGUoeyBrZXlTaXplOiA4IH0pO1xuXHQgICAgICAgICAqICAgICB2YXIga2RmID0gQ3J5cHRvSlMuYWxnby5FdnBLREYuY3JlYXRlKHsga2V5U2l6ZTogOCwgaXRlcmF0aW9uczogMTAwMCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2ZnKSB7XG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlcml2ZXMgYSBrZXkgZnJvbSBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBzYWx0IEEgc2FsdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIga2V5ID0ga2RmLmNvbXB1dGUocGFzc3dvcmQsIHNhbHQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNvbXB1dGU6IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCkge1xuXHQgICAgICAgICAgICB2YXIgYmxvY2s7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGNmZyA9IHRoaXMuY2ZnO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXQgaGFzaGVyXG5cdCAgICAgICAgICAgIHZhciBoYXNoZXIgPSBjZmcuaGFzaGVyLmNyZWF0ZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIEluaXRpYWwgdmFsdWVzXG5cdCAgICAgICAgICAgIHZhciBkZXJpdmVkS2V5ID0gV29yZEFycmF5LmNyZWF0ZSgpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGVyaXZlZEtleVdvcmRzID0gZGVyaXZlZEtleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGtleVNpemUgPSBjZmcua2V5U2l6ZTtcblx0ICAgICAgICAgICAgdmFyIGl0ZXJhdGlvbnMgPSBjZmcuaXRlcmF0aW9ucztcblxuXHQgICAgICAgICAgICAvLyBHZW5lcmF0ZSBrZXlcblx0ICAgICAgICAgICAgd2hpbGUgKGRlcml2ZWRLZXlXb3Jkcy5sZW5ndGggPCBrZXlTaXplKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoYmxvY2spIHtcblx0ICAgICAgICAgICAgICAgICAgICBoYXNoZXIudXBkYXRlKGJsb2NrKTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgICAgIGJsb2NrID0gaGFzaGVyLnVwZGF0ZShwYXNzd29yZCkuZmluYWxpemUoc2FsdCk7XG5cdCAgICAgICAgICAgICAgICBoYXNoZXIucmVzZXQoKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gSXRlcmF0aW9uc1xuXHQgICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDE7IGkgPCBpdGVyYXRpb25zOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgICAgICBibG9jayA9IGhhc2hlci5maW5hbGl6ZShibG9jayk7XG5cdCAgICAgICAgICAgICAgICAgICAgaGFzaGVyLnJlc2V0KCk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIGRlcml2ZWRLZXkuY29uY2F0KGJsb2NrKTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICBkZXJpdmVkS2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIGRlcml2ZWRLZXk7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogRGVyaXZlcyBhIGtleSBmcm9tIGEgcGFzc3dvcmQuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBwYXNzd29yZCBUaGUgcGFzc3dvcmQuXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IHNhbHQgQSBzYWx0LlxuXHQgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIGNvbXB1dGF0aW9uLlxuXHQgICAgICpcblx0ICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRlcml2ZWQga2V5LlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgICAqICAgICB2YXIga2V5ID0gQ3J5cHRvSlMuRXZwS0RGKHBhc3N3b3JkLCBzYWx0LCB7IGtleVNpemU6IDggfSk7XG5cdCAgICAgKiAgICAgdmFyIGtleSA9IENyeXB0b0pTLkV2cEtERihwYXNzd29yZCwgc2FsdCwgeyBrZXlTaXplOiA4LCBpdGVyYXRpb25zOiAxMDAwIH0pO1xuXHQgICAgICovXG5cdCAgICBDLkV2cEtERiA9IGZ1bmN0aW9uIChwYXNzd29yZCwgc2FsdCwgY2ZnKSB7XG5cdCAgICAgICAgcmV0dXJuIEV2cEtERi5jcmVhdGUoY2ZnKS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblx0ICAgIH07XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuRXZwS0RGO1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMjggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDYpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI3KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQvKipcblx0ICogQ2lwaGVyIGNvcmUgY29tcG9uZW50cy5cblx0ICovXG5cdENyeXB0b0pTLmxpYi5DaXBoZXIgfHwgKGZ1bmN0aW9uICh1bmRlZmluZWQpIHtcblx0ICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgdmFyIEMgPSBDcnlwdG9KUztcblx0ICAgIHZhciBDX2xpYiA9IEMubGliO1xuXHQgICAgdmFyIEJhc2UgPSBDX2xpYi5CYXNlO1xuXHQgICAgdmFyIFdvcmRBcnJheSA9IENfbGliLldvcmRBcnJheTtcblx0ICAgIHZhciBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtID0gQ19saWIuQnVmZmVyZWRCbG9ja0FsZ29yaXRobTtcblx0ICAgIHZhciBDX2VuYyA9IEMuZW5jO1xuXHQgICAgdmFyIFV0ZjggPSBDX2VuYy5VdGY4O1xuXHQgICAgdmFyIEJhc2U2NCA9IENfZW5jLkJhc2U2NDtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cdCAgICB2YXIgRXZwS0RGID0gQ19hbGdvLkV2cEtERjtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGNpcGhlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0ga2V5U2l6ZSBUaGlzIGNpcGhlcidzIGtleSBzaXplLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBpdlNpemUgVGhpcyBjaXBoZXIncyBJViBzaXplLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAqIEBwcm9wZXJ0eSB7bnVtYmVyfSBfRU5DX1hGT1JNX01PREUgQSBjb25zdGFudCByZXByZXNlbnRpbmcgZW5jcnlwdGlvbiBtb2RlLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IF9ERUNfWEZPUk1fTU9ERSBBIGNvbnN0YW50IHJlcHJlc2VudGluZyBkZWNyeXB0aW9uIG1vZGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDaXBoZXIgPSBDX2xpYi5DaXBoZXIgPSBCdWZmZXJlZEJsb2NrQWxnb3JpdGhtLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29uZmlndXJhdGlvbiBvcHRpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGl2IFRoZSBJViB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQmFzZS5leHRlbmQoKSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZW5jcnlwdGlvbiBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRW5jcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRW5jcnlwdG9yOiBmdW5jdGlvbiAoa2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0VOQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENyZWF0ZXMgdGhpcyBjaXBoZXIgaW4gZGVjcnlwdGlvbiBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGtleSBUaGUga2V5LlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJ9IEEgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyID0gQ3J5cHRvSlMuYWxnby5BRVMuY3JlYXRlRGVjcnlwdG9yKGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRGVjcnlwdG9yOiBmdW5jdGlvbiAoa2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlKHRoaXMuX0RFQ19YRk9STV9NT0RFLCBrZXksIGNmZyk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBjaXBoZXIuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0geGZvcm1Nb2RlIEVpdGhlciB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHRyYW5zb3JtYXRpb24gbW9kZSBjb25zdGFudC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlciA9IENyeXB0b0pTLmFsZ28uQUVTLmNyZWF0ZShDcnlwdG9KUy5hbGdvLkFFUy5fRU5DX1hGT1JNX01PREUsIGtleVdvcmRBcnJheSwgeyBpdjogaXZXb3JkQXJyYXkgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgaW5pdDogZnVuY3Rpb24gKHhmb3JtTW9kZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgLy8gQXBwbHkgY29uZmlnIGRlZmF1bHRzXG5cdCAgICAgICAgICAgIHRoaXMuY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gU3RvcmUgdHJhbnNmb3JtIG1vZGUgYW5kIGtleVxuXHQgICAgICAgICAgICB0aGlzLl94Zm9ybU1vZGUgPSB4Zm9ybU1vZGU7XG5cdCAgICAgICAgICAgIHRoaXMuX2tleSA9IGtleTtcblxuXHQgICAgICAgICAgICAvLyBTZXQgaW5pdGlhbCB2YWx1ZXNcblx0ICAgICAgICAgICAgdGhpcy5yZXNldCgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBSZXNldHMgdGhpcyBjaXBoZXIgdG8gaXRzIGluaXRpYWwgc3RhdGUuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIGNpcGhlci5yZXNldCgpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHJlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFJlc2V0IGRhdGEgYnVmZmVyXG5cdCAgICAgICAgICAgIEJ1ZmZlcmVkQmxvY2tBbGdvcml0aG0ucmVzZXQuY2FsbCh0aGlzKTtcblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xuXHQgICAgICAgICAgICB0aGlzLl9kb1Jlc2V0KCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEFkZHMgZGF0YSB0byBiZSBlbmNyeXB0ZWQgb3IgZGVjcnlwdGVkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBkYXRhVXBkYXRlIFRoZSBkYXRhIHRvIGVuY3J5cHQgb3IgZGVjcnlwdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge1dvcmRBcnJheX0gVGhlIGRhdGEgYWZ0ZXIgcHJvY2Vzc2luZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5wcm9jZXNzKCdkYXRhJyk7XG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIucHJvY2Vzcyh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHByb2Nlc3M6IGZ1bmN0aW9uIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGVuZFxuXHQgICAgICAgICAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XG5cblx0ICAgICAgICAgICAgLy8gUHJvY2VzcyBhdmFpbGFibGUgYmxvY2tzXG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLl9wcm9jZXNzKCk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEZpbmFsaXplcyB0aGUgZW5jcnlwdGlvbiBvciBkZWNyeXB0aW9uIHByb2Nlc3MuXG5cdCAgICAgICAgICogTm90ZSB0aGF0IHRoZSBmaW5hbGl6ZSBvcGVyYXRpb24gaXMgZWZmZWN0aXZlbHkgYSBkZXN0cnVjdGl2ZSwgcmVhZC1vbmNlIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gZGF0YVVwZGF0ZSBUaGUgZmluYWwgZGF0YSB0byBlbmNyeXB0IG9yIGRlY3J5cHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBkYXRhIGFmdGVyIGZpbmFsIHByb2Nlc3NpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBlbmNyeXB0ZWQgPSBjaXBoZXIuZmluYWxpemUoKTtcblx0ICAgICAgICAgKiAgICAgdmFyIGVuY3J5cHRlZCA9IGNpcGhlci5maW5hbGl6ZSgnZGF0YScpO1xuXHQgICAgICAgICAqICAgICB2YXIgZW5jcnlwdGVkID0gY2lwaGVyLmZpbmFsaXplKHdvcmRBcnJheSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZmluYWxpemU6IGZ1bmN0aW9uIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgIC8vIEZpbmFsIGRhdGEgdXBkYXRlXG5cdCAgICAgICAgICAgIGlmIChkYXRhVXBkYXRlKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9hcHBlbmQoZGF0YVVwZGF0ZSk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBQZXJmb3JtIGNvbmNyZXRlLWNpcGhlciBsb2dpY1xuXHQgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWREYXRhID0gdGhpcy5fZG9GaW5hbGl6ZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZERhdGE7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGtleVNpemU6IDEyOC8zMixcblxuXHQgICAgICAgIGl2U2l6ZTogMTI4LzMyLFxuXG5cdCAgICAgICAgX0VOQ19YRk9STV9NT0RFOiAxLFxuXG5cdCAgICAgICAgX0RFQ19YRk9STV9NT0RFOiAyLFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyBzaG9ydGN1dCBmdW5jdGlvbnMgdG8gYSBjaXBoZXIncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIHRvIGNyZWF0ZSBhIGhlbHBlciBmb3IuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtPYmplY3R9IEFuIG9iamVjdCB3aXRoIGVuY3J5cHQgYW5kIGRlY3J5cHQgc2hvcnRjdXQgZnVuY3Rpb25zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgQUVTID0gQ3J5cHRvSlMubGliLkNpcGhlci5fY3JlYXRlSGVscGVyKENyeXB0b0pTLmFsZ28uQUVTKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBfY3JlYXRlSGVscGVyOiAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICBmdW5jdGlvbiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpIHtcblx0ICAgICAgICAgICAgICAgIGlmICh0eXBlb2Yga2V5ID09ICdzdHJpbmcnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFBhc3N3b3JkQmFzZWRDaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBTZXJpYWxpemFibGVDaXBoZXI7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gZnVuY3Rpb24gKGNpcGhlcikge1xuXHQgICAgICAgICAgICAgICAgcmV0dXJuIHtcblx0ICAgICAgICAgICAgICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAobWVzc2FnZSwga2V5LCBjZmcpIHtcblx0ICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlbGVjdENpcGhlclN0cmF0ZWd5KGtleSkuZW5jcnlwdChjaXBoZXIsIG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAgICAgICAgICAgICAgICB9LFxuXG5cdCAgICAgICAgICAgICAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBzZWxlY3RDaXBoZXJTdHJhdGVneShrZXkpLmRlY3J5cHQoY2lwaGVyLCBjaXBoZXJ0ZXh0LCBrZXksIGNmZyk7XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXHQgICAgICAgICAgICAgICAgfTtcblx0ICAgICAgICAgICAgfTtcblx0ICAgICAgICB9KCkpXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIHN0cmVhbSBjaXBoZXIgdGVtcGxhdGUuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgbnVtYmVyIG9mIDMyLWJpdCB3b3JkcyB0aGlzIGNpcGhlciBvcGVyYXRlcyBvbi4gRGVmYXVsdDogMSAoMzIgYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIFN0cmVhbUNpcGhlciA9IENfbGliLlN0cmVhbUNpcGhlciA9IENpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFByb2Nlc3MgcGFydGlhbCBibG9ja3Ncblx0ICAgICAgICAgICAgdmFyIGZpbmFsUHJvY2Vzc2VkQmxvY2tzID0gdGhpcy5fcHJvY2VzcyghISdmbHVzaCcpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBmaW5hbFByb2Nlc3NlZEJsb2Nrcztcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgYmxvY2tTaXplOiAxXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNb2RlIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfbW9kZSA9IEMubW9kZSA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIEFic3RyYWN0IGJhc2UgYmxvY2sgY2lwaGVyIG1vZGUgdGVtcGxhdGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBCbG9ja0NpcGhlck1vZGUgPSBDX2xpYi5CbG9ja0NpcGhlck1vZGUgPSBCYXNlLmV4dGVuZCh7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ3JlYXRlcyB0aGlzIG1vZGUgZm9yIGVuY3J5cHRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIEEgYmxvY2sgY2lwaGVyIGluc3RhbmNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IGl2IFRoZSBJViB3b3Jkcy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIG1vZGUgPSBDcnlwdG9KUy5tb2RlLkNCQy5jcmVhdGVFbmNyeXB0b3IoY2lwaGVyLCBpdi53b3Jkcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgY3JlYXRlRW5jcnlwdG9yOiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5FbmNyeXB0b3IuY3JlYXRlKGNpcGhlciwgaXYpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDcmVhdGVzIHRoaXMgbW9kZSBmb3IgZGVjcnlwdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgQSBibG9jayBjaXBoZXIgaW5zdGFuY2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtBcnJheX0gaXYgVGhlIElWIHdvcmRzLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgbW9kZSA9IENyeXB0b0pTLm1vZGUuQ0JDLmNyZWF0ZURlY3J5cHRvcihjaXBoZXIsIGl2LndvcmRzKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjcmVhdGVEZWNyeXB0b3I6IGZ1bmN0aW9uIChjaXBoZXIsIGl2KSB7XG5cdCAgICAgICAgICAgIHJldHVybiB0aGlzLkRlY3J5cHRvci5jcmVhdGUoY2lwaGVyLCBpdik7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEluaXRpYWxpemVzIGEgbmV3bHkgY3JlYXRlZCBtb2RlLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBBIGJsb2NrIGNpcGhlciBpbnN0YW5jZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0FycmF5fSBpdiBUaGUgSVYgd29yZHMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBtb2RlID0gQ3J5cHRvSlMubW9kZS5DQkMuRW5jcnlwdG9yLmNyZWF0ZShjaXBoZXIsIGl2LndvcmRzKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyLCBpdikge1xuXHQgICAgICAgICAgICB0aGlzLl9jaXBoZXIgPSBjaXBoZXI7XG5cdCAgICAgICAgICAgIHRoaXMuX2l2ID0gaXY7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogQ2lwaGVyIEJsb2NrIENoYWluaW5nIG1vZGUuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDQkMgPSBDX21vZGUuQ0JDID0gKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBBYnN0cmFjdCBiYXNlIENCQyBtb2RlLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHZhciBDQkMgPSBCbG9ja0NpcGhlck1vZGUuZXh0ZW5kKCk7XG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDQkMgZW5jcnlwdG9yLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIENCQy5FbmNyeXB0b3IgPSBDQkMuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBYT1IgYW5kIGVuY3J5cHRcblx0ICAgICAgICAgICAgICAgIHhvckJsb2NrLmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplKTtcblx0ICAgICAgICAgICAgICAgIGNpcGhlci5lbmNyeXB0QmxvY2sod29yZHMsIG9mZnNldCk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFJlbWVtYmVyIHRoaXMgYmxvY2sgdG8gdXNlIHdpdGggbmV4dCBibG9ja1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gd29yZHMuc2xpY2Uob2Zmc2V0LCBvZmZzZXQgKyBibG9ja1NpemUpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDQkMgZGVjcnlwdG9yLlxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIENCQy5EZWNyeXB0b3IgPSBDQkMuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgLyoqXG5cdCAgICAgICAgICAgICAqIFByb2Nlc3NlcyB0aGUgZGF0YSBibG9jayBhdCBvZmZzZXQuXG5cdCAgICAgICAgICAgICAqXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7QXJyYXl9IHdvcmRzIFRoZSBkYXRhIHdvcmRzIHRvIG9wZXJhdGUgb24uXG5cdCAgICAgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBvZmZzZXQgVGhlIG9mZnNldCB3aGVyZSB0aGUgYmxvY2sgc3RhcnRzLlxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAgICAgKlxuXHQgICAgICAgICAgICAgKiAgICAgbW9kZS5wcm9jZXNzQmxvY2soZGF0YS53b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICovXG5cdCAgICAgICAgICAgIHByb2Nlc3NCbG9jazogZnVuY3Rpb24gKHdvcmRzLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICAgICAgdmFyIGNpcGhlciA9IHRoaXMuX2NpcGhlcjtcblx0ICAgICAgICAgICAgICAgIHZhciBibG9ja1NpemUgPSBjaXBoZXIuYmxvY2tTaXplO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1lbWJlciB0aGlzIGJsb2NrIHRvIHVzZSB3aXRoIG5leHQgYmxvY2tcblx0ICAgICAgICAgICAgICAgIHZhciB0aGlzQmxvY2sgPSB3b3Jkcy5zbGljZShvZmZzZXQsIG9mZnNldCArIGJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIERlY3J5cHQgYW5kIFhPUlxuXHQgICAgICAgICAgICAgICAgY2lwaGVyLmRlY3J5cHRCbG9jayh3b3Jkcywgb2Zmc2V0KTtcblx0ICAgICAgICAgICAgICAgIHhvckJsb2NrLmNhbGwodGhpcywgd29yZHMsIG9mZnNldCwgYmxvY2tTaXplKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVGhpcyBibG9jayBiZWNvbWVzIHRoZSBwcmV2aW91cyBibG9ja1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fcHJldkJsb2NrID0gdGhpc0Jsb2NrO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgfSk7XG5cblx0ICAgICAgICBmdW5jdGlvbiB4b3JCbG9jayh3b3Jkcywgb2Zmc2V0LCBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgdmFyIGJsb2NrO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBpdiA9IHRoaXMuX2l2O1xuXG5cdCAgICAgICAgICAgIC8vIENob29zZSBtaXhpbmcgYmxvY2tcblx0ICAgICAgICAgICAgaWYgKGl2KSB7XG5cdCAgICAgICAgICAgICAgICBibG9jayA9IGl2O1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgSVYgZm9yIHN1YnNlcXVlbnQgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9pdiA9IHVuZGVmaW5lZDtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIGJsb2NrID0gdGhpcy5fcHJldkJsb2NrO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gWE9SIGJsb2Nrc1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJsb2NrU2l6ZTsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tvZmZzZXQgKyBpXSBePSBibG9ja1tpXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblxuXHQgICAgICAgIHJldHVybiBDQkM7XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFBhZGRpbmcgbmFtZXNwYWNlLlxuXHQgICAgICovXG5cdCAgICB2YXIgQ19wYWQgPSBDLnBhZCA9IHt9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFBLQ1MgIzUvNyBwYWRkaW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgUGtjczcgPSBDX3BhZC5Qa2NzNyA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBQYWRzIGRhdGEgdXNpbmcgdGhlIGFsZ29yaXRobSBkZWZpbmVkIGluIFBLQ1MgIzUvNy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBkYXRhIFRoZSBkYXRhIHRvIHBhZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0gYmxvY2tTaXplIFRoZSBtdWx0aXBsZSB0aGF0IHRoZSBkYXRhIHNob3VsZCBiZSBwYWRkZWQgdG8uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIENyeXB0b0pTLnBhZC5Qa2NzNy5wYWQod29yZEFycmF5LCA0KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYWQ6IGZ1bmN0aW9uIChkYXRhLCBibG9ja1NpemUpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIGJsb2NrU2l6ZUJ5dGVzID0gYmxvY2tTaXplICogNDtcblxuXHQgICAgICAgICAgICAvLyBDb3VudCBwYWRkaW5nIGJ5dGVzXG5cdCAgICAgICAgICAgIHZhciBuUGFkZGluZ0J5dGVzID0gYmxvY2tTaXplQnl0ZXMgLSBkYXRhLnNpZ0J5dGVzICUgYmxvY2tTaXplQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIHBhZGRpbmcgd29yZFxuXHQgICAgICAgICAgICB2YXIgcGFkZGluZ1dvcmQgPSAoblBhZGRpbmdCeXRlcyA8PCAyNCkgfCAoblBhZGRpbmdCeXRlcyA8PCAxNikgfCAoblBhZGRpbmdCeXRlcyA8PCA4KSB8IG5QYWRkaW5nQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ3JlYXRlIHBhZGRpbmdcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmdXb3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5QYWRkaW5nQnl0ZXM7IGkgKz0gNCkge1xuXHQgICAgICAgICAgICAgICAgcGFkZGluZ1dvcmRzLnB1c2gocGFkZGluZ1dvcmQpO1xuXHQgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIHZhciBwYWRkaW5nID0gV29yZEFycmF5LmNyZWF0ZShwYWRkaW5nV29yZHMsIG5QYWRkaW5nQnl0ZXMpO1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGEuY29uY2F0KHBhZGRpbmcpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBVbnBhZHMgZGF0YSB0aGF0IGhhZCBiZWVuIHBhZGRlZCB1c2luZyB0aGUgYWxnb3JpdGhtIGRlZmluZWQgaW4gUEtDUyAjNS83LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IGRhdGEgVGhlIGRhdGEgdG8gdW5wYWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIENyeXB0b0pTLnBhZC5Qa2NzNy51bnBhZCh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHVucGFkOiBmdW5jdGlvbiAoZGF0YSkge1xuXHQgICAgICAgICAgICAvLyBHZXQgbnVtYmVyIG9mIHBhZGRpbmcgYnl0ZXMgZnJvbSBsYXN0IGJ5dGVcblx0ICAgICAgICAgICAgdmFyIG5QYWRkaW5nQnl0ZXMgPSBkYXRhLndvcmRzWyhkYXRhLnNpZ0J5dGVzIC0gMSkgPj4+IDJdICYgMHhmZjtcblxuXHQgICAgICAgICAgICAvLyBSZW1vdmUgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhLnNpZ0J5dGVzIC09IG5QYWRkaW5nQnl0ZXM7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBYnN0cmFjdCBiYXNlIGJsb2NrIGNpcGhlciB0ZW1wbGF0ZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcHJvcGVydHkge251bWJlcn0gYmxvY2tTaXplIFRoZSBudW1iZXIgb2YgMzItYml0IHdvcmRzIHRoaXMgY2lwaGVyIG9wZXJhdGVzIG9uLiBEZWZhdWx0OiA0ICgxMjggYml0cylcblx0ICAgICAqL1xuXHQgICAgdmFyIEJsb2NrQ2lwaGVyID0gQ19saWIuQmxvY2tDaXBoZXIgPSBDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge01vZGV9IG1vZGUgVGhlIGJsb2NrIG1vZGUgdG8gdXNlLiBEZWZhdWx0OiBDQkNcblx0ICAgICAgICAgKiBAcHJvcGVydHkge1BhZGRpbmd9IHBhZGRpbmcgVGhlIHBhZGRpbmcgc3RyYXRlZ3kgdG8gdXNlLiBEZWZhdWx0OiBQa2NzN1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogQ2lwaGVyLmNmZy5leHRlbmQoe1xuXHQgICAgICAgICAgICBtb2RlOiBDQkMsXG5cdCAgICAgICAgICAgIHBhZGRpbmc6IFBrY3M3XG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICByZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgbW9kZUNyZWF0b3I7XG5cblx0ICAgICAgICAgICAgLy8gUmVzZXQgY2lwaGVyXG5cdCAgICAgICAgICAgIENpcGhlci5yZXNldC5jYWxsKHRoaXMpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2ZnID0gdGhpcy5jZmc7XG5cdCAgICAgICAgICAgIHZhciBpdiA9IGNmZy5pdjtcblx0ICAgICAgICAgICAgdmFyIG1vZGUgPSBjZmcubW9kZTtcblxuXHQgICAgICAgICAgICAvLyBSZXNldCBibG9jayBtb2RlXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fRU5DX1hGT1JNX01PREUpIHtcblx0ICAgICAgICAgICAgICAgIG1vZGVDcmVhdG9yID0gbW9kZS5jcmVhdGVFbmNyeXB0b3I7XG5cdCAgICAgICAgICAgIH0gZWxzZSAvKiBpZiAodGhpcy5feGZvcm1Nb2RlID09IHRoaXMuX0RFQ19YRk9STV9NT0RFKSAqLyB7XG5cdCAgICAgICAgICAgICAgICBtb2RlQ3JlYXRvciA9IG1vZGUuY3JlYXRlRGVjcnlwdG9yO1xuXHQgICAgICAgICAgICAgICAgLy8gS2VlcCBhdCBsZWFzdCBvbmUgYmxvY2sgaW4gdGhlIGJ1ZmZlciBmb3IgdW5wYWRkaW5nXG5cdCAgICAgICAgICAgICAgICB0aGlzLl9taW5CdWZmZXJTaXplID0gMTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl9tb2RlICYmIHRoaXMuX21vZGUuX19jcmVhdG9yID09IG1vZGVDcmVhdG9yKSB7XG5cdCAgICAgICAgICAgICAgICB0aGlzLl9tb2RlLmluaXQodGhpcywgaXYgJiYgaXYud29yZHMpO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbW9kZSA9IG1vZGVDcmVhdG9yLmNhbGwobW9kZSwgdGhpcywgaXYgJiYgaXYud29yZHMpO1xuXHQgICAgICAgICAgICAgICAgdGhpcy5fbW9kZS5fX2NyZWF0b3IgPSBtb2RlQ3JlYXRvcjtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uICh3b3Jkcywgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX21vZGUucHJvY2Vzc0Jsb2NrKHdvcmRzLCBvZmZzZXQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB2YXIgZmluYWxQcm9jZXNzZWRCbG9ja3M7XG5cblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIHBhZGRpbmcgPSB0aGlzLmNmZy5wYWRkaW5nO1xuXG5cdCAgICAgICAgICAgIC8vIEZpbmFsaXplXG5cdCAgICAgICAgICAgIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fRU5DX1hGT1JNX01PREUpIHtcblx0ICAgICAgICAgICAgICAgIC8vIFBhZCBkYXRhXG5cdCAgICAgICAgICAgICAgICBwYWRkaW5nLnBhZCh0aGlzLl9kYXRhLCB0aGlzLmJsb2NrU2l6ZSk7XG5cblx0ICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblx0ICAgICAgICAgICAgfSBlbHNlIC8qIGlmICh0aGlzLl94Zm9ybU1vZGUgPT0gdGhpcy5fREVDX1hGT1JNX01PREUpICovIHtcblx0ICAgICAgICAgICAgICAgIC8vIFByb2Nlc3MgZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgICAgICBmaW5hbFByb2Nlc3NlZEJsb2NrcyA9IHRoaXMuX3Byb2Nlc3MoISEnZmx1c2gnKTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVW5wYWQgZGF0YVxuXHQgICAgICAgICAgICAgICAgcGFkZGluZy51bnBhZChmaW5hbFByb2Nlc3NlZEJsb2Nrcyk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gZmluYWxQcm9jZXNzZWRCbG9ja3M7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGJsb2NrU2l6ZTogMTI4LzMyXG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIGNvbGxlY3Rpb24gb2YgY2lwaGVyIHBhcmFtZXRlcnMuXG5cdCAgICAgKlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGNpcGhlcnRleHQgVGhlIHJhdyBjaXBoZXJ0ZXh0LlxuXHQgICAgICogQHByb3BlcnR5IHtXb3JkQXJyYXl9IGtleSBUaGUga2V5IHRvIHRoaXMgY2lwaGVydGV4dC5cblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBpdiBUaGUgSVYgdXNlZCBpbiB0aGUgY2lwaGVyaW5nIG9wZXJhdGlvbi5cblx0ICAgICAqIEBwcm9wZXJ0eSB7V29yZEFycmF5fSBzYWx0IFRoZSBzYWx0IHVzZWQgd2l0aCBhIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtDaXBoZXJ9IGFsZ29yaXRobSBUaGUgY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqIEBwcm9wZXJ0eSB7TW9kZX0gbW9kZSBUaGUgYmxvY2sgbW9kZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtQYWRkaW5nfSBwYWRkaW5nIFRoZSBwYWRkaW5nIHNjaGVtZSB1c2VkIGluIHRoZSBjaXBoZXJpbmcgb3BlcmF0aW9uLlxuXHQgICAgICogQHByb3BlcnR5IHtudW1iZXJ9IGJsb2NrU2l6ZSBUaGUgYmxvY2sgc2l6ZSBvZiB0aGUgY2lwaGVyLlxuXHQgICAgICogQHByb3BlcnR5IHtGb3JtYXR9IGZvcm1hdHRlciBUaGUgZGVmYXVsdCBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cblx0ICAgICAqL1xuXHQgICAgdmFyIENpcGhlclBhcmFtcyA9IENfbGliLkNpcGhlclBhcmFtcyA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBJbml0aWFsaXplcyBhIG5ld2x5IGNyZWF0ZWQgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2lwaGVyUGFyYW1zIEFuIG9iamVjdCB3aXRoIGFueSBvZiB0aGUgcG9zc2libGUgY2lwaGVyIHBhcmFtZXRlcnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5saWIuQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7XG5cdCAgICAgICAgICogICAgICAgICBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAga2V5OiBrZXlXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBpdjogaXZXb3JkQXJyYXksXG5cdCAgICAgICAgICogICAgICAgICBzYWx0OiBzYWx0V29yZEFycmF5LFxuXHQgICAgICAgICAqICAgICAgICAgYWxnb3JpdGhtOiBDcnlwdG9KUy5hbGdvLkFFUyxcblx0ICAgICAgICAgKiAgICAgICAgIG1vZGU6IENyeXB0b0pTLm1vZGUuQ0JDLFxuXHQgICAgICAgICAqICAgICAgICAgcGFkZGluZzogQ3J5cHRvSlMucGFkLlBLQ1M3LFxuXHQgICAgICAgICAqICAgICAgICAgYmxvY2tTaXplOiA0LFxuXHQgICAgICAgICAqICAgICAgICAgZm9ybWF0dGVyOiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTFxuXHQgICAgICAgICAqICAgICB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBpbml0OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XG5cdCAgICAgICAgICAgIHRoaXMubWl4SW4oY2lwaGVyUGFyYW1zKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgdGhpcyBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Rm9ybWF0fSBmb3JtYXR0ZXIgKE9wdGlvbmFsKSBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBzdHJpbmdpZmllZCBjaXBoZXIgcGFyYW1zLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHRocm93cyBFcnJvciBJZiBuZWl0aGVyIHRoZSBmb3JtYXR0ZXIgbm9yIHRoZSBkZWZhdWx0IGZvcm1hdHRlciBpcyBzZXQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBzdHJpbmcgPSBjaXBoZXJQYXJhbXMgKyAnJztcblx0ICAgICAgICAgKiAgICAgdmFyIHN0cmluZyA9IGNpcGhlclBhcmFtcy50b1N0cmluZygpO1xuXHQgICAgICAgICAqICAgICB2YXIgc3RyaW5nID0gY2lwaGVyUGFyYW1zLnRvU3RyaW5nKENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICB0b1N0cmluZzogZnVuY3Rpb24gKGZvcm1hdHRlcikge1xuXHQgICAgICAgICAgICByZXR1cm4gKGZvcm1hdHRlciB8fCB0aGlzLmZvcm1hdHRlcikuc3RyaW5naWZ5KHRoaXMpO1xuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEZvcm1hdCBuYW1lc3BhY2UuXG5cdCAgICAgKi9cblx0ICAgIHZhciBDX2Zvcm1hdCA9IEMuZm9ybWF0ID0ge307XG5cblx0ICAgIC8qKlxuXHQgICAgICogT3BlblNTTCBmb3JtYXR0aW5nIHN0cmF0ZWd5LlxuXHQgICAgICovXG5cdCAgICB2YXIgT3BlblNTTEZvcm1hdHRlciA9IENfZm9ybWF0Lk9wZW5TU0wgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgYSBjaXBoZXIgcGFyYW1zIG9iamVjdCB0byBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJQYXJhbXN9IGNpcGhlclBhcmFtcyBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtzdHJpbmd9IFRoZSBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgb3BlblNTTFN0cmluZyA9IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMLnN0cmluZ2lmeShjaXBoZXJQYXJhbXMpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKGNpcGhlclBhcmFtcykge1xuXHQgICAgICAgICAgICB2YXIgd29yZEFycmF5O1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IGNpcGhlclBhcmFtcy5jaXBoZXJ0ZXh0O1xuXHQgICAgICAgICAgICB2YXIgc2FsdCA9IGNpcGhlclBhcmFtcy5zYWx0O1xuXG5cdCAgICAgICAgICAgIC8vIEZvcm1hdFxuXHQgICAgICAgICAgICBpZiAoc2FsdCkge1xuXHQgICAgICAgICAgICAgICAgd29yZEFycmF5ID0gV29yZEFycmF5LmNyZWF0ZShbMHg1MzYxNmM3NCwgMHg2NTY0NWY1Zl0pLmNvbmNhdChzYWx0KS5jb25jYXQoY2lwaGVydGV4dCk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICB3b3JkQXJyYXkgPSBjaXBoZXJ0ZXh0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHdvcmRBcnJheS50b1N0cmluZyhCYXNlNjQpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhbiBPcGVuU1NMLWNvbXBhdGlibGUgc3RyaW5nIHRvIGEgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gb3BlblNTTFN0ciBUaGUgT3BlblNTTC1jb21wYXRpYmxlIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVyUGFyYW1zID0gQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wucGFyc2Uob3BlblNTTFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChvcGVuU1NMU3RyKSB7XG5cdCAgICAgICAgICAgIHZhciBzYWx0O1xuXG5cdCAgICAgICAgICAgIC8vIFBhcnNlIGJhc2U2NFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IEJhc2U2NC5wYXJzZShvcGVuU1NMU3RyKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dFdvcmRzID0gY2lwaGVydGV4dC53b3JkcztcblxuXHQgICAgICAgICAgICAvLyBUZXN0IGZvciBzYWx0XG5cdCAgICAgICAgICAgIGlmIChjaXBoZXJ0ZXh0V29yZHNbMF0gPT0gMHg1MzYxNmM3NCAmJiBjaXBoZXJ0ZXh0V29yZHNbMV0gPT0gMHg2NTY0NWY1Zikge1xuXHQgICAgICAgICAgICAgICAgLy8gRXh0cmFjdCBzYWx0XG5cdCAgICAgICAgICAgICAgICBzYWx0ID0gV29yZEFycmF5LmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoMiwgNCkpO1xuXG5cdCAgICAgICAgICAgICAgICAvLyBSZW1vdmUgc2FsdCBmcm9tIGNpcGhlcnRleHRcblx0ICAgICAgICAgICAgICAgIGNpcGhlcnRleHRXb3Jkcy5zcGxpY2UoMCwgNCk7XG5cdCAgICAgICAgICAgICAgICBjaXBoZXJ0ZXh0LnNpZ0J5dGVzIC09IDE2O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgcmV0dXJuIENpcGhlclBhcmFtcy5jcmVhdGUoeyBjaXBoZXJ0ZXh0OiBjaXBoZXJ0ZXh0LCBzYWx0OiBzYWx0IH0pO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIC8qKlxuXHQgICAgICogQSBjaXBoZXIgd3JhcHBlciB0aGF0IHJldHVybnMgY2lwaGVydGV4dCBhcyBhIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNlcmlhbGl6YWJsZUNpcGhlciA9IENfbGliLlNlcmlhbGl6YWJsZUNpcGhlciA9IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge0Zvcm1hdHRlcn0gZm9ybWF0IFRoZSBmb3JtYXR0aW5nIHN0cmF0ZWd5IHRvIGNvbnZlcnQgY2lwaGVyIHBhcmFtIG9iamVjdHMgdG8gYW5kIGZyb20gYSBzdHJpbmcuIERlZmF1bHQ6IE9wZW5TU0xcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBjZmc6IEJhc2UuZXh0ZW5kKHtcblx0ICAgICAgICAgICAgZm9ybWF0OiBPcGVuU1NMRm9ybWF0dGVyXG5cdCAgICAgICAgfSksXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBFbmNyeXB0cyBhIG1lc3NhZ2UuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gZW5jcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0ga2V5IFRoZSBrZXkuXG5cdCAgICAgICAgICogQHBhcmFtIHtPYmplY3R9IGNmZyAoT3B0aW9uYWwpIFRoZSBjb25maWd1cmF0aW9uIG9wdGlvbnMgdG8gdXNlIGZvciB0aGlzIG9wZXJhdGlvbi5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge0NpcGhlclBhcmFtc30gQSBjaXBoZXIgcGFyYW1zIG9iamVjdC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGNpcGhlcnRleHRQYXJhbXMgPSBDcnlwdG9KUy5saWIuU2VyaWFsaXphYmxlQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBtZXNzYWdlLCBrZXksIHsgaXY6IGl2IH0pO1xuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5TZXJpYWxpemFibGVDaXBoZXIuZW5jcnlwdChDcnlwdG9KUy5hbGdvLkFFUywgbWVzc2FnZSwga2V5LCB7IGl2OiBpdiwgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBtZXNzYWdlLCBrZXksIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICB2YXIgZW5jcnlwdG9yID0gY2lwaGVyLmNyZWF0ZUVuY3J5cHRvcihrZXksIGNmZyk7XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJ0ZXh0ID0gZW5jcnlwdG9yLmZpbmFsaXplKG1lc3NhZ2UpO1xuXG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciBjaXBoZXJDZmcgPSBlbmNyeXB0b3IuY2ZnO1xuXG5cdCAgICAgICAgICAgIC8vIENyZWF0ZSBhbmQgcmV0dXJuIHNlcmlhbGl6YWJsZSBjaXBoZXIgcGFyYW1zXG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHtcblx0ICAgICAgICAgICAgICAgIGNpcGhlcnRleHQ6IGNpcGhlcnRleHQsXG5cdCAgICAgICAgICAgICAgICBrZXk6IGtleSxcblx0ICAgICAgICAgICAgICAgIGl2OiBjaXBoZXJDZmcuaXYsXG5cdCAgICAgICAgICAgICAgICBhbGdvcml0aG06IGNpcGhlcixcblx0ICAgICAgICAgICAgICAgIG1vZGU6IGNpcGhlckNmZy5tb2RlLFxuXHQgICAgICAgICAgICAgICAgcGFkZGluZzogY2lwaGVyQ2ZnLnBhZGRpbmcsXG5cdCAgICAgICAgICAgICAgICBibG9ja1NpemU6IGNpcGhlci5ibG9ja1NpemUsXG5cdCAgICAgICAgICAgICAgICBmb3JtYXR0ZXI6IGNmZy5mb3JtYXRcblx0ICAgICAgICAgICAgfSk7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIERlY3J5cHRzIHNlcmlhbGl6ZWQgY2lwaGVydGV4dC5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyfSBjaXBoZXIgVGhlIGNpcGhlciBhbGdvcml0aG0gdG8gdXNlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfHN0cmluZ30gY2lwaGVydGV4dCBUaGUgY2lwaGVydGV4dCB0byBkZWNyeXB0LlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fSBrZXkgVGhlIGtleS5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgcGxhaW50ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqICAgICB2YXIgcGxhaW50ZXh0ID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBjaXBoZXJ0ZXh0UGFyYW1zLCBrZXksIHsgaXY6IGl2LCBmb3JtYXQ6IENyeXB0b0pTLmZvcm1hdC5PcGVuU1NMIH0pO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGRlY3J5cHQ6IGZ1bmN0aW9uIChjaXBoZXIsIGNpcGhlcnRleHQsIGtleSwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0IHN0cmluZyB0byBDaXBoZXJQYXJhbXNcblx0ICAgICAgICAgICAgY2lwaGVydGV4dCA9IHRoaXMuX3BhcnNlKGNpcGhlcnRleHQsIGNmZy5mb3JtYXQpO1xuXG5cdCAgICAgICAgICAgIC8vIERlY3J5cHRcblx0ICAgICAgICAgICAgdmFyIHBsYWludGV4dCA9IGNpcGhlci5jcmVhdGVEZWNyeXB0b3Ioa2V5LCBjZmcpLmZpbmFsaXplKGNpcGhlcnRleHQuY2lwaGVydGV4dCk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogQ29udmVydHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHRvIENpcGhlclBhcmFtcyxcblx0ICAgICAgICAgKiBlbHNlIGFzc3VtZWQgQ2lwaGVyUGFyYW1zIGFscmVhZHkgYW5kIHJldHVybnMgY2lwaGVydGV4dCB1bmNoYW5nZWQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtGb3JtYXR0ZXJ9IGZvcm1hdCBUaGUgZm9ybWF0dGluZyBzdHJhdGVneSB0byB1c2UgdG8gcGFyc2Ugc2VyaWFsaXplZCBjaXBoZXJ0ZXh0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgdW5zZXJpYWxpemVkIGNpcGhlcnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJ0ZXh0UGFyYW1zID0gQ3J5cHRvSlMubGliLlNlcmlhbGl6YWJsZUNpcGhlci5fcGFyc2UoY2lwaGVydGV4dFN0cmluZ09yUGFyYW1zLCBmb3JtYXQpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIF9wYXJzZTogZnVuY3Rpb24gKGNpcGhlcnRleHQsIGZvcm1hdCkge1xuXHQgICAgICAgICAgICBpZiAodHlwZW9mIGNpcGhlcnRleHQgPT0gJ3N0cmluZycpIHtcblx0ICAgICAgICAgICAgICAgIHJldHVybiBmb3JtYXQucGFyc2UoY2lwaGVydGV4dCwgdGhpcyk7XG5cdCAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIEtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uIG5hbWVzcGFjZS5cblx0ICAgICAqL1xuXHQgICAgdmFyIENfa2RmID0gQy5rZGYgPSB7fTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBPcGVuU1NMIGtleSBkZXJpdmF0aW9uIGZ1bmN0aW9uLlxuXHQgICAgICovXG5cdCAgICB2YXIgT3BlblNTTEtkZiA9IENfa2RmLk9wZW5TU0wgPSB7XG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVyaXZlcyBhIGtleSBhbmQgSVYgZnJvbSBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZCB0byBkZXJpdmUgZnJvbS5cblx0ICAgICAgICAgKiBAcGFyYW0ge251bWJlcn0ga2V5U2l6ZSBUaGUgc2l6ZSBpbiB3b3JkcyBvZiB0aGUga2V5IHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7bnVtYmVyfSBpdlNpemUgVGhlIHNpemUgaW4gd29yZHMgb2YgdGhlIElWIHRvIGdlbmVyYXRlLlxuXHQgICAgICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gc2FsdCAoT3B0aW9uYWwpIEEgNjQtYml0IHNhbHQgdG8gdXNlLiBJZiBvbWl0dGVkLCBhIHNhbHQgd2lsbCBiZSBnZW5lcmF0ZWQgcmFuZG9tbHkuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtDaXBoZXJQYXJhbXN9IEEgY2lwaGVyIHBhcmFtcyBvYmplY3Qgd2l0aCB0aGUga2V5LCBJViwgYW5kIHNhbHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMik7XG5cdCAgICAgICAgICogICAgIHZhciBkZXJpdmVkUGFyYW1zID0gQ3J5cHRvSlMua2RmLk9wZW5TU0wuZXhlY3V0ZSgnUGFzc3dvcmQnLCAyNTYvMzIsIDEyOC8zMiwgJ3NhbHRzYWx0Jyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZXhlY3V0ZTogZnVuY3Rpb24gKHBhc3N3b3JkLCBrZXlTaXplLCBpdlNpemUsIHNhbHQpIHtcblx0ICAgICAgICAgICAgLy8gR2VuZXJhdGUgcmFuZG9tIHNhbHRcblx0ICAgICAgICAgICAgaWYgKCFzYWx0KSB7XG5cdCAgICAgICAgICAgICAgICBzYWx0ID0gV29yZEFycmF5LnJhbmRvbSg2NC84KTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIERlcml2ZSBrZXkgYW5kIElWXG5cdCAgICAgICAgICAgIHZhciBrZXkgPSBFdnBLREYuY3JlYXRlKHsga2V5U2l6ZToga2V5U2l6ZSArIGl2U2l6ZSB9KS5jb21wdXRlKHBhc3N3b3JkLCBzYWx0KTtcblxuXHQgICAgICAgICAgICAvLyBTZXBhcmF0ZSBrZXkgYW5kIElWXG5cdCAgICAgICAgICAgIHZhciBpdiA9IFdvcmRBcnJheS5jcmVhdGUoa2V5LndvcmRzLnNsaWNlKGtleVNpemUpLCBpdlNpemUgKiA0KTtcblx0ICAgICAgICAgICAga2V5LnNpZ0J5dGVzID0ga2V5U2l6ZSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIHBhcmFtc1xuXHQgICAgICAgICAgICByZXR1cm4gQ2lwaGVyUGFyYW1zLmNyZWF0ZSh7IGtleToga2V5LCBpdjogaXYsIHNhbHQ6IHNhbHQgfSk7XG5cdCAgICAgICAgfVxuXHQgICAgfTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBIHNlcmlhbGl6YWJsZSBjaXBoZXIgd3JhcHBlciB0aGF0IGRlcml2ZXMgdGhlIGtleSBmcm9tIGEgcGFzc3dvcmQsXG5cdCAgICAgKiBhbmQgcmV0dXJucyBjaXBoZXJ0ZXh0IGFzIGEgc2VyaWFsaXphYmxlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICovXG5cdCAgICB2YXIgUGFzc3dvcmRCYXNlZENpcGhlciA9IENfbGliLlBhc3N3b3JkQmFzZWRDaXBoZXIgPSBTZXJpYWxpemFibGVDaXBoZXIuZXh0ZW5kKHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb25maWd1cmF0aW9uIG9wdGlvbnMuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcHJvcGVydHkge0tERn0ga2RmIFRoZSBrZXkgZGVyaXZhdGlvbiBmdW5jdGlvbiB0byB1c2UgdG8gZ2VuZXJhdGUgYSBrZXkgYW5kIElWIGZyb20gYSBwYXNzd29yZC4gRGVmYXVsdDogT3BlblNTTFxuXHQgICAgICAgICAqL1xuXHQgICAgICAgIGNmZzogU2VyaWFsaXphYmxlQ2lwaGVyLmNmZy5leHRlbmQoe1xuXHQgICAgICAgICAgICBrZGY6IE9wZW5TU0xLZGZcblx0ICAgICAgICB9KSxcblxuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIEVuY3J5cHRzIGEgbWVzc2FnZSB1c2luZyBhIHBhc3N3b3JkLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtDaXBoZXJ9IGNpcGhlciBUaGUgY2lwaGVyIGFsZ29yaXRobSB0byB1c2UuXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGVuY3J5cHQuXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHBhc3N3b3JkIFRoZSBwYXNzd29yZC5cblx0ICAgICAgICAgKiBAcGFyYW0ge09iamVjdH0gY2ZnIChPcHRpb25hbCkgVGhlIGNvbmZpZ3VyYXRpb24gb3B0aW9ucyB0byB1c2UgZm9yIHRoaXMgb3BlcmF0aW9uLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBBIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHN0YXRpY1xuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQGV4YW1wbGVcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcpO1xuXHQgICAgICAgICAqICAgICB2YXIgY2lwaGVydGV4dFBhcmFtcyA9IENyeXB0b0pTLmxpYi5QYXNzd29yZEJhc2VkQ2lwaGVyLmVuY3J5cHQoQ3J5cHRvSlMuYWxnby5BRVMsIG1lc3NhZ2UsICdwYXNzd29yZCcsIHsgZm9ybWF0OiBDcnlwdG9KUy5mb3JtYXQuT3BlblNTTCB9KTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBlbmNyeXB0OiBmdW5jdGlvbiAoY2lwaGVyLCBtZXNzYWdlLCBwYXNzd29yZCwgY2ZnKSB7XG5cdCAgICAgICAgICAgIC8vIEFwcGx5IGNvbmZpZyBkZWZhdWx0c1xuXHQgICAgICAgICAgICBjZmcgPSB0aGlzLmNmZy5leHRlbmQoY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBvdGhlciBwYXJhbXNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBjZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplKTtcblxuXHQgICAgICAgICAgICAvLyBBZGQgSVYgdG8gY29uZmlnXG5cdCAgICAgICAgICAgIGNmZy5pdiA9IGRlcml2ZWRQYXJhbXMuaXY7XG5cblx0ICAgICAgICAgICAgLy8gRW5jcnlwdFxuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IFNlcmlhbGl6YWJsZUNpcGhlci5lbmNyeXB0LmNhbGwodGhpcywgY2lwaGVyLCBtZXNzYWdlLCBkZXJpdmVkUGFyYW1zLmtleSwgY2ZnKTtcblxuXHQgICAgICAgICAgICAvLyBNaXggaW4gZGVyaXZlZCBwYXJhbXNcblx0ICAgICAgICAgICAgY2lwaGVydGV4dC5taXhJbihkZXJpdmVkUGFyYW1zKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2lwaGVydGV4dDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgLyoqXG5cdCAgICAgICAgICogRGVjcnlwdHMgc2VyaWFsaXplZCBjaXBoZXJ0ZXh0IHVzaW5nIGEgcGFzc3dvcmQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlcn0gY2lwaGVyIFRoZSBjaXBoZXIgYWxnb3JpdGhtIHRvIHVzZS5cblx0ICAgICAgICAgKiBAcGFyYW0ge0NpcGhlclBhcmFtc3xzdHJpbmd9IGNpcGhlcnRleHQgVGhlIGNpcGhlcnRleHQgdG8gZGVjcnlwdC5cblx0ICAgICAgICAgKiBAcGFyYW0ge3N0cmluZ30gcGFzc3dvcmQgVGhlIHBhc3N3b3JkLlxuXHQgICAgICAgICAqIEBwYXJhbSB7T2JqZWN0fSBjZmcgKE9wdGlvbmFsKSBUaGUgY29uZmlndXJhdGlvbiBvcHRpb25zIHRvIHVzZSBmb3IgdGhpcyBvcGVyYXRpb24uXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBwbGFpbnRleHQuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBmb3JtYXR0ZWRDaXBoZXJ0ZXh0LCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICogICAgIHZhciBwbGFpbnRleHQgPSBDcnlwdG9KUy5saWIuUGFzc3dvcmRCYXNlZENpcGhlci5kZWNyeXB0KENyeXB0b0pTLmFsZ28uQUVTLCBjaXBoZXJ0ZXh0UGFyYW1zLCAncGFzc3dvcmQnLCB7IGZvcm1hdDogQ3J5cHRvSlMuZm9ybWF0Lk9wZW5TU0wgfSk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgZGVjcnlwdDogZnVuY3Rpb24gKGNpcGhlciwgY2lwaGVydGV4dCwgcGFzc3dvcmQsIGNmZykge1xuXHQgICAgICAgICAgICAvLyBBcHBseSBjb25maWcgZGVmYXVsdHNcblx0ICAgICAgICAgICAgY2ZnID0gdGhpcy5jZmcuZXh0ZW5kKGNmZyk7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydCBzdHJpbmcgdG8gQ2lwaGVyUGFyYW1zXG5cdCAgICAgICAgICAgIGNpcGhlcnRleHQgPSB0aGlzLl9wYXJzZShjaXBoZXJ0ZXh0LCBjZmcuZm9ybWF0KTtcblxuXHQgICAgICAgICAgICAvLyBEZXJpdmUga2V5IGFuZCBvdGhlciBwYXJhbXNcblx0ICAgICAgICAgICAgdmFyIGRlcml2ZWRQYXJhbXMgPSBjZmcua2RmLmV4ZWN1dGUocGFzc3dvcmQsIGNpcGhlci5rZXlTaXplLCBjaXBoZXIuaXZTaXplLCBjaXBoZXJ0ZXh0LnNhbHQpO1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBJViB0byBjb25maWdcblx0ICAgICAgICAgICAgY2ZnLml2ID0gZGVyaXZlZFBhcmFtcy5pdjtcblxuXHQgICAgICAgICAgICAvLyBEZWNyeXB0XG5cdCAgICAgICAgICAgIHZhciBwbGFpbnRleHQgPSBTZXJpYWxpemFibGVDaXBoZXIuZGVjcnlwdC5jYWxsKHRoaXMsIGNpcGhlciwgY2lwaGVydGV4dCwgZGVyaXZlZFBhcmFtcy5rZXksIGNmZyk7XG5cblx0ICAgICAgICAgICAgcmV0dXJuIHBsYWludGV4dDtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblx0fSgpKTtcblxuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogMjkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuUmVxdWVzdCA9IGV4cG9ydHMuY3JlYXRlUmVxdWVzdCA9IHZvaWQgMDtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGNvbWV0dHJhbnNwb3J0XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDEyKSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIGV2ZW50ZW1pdHRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg3KSk7XG52YXIgZXJyb3JpbmZvXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDQpO1xudmFyIGRlZmF1bHRzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIFhIUlN0YXRlc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyMSkpO1xuLy8gV29ya2Fyb3VuZCBmb3Igc2FsZXNmb3JjZSBsaWdodG5pbmcgbG9ja2VyIGNvbXBhdGliaWxpdHlcbnZhciBnbG9iYWxPYmplY3QgPSBVdGlscy5nZXRHbG9iYWxPYmplY3QoKTtcbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xuLyogQ2FuJ3QganVzdCB1c2Ugd2luZG93LkFibHksIGFzIHRoYXQgd29uJ3QgZXhpc3QgaWYgdXNpbmcgdGhlIGNvbW1vbmpzIHZlcnNpb24uICovXG52YXIgXyA9IChnbG9iYWxPYmplY3QuX2FibHlqc19qc29ucCA9IHt9KTtcbi8qIGV4cHJlc3Mgc3RyaXBzIG91dCBwYXJhbnRoZXNlcyBmcm9tIHRoZSBjYWxsYmFjayFcbiAqIEtsdWRnZSB0byBzdGlsbCBhbG93IGl0cyByZXNwb25zZXMgdG8gd29yaywgd2hpbGUgbm90IGtlZXBpbmcgdGhlXG4gKiBmdW5jdGlvbiBmb3JtIGZvciBub3JtYWwgdXNlIGFuZCBub3QgY2x1dHRlcmluZyB3aW5kb3cuQWJseVxuICogaHR0cHM6Ly9naXRodWIuY29tL2V4cHJlc3Nqcy9leHByZXNzL2Jsb2IvNWI0ZDRiNGFiMTMyNDc0MzUzNGZiY2Q0NzA5ZjRlNzViYjRiNGU5ZC9saWIvcmVzcG9uc2UuanMjTDMwNVxuICovXG5fLl8gPSBmdW5jdGlvbiAoaWQpIHtcbiAgICByZXR1cm4gX1snXycgKyBpZF0gfHwgbm9vcDtcbn07XG52YXIgaWRDb3VudGVyID0gMTtcbnZhciBzaG9ydE5hbWUgPSAnanNvbnAnO1xuZnVuY3Rpb24gY3JlYXRlUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBtZXRob2QpIHtcbiAgICAvKiBKU09OUCByZXF1ZXN0cyBhcmUgdXNlZCBlaXRoZXIgd2l0aCB0aGUgY29udGV4dCBiZWluZyBhIHJlYWx0aW1lXG4gICAgICogdHJhbnNwb3J0LCBvciB3aXRoIHRpbWVvdXRzIHBhc3NlZCBpbiAoZm9yIHdoZW4gdXNlZCBieSBhIHJlc3QgY2xpZW50KSxcbiAgICAgKiBvciBjb21wbGV0ZWx5IHN0YW5kYWxvbmUuICBVc2UgdGhlIGFwcHJvcHJpYXRlIHRpbWVvdXRzIGluIGVhY2ggY2FzZSAqL1xuICAgIHRpbWVvdXRzID0gdGltZW91dHMgfHwgZGVmYXVsdHNfMS5kZWZhdWx0LlRJTUVPVVRTO1xuICAgIHJldHVybiBuZXcgUmVxdWVzdCh1bmRlZmluZWQsIHVyaSwgaGVhZGVycywgVXRpbHMuY29weShwYXJhbXMpLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMsIG1ldGhvZCk7XG59XG5leHBvcnRzLmNyZWF0ZVJlcXVlc3QgPSBjcmVhdGVSZXF1ZXN0O1xudmFyIEpTT05QVHJhbnNwb3J0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKEpTT05QVHJhbnNwb3J0LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIEpTT05QVHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lO1xuICAgICAgICBwYXJhbXMuc3RyZWFtID0gZmFsc2U7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgSlNPTlBUcmFuc3BvcnQuaXNBdmFpbGFibGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmpzb25wU3VwcG9ydGVkICYmIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuYWxsb3dDb21ldDtcbiAgICB9O1xuICAgIEpTT05QVHJhbnNwb3J0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdKU09OUFRyYW5zcG9ydDsgdXJpPScgKyB0aGlzLmJhc2VVcmkgKyAnOyBpc0Nvbm5lY3RlZD0nICsgdGhpcy5pc0Nvbm5lY3RlZDtcbiAgICB9O1xuICAgIEpTT05QVHJhbnNwb3J0LnByb3RvdHlwZS5jcmVhdGVSZXF1ZXN0ID0gZnVuY3Rpb24gKHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCByZXF1ZXN0TW9kZSwgdGltZW91dHMsIG1ldGhvZCkge1xuICAgICAgICAvKiBKU09OUCByZXF1ZXN0cyBhcmUgdXNlZCBlaXRoZXIgd2l0aCB0aGUgY29udGV4dCBiZWluZyBhIHJlYWx0aW1lXG4gICAgICAgICAqIHRyYW5zcG9ydCwgb3Igd2l0aCB0aW1lb3V0cyBwYXNzZWQgaW4gKGZvciB3aGVuIHVzZWQgYnkgYSByZXN0IGNsaWVudCksXG4gICAgICAgICAqIG9yIGNvbXBsZXRlbHkgc3RhbmRhbG9uZS4gIFVzZSB0aGUgYXBwcm9wcmlhdGUgdGltZW91dHMgaW4gZWFjaCBjYXNlICovXG4gICAgICAgIHRpbWVvdXRzID0gKHRoaXMgPT09IG51bGwgfHwgdGhpcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogdGhpcy50aW1lb3V0cykgfHwgdGltZW91dHMgfHwgZGVmYXVsdHNfMS5kZWZhdWx0LlRJTUVPVVRTO1xuICAgICAgICByZXR1cm4gY3JlYXRlUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgcmVxdWVzdE1vZGUsIHRpbWVvdXRzLCBtZXRob2QpO1xuICAgIH07XG4gICAgcmV0dXJuIEpTT05QVHJhbnNwb3J0O1xufShjb21ldHRyYW5zcG9ydF8xLmRlZmF1bHQpKTtcbnZhciBSZXF1ZXN0ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJlcXVlc3QsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVxdWVzdChpZCwgdXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aW1lb3V0cywgbWV0aG9kKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIGlmIChpZCA9PT0gdW5kZWZpbmVkKVxuICAgICAgICAgICAgaWQgPSBpZENvdW50ZXIrKztcbiAgICAgICAgX3RoaXMuaWQgPSBpZDtcbiAgICAgICAgX3RoaXMudXJpID0gdXJpO1xuICAgICAgICBfdGhpcy5wYXJhbXMgPSBwYXJhbXMgfHwge307XG4gICAgICAgIF90aGlzLnBhcmFtcy5ybmQgPSBVdGlscy5jaGVhcFJhbmRTdHIoKTtcbiAgICAgICAgaWYgKGhlYWRlcnMpIHtcbiAgICAgICAgICAgIC8qIEpTT05QIGRvZXNuJ3QgYWxsb3cgaGVhZGVycy4gQ2hlcnJ5LXBpY2sgYSBjb3VwbGUgdG8gdHVybiBpbnRvIHFzIHBhcmFtcyAqL1xuICAgICAgICAgICAgaWYgKGhlYWRlcnNbJ1gtQWJseS1WZXJzaW9uJ10pXG4gICAgICAgICAgICAgICAgX3RoaXMucGFyYW1zLnYgPSBoZWFkZXJzWydYLUFibHktVmVyc2lvbiddO1xuICAgICAgICAgICAgaWYgKGhlYWRlcnNbJ1gtQWJseS1MaWInXSlcbiAgICAgICAgICAgICAgICBfdGhpcy5wYXJhbXMubGliID0gaGVhZGVyc1snWC1BYmx5LUxpYiddO1xuICAgICAgICB9XG4gICAgICAgIF90aGlzLmJvZHkgPSBib2R5O1xuICAgICAgICBfdGhpcy5tZXRob2QgPSBtZXRob2Q7XG4gICAgICAgIF90aGlzLnJlcXVlc3RNb2RlID0gcmVxdWVzdE1vZGU7XG4gICAgICAgIF90aGlzLnRpbWVvdXRzID0gdGltZW91dHM7XG4gICAgICAgIF90aGlzLnJlcXVlc3RDb21wbGV0ZSA9IGZhbHNlO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlcXVlc3QucHJvdG90eXBlLmV4ZWMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBpZCA9IHRoaXMuaWQsIGJvZHkgPSB0aGlzLmJvZHksIG1ldGhvZCA9IHRoaXMubWV0aG9kLCB1cmkgPSB0aGlzLnVyaSwgcGFyYW1zID0gdGhpcy5wYXJhbXM7XG4gICAgICAgIHBhcmFtcy5jYWxsYmFjayA9ICdfYWJseWpzX2pzb25wLl8oJyArIGlkICsgJyknO1xuICAgICAgICBwYXJhbXMuZW52ZWxvcGUgPSAnanNvbnAnO1xuICAgICAgICBpZiAoYm9keSkge1xuICAgICAgICAgICAgcGFyYW1zLmJvZHkgPSBib2R5O1xuICAgICAgICB9XG4gICAgICAgIGlmIChtZXRob2QgJiYgbWV0aG9kICE9PSAnZ2V0Jykge1xuICAgICAgICAgICAgcGFyYW1zLm1ldGhvZCA9IG1ldGhvZDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2NyaXB0ID0gKHRoaXMuc2NyaXB0ID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudCgnc2NyaXB0JykpO1xuICAgICAgICB2YXIgc3JjID0gdXJpICsgVXRpbHMudG9RdWVyeVN0cmluZyhwYXJhbXMpO1xuICAgICAgICBzY3JpcHQuc3JjID0gc3JjO1xuICAgICAgICBpZiAoc2NyaXB0LnNyYy5zcGxpdCgnLycpLnNsaWNlKC0xKVswXSAhPT0gc3JjLnNwbGl0KCcvJykuc2xpY2UoLTEpWzBdKSB7XG4gICAgICAgICAgICAvKiBUaGUgc3JjIGhhcyBiZWVuIHRydW5jYXRlZC4gQ2FuJ3QgYWJvcnQsIGJ1dCBjYW4gYXQgbGVhc3QgZW1pdCBhblxuICAgICAgICAgICAgICogZXJyb3Igc28gdGhlIHVzZXIga25vd3Mgd2hhdCdzIGdvbmUgd3JvbmcuIChDYW4ndCBjb21wYXJlIHN0cmluZ3NcbiAgICAgICAgICAgICAqIGRpcmVjdGx5IGFzIHNyYyBtYXkgaGF2ZSBhIHBvcnQsIHNjcmlwdC5zcmMgd29uJ3QpICovXG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0pTT05QIFJlcXVlc3QuZXhlYygpJywgJ1dhcm5pbmc6IHRoZSBicm93c2VyIGFwcGVhcnMgdG8gaGF2ZSB0cnVuY2F0ZWQgdGhlIHNjcmlwdCBVUkkuIFRoaXMgd2lsbCBsaWtlbHkgcmVzdWx0IGluIHRoZSByZXF1ZXN0IGZhaWxpbmcgZHVlIHRvIGFuIHVucGFyc2VhYmxlIGJvZHkgcGFyYW0nKTtcbiAgICAgICAgfVxuICAgICAgICBzY3JpcHQuYXN5bmMgPSB0cnVlO1xuICAgICAgICBzY3JpcHQudHlwZSA9ICd0ZXh0L2phdmFzY3JpcHQnO1xuICAgICAgICBzY3JpcHQuY2hhcnNldCA9ICdVVEYtOCc7XG4gICAgICAgIHNjcmlwdC5vbmVycm9yID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgX3RoaXMuY29tcGxldGUobmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ0pTT05QIHNjcmlwdCBlcnJvciAoZXZlbnQ6ICcgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QoZXJyKSArICcpJywgbnVsbCwgNDAwKSk7XG4gICAgICAgIH07XG4gICAgICAgIF9bJ18nICsgaWRdID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgICAgIGlmIChtZXNzYWdlLnN0YXR1c0NvZGUpIHtcbiAgICAgICAgICAgICAgICAvKiBIYW5kbGUgYXMgZW52ZWxvcGVkIGpzb25wLCBhcyBhbGwganNvbnAgdHJhbnNwb3J0IHVzZXMgc2hvdWxkIGJlICovXG4gICAgICAgICAgICAgICAgdmFyIHJlc3BvbnNlID0gbWVzc2FnZS5yZXNwb25zZTtcbiAgICAgICAgICAgICAgICBpZiAobWVzc2FnZS5zdGF0dXNDb2RlID09IDIwNCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wbGV0ZShudWxsLCBudWxsLCBudWxsLCBtZXNzYWdlLnN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICghcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29tcGxldGUobmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ0ludmFsaWQgc2VydmVyIHJlc3BvbnNlOiBubyBlbnZlbG9wZSBkZXRlY3RlZCcsIG51bGwsIDUwMCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChtZXNzYWdlLnN0YXR1c0NvZGUgPCA0MDAgfHwgVXRpbHMuaXNBcnJheShyZXNwb25zZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogSWYgcmVzcG9uc2UgaXMgYW4gYXJyYXksIGl0J3MgYW4gYXJyYXkgb2YgcHJvdG9jb2wgbWVzc2FnZXMgLS0gZXZlbiBpZlxuICAgICAgICAgICAgICAgICAgICAgKiBpdCBjb250YWlucyBhbiBlcnJvciBhY3Rpb24gKGhlbmNlIHRoZSBub25zdWNjZXNzIHN0YXR1c2NvZGUpLCB3ZSBjYW5cbiAgICAgICAgICAgICAgICAgICAgICogY29uc2lkZXIgdGhlIHJlcXVlc3QgdG8gaGF2ZSBzdWNjZWVkZWQsIGp1c3QgcGFzcyBpdCBvbiB0b1xuICAgICAgICAgICAgICAgICAgICAgKiBvblByb3RvY29sTWVzc2FnZSB0byBkZWNpZGUgd2hhdCB0byBkbyAqL1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5jb21wbGV0ZShudWxsLCByZXNwb25zZSwgbWVzc2FnZS5oZWFkZXJzLCBtZXNzYWdlLnN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGVyciA9IHJlc3BvbnNlLmVycm9yIHx8IG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCdFcnJvciByZXNwb25zZSByZWNlaXZlZCBmcm9tIHNlcnZlcicsIG51bGwsIG1lc3NhZ2Uuc3RhdHVzQ29kZSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlKGVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgLyogSGFuZGxlIGFzIG5vbi1lbnZlbG9wZWQgLS0gYXMgd2lsbCBiZSBlZyBmcm9tIGEgY3VzdG9tZXIncyBhdXRoVXJsIHNlcnZlciAqL1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbXBsZXRlKG51bGwsIG1lc3NhZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgdGltZW91dCA9IHRoaXMucmVxdWVzdE1vZGUgPT0gWEhSU3RhdGVzXzEuZGVmYXVsdC5SRVFfU0VORCA/IHRoaXMudGltZW91dHMuaHR0cFJlcXVlc3RUaW1lb3V0IDogdGhpcy50aW1lb3V0cy5yZWN2VGltZW91dDtcbiAgICAgICAgdGhpcy50aW1lciA9IHNldFRpbWVvdXQodGhpcy5hYm9ydC5iaW5kKHRoaXMpLCB0aW1lb3V0KTtcbiAgICAgICAgdmFyIGhlYWQgPSBkb2N1bWVudC5nZXRFbGVtZW50c0J5VGFnTmFtZSgnaGVhZCcpWzBdO1xuICAgICAgICBoZWFkLmluc2VydEJlZm9yZShzY3JpcHQsIGhlYWQuZmlyc3RDaGlsZCk7XG4gICAgfTtcbiAgICBSZXF1ZXN0LnByb3RvdHlwZS5jb21wbGV0ZSA9IGZ1bmN0aW9uIChlcnIsIGJvZHksIGhlYWRlcnMsIHN0YXR1c0NvZGUpIHtcbiAgICAgICAgaGVhZGVycyA9IGhlYWRlcnMgfHwge307XG4gICAgICAgIGlmICghdGhpcy5yZXF1ZXN0Q29tcGxldGUpIHtcbiAgICAgICAgICAgIHRoaXMucmVxdWVzdENvbXBsZXRlID0gdHJ1ZTtcbiAgICAgICAgICAgIHZhciBjb250ZW50VHlwZSA9IHZvaWQgMDtcbiAgICAgICAgICAgIGlmIChib2R5KSB7XG4gICAgICAgICAgICAgICAgY29udGVudFR5cGUgPSB0eXBlb2YgYm9keSA9PSAnc3RyaW5nJyA/ICd0ZXh0L3BsYWluJyA6ICdhcHBsaWNhdGlvbi9qc29uJztcbiAgICAgICAgICAgICAgICBoZWFkZXJzWydjb250ZW50LXR5cGUnXSA9IGNvbnRlbnRUeXBlO1xuICAgICAgICAgICAgICAgIHRoaXMuZW1pdCgnZGF0YScsIGJvZHkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5lbWl0KCdjb21wbGV0ZScsIGVyciwgYm9keSwgaGVhZGVycywgLyogdW5wYWNrZWQ6ICovIHRydWUsIHN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgdGhpcy5kaXNwb3NlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlcXVlc3QucHJvdG90eXBlLmFib3J0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLmRpc3Bvc2UoKTtcbiAgICB9O1xuICAgIFJlcXVlc3QucHJvdG90eXBlLmRpc3Bvc2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciB0aW1lciA9IHRoaXMudGltZXI7XG4gICAgICAgIGlmICh0aW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHRpbWVyKTtcbiAgICAgICAgICAgIHRoaXMudGltZXIgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHZhciBzY3JpcHQgPSB0aGlzLnNjcmlwdDtcbiAgICAgICAgaWYgKHNjcmlwdC5wYXJlbnROb2RlKVxuICAgICAgICAgICAgc2NyaXB0LnBhcmVudE5vZGUucmVtb3ZlQ2hpbGQoc2NyaXB0KTtcbiAgICAgICAgZGVsZXRlIF9bdGhpcy5pZF07XG4gICAgICAgIHRoaXMuZW1pdCgnZGlzcG9zZWQnKTtcbiAgICB9O1xuICAgIHJldHVybiBSZXF1ZXN0O1xufShldmVudGVtaXR0ZXJfMS5kZWZhdWx0KSk7XG5leHBvcnRzLlJlcXVlc3QgPSBSZXF1ZXN0O1xuZnVuY3Rpb24gZGVmYXVsdF8xKGNvbm5lY3Rpb25NYW5hZ2VyKSB7XG4gICAgZ2xvYmFsT2JqZWN0LkpTT05QVHJhbnNwb3J0ID0gSlNPTlBUcmFuc3BvcnQ7XG4gICAgaWYgKEpTT05QVHJhbnNwb3J0LmlzQXZhaWxhYmxlKCkpIHtcbiAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0c1tzaG9ydE5hbWVdID0gSlNPTlBUcmFuc3BvcnQ7XG4gICAgfVxuICAgIHJldHVybiBKU09OUFRyYW5zcG9ydDtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGRlZmF1bHRfMTtcblxuXG4vKioqLyB9KSxcbi8qIDMwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIGRlZmF1bHRzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKTtcbnZhciBhdXRoXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSk7XG52YXIgcHVzaF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0NikpO1xudmFyIHBhZ2luYXRlZHJlc291cmNlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE5KSk7XG52YXIgY2hhbm5lbF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzMykpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgc3RhdHNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNDkpKTtcbnZhciBIdHRwTWV0aG9kc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxOCkpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciBtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDkpKTtcbnZhciBwcmVzZW5jZW1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTUpKTtcbnZhciByZXNvdXJjZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxNCkpO1xudmFyIG5vb3AgPSBmdW5jdGlvbiAoKSB7IH07XG52YXIgUmVzdCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXN0KG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKCFvcHRpb25zKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ25vIG9wdGlvbnMgcHJvdmlkZWQnO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdSZXN0KCknLCBtc2cpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG9wdGlvbnNPYmogPSBkZWZhdWx0c18xLmRlZmF1bHQub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgaWYgKG9wdGlvbnNPYmoubG9nKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LnNldExvZyhvcHRpb25zT2JqLmxvZy5sZXZlbCwgb3B0aW9uc09iai5sb2cuaGFuZGxlcik7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZXN0KCknLCAnaW5pdGlhbGl6ZWQgd2l0aCBjbGllbnRPcHRpb25zICcgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3Qob3B0aW9ucykpO1xuICAgICAgICB2YXIgbm9ybWFsT3B0aW9ucyA9ICh0aGlzLm9wdGlvbnMgPSBkZWZhdWx0c18xLmRlZmF1bHQubm9ybWFsaXNlT3B0aW9ucyhvcHRpb25zT2JqKSk7XG4gICAgICAgIC8qIHByb2Nlc3Mgb3B0aW9ucyAqL1xuICAgICAgICBpZiAobm9ybWFsT3B0aW9ucy5rZXkpIHtcbiAgICAgICAgICAgIHZhciBrZXlNYXRjaCA9IG5vcm1hbE9wdGlvbnMua2V5Lm1hdGNoKC9eKFteOlxcc10rKTooW146Llxcc10rKSQvKTtcbiAgICAgICAgICAgIGlmICgha2V5TWF0Y2gpIHtcbiAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ2ludmFsaWQga2V5IHBhcmFtZXRlcic7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdSZXN0KCknLCBtc2cpO1xuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgNDA0MDAsIDQwNCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBub3JtYWxPcHRpb25zLmtleU5hbWUgPSBrZXlNYXRjaFsxXTtcbiAgICAgICAgICAgIG5vcm1hbE9wdGlvbnMua2V5U2VjcmV0ID0ga2V5TWF0Y2hbMl07XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCdjbGllbnRJZCcgaW4gbm9ybWFsT3B0aW9ucykge1xuICAgICAgICAgICAgaWYgKCEodHlwZW9mIG5vcm1hbE9wdGlvbnMuY2xpZW50SWQgPT09ICdzdHJpbmcnIHx8IG5vcm1hbE9wdGlvbnMuY2xpZW50SWQgPT09IG51bGwpKVxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdjbGllbnRJZCBtdXN0IGJlIGVpdGhlciBhIHN0cmluZyBvciBudWxsJywgNDAwMTIsIDQwMCk7XG4gICAgICAgICAgICBlbHNlIGlmIChub3JtYWxPcHRpb25zLmNsaWVudElkID09PSAnKicpXG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0NhbuKAmXQgdXNlIFwiKlwiIGFzIGEgY2xpZW50SWQgYXMgdGhhdCBzdHJpbmcgaXMgcmVzZXJ2ZWQuIChUbyBjaGFuZ2UgdGhlIGRlZmF1bHQgdG9rZW4gcmVxdWVzdCBiZWhhdmlvdXIgdG8gdXNlIGEgd2lsZGNhcmQgY2xpZW50SWQsIHVzZSB7ZGVmYXVsdFRva2VuUGFyYW1zOiB7Y2xpZW50SWQ6IFwiKlwifX0pJywgNDAwMTIsIDQwMCk7XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdSZXN0KCknLCAnc3RhcnRlZDsgdmVyc2lvbiA9ICcgKyBkZWZhdWx0c18xLmRlZmF1bHQudmVyc2lvbik7XG4gICAgICAgIHRoaXMuYmFzZVVyaSA9IHRoaXMuYXV0aG9yaXR5ID0gZnVuY3Rpb24gKGhvc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBkZWZhdWx0c18xLmRlZmF1bHQuZ2V0SHR0cFNjaGVtZShub3JtYWxPcHRpb25zKSArIGhvc3QgKyAnOicgKyBkZWZhdWx0c18xLmRlZmF1bHQuZ2V0UG9ydChub3JtYWxPcHRpb25zLCBmYWxzZSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuX2N1cnJlbnRGYWxsYmFjayA9IG51bGw7XG4gICAgICAgIHRoaXMuc2VydmVyVGltZU9mZnNldCA9IG51bGw7XG4gICAgICAgIHRoaXMuaHR0cCA9IG5ldyBwbGF0Zm9ybV8xLmRlZmF1bHQuSHR0cChub3JtYWxPcHRpb25zKTtcbiAgICAgICAgdGhpcy5hdXRoID0gbmV3IGF1dGhfMS5kZWZhdWx0KHRoaXMsIG5vcm1hbE9wdGlvbnMpO1xuICAgICAgICB0aGlzLmNoYW5uZWxzID0gbmV3IENoYW5uZWxzKHRoaXMpO1xuICAgICAgICB0aGlzLnB1c2ggPSBuZXcgcHVzaF8xLmRlZmF1bHQodGhpcyk7XG4gICAgfVxuICAgIFJlc3QucHJvdG90eXBlLnN0YXRzID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgLyogcGFyYW1zIGFuZCBjYWxsYmFjayBhcmUgb3B0aW9uYWw7IHNlZSBpZiBwYXJhbXMgY29udGFpbnMgdGhlIGNhbGxiYWNrICovXG4gICAgICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnc3RhdHMnLCBbcGFyYW1zXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRHZXRIZWFkZXJzKHRoaXMub3B0aW9ucyksIGZvcm1hdCA9IHRoaXMub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGVudmVsb3BlID0gdGhpcy5odHRwLnN1cHBvcnRzTGlua0hlYWRlcnMgPyB1bmRlZmluZWQgOiBmb3JtYXQ7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHRoaXMub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgbmV3IHBhZ2luYXRlZHJlc291cmNlXzEuZGVmYXVsdCh0aGlzLCAnL3N0YXRzJywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uIChib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgdmFyIHN0YXRzVmFsdWVzID0gdW5wYWNrZWQgPyBib2R5IDogSlNPTi5wYXJzZShib2R5KTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgc3RhdHNWYWx1ZXMubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgc3RhdHNWYWx1ZXNbaV0gPSBzdGF0c18xLmRlZmF1bHQuZnJvbVZhbHVlcyhzdGF0c1ZhbHVlc1tpXSk7XG4gICAgICAgICAgICByZXR1cm4gc3RhdHNWYWx1ZXM7XG4gICAgICAgIH0pLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlc3QucHJvdG90eXBlLnRpbWUgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICd0aW1lJywgW3BhcmFtc10pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgX2NhbGxiYWNrID0gY2FsbGJhY2sgfHwgbm9vcDtcbiAgICAgICAgdmFyIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0R2V0SGVhZGVycyh0aGlzLm9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCB0aGlzLm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIHZhciB0aW1lVXJpID0gZnVuY3Rpb24gKGhvc3QpIHtcbiAgICAgICAgICAgIHJldHVybiBfdGhpcy5hdXRob3JpdHkoaG9zdCkgKyAnL3RpbWUnO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmh0dHAuZG8oSHR0cE1ldGhvZHNfMS5kZWZhdWx0LkdldCwgdGhpcywgdGltZVVyaSwgaGVhZGVycywgbnVsbCwgcGFyYW1zLCBmdW5jdGlvbiAoZXJyLCByZXMsIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgX2NhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCF1bnBhY2tlZClcbiAgICAgICAgICAgICAgICByZXMgPSBKU09OLnBhcnNlKHJlcyk7XG4gICAgICAgICAgICB2YXIgdGltZSA9IHJlc1swXTtcbiAgICAgICAgICAgIGlmICghdGltZSkge1xuICAgICAgICAgICAgICAgIF9jYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnSW50ZXJuYWwgZXJyb3IgKHVuZXhwZWN0ZWQgcmVzdWx0IHR5cGUgZnJvbSBHRVQgL3RpbWUpJywgNTAwMDAsIDUwMCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGNhbGN1bGF0ZSB0aW1lIG9mZnNldCBvbmx5IG9uY2UgZm9yIHRoaXMgZGV2aWNlIGJ5IGFkZGluZyB0byB0aGUgcHJvdG90eXBlICovXG4gICAgICAgICAgICBfdGhpcy5zZXJ2ZXJUaW1lT2Zmc2V0ID0gdGltZSAtIFV0aWxzLm5vdygpO1xuICAgICAgICAgICAgX2NhbGxiYWNrKG51bGwsIHRpbWUpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlc3QucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiAobWV0aG9kLCBwYXRoLCBwYXJhbXMsIGJvZHksIGN1c3RvbUhlYWRlcnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciB1c2VCaW5hcnkgPSB0aGlzLm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wsIGVuY29kZXIgPSB1c2VCaW5hcnkgPyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm1zZ3BhY2suZW5jb2RlIDogSlNPTi5zdHJpbmdpZnksIGRlY29kZXIgPSB1c2VCaW5hcnkgPyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm1zZ3BhY2suZGVjb2RlIDogSlNPTi5wYXJzZSwgZm9ybWF0ID0gdXNlQmluYXJ5ID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgZW52ZWxvcGUgPSB0aGlzLmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdDtcbiAgICAgICAgcGFyYW1zID0gcGFyYW1zIHx8IHt9O1xuICAgICAgICB2YXIgX21ldGhvZCA9IG1ldGhvZC50b0xvd2VyQ2FzZSgpO1xuICAgICAgICB2YXIgaGVhZGVycyA9IF9tZXRob2QgPT0gJ2dldCcgPyBVdGlscy5kZWZhdWx0R2V0SGVhZGVycyh0aGlzLm9wdGlvbnMsIGZvcm1hdCkgOiBVdGlscy5kZWZhdWx0UG9zdEhlYWRlcnModGhpcy5vcHRpb25zLCBmb3JtYXQpO1xuICAgICAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3JlcXVlc3QnLCBbbWV0aG9kLCBwYXRoLCBwYXJhbXMsIGJvZHksIGN1c3RvbUhlYWRlcnNdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGJvZHkgIT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICBib2R5ID0gZW5jb2Rlcihib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5vcHRpb25zLmhlYWRlcnMpIHtcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHRoaXMub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY3VzdG9tSGVhZGVycykge1xuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgY3VzdG9tSGVhZGVycyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHBhZ2luYXRlZFJlc291cmNlID0gbmV3IHBhZ2luYXRlZHJlc291cmNlXzEuZGVmYXVsdCh0aGlzLCBwYXRoLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24gKHJlc2JvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gVXRpbHMuZW5zdXJlQXJyYXkodW5wYWNrZWQgPyByZXNib2R5IDogZGVjb2RlcihyZXNib2R5KSk7XG4gICAgICAgIH0sIFxuICAgICAgICAvKiB1c2VIdHRwUGFnaW5hdGVkUmVzcG9uc2U6ICovIHRydWUpO1xuICAgICAgICBpZiAoIVV0aWxzLmFyckluKHBsYXRmb3JtXzEuZGVmYXVsdC5IdHRwLm1ldGhvZHMsIF9tZXRob2QpKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVW5zdXBwb3J0ZWQgbWV0aG9kICcgKyBfbWV0aG9kLCA0MDUwMCwgNDA1KTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoVXRpbHMuYXJySW4ocGxhdGZvcm1fMS5kZWZhdWx0Lkh0dHAubWV0aG9kc1dpdGhCb2R5LCBfbWV0aG9kKSkge1xuICAgICAgICAgICAgcGFnaW5hdGVkUmVzb3VyY2VbX21ldGhvZF0ocGFyYW1zLCBib2R5LCBjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBwYWdpbmF0ZWRSZXNvdXJjZVtfbWV0aG9kXShwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVzdC5wcm90b3R5cGUuYmF0Y2hQdWJsaXNoID0gZnVuY3Rpb24gKHNwZWNPclNwZWNzLCBjYWxsYmFja0FyZykge1xuICAgICAgICBpZiAoY2FsbGJhY2tBcmcgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2JhdGNoUHVibGlzaCcsIFtzcGVjT3JTcGVjc10pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2tBcmcgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjYWxsYmFjayA9IGNhbGxiYWNrQXJnO1xuICAgICAgICB2YXIgcmVxdWVzdEJvZHlEVE87XG4gICAgICAgIHZhciBzaW5nbGVTcGVjTW9kZTtcbiAgICAgICAgaWYgKFV0aWxzLmlzQXJyYXkoc3BlY09yU3BlY3MpKSB7XG4gICAgICAgICAgICByZXF1ZXN0Qm9keURUTyA9IHNwZWNPclNwZWNzO1xuICAgICAgICAgICAgc2luZ2xlU3BlY01vZGUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJlcXVlc3RCb2R5RFRPID0gW3NwZWNPclNwZWNzXTtcbiAgICAgICAgICAgIHNpbmdsZVNwZWNNb2RlID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZm9ybWF0ID0gdGhpcy5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRQb3N0SGVhZGVycyh0aGlzLm9wdGlvbnMsIGZvcm1hdCk7XG4gICAgICAgIGlmICh0aGlzLm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHRoaXMub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgdmFyIHJlcXVlc3RCb2R5ID0gVXRpbHMuZW5jb2RlQm9keShyZXF1ZXN0Qm9keURUTywgZm9ybWF0KTtcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LnBvc3QodGhpcywgJy9tZXNzYWdlcycsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCB7IG5ld0JhdGNoUmVzcG9uc2U6ICd0cnVlJyB9LCBudWxsLCBmdW5jdGlvbiAoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIC8vIFRPRE8gcmVtb3ZlIHRoaXMgdHlwZSBhc3NlcnRpb24gYWZ0ZXIgZml4aW5nIGh0dHBzOi8vZ2l0aHViLmNvbS9hYmx5L2FibHktanMvaXNzdWVzLzE0MDVcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBiYXRjaFJlc3VsdHMgPSAodW5wYWNrZWQgPyBib2R5IDogVXRpbHMuZGVjb2RlQm9keShib2R5LCBmb3JtYXQpKTtcbiAgICAgICAgICAgIC8vIEkgZG9uJ3QgbG92ZSB0aGUgYmVsb3cgdHlwZSBhc3NlcnRpb25zIGZvciBgY2FsbGJhY2tgIGJ1dCBub3Qgc3VyZSBob3cgdG8gYXZvaWQgdGhlbVxuICAgICAgICAgICAgaWYgKHNpbmdsZVNwZWNNb2RlKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgYmF0Y2hSZXN1bHRzWzBdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGJhdGNoUmVzdWx0cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVzdC5wcm90b3R5cGUuYmF0Y2hQcmVzZW5jZSA9IGZ1bmN0aW9uIChjaGFubmVscywgY2FsbGJhY2tBcmcpIHtcbiAgICAgICAgaWYgKGNhbGxiYWNrQXJnID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdiYXRjaFByZXNlbmNlJywgW2NoYW5uZWxzXSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFja0FyZyA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNhbGxiYWNrID0gY2FsbGJhY2tBcmc7XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdFBvc3RIZWFkZXJzKHRoaXMub3B0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgdGhpcy5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICB2YXIgY2hhbm5lbHNQYXJhbSA9IGNoYW5uZWxzLmpvaW4oJywnKTtcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LmdldCh0aGlzLCAnL3ByZXNlbmNlJywgaGVhZGVycywgeyBuZXdCYXRjaFJlc3BvbnNlOiAndHJ1ZScsIGNoYW5uZWxzOiBjaGFubmVsc1BhcmFtIH0sIG51bGwsIGZ1bmN0aW9uIChlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgLy8gVE9ETyByZW1vdmUgdGhpcyB0eXBlIGFzc2VydGlvbiBhZnRlciBmaXhpbmcgaHR0cHM6Ly9naXRodWIuY29tL2FibHkvYWJseS1qcy9pc3N1ZXMvMTQwNVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdmFyIGJhdGNoUmVzdWx0ID0gKHVucGFja2VkID8gYm9keSA6IFV0aWxzLmRlY29kZUJvZHkoYm9keSwgZm9ybWF0KSk7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBiYXRjaFJlc3VsdCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVzdC5wcm90b3R5cGUuc2V0TG9nID0gZnVuY3Rpb24gKGxvZ09wdGlvbnMpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5zZXRMb2cobG9nT3B0aW9ucy5sZXZlbCwgbG9nT3B0aW9ucy5oYW5kbGVyKTtcbiAgICB9O1xuICAgIFJlc3QuUHJvbWlzZSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XG4gICAgICAgIG9wdGlvbnMgPSBkZWZhdWx0c18xLmRlZmF1bHQub2JqZWN0aWZ5T3B0aW9ucyhvcHRpb25zKTtcbiAgICAgICAgb3B0aW9ucy5wcm9taXNlcyA9IHRydWU7XG4gICAgICAgIHJldHVybiBuZXcgUmVzdChvcHRpb25zKTtcbiAgICB9O1xuICAgIFJlc3QuQ2FsbGJhY2tzID0gUmVzdDtcbiAgICBSZXN0LlBsYXRmb3JtID0gcGxhdGZvcm1fMS5kZWZhdWx0O1xuICAgIFJlc3QuTWVzc2FnZSA9IG1lc3NhZ2VfMS5kZWZhdWx0O1xuICAgIFJlc3QuUHJlc2VuY2VNZXNzYWdlID0gcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdDtcbiAgICByZXR1cm4gUmVzdDtcbn0oKSk7XG52YXIgQ2hhbm5lbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhbm5lbHMocmVzdCkge1xuICAgICAgICB0aGlzLnJlc3QgPSByZXN0O1xuICAgICAgICB0aGlzLmFsbCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgfVxuICAgIENoYW5uZWxzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSwgY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgbmFtZSA9IFN0cmluZyhuYW1lKTtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXTtcbiAgICAgICAgaWYgKCFjaGFubmVsKSB7XG4gICAgICAgICAgICB0aGlzLmFsbFtuYW1lXSA9IGNoYW5uZWwgPSBuZXcgY2hhbm5lbF8xLmRlZmF1bHQodGhpcy5yZXN0LCBuYW1lLCBjaGFubmVsT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgICAgIGNoYW5uZWwuc2V0T3B0aW9ucyhjaGFubmVsT3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNoYW5uZWw7XG4gICAgfTtcbiAgICAvKiBJbmNsdWRlZCB0byBzdXBwb3J0IGNlcnRhaW4gbmljaGUgdXNlLWNhc2VzOyBtb3N0IHVzZXJzIHNob3VsZCBpZ25vcmUgdGhpcy5cbiAgICAgKiBQbGVhc2UgZG8gbm90IHVzZSB0aGlzIHVubGVzcyB5b3Uga25vdyB3aGF0IHlvdSdyZSBkb2luZyAqL1xuICAgIENoYW5uZWxzLnByb3RvdHlwZS5yZWxlYXNlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgZGVsZXRlIHRoaXMuYWxsW1N0cmluZyhuYW1lKV07XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhbm5lbHM7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUmVzdDtcblxuXG4vKioqLyB9KSxcbi8qIDMxICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHRyZXR1cm4gQ3J5cHRvSlMuZW5jLlV0Zjg7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAzMiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNikpO1xuXHR9XG5cdGVsc2Uge31cbn0odGhpcywgZnVuY3Rpb24gKENyeXB0b0pTKSB7XG5cblx0KGZ1bmN0aW9uIChNYXRoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgSGFzaGVyID0gQ19saWIuSGFzaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gSW5pdGlhbGl6YXRpb24gYW5kIHJvdW5kIGNvbnN0YW50cyB0YWJsZXNcblx0ICAgIHZhciBIID0gW107XG5cdCAgICB2YXIgSyA9IFtdO1xuXG5cdCAgICAvLyBDb21wdXRlIGNvbnN0YW50c1xuXHQgICAgKGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICBmdW5jdGlvbiBpc1ByaW1lKG4pIHtcblx0ICAgICAgICAgICAgdmFyIHNxcnROID0gTWF0aC5zcXJ0KG4pO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBmYWN0b3IgPSAyOyBmYWN0b3IgPD0gc3FydE47IGZhY3RvcisrKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoIShuICUgZmFjdG9yKSkge1xuXHQgICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcblx0ICAgICAgICAgICAgICAgIH1cblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB0cnVlO1xuXHQgICAgICAgIH1cblxuXHQgICAgICAgIGZ1bmN0aW9uIGdldEZyYWN0aW9uYWxCaXRzKG4pIHtcblx0ICAgICAgICAgICAgcmV0dXJuICgobiAtIChuIHwgMCkpICogMHgxMDAwMDAwMDApIHwgMDtcblx0ICAgICAgICB9XG5cblx0ICAgICAgICB2YXIgbiA9IDI7XG5cdCAgICAgICAgdmFyIG5QcmltZSA9IDA7XG5cdCAgICAgICAgd2hpbGUgKG5QcmltZSA8IDY0KSB7XG5cdCAgICAgICAgICAgIGlmIChpc1ByaW1lKG4pKSB7XG5cdCAgICAgICAgICAgICAgICBpZiAoblByaW1lIDwgOCkge1xuXHQgICAgICAgICAgICAgICAgICAgIEhbblByaW1lXSA9IGdldEZyYWN0aW9uYWxCaXRzKE1hdGgucG93KG4sIDEgLyAyKSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgICAgICBLW25QcmltZV0gPSBnZXRGcmFjdGlvbmFsQml0cyhNYXRoLnBvdyhuLCAxIC8gMykpO1xuXG5cdCAgICAgICAgICAgICAgICBuUHJpbWUrKztcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIG4rKztcblx0ICAgICAgICB9XG5cdCAgICB9KCkpO1xuXG5cdCAgICAvLyBSZXVzYWJsZSBvYmplY3Rcblx0ICAgIHZhciBXID0gW107XG5cblx0ICAgIC8qKlxuXHQgICAgICogU0hBLTI1NiBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTI1NiA9IENfYWxnby5TSEEyNTYgPSBIYXNoZXIuZXh0ZW5kKHtcblx0ICAgICAgICBfZG9SZXNldDogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICB0aGlzLl9oYXNoID0gbmV3IFdvcmRBcnJheS5pbml0KEguc2xpY2UoMCkpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblx0ICAgICAgICAgICAgdmFyIGUgPSBIWzRdO1xuXHQgICAgICAgICAgICB2YXIgZiA9IEhbNV07XG5cdCAgICAgICAgICAgIHZhciBnID0gSFs2XTtcblx0ICAgICAgICAgICAgdmFyIGggPSBIWzddO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgNjQ7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBNW29mZnNldCArIGldIHwgMDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMHggPSBXW2kgLSAxNV07XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIGdhbW1hMCAgPSAoKGdhbW1hMHggPDwgMjUpIHwgKGdhbW1hMHggPj4+IDcpKSAgXlxuXHQgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKChnYW1tYTB4IDw8IDE0KSB8IChnYW1tYTB4ID4+PiAxOCkpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZ2FtbWEweCA+Pj4gMyk7XG5cblx0ICAgICAgICAgICAgICAgICAgICB2YXIgZ2FtbWExeCA9IFdbaSAtIDJdO1xuXHQgICAgICAgICAgICAgICAgICAgIHZhciBnYW1tYTEgID0gKChnYW1tYTF4IDw8IDE1KSB8IChnYW1tYTF4ID4+PiAxNykpIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICgoZ2FtbWExeCA8PCAxMykgfCAoZ2FtbWExeCA+Pj4gMTkpKSBeXG5cdCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgKGdhbW1hMXggPj4+IDEwKTtcblxuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBnYW1tYTAgKyBXW2kgLSA3XSArIGdhbW1hMSArIFdbaSAtIDE2XTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgdmFyIGNoICA9IChlICYgZikgXiAofmUgJiBnKTtcblx0ICAgICAgICAgICAgICAgIHZhciBtYWogPSAoYSAmIGIpIF4gKGEgJiBjKSBeIChiICYgYyk7XG5cblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTAgPSAoKGEgPDwgMzApIHwgKGEgPj4+IDIpKSBeICgoYSA8PCAxOSkgfCAoYSA+Pj4gMTMpKSBeICgoYSA8PCAxMCkgfCAoYSA+Pj4gMjIpKTtcblx0ICAgICAgICAgICAgICAgIHZhciBzaWdtYTEgPSAoKGUgPDwgMjYpIHwgKGUgPj4+IDYpKSBeICgoZSA8PCAyMSkgfCAoZSA+Pj4gMTEpKSBeICgoZSA8PCA3KSAgfCAoZSA+Pj4gMjUpKTtcblxuXHQgICAgICAgICAgICAgICAgdmFyIHQxID0gaCArIHNpZ21hMSArIGNoICsgS1tpXSArIFdbaV07XG5cdCAgICAgICAgICAgICAgICB2YXIgdDIgPSBzaWdtYTAgKyBtYWo7XG5cblx0ICAgICAgICAgICAgICAgIGggPSBnO1xuXHQgICAgICAgICAgICAgICAgZyA9IGY7XG5cdCAgICAgICAgICAgICAgICBmID0gZTtcblx0ICAgICAgICAgICAgICAgIGUgPSAoZCArIHQxKSB8IDA7XG5cdCAgICAgICAgICAgICAgICBkID0gYztcblx0ICAgICAgICAgICAgICAgIGMgPSBiO1xuXHQgICAgICAgICAgICAgICAgYiA9IGE7XG5cdCAgICAgICAgICAgICAgICBhID0gKHQxICsgdDIpIHwgMDtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICAgICAgSFs0XSA9IChIWzRdICsgZSkgfCAwO1xuXHQgICAgICAgICAgICBIWzVdID0gKEhbNV0gKyBmKSB8IDA7XG5cdCAgICAgICAgICAgIEhbNl0gPSAoSFs2XSArIGcpIHwgMDtcblx0ICAgICAgICAgICAgSFs3XSA9IChIWzddICsgaCkgfCAwO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9GaW5hbGl6ZTogZnVuY3Rpb24gKCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGRhdGEgPSB0aGlzLl9kYXRhO1xuXHQgICAgICAgICAgICB2YXIgZGF0YVdvcmRzID0gZGF0YS53b3JkcztcblxuXHQgICAgICAgICAgICB2YXIgbkJpdHNUb3RhbCA9IHRoaXMuX25EYXRhQnl0ZXMgKiA4O1xuXHQgICAgICAgICAgICB2YXIgbkJpdHNMZWZ0ID0gZGF0YS5zaWdCeXRlcyAqIDg7XG5cblx0ICAgICAgICAgICAgLy8gQWRkIHBhZGRpbmdcblx0ICAgICAgICAgICAgZGF0YVdvcmRzW25CaXRzTGVmdCA+Pj4gNV0gfD0gMHg4MCA8PCAoMjQgLSBuQml0c0xlZnQgJSAzMik7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTRdID0gTWF0aC5mbG9vcihuQml0c1RvdGFsIC8gMHgxMDAwMDAwMDApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE1XSA9IG5CaXRzVG90YWw7XG5cdCAgICAgICAgICAgIGRhdGEuc2lnQnl0ZXMgPSBkYXRhV29yZHMubGVuZ3RoICogNDtcblxuXHQgICAgICAgICAgICAvLyBIYXNoIGZpbmFsIGJsb2Nrc1xuXHQgICAgICAgICAgICB0aGlzLl9wcm9jZXNzKCk7XG5cblx0ICAgICAgICAgICAgLy8gUmV0dXJuIGZpbmFsIGNvbXB1dGVkIGhhc2hcblx0ICAgICAgICAgICAgcmV0dXJuIHRoaXMuX2hhc2g7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIGNsb25lOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciBjbG9uZSA9IEhhc2hlci5jbG9uZS5jYWxsKHRoaXMpO1xuXHQgICAgICAgICAgICBjbG9uZS5faGFzaCA9IHRoaXMuX2hhc2guY2xvbmUoKTtcblxuXHQgICAgICAgICAgICByZXR1cm4gY2xvbmU7XG5cdCAgICAgICAgfVxuXHQgICAgfSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIGhhc2hlcidzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhhc2ggPSBDcnlwdG9KUy5TSEEyNTYoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTI1Nih3b3JkQXJyYXkpO1xuXHQgICAgICovXG5cdCAgICBDLlNIQTI1NiA9IEhhc2hlci5fY3JlYXRlSGVscGVyKFNIQTI1Nik7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMjU2KG1lc3NhZ2UsIGtleSk7XG5cdCAgICAgKi9cblx0ICAgIEMuSG1hY1NIQTI1NiA9IEhhc2hlci5fY3JlYXRlSG1hY0hlbHBlcihTSEEyNTYpO1xuXHR9KE1hdGgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5TSEEyNTY7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiAzMyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgZXZlbnRlbWl0dGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIHByZXNlbmNlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDM0KSk7XG52YXIgbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg5KSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBwYWdpbmF0ZWRyZXNvdXJjZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxOSkpO1xudmFyIHJlc291cmNlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE0KSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xuZnVuY3Rpb24gbm9vcCgpIHsgfVxudmFyIE1TR19JRF9FTlRST1BZX0JZVEVTID0gOTtcbmZ1bmN0aW9uIGFsbEVtcHR5SWRzKG1lc3NhZ2VzKSB7XG4gICAgcmV0dXJuIFV0aWxzLmFyckV2ZXJ5KG1lc3NhZ2VzLCBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICByZXR1cm4gIW1lc3NhZ2UuaWQ7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBub3JtYWxpc2VDaGFubmVsT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgdmFyIGNoYW5uZWxPcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcbiAgICBpZiAoY2hhbm5lbE9wdGlvbnMuY2lwaGVyKSB7XG4gICAgICAgIGlmICghcGxhdGZvcm1fMS5kZWZhdWx0LkNyeXB0bylcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignRW5jcnlwdGlvbiBub3QgZW5hYmxlZDsgdXNlIGFibHkuZW5jcnlwdGlvbi5qcyBpbnN0ZWFkJyk7XG4gICAgICAgIHZhciBjaXBoZXIgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQ3J5cHRvLmdldENpcGhlcihjaGFubmVsT3B0aW9ucy5jaXBoZXIpO1xuICAgICAgICBjaGFubmVsT3B0aW9ucy5jaXBoZXIgPSBjaXBoZXIuY2lwaGVyUGFyYW1zO1xuICAgICAgICBjaGFubmVsT3B0aW9ucy5jaGFubmVsQ2lwaGVyID0gY2lwaGVyLmNpcGhlcjtcbiAgICB9XG4gICAgZWxzZSBpZiAoJ2NpcGhlcicgaW4gY2hhbm5lbE9wdGlvbnMpIHtcbiAgICAgICAgLyogRG9uJ3QgZGVhY3RpdmF0ZSBhbiBleGlzdGluZyBjaXBoZXIgdW5sZXNzIG9wdGlvbnNcbiAgICAgICAgICogaGFzIGEgJ2NpcGhlcicga2V5IHRoYXQncyBmYWxzZXkgKi9cbiAgICAgICAgY2hhbm5lbE9wdGlvbnMuY2lwaGVyID0gdW5kZWZpbmVkO1xuICAgICAgICBjaGFubmVsT3B0aW9ucy5jaGFubmVsQ2lwaGVyID0gbnVsbDtcbiAgICB9XG4gICAgcmV0dXJuIGNoYW5uZWxPcHRpb25zO1xufVxudmFyIENoYW5uZWwgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ2hhbm5lbCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDaGFubmVsKHJlc3QsIG5hbWUsIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ2hhbm5lbCgpJywgJ3N0YXJ0ZWQ7IG5hbWUgPSAnICsgbmFtZSk7XG4gICAgICAgIF90aGlzLnJlc3QgPSByZXN0O1xuICAgICAgICBfdGhpcy5uYW1lID0gbmFtZTtcbiAgICAgICAgX3RoaXMuYmFzZVBhdGggPSAnL2NoYW5uZWxzLycgKyBlbmNvZGVVUklDb21wb25lbnQobmFtZSk7XG4gICAgICAgIF90aGlzLnByZXNlbmNlID0gbmV3IHByZXNlbmNlXzEuZGVmYXVsdChfdGhpcyk7XG4gICAgICAgIF90aGlzLmNoYW5uZWxPcHRpb25zID0gbm9ybWFsaXNlQ2hhbm5lbE9wdGlvbnMoY2hhbm5lbE9wdGlvbnMpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENoYW5uZWwucHJvdG90eXBlLnNldE9wdGlvbnMgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICB0aGlzLmNoYW5uZWxPcHRpb25zID0gbm9ybWFsaXNlQ2hhbm5lbE9wdGlvbnMob3B0aW9ucyk7XG4gICAgfTtcbiAgICBDaGFubmVsLnByb3RvdHlwZS5oaXN0b3J5ID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDaGFubmVsLmhpc3RvcnkoKScsICdjaGFubmVsID0gJyArIHRoaXMubmFtZSk7XG4gICAgICAgIC8qIHBhcmFtcyBhbmQgY2FsbGJhY2sgYXJlIG9wdGlvbmFsOyBzZWUgaWYgcGFyYW1zIGNvbnRhaW5zIHRoZSBjYWxsYmFjayAqL1xuICAgICAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBwYXJhbXMgPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gcGFyYW1zO1xuICAgICAgICAgICAgICAgIHBhcmFtcyA9IG51bGw7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnaGlzdG9yeScsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB0aGlzLl9oaXN0b3J5KHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgQ2hhbm5lbC5wcm90b3R5cGUuX2hpc3RvcnkgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucmVzdCwgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgZW52ZWxvcGUgPSB0aGlzLnJlc3QuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0LCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdEdldEhlYWRlcnMocmVzdC5vcHRpb25zLCBmb3JtYXQpO1xuICAgICAgICBpZiAocmVzdC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcbiAgICAgICAgbmV3IHBhZ2luYXRlZHJlc291cmNlXzEuZGVmYXVsdChyZXN0LCB0aGlzLmJhc2VQYXRoICsgJy9tZXNzYWdlcycsIGhlYWRlcnMsIGVudmVsb3BlLCBmdW5jdGlvbiAoYm9keSwgaGVhZGVycywgdW5wYWNrZWQpIHtcbiAgICAgICAgICAgIHJldHVybiBtZXNzYWdlXzEuZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIG9wdGlvbnMsIHVucGFja2VkID8gdW5kZWZpbmVkIDogZm9ybWF0KTtcbiAgICAgICAgfSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgQ2hhbm5lbC5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ0NvdW50ID0gYXJndW1lbnRzLmxlbmd0aCwgZmlyc3QgPSBhcmd1bWVudHNbMF0sIHNlY29uZCA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJndW1lbnRzW2FyZ0NvdW50IC0gMV07XG4gICAgICAgIHZhciBtZXNzYWdlcztcbiAgICAgICAgdmFyIHBhcmFtcztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAncHVibGlzaCcsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBmaXJzdCA9PT0gJ3N0cmluZycgfHwgZmlyc3QgPT09IG51bGwpIHtcbiAgICAgICAgICAgIC8qIChuYW1lLCBkYXRhLCAuLi4pICovXG4gICAgICAgICAgICBtZXNzYWdlcyA9IFttZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHsgbmFtZTogZmlyc3QsIGRhdGE6IHNlY29uZCB9KV07XG4gICAgICAgICAgICBwYXJhbXMgPSBhcmd1bWVudHNbMl07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVXRpbHMuaXNPYmplY3QoZmlyc3QpKSB7XG4gICAgICAgICAgICBtZXNzYWdlcyA9IFttZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKGZpcnN0KV07XG4gICAgICAgICAgICBwYXJhbXMgPSBhcmd1bWVudHNbMV07XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoVXRpbHMuaXNBcnJheShmaXJzdCkpIHtcbiAgICAgICAgICAgIG1lc3NhZ2VzID0gbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlc0FycmF5KGZpcnN0KTtcbiAgICAgICAgICAgIHBhcmFtcyA9IGFyZ3VtZW50c1sxXTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdUaGUgc2luZ2xlLWFyZ3VtZW50IGZvcm0gb2YgcHVibGlzaCgpIGV4cGVjdHMgYSBtZXNzYWdlIG9iamVjdCBvciBhbiBhcnJheSBvZiBtZXNzYWdlIG9iamVjdHMnLCA0MDAxMywgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyAhPT0gJ29iamVjdCcgfHwgIXBhcmFtcykge1xuICAgICAgICAgICAgLyogTm8gcGFyYW1zIHN1cHBsaWVkIChzbyBhZnRlci1tZXNzYWdlIGFyZ3VtZW50IGlzIGp1c3QgdGhlIGNhbGxiYWNrIG9yIHVuZGVmaW5lZCkgKi9cbiAgICAgICAgICAgIHBhcmFtcyA9IHt9O1xuICAgICAgICB9XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5yZXN0LCBvcHRpb25zID0gcmVzdC5vcHRpb25zLCBmb3JtYXQgPSBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nID0gcmVzdC5vcHRpb25zLmlkZW1wb3RlbnRSZXN0UHVibGlzaGluZywgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRQb3N0SGVhZGVycyhyZXN0Lm9wdGlvbnMsIGZvcm1hdCk7XG4gICAgICAgIGlmIChvcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCBvcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBpZiAoaWRlbXBvdGVudFJlc3RQdWJsaXNoaW5nICYmIGFsbEVtcHR5SWRzKG1lc3NhZ2VzKSkge1xuICAgICAgICAgICAgdmFyIG1zZ0lkQmFzZV8xID0gVXRpbHMucmFuZG9tU3RyaW5nKE1TR19JRF9FTlRST1BZX0JZVEVTKTtcbiAgICAgICAgICAgIFV0aWxzLmFyckZvckVhY2gobWVzc2FnZXMsIGZ1bmN0aW9uIChtZXNzYWdlLCBpbmRleCkge1xuICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWQgPSBtc2dJZEJhc2VfMSArICc6JyArIGluZGV4LnRvU3RyaW5nKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBtZXNzYWdlXzEuZGVmYXVsdC5lbmNvZGVBcnJheShtZXNzYWdlcywgdGhpcy5jaGFubmVsT3B0aW9ucywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogUlNMMWkgKi9cbiAgICAgICAgICAgIHZhciBzaXplID0gbWVzc2FnZV8xLmRlZmF1bHQuZ2V0TWVzc2FnZXNTaXplKG1lc3NhZ2VzKSwgbWF4TWVzc2FnZVNpemUgPSBvcHRpb25zLm1heE1lc3NhZ2VTaXplO1xuICAgICAgICAgICAgaWYgKHNpemUgPiBtYXhNZXNzYWdlU2l6ZSkge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdNYXhpbXVtIHNpemUgb2YgbWVzc2FnZXMgdGhhdCBjYW4gYmUgcHVibGlzaGVkIGF0IG9uY2UgZXhjZWVkZWQgKCB3YXMgJyArXG4gICAgICAgICAgICAgICAgICAgIHNpemUgK1xuICAgICAgICAgICAgICAgICAgICAnIGJ5dGVzOyBsaW1pdCBpcyAnICtcbiAgICAgICAgICAgICAgICAgICAgbWF4TWVzc2FnZVNpemUgK1xuICAgICAgICAgICAgICAgICAgICAnIGJ5dGVzKScsIDQwMDA5LCA0MDApKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5fcHVibGlzaChtZXNzYWdlXzEuZGVmYXVsdC5zZXJpYWxpemUobWVzc2FnZXMsIGZvcm1hdCksIGhlYWRlcnMsIHBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIENoYW5uZWwucHJvdG90eXBlLl9wdWJsaXNoID0gZnVuY3Rpb24gKHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdC5wb3N0KHRoaXMucmVzdCwgdGhpcy5iYXNlUGF0aCArICcvbWVzc2FnZXMnLCByZXF1ZXN0Qm9keSwgaGVhZGVycywgcGFyYW1zLCBudWxsLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBDaGFubmVsLnByb3RvdHlwZS5zdGF0dXMgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJyAmJiB0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnc3RhdHVzJywgW10pO1xuICAgICAgICB9XG4gICAgICAgIHZhciBmb3JtYXQgPSB0aGlzLnJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb247XG4gICAgICAgIHZhciBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdFBvc3RIZWFkZXJzKHRoaXMucmVzdC5vcHRpb25zLCBmb3JtYXQpO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQuZ2V0KHRoaXMucmVzdCwgdGhpcy5iYXNlUGF0aCwgaGVhZGVycywge30sIGZvcm1hdCwgY2FsbGJhY2sgfHwgbm9vcCk7XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhbm5lbDtcbn0oZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ2hhbm5lbDtcblxuXG4vKioqLyB9KSxcbi8qIDM0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBldmVudGVtaXR0ZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNykpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgcGFnaW5hdGVkcmVzb3VyY2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTkpKTtcbnZhciBwcmVzZW5jZW1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTUpKTtcbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbnZhciBQcmVzZW5jZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhQcmVzZW5jZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcmVzZW5jZShjaGFubmVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICBfdGhpcy5iYXNlUGF0aCA9IGNoYW5uZWwuYmFzZVBhdGggKyAnL3ByZXNlbmNlJztcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQcmVzZW5jZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdQcmVzZW5jZS5nZXQoKScsICdjaGFubmVsID0gJyArIHRoaXMuY2hhbm5lbC5uYW1lKTtcbiAgICAgICAgLyogcGFyYW1zIGFuZCBjYWxsYmFjayBhcmUgb3B0aW9uYWw7IHNlZSBpZiBwYXJhbXMgY29udGFpbnMgdGhlIGNhbGxiYWNrICovXG4gICAgICAgIGlmIChjYWxsYmFjayA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBpZiAodHlwZW9mIHBhcmFtcyA9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICAgICAgICAgICAgcGFyYW1zID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWwucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2dldCcsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdCA9IHRoaXMuY2hhbm5lbC5yZXN0LCBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBlbnZlbG9wZSA9IHRoaXMuY2hhbm5lbC5yZXN0Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRHZXRIZWFkZXJzKHJlc3Qub3B0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuY2hhbm5lbC5jaGFubmVsT3B0aW9ucztcbiAgICAgICAgbmV3IHBhZ2luYXRlZHJlc291cmNlXzEuZGVmYXVsdChyZXN0LCB0aGlzLmJhc2VQYXRoLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24gKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICByZXR1cm4gcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIG9wdGlvbnMsIHVucGFja2VkID8gdW5kZWZpbmVkIDogZm9ybWF0KTtcbiAgICAgICAgfSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUHJlc2VuY2UucHJvdG90eXBlLmhpc3RvcnkgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1ByZXNlbmNlLmhpc3RvcnkoKScsICdjaGFubmVsID0gJyArIHRoaXMuY2hhbm5lbC5uYW1lKTtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2hpc3RvcnkocGFyYW1zLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBQcmVzZW5jZS5wcm90b3R5cGUuX2hpc3RvcnkgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICAvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbC5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnX2hpc3RvcnknLCBbcGFyYW1zXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVzdCA9IHRoaXMuY2hhbm5lbC5yZXN0LCBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBlbnZlbG9wZSA9IHRoaXMuY2hhbm5lbC5yZXN0Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRHZXRIZWFkZXJzKHJlc3Qub3B0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICB2YXIgb3B0aW9ucyA9IHRoaXMuY2hhbm5lbC5jaGFubmVsT3B0aW9ucztcbiAgICAgICAgbmV3IHBhZ2luYXRlZHJlc291cmNlXzEuZGVmYXVsdChyZXN0LCB0aGlzLmJhc2VQYXRoICsgJy9oaXN0b3J5JywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uIChib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHByZXNlbmNlbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVJlc3BvbnNlQm9keShib2R5LCBvcHRpb25zLCB1bnBhY2tlZCA/IHVuZGVmaW5lZCA6IGZvcm1hdCk7XG4gICAgICAgIH0pLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIHJldHVybiBQcmVzZW5jZTtcbn0oZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUHJlc2VuY2U7XG5cblxuLyoqKi8gfSksXG4vKiAzNSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqLyhmdW5jdGlvbihnbG9iYWwpIHtcbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbmV4cG9ydHMuVHJhbnNwb3J0UGFyYW1zID0gdm9pZCAwO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIHByb3RvY29sbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxMCkpO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgcHJvdG9jb2xfMSA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oNTIpKTtcbnZhciBkZWZhdWx0c18xID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg4KSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIGV2ZW50ZW1pdHRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg3KSk7XG52YXIgbWVzc2FnZXF1ZXVlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDM2KSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzcpKTtcbnZhciBjb25uZWN0aW9uZXJyb3JzXzEgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDIwKSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBhdXRoXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE3KSk7XG52YXIgbWVzc2FnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg5KSk7XG52YXIgbXVsdGljYXN0ZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjMpKTtcbnZhciB3ZWJzb2NrZXR0cmFuc3BvcnRfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNTMpKTtcbnZhciB0cmFuc3BvcnRfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjYpKTtcbnZhciBIdHRwU3RhdHVzQ29kZXNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjUpKTtcbnZhciBoYXZlV2ViU3RvcmFnZSA9IGZ1bmN0aW9uICgpIHsgdmFyIF9hOyByZXR1cm4gdHlwZW9mIHBsYXRmb3JtXzEuZGVmYXVsdC5XZWJTdG9yYWdlICE9PSAndW5kZWZpbmVkJyAmJiAoKF9hID0gcGxhdGZvcm1fMS5kZWZhdWx0LldlYlN0b3JhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5sb2NhbFN1cHBvcnRlZCk7IH07XG52YXIgaGF2ZVNlc3Npb25TdG9yYWdlID0gZnVuY3Rpb24gKCkgeyB2YXIgX2E7IHJldHVybiB0eXBlb2YgcGxhdGZvcm1fMS5kZWZhdWx0LldlYlN0b3JhZ2UgIT09ICd1bmRlZmluZWQnICYmICgoX2EgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuV2ViU3RvcmFnZSkgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnNlc3Npb25TdXBwb3J0ZWQpOyB9O1xudmFyIGFjdGlvbnMgPSBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LkFjdGlvbjtcbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xudmFyIHRyYW5zcG9ydFByZWZlcmVuY2VOYW1lID0gJ2FibHktdHJhbnNwb3J0LXByZWZlcmVuY2UnO1xudmFyIHNlc3Npb25SZWNvdmVyeU5hbWUgPSAnYWJseS1jb25uZWN0aW9uLXJlY292ZXJ5JztcbmZ1bmN0aW9uIGdldFNlc3Npb25SZWNvdmVyRGF0YSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBoYXZlU2Vzc2lvblN0b3JhZ2UoKSAmJiAoKF9iID0gKF9hID0gcGxhdGZvcm1fMS5kZWZhdWx0LldlYlN0b3JhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXRTZXNzaW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgc2Vzc2lvblJlY292ZXJ5TmFtZSkpO1xufVxuZnVuY3Rpb24gc2V0U2Vzc2lvblJlY292ZXJEYXRhKHZhbHVlKSB7XG4gICAgdmFyIF9hLCBfYjtcbiAgICByZXR1cm4gaGF2ZVNlc3Npb25TdG9yYWdlKCkgJiYgKChfYiA9IChfYSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5XZWJTdG9yYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0U2Vzc2lvbikgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLmNhbGwoX2EsIHNlc3Npb25SZWNvdmVyeU5hbWUsIHZhbHVlKSk7XG59XG5mdW5jdGlvbiBjbGVhclNlc3Npb25SZWNvdmVyRGF0YSgpIHtcbiAgICB2YXIgX2EsIF9iO1xuICAgIHJldHVybiBoYXZlU2Vzc2lvblN0b3JhZ2UoKSAmJiAoKF9iID0gKF9hID0gcGxhdGZvcm1fMS5kZWZhdWx0LldlYlN0b3JhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZW1vdmVTZXNzaW9uKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgc2Vzc2lvblJlY292ZXJ5TmFtZSkpO1xufVxuZnVuY3Rpb24gYmV0dGVyVHJhbnNwb3J0VGhhbihhLCBiKSB7XG4gICAgcmV0dXJuIChVdGlscy5hcnJJbmRleE9mKHBsYXRmb3JtXzEuZGVmYXVsdC5EZWZhdWx0cy50cmFuc3BvcnRQcmVmZXJlbmNlT3JkZXIsIGEuc2hvcnROYW1lKSA+XG4gICAgICAgIFV0aWxzLmFyckluZGV4T2YocGxhdGZvcm1fMS5kZWZhdWx0LkRlZmF1bHRzLnRyYW5zcG9ydFByZWZlcmVuY2VPcmRlciwgYi5zaG9ydE5hbWUpKTtcbn1cbmZ1bmN0aW9uIGJ1bmRsZVdpdGgoZGVzdCwgc3JjLCBtYXhTaXplKSB7XG4gICAgdmFyIGFjdGlvbjtcbiAgICBpZiAoZGVzdC5jaGFubmVsICE9PSBzcmMuY2hhbm5lbCkge1xuICAgICAgICAvKiBSVEw2ZDMgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoKGFjdGlvbiA9IGRlc3QuYWN0aW9uKSAhPT0gYWN0aW9ucy5QUkVTRU5DRSAmJiBhY3Rpb24gIT09IGFjdGlvbnMuTUVTU0FHRSkge1xuICAgICAgICAvKiBSVEw2ZCAtIGNhbiBvbmx5IGJ1bmRsZSBtZXNzYWdlcyBvciBwcmVzZW5jZSAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChhY3Rpb24gIT09IHNyYy5hY3Rpb24pIHtcbiAgICAgICAgLyogUlRMNmQ0ICovXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgdmFyIGtpbmQgPSBhY3Rpb24gPT09IGFjdGlvbnMuUFJFU0VOQ0UgPyAncHJlc2VuY2UnIDogJ21lc3NhZ2VzJywgcHJvcG9zZWQgPSBkZXN0W2tpbmRdLmNvbmNhdChzcmNba2luZF0pLCBzaXplID0gbWVzc2FnZV8xLmRlZmF1bHQuZ2V0TWVzc2FnZXNTaXplKHByb3Bvc2VkKTtcbiAgICBpZiAoc2l6ZSA+IG1heFNpemUpIHtcbiAgICAgICAgLyogUlRMNmQxICovXG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgaWYgKCFVdGlscy5hbGxTYW1lKHByb3Bvc2VkLCAnY2xpZW50SWQnKSkge1xuICAgICAgICAvKiBSVEw2ZDIgKi9cbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBpZiAoIVV0aWxzLmFyckV2ZXJ5KHByb3Bvc2VkLCBmdW5jdGlvbiAobXNnKSB7XG4gICAgICAgIHJldHVybiAhbXNnLmlkO1xuICAgIH0pKSB7XG4gICAgICAgIC8qIFJUTDZkNyAqL1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8qIHdlJ3JlIGdvb2QgdG8gZ28hICovXG4gICAgZGVzdFtraW5kXSA9IHByb3Bvc2VkO1xuICAgIHJldHVybiB0cnVlO1xufVxuZnVuY3Rpb24gZGVjb2RlUmVjb3ZlcnlLZXkocmVjb3ZlcnlLZXkpIHtcbiAgICB0cnkge1xuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShyZWNvdmVyeUtleSk7XG4gICAgfVxuICAgIGNhdGNoIChlKSB7XG4gICAgICAgIHJldHVybiBudWxsO1xuICAgIH1cbn1cbnZhciBUcmFuc3BvcnRQYXJhbXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gVHJhbnNwb3J0UGFyYW1zKG9wdGlvbnMsIGhvc3QsIG1vZGUsIGNvbm5lY3Rpb25LZXkpIHtcbiAgICAgICAgdGhpcy5vcHRpb25zID0gb3B0aW9ucztcbiAgICAgICAgdGhpcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgdGhpcy5tb2RlID0gbW9kZTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uS2V5ID0gY29ubmVjdGlvbktleTtcbiAgICAgICAgdGhpcy5mb3JtYXQgPSBvcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbjtcbiAgICB9XG4gICAgVHJhbnNwb3J0UGFyYW1zLnByb3RvdHlwZS5nZXRDb25uZWN0UGFyYW1zID0gZnVuY3Rpb24gKGF1dGhQYXJhbXMpIHtcbiAgICAgICAgdmFyIHBhcmFtcyA9IGF1dGhQYXJhbXMgPyBVdGlscy5jb3B5KGF1dGhQYXJhbXMpIDoge307XG4gICAgICAgIHZhciBvcHRpb25zID0gdGhpcy5vcHRpb25zO1xuICAgICAgICBzd2l0Y2ggKHRoaXMubW9kZSkge1xuICAgICAgICAgICAgY2FzZSAndXBncmFkZSc6XG4gICAgICAgICAgICAgICAgcGFyYW1zLnVwZ3JhZGUgPSB0aGlzLmNvbm5lY3Rpb25LZXk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZXN1bWUnOlxuICAgICAgICAgICAgICAgIHBhcmFtcy5yZXN1bWUgPSB0aGlzLmNvbm5lY3Rpb25LZXk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdyZWNvdmVyJzoge1xuICAgICAgICAgICAgICAgIHZhciByZWNvdmVyeUNvbnRleHQgPSBkZWNvZGVSZWNvdmVyeUtleShvcHRpb25zLnJlY292ZXIpO1xuICAgICAgICAgICAgICAgIGlmIChyZWNvdmVyeUNvbnRleHQpIHtcbiAgICAgICAgICAgICAgICAgICAgcGFyYW1zLnJlY292ZXIgPSByZWNvdmVyeUNvbnRleHQuY29ubmVjdGlvbktleTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICB9XG4gICAgICAgIGlmIChvcHRpb25zLmNsaWVudElkICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5jbGllbnRJZCA9IG9wdGlvbnMuY2xpZW50SWQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMuZWNob01lc3NhZ2VzID09PSBmYWxzZSkge1xuICAgICAgICAgICAgcGFyYW1zLmVjaG8gPSAnZmFsc2UnO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZvcm1hdCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBwYXJhbXMuZm9ybWF0ID0gdGhpcy5mb3JtYXQ7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuc3RyZWFtICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5zdHJlYW0gPSB0aGlzLnN0cmVhbTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5oZWFydGJlYXRzICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIHBhcmFtcy5oZWFydGJlYXRzID0gdGhpcy5oZWFydGJlYXRzO1xuICAgICAgICB9XG4gICAgICAgIHBhcmFtcy52ID0gZGVmYXVsdHNfMS5kZWZhdWx0LnByb3RvY29sVmVyc2lvbjtcbiAgICAgICAgcGFyYW1zLmFnZW50ID0gKDAsIGRlZmF1bHRzXzEuZ2V0QWdlbnRTdHJpbmcpKHRoaXMub3B0aW9ucyk7XG4gICAgICAgIGlmIChvcHRpb25zLnRyYW5zcG9ydFBhcmFtcyAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBVdGlscy5taXhpbihwYXJhbXMsIG9wdGlvbnMudHJhbnNwb3J0UGFyYW1zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcGFyYW1zO1xuICAgIH07XG4gICAgVHJhbnNwb3J0UGFyYW1zLnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICdbbW9kZT0nICsgdGhpcy5tb2RlO1xuICAgICAgICBpZiAodGhpcy5ob3N0KSB7XG4gICAgICAgICAgICByZXN1bHQgKz0gJyxob3N0PScgKyB0aGlzLmhvc3Q7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuY29ubmVjdGlvbktleSkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcsY29ubmVjdGlvbktleT0nICsgdGhpcy5jb25uZWN0aW9uS2V5O1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZvcm1hdCkge1xuICAgICAgICAgICAgcmVzdWx0ICs9ICcsZm9ybWF0PScgKyB0aGlzLmZvcm1hdDtcbiAgICAgICAgfVxuICAgICAgICByZXN1bHQgKz0gJ10nO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgcmV0dXJuIFRyYW5zcG9ydFBhcmFtcztcbn0oKSk7XG5leHBvcnRzLlRyYW5zcG9ydFBhcmFtcyA9IFRyYW5zcG9ydFBhcmFtcztcbnZhciBDb25uZWN0aW9uTWFuYWdlciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhDb25uZWN0aW9uTWFuYWdlciwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBDb25uZWN0aW9uTWFuYWdlcihyZWFsdGltZSwgb3B0aW9ucykge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5kaXNjb25uZWN0ZWRSZXRyeUNvdW50ID0gMDtcbiAgICAgICAgQ29ubmVjdGlvbk1hbmFnZXIuaW5pdFRyYW5zcG9ydHMoKTtcbiAgICAgICAgX3RoaXMucmVhbHRpbWUgPSByZWFsdGltZTtcbiAgICAgICAgX3RoaXMub3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICAgIHZhciB0aW1lb3V0cyA9IG9wdGlvbnMudGltZW91dHM7XG4gICAgICAgIC8qIGNvbm5lY3RpbmdUaW1lb3V0OiBsZWF2ZSBwcmVmZXJlbmNlQ29ubmVjdFRpbWVvdXQgKH42cykgdG8gdHJ5IHRoZVxuICAgICAgICAgKiBwcmVmZXJlbmNlIHRyYW5zcG9ydCwgdGhlbiByZWFsdGltZVJlcXVlc3RUaW1lb3V0ICh+MTBzKSB0byBlc3RhYmxpc2hcbiAgICAgICAgICogdGhlIGJhc2UgdHJhbnNwb3J0IGluIGNhc2UgdGhhdCBmYWlscyAqL1xuICAgICAgICB2YXIgY29ubmVjdGluZ1RpbWVvdXQgPSB0aW1lb3V0cy5wcmVmZXJlbmNlQ29ubmVjdFRpbWVvdXQgKyB0aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0O1xuICAgICAgICBfdGhpcy5zdGF0ZXMgPSB7XG4gICAgICAgICAgICBpbml0aWFsaXplZDoge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnaW5pdGlhbGl6ZWQnLFxuICAgICAgICAgICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBxdWV1ZUV2ZW50czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmYWlsU3RhdGU6ICdkaXNjb25uZWN0ZWQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbm5lY3Rpbmc6IHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ2Nvbm5lY3RpbmcnLFxuICAgICAgICAgICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBxdWV1ZUV2ZW50czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZXRyeURlbGF5OiBjb25uZWN0aW5nVGltZW91dCxcbiAgICAgICAgICAgICAgICBmYWlsU3RhdGU6ICdkaXNjb25uZWN0ZWQnLFxuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGNvbm5lY3RlZDoge1xuICAgICAgICAgICAgICAgIHN0YXRlOiAnY29ubmVjdGVkJyxcbiAgICAgICAgICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcXVldWVFdmVudHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNlbmRFdmVudHM6IHRydWUsXG4gICAgICAgICAgICAgICAgZmFpbFN0YXRlOiAnZGlzY29ubmVjdGVkJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzeW5jaHJvbml6aW5nOiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdjb25uZWN0ZWQnLFxuICAgICAgICAgICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBxdWV1ZUV2ZW50czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBmb3JjZVF1ZXVlRXZlbnRzOiB0cnVlLFxuICAgICAgICAgICAgICAgIGZhaWxTdGF0ZTogJ2Rpc2Nvbm5lY3RlZCcsXG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZGlzY29ubmVjdGVkOiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdkaXNjb25uZWN0ZWQnLFxuICAgICAgICAgICAgICAgIHRlcm1pbmFsOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBxdWV1ZUV2ZW50czogdHJ1ZSxcbiAgICAgICAgICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZXRyeURlbGF5OiB0aW1lb3V0cy5kaXNjb25uZWN0ZWRSZXRyeVRpbWVvdXQsXG4gICAgICAgICAgICAgICAgZmFpbFN0YXRlOiAnZGlzY29ubmVjdGVkJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzdXNwZW5kZWQ6IHtcbiAgICAgICAgICAgICAgICBzdGF0ZTogJ3N1c3BlbmRlZCcsXG4gICAgICAgICAgICAgICAgdGVybWluYWw6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHF1ZXVlRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICBzZW5kRXZlbnRzOiBmYWxzZSxcbiAgICAgICAgICAgICAgICByZXRyeURlbGF5OiB0aW1lb3V0cy5zdXNwZW5kZWRSZXRyeVRpbWVvdXQsXG4gICAgICAgICAgICAgICAgZmFpbFN0YXRlOiAnc3VzcGVuZGVkJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zaW5nOiB7XG4gICAgICAgICAgICAgICAgc3RhdGU6ICdjbG9zaW5nJyxcbiAgICAgICAgICAgICAgICB0ZXJtaW5hbDogZmFsc2UsXG4gICAgICAgICAgICAgICAgcXVldWVFdmVudHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHNlbmRFdmVudHM6IGZhbHNlLFxuICAgICAgICAgICAgICAgIHJldHJ5RGVsYXk6IHRpbWVvdXRzLnJlYWx0aW1lUmVxdWVzdFRpbWVvdXQsXG4gICAgICAgICAgICAgICAgZmFpbFN0YXRlOiAnY2xvc2VkJyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBjbG9zZWQ6IHsgc3RhdGU6ICdjbG9zZWQnLCB0ZXJtaW5hbDogdHJ1ZSwgcXVldWVFdmVudHM6IGZhbHNlLCBzZW5kRXZlbnRzOiBmYWxzZSwgZmFpbFN0YXRlOiAnY2xvc2VkJyB9LFxuICAgICAgICAgICAgZmFpbGVkOiB7IHN0YXRlOiAnZmFpbGVkJywgdGVybWluYWw6IHRydWUsIHF1ZXVlRXZlbnRzOiBmYWxzZSwgc2VuZEV2ZW50czogZmFsc2UsIGZhaWxTdGF0ZTogJ2ZhaWxlZCcgfSxcbiAgICAgICAgfTtcbiAgICAgICAgX3RoaXMuc3RhdGUgPSBfdGhpcy5zdGF0ZXMuaW5pdGlhbGl6ZWQ7XG4gICAgICAgIF90aGlzLmVycm9yUmVhc29uID0gbnVsbDtcbiAgICAgICAgX3RoaXMucXVldWVkTWVzc2FnZXMgPSBuZXcgbWVzc2FnZXF1ZXVlXzEuZGVmYXVsdCgpO1xuICAgICAgICBfdGhpcy5tc2dTZXJpYWwgPSAwO1xuICAgICAgICBfdGhpcy5jb25uZWN0aW9uRGV0YWlscyA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMuY29ubmVjdGlvbklkID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5jb25uZWN0aW9uS2V5ID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5jb25uZWN0aW9uU3RhdGVUdGwgPSB0aW1lb3V0cy5jb25uZWN0aW9uU3RhdGVUdGw7XG4gICAgICAgIF90aGlzLm1heElkbGVJbnRlcnZhbCA9IG51bGw7XG4gICAgICAgIF90aGlzLnRyYW5zcG9ydHMgPSBVdGlscy5pbnRlcnNlY3Qob3B0aW9ucy50cmFuc3BvcnRzIHx8IGRlZmF1bHRzXzEuZGVmYXVsdC5kZWZhdWx0VHJhbnNwb3J0cywgQ29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0cyk7XG4gICAgICAgIC8qIGJhc2VUcmFuc3BvcnRzIHNlbGVjdHMgdGhlIGxlZnRtb3N0IHRyYW5zcG9ydCBpbiB0aGUgRGVmYXVsdHMuYmFzZVRyYW5zcG9ydE9yZGVyIGxpc3RcbiAgICAgICAgICogdGhhdCdzIGJvdGggcmVxdWVzdGVkIGFuZCBzdXBwb3J0ZWQuIE5vcm1hbGx5IHRoaXMgd2lsbCBiZSB4aHJfcG9sbGluZztcbiAgICAgICAgICogaWYgeGhyIGlzbid0IHN1cHBvcnRlZCBpdCB3aWxsIGJlIGpzb25wLiBJZiB0aGUgdXNlciBoYXMgZm9yY2VkIGFcbiAgICAgICAgICogdHJhbnNwb3J0LCBpdCdsbCBqdXN0IGJlIHRoYXQgb25lLiAqL1xuICAgICAgICBfdGhpcy5iYXNlVHJhbnNwb3J0ID0gVXRpbHMuaW50ZXJzZWN0KGRlZmF1bHRzXzEuZGVmYXVsdC5iYXNlVHJhbnNwb3J0T3JkZXIsIF90aGlzLnRyYW5zcG9ydHMpWzBdO1xuICAgICAgICBfdGhpcy51cGdyYWRlVHJhbnNwb3J0cyA9IFV0aWxzLmludGVyc2VjdChfdGhpcy50cmFuc3BvcnRzLCBkZWZhdWx0c18xLmRlZmF1bHQudXBncmFkZVRyYW5zcG9ydHMpO1xuICAgICAgICBfdGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlID0gbnVsbDtcbiAgICAgICAgX3RoaXMuaHR0cEhvc3RzID0gZGVmYXVsdHNfMS5kZWZhdWx0LmdldEhvc3RzKG9wdGlvbnMpO1xuICAgICAgICBfdGhpcy5hY3RpdmVQcm90b2NvbCA9IG51bGw7XG4gICAgICAgIF90aGlzLnByb3Bvc2VkVHJhbnNwb3J0cyA9IFtdO1xuICAgICAgICBfdGhpcy5wZW5kaW5nVHJhbnNwb3J0cyA9IFtdO1xuICAgICAgICBfdGhpcy5ob3N0ID0gbnVsbDtcbiAgICAgICAgX3RoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ID0gbnVsbDtcbiAgICAgICAgX3RoaXMubGFzdEFjdGl2aXR5ID0gbnVsbDtcbiAgICAgICAgX3RoaXMuZm9yY2VGYWxsYmFja0hvc3QgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMuY29ubmVjdENvdW50ZXIgPSAwO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCAnc3RhcnRlZCcpO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCAncmVxdWVzdGVkIHRyYW5zcG9ydHMgPSBbJyArIChvcHRpb25zLnRyYW5zcG9ydHMgfHwgZGVmYXVsdHNfMS5kZWZhdWx0LmRlZmF1bHRUcmFuc3BvcnRzKSArICddJyk7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKScsICdhdmFpbGFibGUgdHJhbnNwb3J0cyA9IFsnICsgX3RoaXMudHJhbnNwb3J0cyArICddJyk7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWUuQ29ubmVjdGlvbk1hbmFnZXIoKScsICdodHRwIGhvc3RzID0gWycgKyBfdGhpcy5odHRwSG9zdHMgKyAnXScpO1xuICAgICAgICBpZiAoIV90aGlzLnRyYW5zcG9ydHMubGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ25vIHJlcXVlc3RlZCB0cmFuc3BvcnRzIGF2YWlsYWJsZSc7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ3JlYWx0aW1lLkNvbm5lY3Rpb25NYW5hZ2VyKCknLCBtc2cpO1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKG1zZyk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGFkZEV2ZW50TGlzdGVuZXIgPSBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmFkZEV2ZW50TGlzdGVuZXI7XG4gICAgICAgIGlmIChhZGRFdmVudExpc3RlbmVyKSB7XG4gICAgICAgICAgICAvKiBpbnRlcmNlcHQgY2xvc2UgZXZlbnQgaW4gYnJvd3NlciB0byBwZXJzaXN0IGNvbm5lY3Rpb24gaWQgaWYgcmVxdWVzdGVkICovXG4gICAgICAgICAgICBpZiAoaGF2ZVNlc3Npb25TdG9yYWdlKCkgJiYgdHlwZW9mIG9wdGlvbnMucmVjb3ZlciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIC8qIFVzdWFsbHkgY2FuJ3QgdXNlIGJpbmQgYXMgbm90IHN1cHBvcnRlZCBpbiBJRTgsIGJ1dCBJRSBkb2Vzbid0IHN1cHBvcnQgc2Vzc2lvblN0b3JhZ2UsIHNvLi4uICovXG4gICAgICAgICAgICAgICAgYWRkRXZlbnRMaXN0ZW5lcignYmVmb3JldW5sb2FkJywgX3RoaXMucGVyc2lzdENvbm5lY3Rpb24uYmluZChfdGhpcykpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG9wdGlvbnMuY2xvc2VPblVubG9hZCA9PT0gdHJ1ZSkge1xuICAgICAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ2JlZm9yZXVubG9hZCcsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUFKT1IsICdSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlcigpJywgJ2JlZm9yZXVubG9hZCBldmVudCBoYXMgdHJpZ2dlcmVkIHRoZSBjb25uZWN0aW9uIHRvIGNsb3NlIGFzIGNsb3NlT25VbmxvYWQgaXMgdHJ1ZScpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogJ2Nsb3NpbmcnIH0pO1xuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogTGlzdGVuIGZvciBvbmxpbmUgYW5kIG9mZmxpbmUgZXZlbnRzICovXG4gICAgICAgICAgICBhZGRFdmVudExpc3RlbmVyKCdvbmxpbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlID09IF90aGlzLnN0YXRlcy5kaXNjb25uZWN0ZWQgfHwgX3RoaXMuc3RhdGUgPT0gX3RoaXMuc3RhdGVzLnN1c3BlbmRlZCkge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyIGNhdWdodCBicm93c2VyIOKAmG9ubGluZeKAmSBldmVudCcsICdyZWF0dGVtcHRpbmcgY29ubmVjdGlvbicpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5yZXF1ZXN0U3RhdGUoeyBzdGF0ZTogJ2Nvbm5lY3RpbmcnIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfdGhpcy5zdGF0ZSA9PSBfdGhpcy5zdGF0ZXMuY29ubmVjdGluZykge1xuICAgICAgICAgICAgICAgICAgICAvLyBSVE4yMGM6IGlmICdvbmxpbmUnIGV2ZW50IHJlY2lldmVkIHdoaWxlIENPTk5FQ1RJTkcsIGFiYW5kb24gY29ubmVjdGlvbiBhdHRlbXB0IGFuZCByZXRyeVxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wZW5kaW5nVHJhbnNwb3J0cy5mb3JFYWNoKGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIERldGFjaCB0cmFuc3BvcnQgbGlzdGVuZXJzIHRvIGF2b2lkIGNvbm5lY3Rpb24gc3RhdGUgc2lkZSBlZmZlY3RzIGZyb20gY2FsbGluZyBkaXNwb3NlXG4gICAgICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQub2ZmKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zdGFydENvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIGFkZEV2ZW50TGlzdGVuZXIoJ29mZmxpbmUnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlID09IF90aGlzLnN0YXRlcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlciBjYXVnaHQgYnJvd3NlciDigJhvZmZsaW5l4oCZIGV2ZW50JywgJ2Rpc2Nvbm5lY3RpbmcgYWN0aXZlIHRyYW5zcG9ydCcpO1xuICAgICAgICAgICAgICAgICAgICAvLyBOb3Qgc3VmZmljaWVudCB0byBqdXN0IGdvIHRvIHRoZSAnZGlzY29ubmVjdGVkJyBzdGF0ZSwgd2FudCB0b1xuICAgICAgICAgICAgICAgICAgICAvLyBmb3JjZSBhbGwgdHJhbnNwb3J0cyB0byByZWF0dGVtcHQgdGhlIGNvbm5lY3Rpb24uIFdpbGwgaW1tZWRpYXRlbHlcbiAgICAgICAgICAgICAgICAgICAgLy8gcmV0cnkuXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLmRpc2Nvbm5lY3RBbGxUcmFuc3BvcnRzKCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25uZWN0aW9uTWFuYWdlci5pbml0VHJhbnNwb3J0cyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgKDAsIHdlYnNvY2tldHRyYW5zcG9ydF8xLmRlZmF1bHQpKENvbm5lY3Rpb25NYW5hZ2VyKTtcbiAgICAgICAgVXRpbHMuYXJyRm9yRWFjaChwbGF0Zm9ybV8xLmRlZmF1bHQuVHJhbnNwb3J0cywgZnVuY3Rpb24gKGluaXRGbikge1xuICAgICAgICAgICAgaW5pdEZuKENvbm5lY3Rpb25NYW5hZ2VyKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY3JlYXRlVHJhbnNwb3J0UGFyYW1zID0gZnVuY3Rpb24gKGhvc3QsIG1vZGUpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBUcmFuc3BvcnRQYXJhbXModGhpcy5vcHRpb25zLCBob3N0LCBtb2RlLCB0aGlzLmNvbm5lY3Rpb25LZXkpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFRyYW5zcG9ydFBhcmFtcyA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZGVjaWRlTW9kZSA9IGZ1bmN0aW9uIChtb2RlQ2IpIHtcbiAgICAgICAgICAgIGlmIChfdGhpcy5jb25uZWN0aW9uS2V5KSB7XG4gICAgICAgICAgICAgICAgbW9kZUNiKCdyZXN1bWUnKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAodHlwZW9mIF90aGlzLm9wdGlvbnMucmVjb3ZlciA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgICAgICAgICBtb2RlQ2IoJ3JlY292ZXInKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgcmVjb3ZlckZuID0gX3RoaXMub3B0aW9ucy5yZWNvdmVyLCBsYXN0U2Vzc2lvbkRhdGEgPSBnZXRTZXNzaW9uUmVjb3ZlckRhdGEoKTtcbiAgICAgICAgICAgIGlmIChsYXN0U2Vzc2lvbkRhdGEgJiYgdHlwZW9mIHJlY292ZXJGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuZ2V0VHJhbnNwb3J0UGFyYW1zKCknLCAnQ2FsbGluZyBjbGllbnRPcHRpb25zLXByb3ZpZGVkIHJlY292ZXIgZnVuY3Rpb24gd2l0aCBsYXN0IHNlc3Npb24gZGF0YScpO1xuICAgICAgICAgICAgICAgIHJlY292ZXJGbihsYXN0U2Vzc2lvbkRhdGEsIGZ1bmN0aW9uIChzaG91bGRSZWNvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzaG91bGRSZWNvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vcHRpb25zLnJlY292ZXIgPSBsYXN0U2Vzc2lvbkRhdGEucmVjb3ZlcnlLZXk7XG4gICAgICAgICAgICAgICAgICAgICAgICBtb2RlQ2IoJ3JlY292ZXInKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1vZGVDYignY2xlYW4nKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1vZGVDYignY2xlYW4nKTtcbiAgICAgICAgfTtcbiAgICAgICAgZGVjaWRlTW9kZShmdW5jdGlvbiAobW9kZSkge1xuICAgICAgICAgICAgdmFyIHRyYW5zcG9ydFBhcmFtcyA9IF90aGlzLmNyZWF0ZVRyYW5zcG9ydFBhcmFtcyhudWxsLCBtb2RlKTtcbiAgICAgICAgICAgIGlmIChtb2RlID09PSAncmVjb3ZlcicpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmdldFRyYW5zcG9ydFBhcmFtcygpJywgJ1RyYW5zcG9ydCByZWNvdmVyeSBtb2RlID0gcmVjb3ZlcjsgcmVjb3ZlcnlLZXkgPSAnICsgX3RoaXMub3B0aW9ucy5yZWNvdmVyKTtcbiAgICAgICAgICAgICAgICB2YXIgcmVjb3ZlcnlDb250ZXh0ID0gZGVjb2RlUmVjb3ZlcnlLZXkoX3RoaXMub3B0aW9ucy5yZWNvdmVyKTtcbiAgICAgICAgICAgICAgICBpZiAocmVjb3ZlcnlDb250ZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm1zZ1NlcmlhbCA9IHJlY292ZXJ5Q29udGV4dC5tc2dTZXJpYWw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5nZXRUcmFuc3BvcnRQYXJhbXMoKScsICdUcmFuc3BvcnQgcGFyYW1zID0gJyArIHRyYW5zcG9ydFBhcmFtcy50b1N0cmluZygpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrKHRyYW5zcG9ydFBhcmFtcyk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLyoqXG4gICAgICogQXR0ZW1wdCB0byBjb25uZWN0IHVzaW5nIGEgZ2l2ZW4gdHJhbnNwb3J0XG4gICAgICogQHBhcmFtIHRyYW5zcG9ydFBhcmFtc1xuICAgICAqIEBwYXJhbSBjYW5kaWRhdGUsIHRoZSB0cmFuc3BvcnQgdG8gdHJ5XG4gICAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAgICovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnRyeUFUcmFuc3BvcnQgPSBmdW5jdGlvbiAodHJhbnNwb3J0UGFyYW1zLCBjYW5kaWRhdGUsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIudHJ5QVRyYW5zcG9ydCgpJywgJ3RyeWluZyAnICsgY2FuZGlkYXRlKTtcbiAgICAgICAgdHJhbnNwb3J0XzEuZGVmYXVsdC50cnlDb25uZWN0KENvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHNbY2FuZGlkYXRlXSwgdGhpcywgdGhpcy5yZWFsdGltZS5hdXRoLCB0cmFuc3BvcnRQYXJhbXMsIGZ1bmN0aW9uICh3cmFwcGVkRXJyLCB0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIHZhciBzdGF0ZSA9IF90aGlzLnN0YXRlO1xuICAgICAgICAgICAgaWYgKHN0YXRlID09IF90aGlzLnN0YXRlcy5jbG9zaW5nIHx8IHN0YXRlID09IF90aGlzLnN0YXRlcy5jbG9zZWQgfHwgc3RhdGUgPT0gX3RoaXMuc3RhdGVzLmZhaWxlZCkge1xuICAgICAgICAgICAgICAgIGlmICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci50cnlBVHJhbnNwb3J0KCknLCAnY29ubmVjdGlvbiAnICsgc3RhdGUuc3RhdGUgKyAnIHdoaWxlIHdlIHdlcmUgYXR0ZW1wdGluZyB0aGUgdHJhbnNwb3J0OyBjbG9zaW5nICcgKyB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuY2xvc2UoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHdyYXBwZWRFcnIpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKScsICd0cmFuc3BvcnQgJyArIGNhbmRpZGF0ZSArICcgJyArIHdyYXBwZWRFcnIuZXZlbnQgKyAnLCBlcnI6ICcgKyB3cmFwcGVkRXJyLmVycm9yLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIC8qIENvbWV0IHRyYW5zcG9ydCBvbmNvbm5lY3QgdG9rZW4gZXJyb3JzIGNhbiBiZSBkZWFsdCB3aXRoIGhlcmUuXG4gICAgICAgICAgICAgICAgICogV2Vic29ja2V0IG9uZXMgb25seSBoYXBwZW4gYWZ0ZXIgdGhlIHRyYW5zcG9ydCBjbGFpbXMgdG8gYmUgdmlhYmxlLFxuICAgICAgICAgICAgICAgICAqIHNvIGFyZSBkZWFsdCB3aXRoIGFzIG5vbi1vbmNvbm5lY3QgdG9rZW4gZXJyb3JzICovXG4gICAgICAgICAgICAgICAgaWYgKGF1dGhfMS5kZWZhdWx0LmlzVG9rZW5FcnIod3JhcHBlZEVyci5lcnJvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgIShfdGhpcy5lcnJvclJlYXNvbiAmJiBhdXRoXzEuZGVmYXVsdC5pc1Rva2VuRXJyKF90aGlzLmVycm9yUmVhc29uKSkpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuZXJyb3JSZWFzb24gPSB3cmFwcGVkRXJyLmVycm9yO1xuICAgICAgICAgICAgICAgICAgICAvKiByZS1nZXQgYSB0b2tlbiBhbmQgdHJ5IGFnYWluICovXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLnJlYWx0aW1lLmF1dGguX2ZvcmNlTmV3VG9rZW4obnVsbCwgbnVsbCwgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKGVycik7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudHJ5QVRyYW5zcG9ydCh0cmFuc3BvcnRQYXJhbXMsIGNhbmRpZGF0ZSwgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAod3JhcHBlZEVyci5ldmVudCA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogRXJyb3IgdGhhdCdzIGZhdGFsIHRvIHRoZSBjb25uZWN0aW9uICovXG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6ICdmYWlsZWQnLCBlcnJvcjogd3JhcHBlZEVyci5lcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sodHJ1ZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKHdyYXBwZWRFcnIuZXZlbnQgPT09ICdkaXNjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmICghKDAsIGNvbm5lY3Rpb25lcnJvcnNfMS5pc1JldHJpYWJsZSkod3JhcHBlZEVyci5lcnJvcikpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC8qIEVycm9yIHJlY2VpdmVkIGZyb20gdGhlIHNlcnZlciB0aGF0IGRvZXMgbm90IGNhbGwgZm9yIHRyeWluZyBhIGZhbGxiYWNrIGhvc3QsIGVnIGEgcmF0ZSBsaW1pdCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogX3RoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlLCBlcnJvcjogd3JhcHBlZEVyci5lcnJvciB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgLyogRXJyb3Igd2l0aCB0aGF0IHRyYW5zcG9ydCBvbmx5OyBjb250aW51ZSB0cnlpbmcgb3RoZXIgZmFsbGJhY2sgaG9zdHMgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGZhbHNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnRyeUFUcmFuc3BvcnQoKScsICd2aWFibGUgdHJhbnNwb3J0ICcgKyBjYW5kaWRhdGUgKyAnOyBzZXR0aW5nIHBlbmRpbmcnKTtcbiAgICAgICAgICAgIF90aGlzLnNldFRyYW5zcG9ydFBlbmRpbmcodHJhbnNwb3J0LCB0cmFuc3BvcnRQYXJhbXMpO1xuICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdHJhbnNwb3J0KTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBpcyBpbmRpY2F0ZWQgdG8gYmUgdmlhYmxlLCBhbmQgdGhlIENvbm5lY3Rpb25NYW5hZ2VyXG4gICAgICogZXhwZWN0cyB0byBhY3RpdmF0ZSB0aGlzIHRyYW5zcG9ydCBhcyBzb29uIGFzIGl0IGlzIGNvbm5lY3RlZC5cbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0XG4gICAgICogQHBhcmFtIHRyYW5zcG9ydFBhcmFtc1xuICAgICAqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZXRUcmFuc3BvcnRQZW5kaW5nID0gZnVuY3Rpb24gKHRyYW5zcG9ydCwgdHJhbnNwb3J0UGFyYW1zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBtb2RlID0gdHJhbnNwb3J0UGFyYW1zLm1vZGU7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2V0VHJhbnNwb3J0UGVuZGluZygpJywgJ3RyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQgKyAnOyBtb2RlID0gJyArIG1vZGUpO1xuICAgICAgICBVdGlscy5hcnJEZWxldGVWYWx1ZSh0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cywgdHJhbnNwb3J0KTtcbiAgICAgICAgdGhpcy5wZW5kaW5nVHJhbnNwb3J0cy5wdXNoKHRyYW5zcG9ydCk7XG4gICAgICAgIHZhciBvcHRpbWFsVHJhbnNwb3J0ID0gcGxhdGZvcm1fMS5kZWZhdWx0LkRlZmF1bHRzLnRyYW5zcG9ydFByZWZlcmVuY2VPcmRlcltwbGF0Zm9ybV8xLmRlZmF1bHQuRGVmYXVsdHMudHJhbnNwb3J0UHJlZmVyZW5jZU9yZGVyLmxlbmd0aCAtIDFdO1xuICAgICAgICB0cmFuc3BvcnQub25jZSgnY29ubmVjdGVkJywgZnVuY3Rpb24gKGVycm9yLCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKSB7XG4gICAgICAgICAgICBpZiAobW9kZSA9PSAndXBncmFkZScgJiYgX3RoaXMuYWN0aXZlUHJvdG9jb2wpIHtcbiAgICAgICAgICAgICAgICAvKiAgaWYgd3MgYW5kIHhocnMgYXJlIGNvbm5lY3RpbmcgaW4gcGFyYWxsZWwsIGRlbGF5IHhocnMgYWN0aXZhdGlvbiB0byBsZXQgd3MgZ28gYWhlYWQgKi9cbiAgICAgICAgICAgICAgICBpZiAodHJhbnNwb3J0LnNob3J0TmFtZSAhPT0gb3B0aW1hbFRyYW5zcG9ydCAmJlxuICAgICAgICAgICAgICAgICAgICBVdGlscy5hcnJJbihfdGhpcy5nZXRVcGdyYWRlUG9zc2liaWxpdGllcygpLCBvcHRpbWFsVHJhbnNwb3J0KSAmJlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY3RpdmVQcm90b2NvbCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbihlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKTtcbiAgICAgICAgICAgICAgICAgICAgfSwgX3RoaXMub3B0aW9ucy50aW1lb3V0cy5wYXJhbGxlbFVwZ3JhZGVEZWxheSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuYWN0aXZhdGVUcmFuc3BvcnQoZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscyk7XG4gICAgICAgICAgICAgICAgLyogYWxsb3cgY29ubmVjdEltcGwgdG8gc3RhcnQgdGhlIHVwZ3JhZGUgcHJvY2VzcyBpZiBuZWVkZWQsIGJ1dCBhbGxvd1xuICAgICAgICAgICAgICAgICAqIG90aGVyIGV2ZW50IGhhbmRsZXJzLCBpbmNsdWRpbmcgYWN0aXZhdGluZyB0aGUgdHJhbnNwb3J0LCB0byBydW4gZmlyc3QgKi9cbiAgICAgICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMuY29ubmVjdEltcGwodHJhbnNwb3J0UGFyYW1zKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtb2RlID09PSAncmVjb3ZlcicgJiYgX3RoaXMub3B0aW9ucy5yZWNvdmVyKSB7XG4gICAgICAgICAgICAgICAgLyogQWZ0ZXIgYSBzdWNjZXNzZnVsIHJlY292ZXJ5LCB3ZSB1bnBlcnNpc3QsIGFzIGEgcmVjb3Zlcnkga2V5IGNhbm5vdFxuICAgICAgICAgICAgICAgICAqIGJlIHVzZWQgbW9yZSB0aGFuIG9uY2UgKi9cbiAgICAgICAgICAgICAgICBfdGhpcy5vcHRpb25zLnJlY292ZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIF90aGlzLnVucGVyc2lzdENvbm5lY3Rpb24oKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcztcbiAgICAgICAgdHJhbnNwb3J0Lm9uKFsnZGlzY29ubmVjdGVkJywgJ2Nsb3NlZCcsICdmYWlsZWQnXSwgZnVuY3Rpb24gKGVycm9yKSB7XG4gICAgICAgICAgICBzZWxmLmRlYWN0aXZhdGVUcmFuc3BvcnQodHJhbnNwb3J0LCB0aGlzLmV2ZW50LCBlcnJvcik7XG4gICAgICAgIH0pO1xuICAgICAgICB0aGlzLmVtaXQoJ3RyYW5zcG9ydC5wZW5kaW5nJywgdHJhbnNwb3J0KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGFuIHVwZ3JhZGUgdHJhbnNwb3J0IGlzIGNvbm5lY3RlZCxcbiAgICAgKiB0byBzY2hlZHVsZSB0aGUgYWN0aXZhdGlvbiBvZiB0aGF0IHRyYW5zcG9ydC5cbiAgICAgKiBAcGFyYW0gZXJyb3JcbiAgICAgKiBAcGFyYW0gdHJhbnNwb3J0XG4gICAgICogQHBhcmFtIGNvbm5lY3Rpb25JZFxuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uRGV0YWlsc1xuICAgICAqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24gPSBmdW5jdGlvbiAoZXJyb3IsIHRyYW5zcG9ydCwgY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgY3VycmVudFRyYW5zcG9ydCA9IHRoaXMuYWN0aXZlUHJvdG9jb2wgJiYgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSwgYWJhbmRvbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBVdGlscy5hcnJEZWxldGVWYWx1ZShfdGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KTtcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RlZCAmJiB0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlcy5jb25uZWN0aW5nKSB7XG4gICAgICAgICAgICAvKiBUaGlzIGlzIG1vc3QgbGlrZWx5IHRvIGhhcHBlbiBmb3IgdGhlIGRlbGF5ZWQgWEhScywgd2hlbiBYSFJzIGFuZCB3cyBhcmUgc2NoZWR1bGVkIGluIHBhcmFsbGVsKi9cbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnQ3VycmVudCBjb25uZWN0aW9uIHN0YXRlICgnICtcbiAgICAgICAgICAgICAgICB0aGlzLnN0YXRlLnN0YXRlICtcbiAgICAgICAgICAgICAgICAodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuc3luY2hyb25pemluZyA/ICcsIGJ1dCB3aXRoIGFuIHVwZ3JhZGUgYWxyZWFkeSBpbiBwcm9ncmVzcycgOiAnJykgK1xuICAgICAgICAgICAgICAgICcpIGlzIG5vdCB2YWxpZCB0byB1cGdyYWRlIGluOyBhYmFuZG9uaW5nIHVwZ3JhZGUgdG8gJyArXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNob3J0TmFtZSk7XG4gICAgICAgICAgICBhYmFuZG9uKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGN1cnJlbnRUcmFuc3BvcnQgJiYgIWJldHRlclRyYW5zcG9ydFRoYW4odHJhbnNwb3J0LCBjdXJyZW50VHJhbnNwb3J0KSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdQcm9wb3NlZCB0cmFuc3BvcnQgJyArXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNob3J0TmFtZSArXG4gICAgICAgICAgICAgICAgJyBpcyBubyBiZXR0ZXIgdGhhbiBjdXJyZW50IGFjdGl2ZSB0cmFuc3BvcnQgJyArXG4gICAgICAgICAgICAgICAgY3VycmVudFRyYW5zcG9ydC5zaG9ydE5hbWUgK1xuICAgICAgICAgICAgICAgICcgLSBhYmFuZG9uaW5nIHVwZ3JhZGUnKTtcbiAgICAgICAgICAgIGFiYW5kb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1NjaGVkdWxpbmcgdHJhbnNwb3J0IHVwZ3JhZGU7IHRyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xuICAgICAgICB2YXIgb2xkUHJvdG9jb2wgPSBudWxsO1xuICAgICAgICBpZiAoIXRyYW5zcG9ydC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgLyogVGhpcyBpcyBvbmx5IHBvc3NpYmxlIGlmIHRoZSB4aHIgc3RyZWFtaW5nIHRyYW5zcG9ydCB3YXMgZGlzY29ubmVjdGVkIGR1cmluZyB0aGUgcGFyYWxsZWxVcGdyYWRlRGVsYXkgKi9cbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnUHJvcG9zZWQgdHJhbnNwb3J0ICcgKyB0cmFuc3BvcnQuc2hvcnROYW1lICsgJ2lzIG5vIGxvbmdlciBjb25uZWN0ZWQ7IGFiYW5kb25pbmcgdXBncmFkZScpO1xuICAgICAgICAgICAgYWJhbmRvbigpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnQ3VycmVudGx5IGNvbm5lY3RlZCwgc28gdGVtcG9yYXJpbHkgcGF1c2luZyBldmVudHMgdW50aWwgdGhlIHVwZ3JhZGUgaXMgY29tcGxldGUnKTtcbiAgICAgICAgICAgIHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nO1xuICAgICAgICAgICAgb2xkUHJvdG9jb2wgPSB0aGlzLmFjdGl2ZVByb3RvY29sO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgIC8qIE5vdGU6IHVwZ3JhZGluZyBmcm9tIHRoZSBjb25uZWN0aW5nIHN0YXRlIGlzIHZhbGlkIGlmIHRoZSBvbGQgYWN0aXZlXG4gICAgICAgICAgICAgKiB0cmFuc3BvcnQgd2FzIGRlYWN0aXZhdGVkIGFmdGVyIHRoZSB1cGdyYWRlIHRyYW5zcG9ydCBmaXJzdCBjb25uZWN0ZWQ7XG4gICAgICAgICAgICAgKiBzZWUgbG9naWMgaW4gZGVhY3RpdmF0ZVRyYW5zcG9ydCAqL1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdDdXJyZW50IGNvbm5lY3Rpb24gc3RhdGUgKCcgK1xuICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUuc3RhdGUgK1xuICAgICAgICAgICAgICAgICh0aGlzLnN0YXRlID09PSB0aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nID8gJywgYnV0IHdpdGggYW4gdXBncmFkZSBhbHJlYWR5IGluIHByb2dyZXNzJyA6ICcnKSArXG4gICAgICAgICAgICAgICAgJykgaXMgbm90IHZhbGlkIHRvIHVwZ3JhZGUgaW47IGFiYW5kb25pbmcgdXBncmFkZSB0byAnICtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc2hvcnROYW1lKTtcbiAgICAgICAgICAgIGFiYW5kb24oKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ1N5bmNpbmcgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgdmFyIGZpbmlzaFVwZ3JhZGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNjaGVkdWxlVHJhbnNwb3J0QWN0aXZhdGlvbigpJywgJ0FjdGl2YXRpbmcgdHJhbnNwb3J0OyB0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIC8vIFNlbmQgQUNUSVZBVEUgdG8gdGVsbCB0aGUgc2VydmVyIHRvIG1ha2UgdGhpcyB0cmFuc3BvcnQgdGhlXG4gICAgICAgICAgICAvLyBhY3RpdmUgdHJhbnNwb3J0LCB3aGljaCBzdXNwZW5kcyBjaGFubmVscyB1bnRpbCB3ZSByZS1hdHRhY2guXG4gICAgICAgICAgICB0cmFuc3BvcnQuc2VuZChwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9ucy5BQ1RJVkFURSxcbiAgICAgICAgICAgIH0pKTtcbiAgICAgICAgICAgIF90aGlzLmFjdGl2YXRlVHJhbnNwb3J0KGVycm9yLCB0cmFuc3BvcnQsIGNvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMpO1xuICAgICAgICAgICAgLyogUmVzdG9yZSBwcmUtc3luYyBzdGF0ZS4gSWYgc3RhdGUgaGFzIGNoYW5nZWQgaW4gdGhlIG1lYW50aW1lLFxuICAgICAgICAgICAgICogZG9uJ3QgdG91Y2ggaXQgLS0gc2luY2UgdGhlIHdlYnNvY2tldCB0cmFuc3BvcnQgd2FpdHMgYSB0aWNrIGJlZm9yZVxuICAgICAgICAgICAgICogZGlzcG9zaW5nIGl0c2VsZiwgaXQncyBwb3NzaWJsZSBmb3IgaXQgdG8gaGF2ZSBoYXBwaWx5IHN5bmNlZFxuICAgICAgICAgICAgICogd2l0aG91dCBlcnIgd2hpbGUsIHVua25vd24gdG8gaXQsIHRoZSBjb25uZWN0aW9uIGhhcyBjbG9zZWQgaW4gdGhlXG4gICAgICAgICAgICAgKiBtZWFudGltZSBhbmQgdGhlIHdzIHRyYW5zcG9ydCBpcyBzY2hlZHVsZWQgZm9yIGRlYXRoICovXG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUgPT09IF90aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zY2hlZHVsZVRyYW5zcG9ydEFjdGl2YXRpb24oKScsICdQcmUtdXBncmFkZSBwcm90b2NvbCBpZGxlLCBzZW5kaW5nIHF1ZXVlZCBtZXNzYWdlcyBvbiB1cGdyYWRlZCB0cmFuc3BvcnQ7IHRyYW5zcG9ydCA9ICcgKyB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlID0gX3RoaXMuc3RhdGVzLmNvbm5lY3RlZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2NoZWR1bGVUcmFuc3BvcnRBY3RpdmF0aW9uKCknLCAnUHJlLXVwZ3JhZGUgcHJvdG9jb2wgaWRsZSwgYnV0IHN0YXRlIGlzIG5vdyAnICsgX3RoaXMuc3RhdGUuc3RhdGUgKyAnLCBzbyBsZWF2aW5nIHVuY2hhbmdlZCcpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF90aGlzLnN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5zZW5kUXVldWVkTWVzc2FnZXMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgLyogV2FpdCB1bnRpbCBzeW5jIGlzIGRvbmUgYW5kIG9sZCB0cmFuc3BvcnQgaXMgaWRsZSBiZWZvcmUgYWN0aXZhdGluZyBuZXcgdHJhbnNwb3J0LiBUaGlzXG4gICAgICAgICAqIGd1YXJhbnRlZXMgdGhhdCBtZXNzYWdlcyBhcnJpdmUgYXQgcmVhbHRpbWUgaW4gdGhlIHNhbWUgb3JkZXIgdGhleSBhcmUgc2VudC5cbiAgICAgICAgICpcbiAgICAgICAgICogSWYgYSBtZXNzYWdlIHRpbWVzIG91dCBvbiB0aGUgb2xkIHRyYW5zcG9ydCwgc2luY2UgaXQncyBzdGlsbCB0aGUgYWN0aXZlIHRyYW5zcG9ydCB0aGVcbiAgICAgICAgICogbWVzc2FnZSB3aWxsIGJlIHJlcXVldWVkLiBkZWFjdGl2YXRlVHJhbnNwb3J0IHdpbGwgc2VlIHRoZSBwZW5kaW5nIHRyYW5zcG9ydCBhbmQgbm90aWZ5XG4gICAgICAgICAqIHRoZSBgY29ubmVjdGluZ2Agc3RhdGUgd2l0aG91dCBzdGFydGluZyBhIG5ldyBjb25uZWN0aW9uLCBzbyB0aGUgbmV3IHRyYW5zcG9ydCBjYW4gdGFrZVxuICAgICAgICAgKiBvdmVyIG9uY2UgZGVhY3RpdmF0ZVRyYW5zcG9ydCBjbGVhcnMgdGhlIG9sZCBwcm90b2NvbCdzIHF1ZXVlLlxuICAgICAgICAgKlxuICAgICAgICAgKiBJZiB0aGVyZSBpcyBubyBvbGQgcHJvdG9jb2wsIHRoYXQgbWVhbnQgdGhhdCB3ZSB3ZXJlbid0IGluIHRoZSBjb25uZWN0ZWQgc3RhdGUgYXQgdGhlXG4gICAgICAgICAqIGJlZ2lubmluZyBvZiB0aGUgc3luYyAtIGxpa2VseSB0aGUgYmFzZSB0cmFuc3BvcnQgZGllZCBqdXN0IGJlZm9yZSB0aGUgc3luYy4gU28gY2FuIGp1c3RcbiAgICAgICAgICogZmluaXNoIHRoZSB1cGdyYWRlLiBJZiB3ZSdyZSBhY3R1YWxseSBpbiBjbG9zaW5nL2ZhaWxlZCByYXRoZXIgdGhhbiBjb25uZWN0aW5nLCB0aGF0J3NcbiAgICAgICAgICogZmluZSwgYWN0aXZhdGV0cmFuc3BvcnQgd2lsbCBkZWFsIHdpdGggdGhhdC4gKi9cbiAgICAgICAgaWYgKG9sZFByb3RvY29sKSB7XG4gICAgICAgICAgICAvKiBNb3N0IG9mIHRoZSB0aW1lIHRoaXMgd2lsbCBiZSBhbHJlYWR5IHRydWU6IHRoZSBuZXctdHJhbnNwb3J0IHN5bmMgd2lsbCBoYXZlIGdpdmVuXG4gICAgICAgICAgICAgKiBlbm91Z2ggdGltZSBmb3IgaW4tZmxpZ2h0IG1lc3NhZ2VzIG9uIHRoZSBvbGQgdHJhbnNwb3J0IHRvIGNvbXBsZXRlLiAqL1xuICAgICAgICAgICAgb2xkUHJvdG9jb2wub25jZUlkbGUoZmluaXNoVXBncmFkZSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBmaW5pc2hVcGdyYWRlKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIGEgdHJhbnNwb3J0IGlzIGNvbm5lY3RlZCwgYW5kIHRoZSBjb25uZWN0aW9ubWFuYWdlciBkZWNpZGVzIHRoYXRcbiAgICAgKiBpdCB3aWxsIG5vdyBiZSB0aGUgYWN0aXZlIHRyYW5zcG9ydC4gUmV0dXJucyB3aGV0aGVyIG9yIG5vdCBpdCBhY3RpdmF0ZWRcbiAgICAgKiB0aGUgdHJhbnNwb3J0IChpZiB0aGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nL2Nsb3NlZCBpdCB3aWxsIGNob29zZSBub3QgdG8pLlxuICAgICAqIEBwYXJhbSB0cmFuc3BvcnQgdGhlIHRyYW5zcG9ydCBpbnN0YW5jZVxuICAgICAqIEBwYXJhbSBjb25uZWN0aW9uSWQgdGhlIGlkIG9mIHRoZSBuZXcgYWN0aXZlIGNvbm5lY3Rpb25cbiAgICAgKiBAcGFyYW0gY29ubmVjdGlvbkRldGFpbHMgdGhlIGRldGFpbHMgb2YgdGhlIG5ldyBhY3RpdmUgY29ubmVjdGlvblxuICAgICAqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5hY3RpdmF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uIChlcnJvciwgdHJhbnNwb3J0LCBjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICd0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgaWYgKGVycm9yKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnZXJyb3IgPSAnICsgZXJyb3IpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb25uZWN0aW9uSWQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuYWN0aXZhdGVUcmFuc3BvcnQoKScsICdjb25uZWN0aW9uSWQgPSAgJyArIGNvbm5lY3Rpb25JZCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGNvbm5lY3Rpb25EZXRhaWxzKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnY29ubmVjdGlvbkRldGFpbHMgPSAgJyArIEpTT04uc3RyaW5naWZ5KGNvbm5lY3Rpb25EZXRhaWxzKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSh0cmFuc3BvcnQpO1xuICAgICAgICAvKiBpZiB0aGUgY29ubmVjdGlvbm1hbmFnZXIgbW92ZWQgdG8gdGhlIGNsb3NpbmcvY2xvc2VkIHN0YXRlIGJlZm9yZSB0aGlzXG4gICAgICAgICAqIGNvbm5lY3Rpb24gZXZlbnQsIHRoZW4gd2Ugd29uJ3QgYWN0aXZhdGUgdGhpcyB0cmFuc3BvcnQgKi9cbiAgICAgICAgdmFyIGV4aXN0aW5nU3RhdGUgPSB0aGlzLnN0YXRlLCBjb25uZWN0ZWRTdGF0ZSA9IHRoaXMuc3RhdGVzLmNvbm5lY3RlZC5zdGF0ZTtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ2N1cnJlbnQgc3RhdGUgPSAnICsgZXhpc3RpbmdTdGF0ZS5zdGF0ZSk7XG4gICAgICAgIGlmIChleGlzdGluZ1N0YXRlLnN0YXRlID09IHRoaXMuc3RhdGVzLmNsb3Npbmcuc3RhdGUgfHxcbiAgICAgICAgICAgIGV4aXN0aW5nU3RhdGUuc3RhdGUgPT0gdGhpcy5zdGF0ZXMuY2xvc2VkLnN0YXRlIHx8XG4gICAgICAgICAgICBleGlzdGluZ1N0YXRlLnN0YXRlID09IHRoaXMuc3RhdGVzLmZhaWxlZC5zdGF0ZSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ0Rpc2Nvbm5lY3RpbmcgdHJhbnNwb3J0IGFuZCBhYmFuZG9uaW5nJyk7XG4gICAgICAgICAgICB0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qIHJlbW92ZSB0aGlzIHRyYW5zcG9ydCBmcm9tIHBlbmRpbmcgdHJhbnNwb3J0cyAqL1xuICAgICAgICBVdGlscy5hcnJEZWxldGVWYWx1ZSh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xuICAgICAgICAvKiBpZiB0aGUgdHJhbnNwb3J0IGlzIG5vdCBjb25uZWN0ZWQgdGhlbiBkb24ndCBhY3RpdmF0ZSBpdCAqL1xuICAgICAgICBpZiAoIXRyYW5zcG9ydC5pc0Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ0RlY2xpbmluZyB0byBhY3RpdmF0ZSB0cmFuc3BvcnQgJyArIHRyYW5zcG9ydCArICcgc2luY2UgaXQgYXBwZWFycyB0byBubyBsb25nZXIgYmUgY29ubmVjdGVkJyk7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgLyogdGhlIGdpdmVuIHRyYW5zcG9ydCBpcyBjb25uZWN0ZWQ7IHRoaXMgd2lsbCBpbW1lZGlhdGVseVxuICAgICAgICAgKiB0YWtlIG92ZXIgYXMgdGhlIGFjdGl2ZSB0cmFuc3BvcnQgKi9cbiAgICAgICAgdmFyIGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wgPSB0aGlzLmFjdGl2ZVByb3RvY29sO1xuICAgICAgICB0aGlzLmFjdGl2ZVByb3RvY29sID0gbmV3IHByb3RvY29sXzEuZGVmYXVsdCh0cmFuc3BvcnQpO1xuICAgICAgICB0aGlzLmhvc3QgPSB0cmFuc3BvcnQucGFyYW1zLmhvc3Q7XG4gICAgICAgIHZhciBjb25uZWN0aW9uS2V5ID0gY29ubmVjdGlvbkRldGFpbHMuY29ubmVjdGlvbktleTtcbiAgICAgICAgaWYgKGNvbm5lY3Rpb25LZXkgJiYgdGhpcy5jb25uZWN0aW9uS2V5ICE9IGNvbm5lY3Rpb25LZXkpIHtcbiAgICAgICAgICAgIHRoaXMuc2V0Q29ubmVjdGlvbihjb25uZWN0aW9uSWQsIGNvbm5lY3Rpb25EZXRhaWxzLCAhIWVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICAvKiBSZWJyb2FkY2FzdCBhbnkgbmV3IGNvbm5lY3Rpb25EZXRhaWxzIGZyb20gdGhlIGFjdGl2ZSB0cmFuc3BvcnQsIHdoaWNoXG4gICAgICAgICAqIGNhbiBjb21lIGF0IGFueSB0aW1lIChlZyBmb2xsb3dpbmcgYSByZWF1dGgpLCBhbmQgZW1pdCBhbiBSVE4yNCBVUERBVEVcbiAgICAgICAgICogZXZlbnQuIChMaXN0ZW5lciBhZGRlZCBvbiBuZXh0VGljayBiZWNhdXNlIHdlJ3JlIGluIGEgdHJhbnNwb3J0Lm9uKCdjb25uZWN0ZWQnKVxuICAgICAgICAgKiBjYWxsYmFjayBhdCB0aGUgbW9tZW50OyBpZiB3ZSBhZGQgaXQgbm93IHdlJ2xsIGJlIGFkZGluZyBpdCB0byB0aGUgZW5kXG4gICAgICAgICAqIG9mIHRoZSBsaXN0ZW5lcnMgYXJyYXkgYW5kIGl0J2xsIGJlIGNhbGxlZCBpbW1lZGlhdGVseSkgKi9cbiAgICAgICAgdGhpcy5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpO1xuICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHRyYW5zcG9ydC5vbignY29ubmVjdGVkJywgZnVuY3Rpb24gKGNvbm5lY3RlZEVyciwgX2Nvbm5lY3Rpb25JZCwgY29ubmVjdGlvbkRldGFpbHMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vbkNvbm5lY3Rpb25EZXRhaWxzVXBkYXRlKGNvbm5lY3Rpb25EZXRhaWxzLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3VwZGF0ZScsIG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfMS5kZWZhdWx0KGNvbm5lY3RlZFN0YXRlLCBjb25uZWN0ZWRTdGF0ZSwgbnVsbCwgY29ubmVjdGVkRXJyKSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIC8qIElmIHByZXZpb3VzbHkgbm90IGNvbm5lY3RlZCwgbm90aWZ5IHRoZSBzdGF0ZSBjaGFuZ2UgKGluY2x1ZGluZyBhbnlcbiAgICAgICAgICogZXJyb3IpLiAqL1xuICAgICAgICBpZiAoZXhpc3RpbmdTdGF0ZS5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlKSB7XG4gICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAvKiBpZiB1cGdyYWRpbmcgd2l0aG91dCBlcnJvciwgbGVhdmUgYW55IGV4aXN0aW5nIGVycm9yUmVhc29uIGFsb25lICovXG4gICAgICAgICAgICAgICAgdGhpcy5lcnJvclJlYXNvbiA9IHRoaXMucmVhbHRpbWUuY29ubmVjdGlvbi5lcnJvclJlYXNvbiA9IGVycm9yO1xuICAgICAgICAgICAgICAgIC8qIE9ubHkgYm90aGVyIGVtaXR0aW5nIGFuIHVwZ3JhZGUgaWYgdGhlcmUncyBhbiBlcnJvcjsgb3RoZXJ3aXNlIGl0J3NcbiAgICAgICAgICAgICAgICAgKiBqdXN0IGEgdHJhbnNwb3J0IHVwZ3JhZGUsIHNvIGF1dGggZGV0YWlscyB3b24ndCBoYXZlIGNoYW5nZWQgKi9cbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfMS5kZWZhdWx0KGNvbm5lY3RlZFN0YXRlLCBjb25uZWN0ZWRTdGF0ZSwgbnVsbCwgZXJyb3IpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogJ2Nvbm5lY3RlZCcsIGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JSZWFzb24gPSB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uZXJyb3JSZWFzb24gPSBlcnJvciB8fCBudWxsO1xuICAgICAgICB9XG4gICAgICAgIC8qIFNlbmQgYWZ0ZXIgdGhlIGNvbm5lY3Rpb24gc3RhdGUgdXBkYXRlLCBhcyBDaGFubmVscyBob29rcyBpbnRvIHRoaXMgdG9cbiAgICAgICAgICogcmVzZW5kIGF0dGFjaGVzIG9uIGEgbmV3IHRyYW5zcG9ydCBpZiBuZWNlc3NhcnkgKi9cbiAgICAgICAgdGhpcy5lbWl0KCd0cmFuc3BvcnQuYWN0aXZlJywgdHJhbnNwb3J0KTtcbiAgICAgICAgLyogR3JhY2VmdWxseSB0ZXJtaW5hdGUgZXhpc3RpbmcgcHJvdG9jb2wgKi9cbiAgICAgICAgaWYgKGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wpIHtcbiAgICAgICAgICAgIGlmIChleGlzdGluZ0FjdGl2ZVByb3RvY29sLm1lc3NhZ2VRdWV1ZS5jb3VudCgpID4gMCkge1xuICAgICAgICAgICAgICAgIC8qIFdlIGNvdWxkIGp1c3QgcmVxdWV1ZSBwZW5kaW5nIG1lc3NhZ2VzIG9uIHRoZSBuZXcgdHJhbnNwb3J0LCBidXRcbiAgICAgICAgICAgICAgICAgKiBhY3R1YWxseSB0aGlzIHNob3VsZCBuZXZlciBoYXBwZW46IHRyYW5zcG9ydHMgc2hvdWxkIG9ubHkgdGFrZSBvdmVyXG4gICAgICAgICAgICAgICAgICogZnJvbSBvdGhlciBhY3RpdmUgdHJhbnNwb3J0cyB3aGVuIHVwZ3JhZGluZywgYW5kIHVwZ3JhZGluZyB3YWl0cyBmb3JcbiAgICAgICAgICAgICAgICAgKiB0aGUgb2xkIHRyYW5zcG9ydCB0byBiZSBpZGxlLiBTbyBsb2cgYW4gZXJyb3IuICovXG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgJ1ByZXZpb3VzIGFjdGl2ZSBwcm90b2NvbCAoZm9yIHRyYW5zcG9ydCAnICtcbiAgICAgICAgICAgICAgICAgICAgZXhpc3RpbmdBY3RpdmVQcm90b2NvbC50cmFuc3BvcnQuc2hvcnROYW1lICtcbiAgICAgICAgICAgICAgICAgICAgJywgbmV3IG9uZSBpcyAnICtcbiAgICAgICAgICAgICAgICAgICAgdHJhbnNwb3J0LnNob3J0TmFtZSArXG4gICAgICAgICAgICAgICAgICAgICcpIGZpbmlzaGluZyB3aXRoICcgK1xuICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0FjdGl2ZVByb3RvY29sLm1lc3NhZ2VRdWV1ZS5jb3VudCgpICtcbiAgICAgICAgICAgICAgICAgICAgJyBtZXNzYWdlcyBzdGlsbCBwZW5kaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoZXhpc3RpbmdBY3RpdmVQcm90b2NvbC50cmFuc3BvcnQgPT09IHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnQXNzdW1wdGlvbiB2aW9sYXRlZDogYWN0aXZhdGluZyBhIHRyYW5zcG9ydCB0aGF0IHdhcyBhbHNvIHRoZSB0cmFuc3BvcnQgZm9yIHRoZSBwcmV2aW91cyBhY3RpdmUgcHJvdG9jb2w7IHRyYW5zcG9ydCA9ICcgK1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc2hvcnROYW1lICtcbiAgICAgICAgICAgICAgICAgICAgJzsgc3RhY2sgPSAnICtcbiAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgbXNnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGV4aXN0aW5nQWN0aXZlUHJvdG9jb2wuZmluaXNoKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgLyogVGVybWluYXRlIGFueSBvdGhlciBwZW5kaW5nIHRyYW5zcG9ydChzKSwgYW5kXG4gICAgICAgICAqIGFib3J0IGFueSBub3QteWV0LXBlbmRpbmcgdHJhbnNwb3J0IGF0dGVtcHRzICovXG4gICAgICAgIFV0aWxzLnNhZmVBcnJGb3JFYWNoKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIGZ1bmN0aW9uIChwZW5kaW5nVHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBpZiAocGVuZGluZ1RyYW5zcG9ydCA9PT0gdHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9ICdBc3N1bXB0aW9uIHZpb2xhdGVkOiBhY3RpdmF0aW5nIGEgdHJhbnNwb3J0IHRoYXQgaXMgc3RpbGwgbWFya2VkIGFzIGEgcGVuZGluZyB0cmFuc3BvcnQ7IHRyYW5zcG9ydCA9ICcgK1xuICAgICAgICAgICAgICAgICAgICB0cmFuc3BvcnQuc2hvcnROYW1lICtcbiAgICAgICAgICAgICAgICAgICAgJzsgc3RhY2sgPSAnICtcbiAgICAgICAgICAgICAgICAgICAgbmV3IEVycm9yKCkuc3RhY2s7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RpdmF0ZVRyYW5zcG9ydCgpJywgbXNnKTtcbiAgICAgICAgICAgICAgICBVdGlscy5hcnJEZWxldGVWYWx1ZShfdGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHBlbmRpbmdUcmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgVXRpbHMuc2FmZUFyckZvckVhY2godGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMsIGZ1bmN0aW9uIChwcm9wb3NlZFRyYW5zcG9ydCkge1xuICAgICAgICAgICAgaWYgKHByb3Bvc2VkVHJhbnNwb3J0ID09PSB0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2YXRlVHJhbnNwb3J0KCknLCAnQXNzdW1wdGlvbiB2aW9sYXRlZDogYWN0aXZhdGluZyBhIHRyYW5zcG9ydCB0aGF0IGlzIHN0aWxsIG1hcmtlZCBhcyBhIHByb3Bvc2VkIHRyYW5zcG9ydDsgdHJhbnNwb3J0ID0gJyArXG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5zaG9ydE5hbWUgK1xuICAgICAgICAgICAgICAgICAgICAnOyBzdGFjayA9ICcgK1xuICAgICAgICAgICAgICAgICAgICBuZXcgRXJyb3IoKS5zdGFjayk7XG4gICAgICAgICAgICAgICAgVXRpbHMuYXJyRGVsZXRlVmFsdWUoX3RoaXMucHJvcG9zZWRUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcHJvcG9zZWRUcmFuc3BvcnQuZGlzcG9zZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICAvKipcbiAgICAgKiBDYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBpcyBubyBsb25nZXIgdGhlIGFjdGl2ZSB0cmFuc3BvcnQuIFRoaXMgY2FuIG9jY3VyXG4gICAgICogaW4gYW55IHRyYW5zcG9ydCBjb25uZWN0aW9uIHN0YXRlLlxuICAgICAqIEBwYXJhbSB0cmFuc3BvcnRcbiAgICAgKi9cbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZGVhY3RpdmF0ZVRyYW5zcG9ydCA9IGZ1bmN0aW9uICh0cmFuc3BvcnQsIHN0YXRlLCBlcnJvcikge1xuICAgICAgICB2YXIgY3VycmVudFByb3RvY29sID0gdGhpcy5hY3RpdmVQcm90b2NvbCwgd2FzQWN0aXZlID0gY3VycmVudFByb3RvY29sICYmIGN1cnJlbnRQcm90b2NvbC5nZXRUcmFuc3BvcnQoKSA9PT0gdHJhbnNwb3J0LCB3YXNQZW5kaW5nID0gVXRpbHMuYXJyRGVsZXRlVmFsdWUodGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgdHJhbnNwb3J0KSwgd2FzUHJvcG9zZWQgPSBVdGlscy5hcnJEZWxldGVWYWx1ZSh0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cywgdHJhbnNwb3J0KSwgbm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbiA9IHRoaXMubm9UcmFuc3BvcnRzU2NoZWR1bGVkRm9yQWN0aXZhdGlvbigpO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKScsICd0cmFuc3BvcnQgPSAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5kZWFjdGl2YXRlVHJhbnNwb3J0KCknLCAnc3RhdGUgPSAnICtcbiAgICAgICAgICAgIHN0YXRlICtcbiAgICAgICAgICAgICh3YXNBY3RpdmUgPyAnOyB3YXMgYWN0aXZlJyA6IHdhc1BlbmRpbmcgPyAnOyB3YXMgcGVuZGluZycgOiB3YXNQcm9wb3NlZCA/ICc7IHdhcyBwcm9wb3NlZCcgOiAnJykgK1xuICAgICAgICAgICAgKG5vVHJhbnNwb3J0c1NjaGVkdWxlZEZvckFjdGl2YXRpb24gPyAnJyA6ICc7IGFub3RoZXIgdHJhbnNwb3J0IGlzIHNjaGVkdWxlZCBmb3IgYWN0aXZhdGlvbicpKTtcbiAgICAgICAgaWYgKGVycm9yICYmIGVycm9yLm1lc3NhZ2UpXG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKScsICdyZWFzb24gPSAgJyArIGVycm9yLm1lc3NhZ2UpO1xuICAgICAgICBpZiAod2FzQWN0aXZlKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKScsICdHZXR0aW5nLCBjbGVhcmluZywgYW5kIHJlcXVldWluZyAnICtcbiAgICAgICAgICAgICAgICB0aGlzLmFjdGl2ZVByb3RvY29sLm1lc3NhZ2VRdWV1ZS5jb3VudCgpICtcbiAgICAgICAgICAgICAgICAnIHBlbmRpbmcgbWVzc2FnZXMnKTtcbiAgICAgICAgICAgIHRoaXMucXVldWVQZW5kaW5nTWVzc2FnZXMoY3VycmVudFByb3RvY29sLmdldFBlbmRpbmdNZXNzYWdlcygpKTtcbiAgICAgICAgICAgIC8qIENsZWFyIGFueSBtZXNzYWdlcyB3ZSByZXF1ZXVlIHRvIGFsbG93IHRoZSBwcm90b2NvbCB0byBiZWNvbWUgaWRsZS5cbiAgICAgICAgICAgICAqIEluIGNhc2Ugb2YgYW4gdXBncmFkZSwgdGhpcyB3aWxsIHRyaWdnZXIgYW4gaW1tZWRpYXRlIGFjdGl2YXRpb24gb2ZcbiAgICAgICAgICAgICAqIHRoZSB1cGdyYWRlIHRyYW5zcG9ydCwgc28gZGVsYXkgYSB0aWNrIHNvIHRoaXMgdHJhbnNwb3J0IGNhbiBmaW5pc2hcbiAgICAgICAgICAgICAqIGRlYWN0aXZhdGluZyAqL1xuICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgY3VycmVudFByb3RvY29sLmNsZWFyUGVuZGluZ01lc3NhZ2VzKCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wgPSB0aGlzLmhvc3QgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgndHJhbnNwb3J0LmluYWN0aXZlJywgdHJhbnNwb3J0KTtcbiAgICAgICAgLyogdGhpcyB0cmFuc3BvcnQgc3RhdGUgY2hhbmdlIGlzIGEgc3RhdGUgY2hhbmdlIGZvciB0aGUgY29ubmVjdGlvbm1hbmFnZXIgaWZcbiAgICAgICAgICogLSB0aGUgdHJhbnNwb3J0IHdhcyB0aGUgYWN0aXZlIHRyYW5zcG9ydCBhbmQgdGhlcmUgYXJlIG5vIHRyYW5zcG9ydHNcbiAgICAgICAgICogICB3aGljaCBhcmUgY29ubmVjdGVkIGFuZCBzY2hlZHVsZWQgZm9yIGFjdGl2YXRpb24sIGp1c3Qgd2FpdGluZyBmb3IgdGhlXG4gICAgICAgICAqICAgYWN0aXZlIHRyYW5zcG9ydCB0byBmaW5pc2ggd2hhdCBpdHMgZG9pbmc7IG9yXG4gICAgICAgICAqIC0gdGhlIHRyYW5zcG9ydCB3YXMgdGhlIGFjdGl2ZSB0cmFuc3BvcnQgYW5kIHRoZSBlcnJvciB3YXMgZmF0YWwgKHNvXG4gICAgICAgICAqICAgdW5oZWFsYWJsZSBieSBhbm90aGVyIHRyYW5zcG9ydCk7IG9yXG4gICAgICAgICAqIC0gdGhlcmUgaXMgbm8gYWN0aXZlIHRyYW5zcG9ydCwgYW5kIHRoaXMgaXMgdGhlIGxhc3QgcmVtYWluaW5nXG4gICAgICAgICAqICAgcGVuZGluZyB0cmFuc3BvcnQgKHNvIHdlIHdlcmUgaW4gdGhlIGNvbm5lY3Rpbmcgc3RhdGUpXG4gICAgICAgICAqL1xuICAgICAgICBpZiAoKHdhc0FjdGl2ZSAmJiBub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uKSB8fFxuICAgICAgICAgICAgKHdhc0FjdGl2ZSAmJiBzdGF0ZSA9PT0gJ2ZhaWxlZCcpIHx8XG4gICAgICAgICAgICBzdGF0ZSA9PT0gJ2Nsb3NlZCcgfHxcbiAgICAgICAgICAgIChjdXJyZW50UHJvdG9jb2wgPT09IG51bGwgJiYgd2FzUGVuZGluZyAmJiB0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLmxlbmd0aCA9PT0gMCkpIHtcbiAgICAgICAgICAgIC8qIElmIHdlJ3JlIGRpc2Nvbm5lY3RlZCB3aXRoIGEgNXh4IHdlIG5lZWQgdG8gdHJ5IGZhbGxiYWNrIGhvc3RzXG4gICAgICAgICAgICAgKiAoUlROMTRkKSwgYnV0IChhKSBkdWUgdG8gaG93IHRoZSB1cGdyYWRlIHNlcXVlbmNlIHdvcmtzLCB0aGVcbiAgICAgICAgICAgICAqIGhvc3QvdHJhbnNwb3J0IHNlbGVjdGlvbiBzZXF1ZW5jZSBvbmx5IGNhcmVzIGFib3V0IGdldHRpbmcgdG9cbiAgICAgICAgICAgICAqIGBwcmVjb25uZWN0YCAoZWcgZXN0YWJsaXNoaW5nIGEgd2Vic29ja2V0KSBnZXR0aW5nIGEgYGRpc2Nvbm5lY3RlZGBcbiAgICAgICAgICAgICAqIHByb3RvY29sIG1lc3NhZ2UgYWZ0ZXJ3YXJkcyBpcyB0b28gbGF0ZTsgYW5kIChiKSBob3N0IHJldHJ5IG9ubHlcbiAgICAgICAgICAgICAqIGFwcGxpZXMgdG8gY29ubmVjdEJhc2UgdW5sZXNzIHRoZSBzdG9yZWQgcHJlZmVyZW5jZSB0cmFuc3BvcnQgZG9lc24ndFxuICAgICAgICAgICAgICogd29yay4gV2Ugc29sdmUgdGhpcyBieSB1bnBlcnNpc3RpbmcgdGhlIHRyYW5zcG9ydCBwcmVmZXJlbmNlIGFuZFxuICAgICAgICAgICAgICogc2V0dGluZyBhbiBpbnN0YW5jZSB2YXJpYWJsZSB0byBmb3JjZSBmYWxsYmFjayBob3N0cyB0byBiZSB1c2VkIChpZlxuICAgICAgICAgICAgICogYW55KSBoZXJlLiBCaXQgb2YgYSBrbHVkZ2UsIGJ1dCBubyByZWFsIGJldHRlciBhbHRlcm5hdGl2ZXMgd2l0aG91dFxuICAgICAgICAgICAgICogcmV3cml0aW5nIHRoZSBlbnRpcmUgdGhpbmcgKi9cbiAgICAgICAgICAgIGlmIChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgJiYgZXJyb3IgJiYgZXJyb3Iuc3RhdHVzQ29kZSA+IDUwMCAmJiB0aGlzLmh0dHBIb3N0cy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICAgICAgdGhpcy51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5mb3JjZUZhbGxiYWNrSG9zdCA9IHRydWU7XG4gICAgICAgICAgICAgICAgLyogYW5kIHRyeSB0byBjb25uZWN0IGFnYWluIHRvIHRyeSBhIGZhbGxiYWNrIGhvc3Qgd2l0aG91dCB3YWl0aW5nIGZvciB0aGUgdXN1YWwgMTVzIGRpc2Nvbm5lY3RlZFJldHJ5VGltZW91dCAqL1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogc3RhdGUsIGVycm9yOiBlcnJvciwgcmV0cnlJbW1lZGlhdGVseTogdHJ1ZSB9KTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBUT0RPIHJlbW92ZSBiZWxvdyBsaW5lIG9uY2UgcmVhbHRpbWUgc2VuZHMgdG9rZW4gZXJyb3JzIGFzIERJU0NPTk5FQ1RFRHMgKi9cbiAgICAgICAgICAgIHZhciBuZXdDb25uZWN0aW9uU3RhdGUgPSBzdGF0ZSA9PT0gJ2ZhaWxlZCcgJiYgYXV0aF8xLmRlZmF1bHQuaXNUb2tlbkVycihlcnJvcikgPyAnZGlzY29ubmVjdGVkJyA6IHN0YXRlO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiBuZXdDb25uZWN0aW9uU3RhdGUsIGVycm9yOiBlcnJvciB9KTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAod2FzQWN0aXZlICYmIHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyAmJiB0aGlzLnN0YXRlICE9PSB0aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nKSB7XG4gICAgICAgICAgICAvKiBJZiB3ZSB3ZXJlIGFjdGl2ZSBidXQgdGhlcmUgaXMgYW5vdGhlciB0cmFuc3BvcnQgc2NoZWR1bGVkIGZvclxuICAgICAgICAgICAgICogYWN0aXZhdGlvbiwgZ28gaW50byB0byB0aGUgY29ubmVjdGluZyBzdGF0ZSB1bnRpbCB0aGF0IHRyYW5zcG9ydFxuICAgICAgICAgICAgICogYWN0aXZhdGVzIGFuZCBzZXRzIHVzIGJhY2sgdG8gY29ubmVjdGVkLiAobWFudWFsbHkgc3RhcnRpbmcgdGhlXG4gICAgICAgICAgICAgKiB0cmFuc2l0aW9uIHRpbWVycyBpbiBjYXNlIHRoYXQgbmV2ZXIgaGFwcGVucykuIChJZiB3ZSB3ZXJlIGluIHRoZVxuICAgICAgICAgICAgICogc3luY2hyb25pemluZyBzdGF0ZSwgdGhlbiB0aGF0J3MgZmluZSwgdGhlIG9sZCB0cmFuc3BvcnQganVzdCBnb3QgaXRzXG4gICAgICAgICAgICAgKiBkaXNjb25uZWN0ZWQgYmVmb3JlIHRoZSBuZXcgb25lIGdvdCB0aGUgc3luYyAtLSBpZ25vcmUgaXQgYW5kIGtlZXBcbiAgICAgICAgICAgICAqIHdhaXRpbmcgZm9yIHRoZSBzeW5jLiBJZiBpdCBmYWlscyB3ZSBoYXZlIGEgc2VwYXJhdGUgc3luYyB0aW1lciB0aGF0XG4gICAgICAgICAgICAgKiB3aWxsIGV4cGlyZSkuICovXG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmRlYWN0aXZhdGVUcmFuc3BvcnQoKScsICd3YXNBY3RpdmUgYnV0IGFub3RoZXIgdHJhbnNwb3J0IGlzIGNvbm5lY3RlZCBhbmQgc2NoZWR1bGVkIGZvciBhY3RpdmF0aW9uLCBzbyBnb2luZyBpbnRvIHRoZSBjb25uZWN0aW5nIHN0YXRlIHVudGlsIGl0IGFjdGl2YXRlcycpO1xuICAgICAgICAgICAgdGhpcy5zdGFydFN1c3BlbmRUaW1lcigpO1xuICAgICAgICAgICAgdGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jb25uZWN0aW5nKTtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogJ2Nvbm5lY3RpbmcnLCBlcnJvcjogZXJyb3IgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qIEhlbHBlciB0aGF0IHJldHVybnMgdHJ1ZSBpZiB0aGVyZSBhcmUgbm8gdHJhbnNwb3J0cyB3aGljaCBhcmUgcGVuZGluZyxcbiAgICAgKiBoYXZlIGJlZW4gY29ubmVjdGVkLCBhbmQgYXJlIGp1c3Qgd2FpdGluZyBmb3Igb25jZU5vUGVuZGluZyB0byBmaXJlIGJlZm9yZVxuICAgICAqIGJlaW5nIGFjdGl2YXRlZCAqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5ub1RyYW5zcG9ydHNTY2hlZHVsZWRGb3JBY3RpdmF0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gKFV0aWxzLmlzRW1wdHkodGhpcy5wZW5kaW5nVHJhbnNwb3J0cykgfHxcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1RyYW5zcG9ydHMuZXZlcnkoZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgICAgIHJldHVybiAhdHJhbnNwb3J0LmlzQ29ubmVjdGVkO1xuICAgICAgICAgICAgfSkpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNldENvbm5lY3Rpb24gPSBmdW5jdGlvbiAoY29ubmVjdGlvbklkLCBjb25uZWN0aW9uRGV0YWlscywgaGFzQ29ubmVjdGlvbkVycm9yKSB7XG4gICAgICAgIC8qIGlmIGNvbm5lY3Rpb25LZXkgY2hhbmdlcyBidXQgY29ubmVjdGlvbklkIHN0YXlzIHRoZSBzYW1lLCB0aGVuIGp1c3QgYVxuICAgICAgICAgKiB0cmFuc3BvcnQgY2hhbmdlIG9uIHRoZSBzYW1lIGNvbm5lY3Rpb24uIElmIGNvbm5lY3Rpb25JZCBjaGFuZ2VzLCB3ZSdyZVxuICAgICAgICAgKiBvbiBhIG5ldyBjb25uZWN0aW9uLCB3aXRoIGltcGxpY2F0aW9ucyBmb3IgbXNnU2VyaWFsIGFuZCBjaGFubmVsIHN0YXRlICovXG4gICAgICAgIC8qIElmIG5vIHByZXZpb3VzIGNvbm5lY3Rpb25JZCwgZG9uJ3QgcmVzZXQgdGhlIG1zZ1NlcmlhbCBhcyBpdCBtYXkgaGF2ZVxuICAgICAgICAgKiBiZWVuIHNldCBieSByZWNvdmVyIGRhdGEgKHVubGVzcyB0aGUgcmVjb3ZlciBmYWlsZWQpICovXG4gICAgICAgIHZhciBwcmV2Q29ubklkID0gdGhpcy5jb25uZWN0aW9uSWQsIGNvbm5JZENoYW5nZWQgPSBwcmV2Q29ubklkICYmIHByZXZDb25uSWQgIT09IGNvbm5lY3Rpb25JZCwgcmVjb3ZlckZhaWx1cmUgPSAhcHJldkNvbm5JZCAmJiBoYXNDb25uZWN0aW9uRXJyb3I7XG4gICAgICAgIGlmIChjb25uSWRDaGFuZ2VkIHx8IHJlY292ZXJGYWlsdXJlKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb24oKScsICdSZXNldHRpbmcgbXNnU2VyaWFsJyk7XG4gICAgICAgICAgICB0aGlzLm1zZ1NlcmlhbCA9IDA7XG4gICAgICAgICAgICAvLyBSVE4xOWEyOiBJbiB0aGUgZXZlbnQgb2YgYSBuZXcgY29ubmVjdGlvbklkLCBwcmV2aW91cyBtc2dTZXJpYWxzIGFyZVxuICAgICAgICAgICAgLy8gbWVhbmluZ2xlc3MuXG4gICAgICAgICAgICB0aGlzLnF1ZXVlZE1lc3NhZ2VzLnJlc2V0U2VuZEF0dGVtcHRlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmNvbm5lY3Rpb25JZCAhPT0gY29ubmVjdGlvbklkKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNldENvbm5lY3Rpb24oKScsICdOZXcgY29ubmVjdGlvbklkOyByZWF0dGFjaGluZyBhbnkgYXR0YWNoZWQgY2hhbm5lbHMnKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uaWQgPSB0aGlzLmNvbm5lY3Rpb25JZCA9IGNvbm5lY3Rpb25JZDtcbiAgICAgICAgdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmtleSA9IHRoaXMuY29ubmVjdGlvbktleSA9IGNvbm5lY3Rpb25EZXRhaWxzLmNvbm5lY3Rpb25LZXk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2xlYXJDb25uZWN0aW9uID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uaWQgPSB0aGlzLmNvbm5lY3Rpb25JZCA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5yZWFsdGltZS5jb25uZWN0aW9uLmtleSA9IHRoaXMuY29ubmVjdGlvbktleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgdGhpcy5tc2dTZXJpYWwgPSAwO1xuICAgICAgICB0aGlzLnVucGVyc2lzdENvbm5lY3Rpb24oKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jcmVhdGVSZWNvdmVyeUtleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLy8gUlROMTZnMi5cbiAgICAgICAgaWYgKCF0aGlzLmNvbm5lY3Rpb25LZXkpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh7XG4gICAgICAgICAgICBjb25uZWN0aW9uS2V5OiB0aGlzLmNvbm5lY3Rpb25LZXksXG4gICAgICAgICAgICBtc2dTZXJpYWw6IHRoaXMubXNnU2VyaWFsLFxuICAgICAgICAgICAgY2hhbm5lbFNlcmlhbHM6IHRoaXMucmVhbHRpbWUuY2hhbm5lbHMuY2hhbm5lbFNlcmlhbHMoKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2hlY2tDb25uZWN0aW9uU3RhdGVGcmVzaG5lc3MgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICghdGhpcy5sYXN0QWN0aXZpdHkgfHwgIXRoaXMuY29ubmVjdGlvbklkKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHNpbmNlTGFzdCA9IFV0aWxzLm5vdygpIC0gdGhpcy5sYXN0QWN0aXZpdHk7XG4gICAgICAgIGlmIChzaW5jZUxhc3QgPiB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCArIHRoaXMubWF4SWRsZUludGVydmFsKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNoZWNrQ29ubmVjdGlvblN0YXRlRnJlc2huZXNzKCknLCAnTGFzdCBrbm93biBhY3Rpdml0eSBmcm9tIHJlYWx0aW1lIHdhcyAnICsgc2luY2VMYXN0ICsgJ21zIGFnbzsgZGlzY2FyZGluZyBjb25uZWN0aW9uIHN0YXRlJyk7XG4gICAgICAgICAgICB0aGlzLmNsZWFyQ29ubmVjdGlvbigpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZXMuY29ubmVjdGluZy5mYWlsU3RhdGUgPSAnc3VzcGVuZGVkJztcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyoqXG4gICAgICogQ2FsbGVkIHdoZW4gdGhlIGNvbm5lY3Rpb25tYW5hZ2VyIHdhbnRzIHRvIHBlcnNpc3QgdHJhbnNwb3J0XG4gICAgICogc3RhdGUgZm9yIGxhdGVyIHJlY292ZXJ5LiBPbmx5IGFwcGxpY2FibGUgaW4gdGhlIGJyb3dzZXIgY29udGV4dC5cbiAgICAgKi9cbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucGVyc2lzdENvbm5lY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmIChoYXZlU2Vzc2lvblN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgdmFyIHJlY292ZXJ5S2V5ID0gdGhpcy5jcmVhdGVSZWNvdmVyeUtleSgpO1xuICAgICAgICAgICAgaWYgKHJlY292ZXJ5S2V5KSB7XG4gICAgICAgICAgICAgICAgc2V0U2Vzc2lvblJlY292ZXJEYXRhKHtcbiAgICAgICAgICAgICAgICAgICAgcmVjb3ZlcnlLZXk6IHJlY292ZXJ5S2V5LFxuICAgICAgICAgICAgICAgICAgICBkaXNjb25uZWN0ZWRBdDogVXRpbHMubm93KCksXG4gICAgICAgICAgICAgICAgICAgIGxvY2F0aW9uOiBnbG9iYWwubG9jYXRpb24sXG4gICAgICAgICAgICAgICAgICAgIGNsaWVudElkOiB0aGlzLnJlYWx0aW1lLmF1dGguY2xpZW50SWQsXG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIENhbGxlZCB3aGVuIHRoZSBjb25uZWN0aW9ubWFuYWdlciB3YW50cyB0byBwZXJzaXN0IHRyYW5zcG9ydFxuICAgICAqIHN0YXRlIGZvciBsYXRlciByZWNvdmVyeS4gT25seSBhcHBsaWNhYmxlIGluIHRoZSBicm93c2VyIGNvbnRleHQuXG4gICAgICovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnVucGVyc2lzdENvbm5lY3Rpb24gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNsZWFyU2Vzc2lvblJlY292ZXJEYXRhKCk7XG4gICAgfTtcbiAgICAvKioqKioqKioqKioqKioqKioqKioqXG4gICAgICogc3RhdGUgbWFuYWdlbWVudFxuICAgICAqKioqKioqKioqKioqKioqKioqKiovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldEVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5lcnJvclJlYXNvbiB8fCB0aGlzLmdldFN0YXRlRXJyb3IoKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5nZXRTdGF0ZUVycm9yID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICByZXR1cm4gKF9iID0gKF9hID0gY29ubmVjdGlvbmVycm9yc18xLmRlZmF1bHQpW3RoaXMuc3RhdGUuc3RhdGVdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYWN0aXZlU3RhdGUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHJldHVybiB0aGlzLnN0YXRlLnF1ZXVlRXZlbnRzIHx8IHRoaXMuc3RhdGUuc2VuZEV2ZW50cztcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5lbmFjdFN0YXRlQ2hhbmdlID0gZnVuY3Rpb24gKHN0YXRlQ2hhbmdlKSB7XG4gICAgICAgIHZhciBsb2dMZXZlbCA9IHN0YXRlQ2hhbmdlLmN1cnJlbnQgPT09ICdmYWlsZWQnID8gbG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IgOiBsb2dnZXJfMS5kZWZhdWx0LkxPR19NQUpPUjtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nTGV2ZWwsICdDb25uZWN0aW9uIHN0YXRlJywgc3RhdGVDaGFuZ2UuY3VycmVudCArIChzdGF0ZUNoYW5nZS5yZWFzb24gPyAnOyByZWFzb246ICcgKyBzdGF0ZUNoYW5nZS5yZWFzb24gOiAnJykpO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmVuYWN0U3RhdGVDaGFuZ2UnLCAnc2V0dGluZyBuZXcgc3RhdGU6ICcgK1xuICAgICAgICAgICAgc3RhdGVDaGFuZ2UuY3VycmVudCArXG4gICAgICAgICAgICAnOyByZWFzb24gPSAnICtcbiAgICAgICAgICAgIChzdGF0ZUNoYW5nZS5yZWFzb24gJiYgc3RhdGVDaGFuZ2UucmVhc29uLm1lc3NhZ2UpKTtcbiAgICAgICAgdmFyIG5ld1N0YXRlID0gKHRoaXMuc3RhdGUgPSB0aGlzLnN0YXRlc1tzdGF0ZUNoYW5nZS5jdXJyZW50XSk7XG4gICAgICAgIGlmIChzdGF0ZUNoYW5nZS5yZWFzb24pIHtcbiAgICAgICAgICAgIHRoaXMuZXJyb3JSZWFzb24gPSBzdGF0ZUNoYW5nZS5yZWFzb247XG4gICAgICAgICAgICB0aGlzLnJlYWx0aW1lLmNvbm5lY3Rpb24uZXJyb3JSZWFzb24gPSBzdGF0ZUNoYW5nZS5yZWFzb247XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG5ld1N0YXRlLnRlcm1pbmFsIHx8IG5ld1N0YXRlLnN0YXRlID09PSAnc3VzcGVuZGVkJykge1xuICAgICAgICAgICAgLyogc3VzcGVuZGVkIGlzIG5vbnRlcm1pbmFsLCBidXQgb25jZSBpbiB0aGUgc3VzcGVuZGVkIHN0YXRlLCByZWFsdGltZVxuICAgICAgICAgICAgICogd2lsbCBoYXZlIGRpc2NhcmRlZCBvdXIgY29ubmVjdGlvbiBzdGF0ZSwgc28gZnV0aGVyIGNvbm5lY3Rpb25cbiAgICAgICAgICAgICAqIGF0dGVtcHRzIHNob3VsZCBzdGFydCBmcm9tIHNjcmF0Y2ggKi9cbiAgICAgICAgICAgIHRoaXMuY2xlYXJDb25uZWN0aW9uKCk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0aW9uc3RhdGUnLCBzdGF0ZUNoYW5nZSk7XG4gICAgfTtcbiAgICAvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxuICAgICAqIENvbm5lY3Rpb25NYW5hZ2VyIGNvbm5lY3Rpb24gbGlmZWN5Y2xlXG4gICAgICoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnN0YXJ0VHJhbnNpdGlvblRpbWVyID0gZnVuY3Rpb24gKHRyYW5zaXRpb25TdGF0ZSkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0VHJhbnNpdGlvblRpbWVyKCknLCAndHJhbnNpdGlvblN0YXRlOiAnICsgdHJhbnNpdGlvblN0YXRlLnN0YXRlKTtcbiAgICAgICAgaWYgKHRoaXMudHJhbnNpdGlvblRpbWVyKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnN0YXJ0VHJhbnNpdGlvblRpbWVyKCknLCAnY2xlYXJpbmcgYWxyZWFkeS1ydW5uaW5nIHRpbWVyJyk7XG4gICAgICAgICAgICBjbGVhclRpbWVvdXQodGhpcy50cmFuc2l0aW9uVGltZXIpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMudHJhbnNpdGlvblRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoX3RoaXMudHJhbnNpdGlvblRpbWVyKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMudHJhbnNpdGlvblRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyICcgKyB0cmFuc2l0aW9uU3RhdGUuc3RhdGUgKyAnIHRpbWVyIGV4cGlyZWQnLCAncmVxdWVzdGluZyBuZXcgc3RhdGU6ICcgKyB0cmFuc2l0aW9uU3RhdGUuZmFpbFN0YXRlKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiB0cmFuc2l0aW9uU3RhdGUuZmFpbFN0YXRlIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0cmFuc2l0aW9uU3RhdGUucmV0cnlEZWxheSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2FuY2VsVHJhbnNpdGlvblRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNhbmNlbFRyYW5zaXRpb25UaW1lcigpJywgJycpO1xuICAgICAgICBpZiAodGhpcy50cmFuc2l0aW9uVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnRyYW5zaXRpb25UaW1lcik7XG4gICAgICAgICAgICB0aGlzLnRyYW5zaXRpb25UaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zdGFydFN1c3BlbmRUaW1lciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuc3VzcGVuZFRpbWVyKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB0aGlzLnN1c3BlbmRUaW1lciA9IHNldFRpbWVvdXQoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgaWYgKF90aGlzLnN1c3BlbmRUaW1lcikge1xuICAgICAgICAgICAgICAgIF90aGlzLnN1c3BlbmRUaW1lciA9IG51bGw7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlciBzdXNwZW5kIHRpbWVyIGV4cGlyZWQnLCAncmVxdWVzdGluZyBuZXcgc3RhdGU6IHN1c3BlbmRlZCcpO1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSA9ICdzdXNwZW5kZWQnO1xuICAgICAgICAgICAgICAgIF90aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6ICdzdXNwZW5kZWQnIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9LCB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2hlY2tTdXNwZW5kVGltZXIgPSBmdW5jdGlvbiAoc3RhdGUpIHtcbiAgICAgICAgaWYgKHN0YXRlICE9PSAnZGlzY29ubmVjdGVkJyAmJiBzdGF0ZSAhPT0gJ3N1c3BlbmRlZCcgJiYgc3RhdGUgIT09ICdjb25uZWN0aW5nJylcbiAgICAgICAgICAgIHRoaXMuY2FuY2VsU3VzcGVuZFRpbWVyKCk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuY2FuY2VsU3VzcGVuZFRpbWVyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aGlzLnN0YXRlcy5jb25uZWN0aW5nLmZhaWxTdGF0ZSA9ICdkaXNjb25uZWN0ZWQnO1xuICAgICAgICBpZiAodGhpcy5zdXNwZW5kVGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnN1c3BlbmRUaW1lcik7XG4gICAgICAgICAgICB0aGlzLnN1c3BlbmRUaW1lciA9IG51bGw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zdGFydFJldHJ5VGltZXIgPSBmdW5jdGlvbiAoaW50ZXJ2YWwpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdGhpcy5yZXRyeVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyIHJldHJ5IHRpbWVyIGV4cGlyZWQnLCAncmV0cnlpbmcnKTtcbiAgICAgICAgICAgIF90aGlzLnJldHJ5VGltZXIgPSBudWxsO1xuICAgICAgICAgICAgX3RoaXMucmVxdWVzdFN0YXRlKHsgc3RhdGU6ICdjb25uZWN0aW5nJyB9KTtcbiAgICAgICAgfSwgaW50ZXJ2YWwpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNhbmNlbFJldHJ5VGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJldHJ5VGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZXIpO1xuICAgICAgICAgICAgdGhpcy5yZXRyeVRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLm5vdGlmeVN0YXRlID0gZnVuY3Rpb24gKGluZGljYXRlZCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgX2EsIF9iO1xuICAgICAgICB2YXIgc3RhdGUgPSBpbmRpY2F0ZWQuc3RhdGU7XG4gICAgICAgIC8qIFdlIHJldHJ5IGltbWVkaWF0ZWx5IGlmOlxuICAgICAgICAgKiAtIHNvbWV0aGluZyBkaXNjb25uZWN0cyB1cyB3aGlsZSB3ZSdyZSBjb25uZWN0ZWQsIG9yXG4gICAgICAgICAqIC0gYSB2aWFibGUgKGJ1dCBub3QgeWV0IGFjdGl2ZSkgdHJhbnNwb3J0IGZhaWxzIGR1ZSB0byBhIHRva2VuIGVycm9yIChzb1xuICAgICAgICAgKiAgIHRoaXMuZXJyb3JSZWFzb24gd2lsbCBiZSBzZXQsIGFuZCBzdGFydENvbm5lY3Qgd2lsbCBkbyBhIGZvcmNlZFxuICAgICAgICAgKiAgIGF1dGhvcml6ZSkuIElmIHRoaXMuZXJyb3JSZWFzb24gaXMgYWxyZWFkeSBzZXQgKHRvIGEgdG9rZW4gZXJyb3IpLFxuICAgICAgICAgKiAgIHRoZW4gdGhlcmUgaGFzIGJlZW4gYXQgbGVhc3Qgb25lIHByZXZpb3VzIGF0dGVtcHQgdG8gY29ubmVjdCB0aGF0IGFsc29cbiAgICAgICAgICogICBmYWlsZWQgZm9yIGEgdG9rZW4gZXJyb3IsIHNvIGJ5IFJUTjE0YiB3ZSBnbyB0byBESVNDT05ORUNURUQgYW5kIHdhaXRcbiAgICAgICAgICogICBiZWZvcmUgdHJ5aW5nIGFnYWluICovXG4gICAgICAgIHZhciByZXRyeUltbWVkaWF0ZWx5ID0gc3RhdGUgPT09ICdkaXNjb25uZWN0ZWQnICYmXG4gICAgICAgICAgICAodGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkIHx8XG4gICAgICAgICAgICAgICAgdGhpcy5zdGF0ZSA9PT0gdGhpcy5zdGF0ZXMuc3luY2hyb25pemluZyB8fFxuICAgICAgICAgICAgICAgIGluZGljYXRlZC5yZXRyeUltbWVkaWF0ZWx5IHx8XG4gICAgICAgICAgICAgICAgKHRoaXMuc3RhdGUgPT09IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcgJiZcbiAgICAgICAgICAgICAgICAgICAgaW5kaWNhdGVkLmVycm9yICYmXG4gICAgICAgICAgICAgICAgICAgIGF1dGhfMS5kZWZhdWx0LmlzVG9rZW5FcnIoaW5kaWNhdGVkLmVycm9yKSAmJlxuICAgICAgICAgICAgICAgICAgICAhKHRoaXMuZXJyb3JSZWFzb24gJiYgYXV0aF8xLmRlZmF1bHQuaXNUb2tlbkVycih0aGlzLmVycm9yUmVhc29uKSkpKTtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5ub3RpZnlTdGF0ZSgpJywgJ25ldyBzdGF0ZTogJyArIHN0YXRlICsgKHJldHJ5SW1tZWRpYXRlbHkgPyAnOyB3aWxsIHJldHJ5IGNvbm5lY3Rpb24gaW1tZWRpYXRlbHknIDogJycpKTtcbiAgICAgICAgLyogZG8gbm90aGluZyBpZiB3ZSdyZSBhbHJlYWR5IGluIHRoZSBpbmRpY2F0ZWQgc3RhdGUgKi9cbiAgICAgICAgaWYgKHN0YXRlID09IHRoaXMuc3RhdGUuc3RhdGUpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIC8qIGtpbGwgdGltZXJzIChwb3NzaWJseSBleGNlcHRpbmcgc3VzcGVuZCB0aW1lciBkZXBlbmRpbmcgb24gdGhlIG5vdGlmaWVkXG4gICAgICAgICAqIHN0YXRlKSwgYXMgdGhlc2UgYXJlIHN1cGVyc2VkZWQgYnkgdGhpcyBub3RpZmljYXRpb24gKi9cbiAgICAgICAgdGhpcy5jYW5jZWxUcmFuc2l0aW9uVGltZXIoKTtcbiAgICAgICAgdGhpcy5jYW5jZWxSZXRyeVRpbWVyKCk7XG4gICAgICAgIHRoaXMuY2hlY2tTdXNwZW5kVGltZXIoaW5kaWNhdGVkLnN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnc3VzcGVuZGVkJyB8fCBzdGF0ZSA9PT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdGVkUmV0cnlDb3VudCA9IDA7XG4gICAgICAgIH1cbiAgICAgICAgLyogZG8gbm90aGluZyBpZiB3ZSdyZSB1bmFibGUgdG8gbW92ZSBmcm9tIHRoZSBjdXJyZW50IHN0YXRlICovXG4gICAgICAgIGlmICh0aGlzLnN0YXRlLnRlcm1pbmFsKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAvKiBwcm9jZXNzIG5ldyBzdGF0ZSAqL1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSB0aGlzLnN0YXRlc1tpbmRpY2F0ZWQuc3RhdGVdO1xuICAgICAgICB2YXIgcmV0cnlEZWxheSA9IG5ld1N0YXRlLnJldHJ5RGVsYXk7XG4gICAgICAgIGlmIChuZXdTdGF0ZS5zdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIHRoaXMuZGlzY29ubmVjdGVkUmV0cnlDb3VudCsrO1xuICAgICAgICAgICAgcmV0cnlEZWxheSA9IFV0aWxzLmdldFJldHJ5VGltZShuZXdTdGF0ZS5yZXRyeURlbGF5LCB0aGlzLmRpc2Nvbm5lY3RlZFJldHJ5Q291bnQpO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFuZ2UgPSBuZXcgY29ubmVjdGlvbnN0YXRlY2hhbmdlXzEuZGVmYXVsdCh0aGlzLnN0YXRlLnN0YXRlLCBuZXdTdGF0ZS5zdGF0ZSwgcmV0cnlEZWxheSwgaW5kaWNhdGVkLmVycm9yIHx8ICgoX2IgPSAoX2EgPSBjb25uZWN0aW9uZXJyb3JzXzEuZGVmYXVsdClbbmV3U3RhdGUuc3RhdGVdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpKTtcbiAgICAgICAgaWYgKHJldHJ5SW1tZWRpYXRlbHkpIHtcbiAgICAgICAgICAgIHZhciBhdXRvUmVjb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGlmIChfdGhpcy5zdGF0ZSA9PT0gX3RoaXMuc3RhdGVzLmRpc2Nvbm5lY3RlZCkge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgPSBVdGlscy5ub3coKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVxdWVzdFN0YXRlKHsgc3RhdGU6ICdjb25uZWN0aW5nJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdmFyIHNpbmNlTGFzdCA9IHRoaXMubGFzdEF1dG9SZWNvbm5lY3RBdHRlbXB0ICYmIFV0aWxzLm5vdygpIC0gdGhpcy5sYXN0QXV0b1JlY29ubmVjdEF0dGVtcHQgKyAxO1xuICAgICAgICAgICAgaWYgKHNpbmNlTGFzdCAmJiBzaW5jZUxhc3QgPCAxMDAwKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5ub3RpZnlTdGF0ZSgpJywgJ0xhc3QgcmVjb25uZWN0IGF0dGVtcHQgd2FzIG9ubHkgJyArXG4gICAgICAgICAgICAgICAgICAgIHNpbmNlTGFzdCArXG4gICAgICAgICAgICAgICAgICAgICdtcyBhZ28sIHdhaXRpbmcgYW5vdGhlciAnICtcbiAgICAgICAgICAgICAgICAgICAgKDEwMDAgLSBzaW5jZUxhc3QpICtcbiAgICAgICAgICAgICAgICAgICAgJ21zIGJlZm9yZSB0cnlpbmcgYWdhaW4nKTtcbiAgICAgICAgICAgICAgICBzZXRUaW1lb3V0KGF1dG9SZWNvbm5lY3QsIDEwMDAgLSBzaW5jZUxhc3QpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhhdXRvUmVjb25uZWN0KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ2Rpc2Nvbm5lY3RlZCcgfHwgc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXJ0UmV0cnlUaW1lcihyZXRyeURlbGF5KTtcbiAgICAgICAgfVxuICAgICAgICAvKiBJZiBnb2luZyBpbnRvIGRpc2Nvbm5lY3Qvc3VzcGVuZGVkIChhbmQgbm90IHJldHJ5aW5nIGltbWVkaWF0ZWx5KSwgb3IgYVxuICAgICAgICAgKiB0ZXJtaW5hbCBzdGF0ZSwgZW5zdXJlIHRoZXJlIGFyZSBubyBvcnBoYW5lZCB0cmFuc3BvcnRzIGhhbmdpbmcgYXJvdW5kLiAqL1xuICAgICAgICBpZiAoKHN0YXRlID09PSAnZGlzY29ubmVjdGVkJyAmJiAhcmV0cnlJbW1lZGlhdGVseSkgfHwgc3RhdGUgPT09ICdzdXNwZW5kZWQnIHx8IG5ld1N0YXRlLnRlcm1pbmFsKSB7XG4gICAgICAgICAgICAvKiBXYWl0IHRpbGwgdGhlIG5leHQgdGljayBzbyB0aGUgY29ubmVjdGlvbiBzdGF0ZSBjaGFuZ2UgaXMgZW5hY3RlZCxcbiAgICAgICAgICAgICAqIHNvIGFib3J0aW5nIHRyYW5zcG9ydHMgZG9lc24ndCB0cmlnZ2VyIHJlZHVuZGFudCBzdGF0ZSBjaGFuZ2VzICovXG4gICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlID09ICdjb25uZWN0ZWQnICYmICF0aGlzLmFjdGl2ZVByb3RvY29sKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm5vdGlmeVN0YXRlKCknLCAnQnJva2VuIGludmFyaWFudDogYXR0ZW1wdGVkIHRvIGdvIGludG8gY29ubmVjdGVkIHN0YXRlLCBidXQgdGhlcmUgaXMgbm8gYWN0aXZlIHByb3RvY29sJyk7XG4gICAgICAgIH1cbiAgICAgICAgLyogaW1wbGVtZW50IHRoZSBjaGFuZ2UgYW5kIG5vdGlmeSAqL1xuICAgICAgICB0aGlzLmVuYWN0U3RhdGVDaGFuZ2UoY2hhbmdlKTtcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUuc2VuZEV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5zZW5kUXVldWVkTWVzc2FnZXMoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICghdGhpcy5zdGF0ZS5xdWV1ZUV2ZW50cykge1xuICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5jaGFubmVscy5wcm9wb2dhdGVDb25uZWN0aW9uSW50ZXJydXB0aW9uKHN0YXRlLCBjaGFuZ2UucmVhc29uKTtcbiAgICAgICAgICAgIHRoaXMuZmFpbFF1ZXVlZE1lc3NhZ2VzKGNoYW5nZS5yZWFzb24pOyAvLyBSVE43Y1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUucmVxdWVzdFN0YXRlID0gZnVuY3Rpb24gKHJlcXVlc3QpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdmFyIHN0YXRlID0gcmVxdWVzdC5zdGF0ZTtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5yZXF1ZXN0U3RhdGUoKScsICdyZXF1ZXN0ZWQgc3RhdGU6ICcgKyBzdGF0ZSArICc7IGN1cnJlbnQgc3RhdGU6ICcgKyB0aGlzLnN0YXRlLnN0YXRlKTtcbiAgICAgICAgaWYgKHN0YXRlID09IHRoaXMuc3RhdGUuc3RhdGUpXG4gICAgICAgICAgICByZXR1cm47IC8qIHNpbGVudGx5IGRvIG5vdGhpbmcgKi9cbiAgICAgICAgLyoga2lsbCBydW5uaW5nIHRpbWVycywgYXMgdGhpcyByZXF1ZXN0IHN1cGVyc2VkZXMgdGhlbSAqL1xuICAgICAgICB0aGlzLmNhbmNlbFRyYW5zaXRpb25UaW1lcigpO1xuICAgICAgICB0aGlzLmNhbmNlbFJldHJ5VGltZXIoKTtcbiAgICAgICAgLyogZm9yIHN1c3BlbmQgdGltZXIgY2hlY2sgcmF0aGVyIHRoYW4gY2FuY2VsIC0tIGVnIHJlcXVlc3RpbmcgYSBjb25uZWN0aW5nXG4gICAgICAgICAqIHN0YXRlIHNob3VsZCBub3QgcmVzZXQgdGhlIHN1c3BlbmQgdGltZXIgKi9cbiAgICAgICAgdGhpcy5jaGVja1N1c3BlbmRUaW1lcihzdGF0ZSk7XG4gICAgICAgIGlmIChzdGF0ZSA9PSAnY29ubmVjdGluZycgJiYgdGhpcy5zdGF0ZS5zdGF0ZSA9PSAnY29ubmVjdGVkJylcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgaWYgKHN0YXRlID09ICdjbG9zaW5nJyAmJiB0aGlzLnN0YXRlLnN0YXRlID09ICdjbG9zZWQnKVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB2YXIgbmV3U3RhdGUgPSB0aGlzLnN0YXRlc1tzdGF0ZV0sIGNoYW5nZSA9IG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfMS5kZWZhdWx0KHRoaXMuc3RhdGUuc3RhdGUsIG5ld1N0YXRlLnN0YXRlLCBudWxsLCByZXF1ZXN0LmVycm9yIHx8ICgoX2IgPSAoX2EgPSBjb25uZWN0aW9uZXJyb3JzXzEuZGVmYXVsdClbbmV3U3RhdGUuc3RhdGVdKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSkpKTtcbiAgICAgICAgdGhpcy5lbmFjdFN0YXRlQ2hhbmdlKGNoYW5nZSk7XG4gICAgICAgIGlmIChzdGF0ZSA9PSAnY29ubmVjdGluZycpIHtcbiAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXJ0Q29ubmVjdCgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHN0YXRlID09ICdjbG9zaW5nJykge1xuICAgICAgICAgICAgdGhpcy5jbG9zZUltcGwoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnN0YXJ0Q29ubmVjdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLmNvbm5lY3RpbmcpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc3RhcnRDb25uZWN0KCknLCAnTXVzdCBiZSBpbiBjb25uZWN0aW5nIHN0YXRlIHRvIGNvbm5lY3QsIGJ1dCB3YXMgJyArIHRoaXMuc3RhdGUuc3RhdGUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHZhciBhdXRoID0gdGhpcy5yZWFsdGltZS5hdXRoO1xuICAgICAgICAvKiBUaGUgcG9pbnQgb2YgdGhlIGNvbm5lY3RDb3VudGVyIG1lY2hhbmlzbSBpcyB0byBlbnN1cmUgdGhhdCB0aGVcbiAgICAgICAgICogY29ubmVjdGlvbiBwcm9jZWR1cmUgY2FuIGJlIGNhbmNlbGxlZC4gV2Ugd2FudCBkaXNjb25uZWN0QWxsVHJhbnNwb3J0c1xuICAgICAgICAgKiB0byBiZSBhYmxlIHRvIHN0b3AgYW55IGluLXByb2dyZXNzIGNvbm5lY3Rpb24sIGV2ZW4gYmVmb3JlIGl0IGdldHMgdG9cbiAgICAgICAgICogdGhlIHN0YWdlIG9mIGhhdmluZyBhIHBlbmRpbmcgKG9yIGV2ZW4gYSBwcm9wb3NlZCkgdHJhbnNwb3J0IHRoYXQgaXQgY2FuXG4gICAgICAgICAqIGRpc3Bvc2UoKSBvZi4gU28gd2UgY2hlY2sgdGhhdCBpdCdzIHN0aWxsIGN1cnJlbnQgYWZ0ZXIgYW55IGFzeW5jIHN0YWdlLFxuICAgICAgICAgKiB1cCB1bnRpbCB0aGUgc3RhZ2UgdGhhdCBpcyBzeW5jaHJvbm91cyB3aXRoIGluc3RhbnRpYXRpbmcgYSB0cmFuc3BvcnQgKi9cbiAgICAgICAgdmFyIGNvbm5lY3RDb3VudCA9ICsrdGhpcy5jb25uZWN0Q291bnRlcjtcbiAgICAgICAgdmFyIGNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBfdGhpcy5jaGVja0Nvbm5lY3Rpb25TdGF0ZUZyZXNobmVzcygpO1xuICAgICAgICAgICAgX3RoaXMuZ2V0VHJhbnNwb3J0UGFyYW1zKGZ1bmN0aW9uICh0cmFuc3BvcnRQYXJhbXMpIHtcbiAgICAgICAgICAgICAgICBpZiAodHJhbnNwb3J0UGFyYW1zLm1vZGUgPT09ICdyZWNvdmVyJyAmJiB0cmFuc3BvcnRQYXJhbXMub3B0aW9ucy5yZWNvdmVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZWNvdmVyeUNvbnRleHQgPSBkZWNvZGVSZWNvdmVyeUtleSh0cmFuc3BvcnRQYXJhbXMub3B0aW9ucy5yZWNvdmVyKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlY292ZXJ5Q29udGV4dCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMucmVhbHRpbWUuY2hhbm5lbHMucmVjb3ZlckNoYW5uZWxzKHJlY292ZXJ5Q29udGV4dC5jaGFubmVsU2VyaWFscyk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3RDb3VudCAhPT0gX3RoaXMuY29ubmVjdENvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBfdGhpcy5jb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5zdGFydENvbm5lY3QoKScsICdzdGFydGluZyBjb25uZWN0aW9uJyk7XG4gICAgICAgIHRoaXMuc3RhcnRTdXNwZW5kVGltZXIoKTtcbiAgICAgICAgdGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jb25uZWN0aW5nKTtcbiAgICAgICAgaWYgKGF1dGgubWV0aG9kID09PSAnYmFzaWMnKSB7XG4gICAgICAgICAgICBjb25uZWN0KCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgYXV0aENiID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChjb25uZWN0Q291bnQgIT09IF90aGlzLmNvbm5lY3RDb3VudGVyKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZShlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAodGhpcy5lcnJvclJlYXNvbiAmJiBhdXRoXzEuZGVmYXVsdC5pc1Rva2VuRXJyKHRoaXMuZXJyb3JSZWFzb24pKSB7XG4gICAgICAgICAgICAgICAgLyogRm9yY2UgYSByZWZldGNoIG9mIGEgbmV3IHRva2VuICovXG4gICAgICAgICAgICAgICAgYXV0aC5fZm9yY2VOZXdUb2tlbihudWxsLCBudWxsLCBhdXRoQ2IpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgYXV0aC5fZW5zdXJlVmFsaWRBdXRoQ3JlZGVudGlhbHMoZmFsc2UsIGF1dGhDYik7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRoZXJlIGFyZSB0aHJlZSBzdGFnZXMgaW4gY29ubmVjdGluZzpcbiAgICAgKiAtIHByZWZlcmVuY2U6IGlmIHRoZXJlIGlzIGEgY2FjaGVkIHRyYW5zcG9ydCBwcmVmZXJlbmNlLCB3ZSB0cnkgdG8gY29ubmVjdFxuICAgICAqICAgb24gdGhhdC4gSWYgdGhhdCBmYWlscyBvciB0aW1lcyBvdXQgd2UgYWJvcnQgdGhlIGF0dGVtcHQsIHJlbW92ZSB0aGVcbiAgICAgKiAgIHByZWZlcmVuY2UgYW5kIGZhbGwgYmFjayB0byBiYXNlLiBJZiBpdCBzdWNjZWVkcywgd2UgdHJ5IHVwZ3JhZGluZyBpdCBpZlxuICAgICAqICAgbmVlZGVkICh3aWxsIG9ubHkgYmUgaW4gdGhlIGNhc2Ugd2hlcmUgdGhlIHByZWZlcmVuY2UgaXMgeGhycyBhbmQgdGhlXG4gICAgICogICBicm93c2VyIHN1cHBvcnRzIHdzKS5cbiAgICAgKiAtIGJhc2U6IHdlIHRyeSB0byBjb25uZWN0IHdpdGggdGhlIGJlc3QgdHJhbnNwb3J0IHRoYXQgd2UgdGhpbmsgd2lsbFxuICAgICAqICAgbmV2ZXIgZmFpbCBmb3IgdGhpcyBicm93c2VyICh1c3VhbGx5IHRoaXMgaXMgeGhyX3BvbGxpbmc7IGZvciB2ZXJ5IG9sZFxuICAgICAqICAgYnJvd3NlcnMgd2lsbCBiZSBqc29ucCwgZm9yIG5vZGUgd2lsbCBiZSBjb21ldCkuIElmIGl0IGRvZXNuJ3Qgd29yaywgd2VcbiAgICAgKiAgIHRyeSBmYWxsYmFjayBob3N0cy5cbiAgICAgKiAtIHVwZ3JhZGU6IGdpdmVuIGEgY29ubmVjdGVkIHRyYW5zcG9ydCwgd2Ugc2VlIGlmIHRoZXJlIGFyZSBhbnkgYmV0dGVyXG4gICAgICogICBvbmVzLCBhbmQgaWYgc28sIHRyeSB0byB1cGdyYWRlIHRvIHRoZW0uXG4gICAgICpcbiAgICAgKiBjb25uZWN0SW1wbCB3b3JrcyBvdXQgd2hhdCBzdGFnZSB5b3UncmUgYXQgKHdoaWNoIGlzIHB1cmVseSBhIGZ1bmN0aW9uIG9mXG4gICAgICogdGhlIGN1cnJlbnQgY29ubmVjdGlvbiBzdGF0ZSBhbmQgd2hldGhlciB0aGVyZSBhcmUgYW55IHN0b3JlZCBwcmVmZXJlbmNlcyksXG4gICAgICogYW5kIGRpc3BhdGNoZXMgYWNjb3JkaW5nbHkuIEFmdGVyIGEgdHJhbnNwb3J0IGhhcyBiZWVuIHNldCBwZW5kaW5nLFxuICAgICAqIHRyeUFUcmFuc3BvcnQgY2FsbHMgY29ubmVjdEltcGwgdG8gc2VlIGlmIHRoZXJlJ3MgYW5vdGhlciBzdGFnZSB0byBiZSBkb25lLlxuICAgICAqICovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNvbm5lY3RJbXBsID0gZnVuY3Rpb24gKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KSB7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGUuc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGluZy5zdGF0ZSAmJiBzdGF0ZSAhPT0gdGhpcy5zdGF0ZXMuY29ubmVjdGVkLnN0YXRlKSB7XG4gICAgICAgICAgICAvKiBPbmx5IGtlZXAgdHJ5aW5nIGFzIGxvbmcgYXMgaW4gdGhlICdjb25uZWN0aW5nJyBzdGF0ZSAob3IgJ2Nvbm5lY3RlZCdcbiAgICAgICAgICAgICAqIGZvciB1cGdyYWRpbmcpLiBBbnkgb3BlcmF0aW9uIGNhbiBwdXQgdXMgaW50byAnZGlzY29ubmVjdGVkJyB0byBjYW5jZWxcbiAgICAgICAgICAgICAqIGNvbm5lY3Rpb24gYXR0ZW1wdHMgYW5kIHdhaXQgYmVmb3JlIHJldHJ5aW5nLCBvciAnZmFpbGVkJyB0byBmYWlsLiAqL1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0SW1wbCgpJywgJ011c3QgYmUgaW4gY29ubmVjdGluZyBzdGF0ZSB0byBjb25uZWN0IChvciBjb25uZWN0ZWQgdG8gdXBncmFkZSksIGJ1dCB3YXMgJyArIHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmICh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0SW1wbCgpJywgJ1RyYW5zcG9ydHMgJyArIHRoaXMucGVuZGluZ1RyYW5zcG9ydHNbMF0udG9TdHJpbmcoKSArICcgY3VycmVudGx5IHBlbmRpbmc7IHRha2luZyBubyBhY3Rpb24nKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PSB0aGlzLnN0YXRlcy5jb25uZWN0ZWQuc3RhdGUpIHtcbiAgICAgICAgICAgIHRoaXMudXBncmFkZUlmTmVlZGVkKHRyYW5zcG9ydFBhcmFtcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAodGhpcy50cmFuc3BvcnRzLmxlbmd0aCA+IDEgJiYgdGhpcy5nZXRUcmFuc3BvcnRQcmVmZXJlbmNlKCkpIHtcbiAgICAgICAgICAgIHRoaXMuY29ubmVjdFByZWZlcmVuY2UodHJhbnNwb3J0UGFyYW1zLCBjb25uZWN0Q291bnQpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5jb25uZWN0QmFzZSh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uICh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgcHJlZmVyZW5jZSA9IHRoaXMuZ2V0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuICAgICAgICB2YXIgcHJlZmVyZW5jZVRpbWVvdXRFeHBpcmVkID0gZmFsc2U7XG4gICAgICAgIGlmICghVXRpbHMuYXJySW4odGhpcy50cmFuc3BvcnRzLCBwcmVmZXJlbmNlKSkge1xuICAgICAgICAgICAgdGhpcy51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RQcmVmZXJlbmNlKCknLCAnVHJ5aW5nIHRvIGNvbm5lY3Qgd2l0aCBzdG9yZWQgdHJhbnNwb3J0IHByZWZlcmVuY2UgJyArIHByZWZlcmVuY2UpO1xuICAgICAgICB2YXIgcHJlZmVyZW5jZVRpbWVvdXQgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHByZWZlcmVuY2VUaW1lb3V0RXhwaXJlZCA9IHRydWU7XG4gICAgICAgICAgICBpZiAoIShfdGhpcy5zdGF0ZS5zdGF0ZSA9PT0gX3RoaXMuc3RhdGVzLmNvbm5lY3RlZC5zdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNvbm5lY3RQcmVmZXJlbmNlKCknLCAnU2hvcnRjaXJjdWl0IGNvbm5lY3Rpb24gYXR0ZW1wdCB3aXRoICcgKyBwcmVmZXJlbmNlICsgJyBmYWlsZWQ7IGNsZWFyaW5nIHByZWZlcmVuY2UgYW5kIHRyeWluZyBmcm9tIHNjcmF0Y2gnKTtcbiAgICAgICAgICAgICAgICAvKiBBYm9ydCBhbGwgY29ubmVjdGlvbiBhdHRlbXB0cy4gKFRoaXMgYWxzbyBkaXNjb25uZWN0cyB0aGUgYWN0aXZlXG4gICAgICAgICAgICAgICAgICogcHJvdG9jb2wsIGJ1dCBub25lIGV4aXN0cyBpZiB3ZSdyZSBub3QgaW4gdGhlIGNvbm5lY3RlZCBzdGF0ZSkgKi9cbiAgICAgICAgICAgICAgICBfdGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuICAgICAgICAgICAgICAgIC8qIEJlIHF1aXRlIGFncmVzc2l2ZSBhYm91dCBjbGVhcmluZyB0aGUgc3RvcmVkIHByZWZlcmVuY2UgaWYgZXZlciBpdCBkb2Vzbid0IHdvcmsgKi9cbiAgICAgICAgICAgICAgICBfdGhpcy51bnBlcnNpc3RUcmFuc3BvcnRQcmVmZXJlbmNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBfdGhpcy5jb25uZWN0SW1wbCh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCk7XG4gICAgICAgIH0sIHRoaXMub3B0aW9ucy50aW1lb3V0cy5wcmVmZXJlbmNlQ29ubmVjdFRpbWVvdXQpO1xuICAgICAgICAvKiBGb3IgY29ubmVjdFByZWZlcmVuY2UsIGp1c3QgdXNlIHRoZSBtYWluIGhvc3QuIElmIGhvc3QgZmFsbGJhY2sgaXMgbmVlZGVkLCBkbyBpdCBpbiBjb25uZWN0QmFzZS5cbiAgICAgICAgICogVGhlIHdzdHJhbnNwb3J0IGl0IHdpbGwgc3Vic3RpdHV0ZSB0aGUgaHR0cGhvc3QgZm9yIGFuIGFwcHJvcHJpYXRlIHdzaG9zdCAqL1xuICAgICAgICB0cmFuc3BvcnRQYXJhbXMuaG9zdCA9IHRoaXMuaHR0cEhvc3RzWzBdO1xuICAgICAgICB0aGlzLnRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCBwcmVmZXJlbmNlLCBmdW5jdGlvbiAoZmF0YWwsIHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHByZWZlcmVuY2VUaW1lb3V0KTtcbiAgICAgICAgICAgIGlmIChwcmVmZXJlbmNlVGltZW91dEV4cGlyZWQgJiYgdHJhbnNwb3J0KSB7XG4gICAgICAgICAgICAgICAgLyogVmlhYmxlLCBidXQgdG9vIGxhdGUgLSBjb25uZWN0SW1wbCgpIHdpbGwgYWxyZWFkeSBiZSB0cnlpbmdcbiAgICAgICAgICAgICAgICAgKiBjb25uZWN0QmFzZSwgYW5kIHdlIHdlcmVuJ3QgaW4gdXBncmFkZSBtb2RlLiBKdXN0IHJlbW92ZSB0aGVcbiAgICAgICAgICAgICAgICAgKiBvbmNvbm5lY3RlZCBsaXN0ZW5lciBhbmQgZ2V0IHJpZCBvZiBpdCAqL1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5vZmYoKTtcbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgICAgIFV0aWxzLmFyckRlbGV0ZVZhbHVlKF90aGlzLnBlbmRpbmdUcmFuc3BvcnRzLCB0cmFuc3BvcnQpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIXRyYW5zcG9ydCAmJiAhZmF0YWwpIHtcbiAgICAgICAgICAgICAgICAvKiBQcmVmZXJlbmNlIGZhaWxlZCBpbiBhIHRyYW5zcG9ydC1zcGVjaWZpYyB3YXkuIFRyeSBtb3JlICovXG4gICAgICAgICAgICAgICAgX3RoaXMudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSgpO1xuICAgICAgICAgICAgICAgIF90aGlzLmNvbm5lY3RJbXBsKHRyYW5zcG9ydFBhcmFtcywgY29ubmVjdENvdW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIElmIHN1Y2VlZGVkLCBvciBmYWlsZWQgZmF0YWxseSwgbm90aGluZyB0byBkbyAqL1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qKlxuICAgICAqIFRyeSB0byBlc3RhYmxpc2ggYSB0cmFuc3BvcnQgb24gdGhlIGJhc2UgdHJhbnNwb3J0ICh0aGUgYmVzdCB0cmFuc3BvcnRcbiAgICAgKiBzdWNoIHRoYXQgaWYgaXQgZG9lc24ndCB3b3JrLCBub3RoaW5nIHdpbGwgd29yaykgYXMgZGV0ZXJtaW5lZCB0aHJvdWdoXG4gICAgICogc3RhdGljIGZlYXR1cmUgZGV0ZWN0aW9uLCBjaGVja2luZyBmb3IgbmV0d29yayBjb25uZWN0aXZpdHkgYW5kIHRyeWluZ1xuICAgICAqIGZhbGxiYWNrIGhvc3RzIGlmIGFwcGxpY2FibGUuXG4gICAgICogQHBhcmFtIHRyYW5zcG9ydFBhcmFtc1xuICAgICAqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5jb25uZWN0QmFzZSA9IGZ1bmN0aW9uICh0cmFuc3BvcnRQYXJhbXMsIGNvbm5lY3RDb3VudCkge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgZ2l2ZVVwID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgX3RoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogX3RoaXMuc3RhdGVzLmNvbm5lY3RpbmcuZmFpbFN0YXRlLCBlcnJvcjogZXJyIH0pO1xuICAgICAgICB9O1xuICAgICAgICB2YXIgY2FuZGlkYXRlSG9zdHMgPSB0aGlzLmh0dHBIb3N0cy5zbGljZSgpO1xuICAgICAgICB2YXIgaG9zdEF0dGVtcHRDYiA9IGZ1bmN0aW9uIChmYXRhbCwgdHJhbnNwb3J0KSB7XG4gICAgICAgICAgICBpZiAoY29ubmVjdENvdW50ICE9PSBfdGhpcy5jb25uZWN0Q291bnRlcikge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghdHJhbnNwb3J0ICYmICFmYXRhbCkge1xuICAgICAgICAgICAgICAgIHRyeUZhbGxiYWNrSG9zdHMoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jb25uZWN0QmFzZSgpJywgJ1RyeWluZyB0byBjb25uZWN0IHdpdGggYmFzZSB0cmFuc3BvcnQgJyArIHRoaXMuYmFzZVRyYW5zcG9ydCk7XG4gICAgICAgIC8qIGZpcnN0IHRyeSB0byBlc3RhYmxpc2ggYSBjb25uZWN0aW9uIHdpdGggdGhlIHByaW9yaXR5IGhvc3Qgd2l0aCBodHRwIHRyYW5zcG9ydCAqL1xuICAgICAgICB2YXIgaG9zdCA9IGNhbmRpZGF0ZUhvc3RzLnNoaWZ0KCk7XG4gICAgICAgIGlmICghaG9zdCkge1xuICAgICAgICAgICAgZ2l2ZVVwKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdVbmFibGUgdG8gY29ubmVjdCAobm8gYXZhaWxhYmxlIGhvc3QpJywgODAwMDMsIDQwNCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRyYW5zcG9ydFBhcmFtcy5ob3N0ID0gaG9zdDtcbiAgICAgICAgLyogdGhpcyBpcyB3aGF0IHdlJ2xsIGJlIGRvaW5nIGlmIHRoZSBhdHRlbXB0IGZvciB0aGUgbWFpbiBob3N0IGZhaWxzICovXG4gICAgICAgIHZhciB0cnlGYWxsYmFja0hvc3RzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgLyogaWYgdGhlcmUgYXJlbid0IGFueSBmYWxsYmFjayBob3N0cywgZmFpbCAqL1xuICAgICAgICAgICAgaWYgKCFjYW5kaWRhdGVIb3N0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgICAgICBnaXZlVXAobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1VuYWJsZSB0byBjb25uZWN0IChhbmQgbm8gbW9yZSBmYWxsYmFjayBob3N0cyB0byB0cnkpJywgODAwMDMsIDQwNCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGJlZm9yZSB0cnlpbmcgYW55IGZhbGxiYWNrIChvciBhbnkgcmVtYWluaW5nIGZhbGxiYWNrKSB3ZSBkZWNpZGUgaWZcbiAgICAgICAgICAgICAqIHRoZXJlIGlzIGEgcHJvYmxlbSB3aXRoIHRoZSBhYmx5IGhvc3QsIG9yIHRoZXJlIGlzIGEgZ2VuZXJhbCBjb25uZWN0aXZpdHlcbiAgICAgICAgICAgICAqIHByb2JsZW0gKi9cbiAgICAgICAgICAgIGlmICghX3RoaXMucmVhbHRpbWUuaHR0cC5jaGVja0Nvbm5lY3Rpdml0eSkge1xuICAgICAgICAgICAgICAgIGdpdmVVcChuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygnSW50ZXJuYWwgZXJyb3I6IEh0dHAuY2hlY2tDb25uZWN0aXZpdHkgbm90IHNldCcsIG51bGwsIDUwMCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF90aGlzLnJlYWx0aW1lLmh0dHAuY2hlY2tDb25uZWN0aXZpdHkoZnVuY3Rpb24gKGVyciwgY29ubmVjdGl2aXR5KSB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbm5lY3RDb3VudCAhPT0gX3RoaXMuY29ubmVjdENvdW50ZXIpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiB3ZSBrbm93IGVyciB3b24ndCBoYXBwZW4gYnV0IGhhbmRsZSBpdCBoZXJlIGFueXdheSAqL1xuICAgICAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2l2ZVVwKGVycik7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCFjb25uZWN0aXZpdHkpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogdGhlIGludGVybmV0IGlzbid0IHJlYWNoYWJsZSwgc28gZG9uJ3QgdHJ5IHRoZSBmYWxsYmFjayBob3N0cyAqL1xuICAgICAgICAgICAgICAgICAgICBnaXZlVXAobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1VuYWJsZSB0byBjb25uZWN0IChuZXR3b3JrIHVucmVhY2hhYmxlKScsIDgwMDAzLCA0MDQpKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAvKiB0aGUgbmV0d29yayBpcyB0aGVyZSwgc28gdGhlcmUncyBhIHByb2JsZW0gd2l0aCB0aGUgbWFpbiBob3N0LCBvclxuICAgICAgICAgICAgICAgICAqIGl0cyBkbnMuIFRyeSB0aGUgZmFsbGJhY2sgaG9zdHMuIFdlIGNvdWxkIHRyeSB0aGVtIHNpbXVsdGFuZW91c2x5IGJ1dFxuICAgICAgICAgICAgICAgICAqIHRoYXQgd291bGQgcG90ZW50aWFsbHkgY2F1c2UgYSBodWdlIHNwaWtlIGluIGxvYWQgb24gdGhlIGxvYWQgYmFsYW5jZXIgKi9cbiAgICAgICAgICAgICAgICB0cmFuc3BvcnRQYXJhbXMuaG9zdCA9IFV0aWxzLmFyclBvcFJhbmRvbUVsZW1lbnQoY2FuZGlkYXRlSG9zdHMpO1xuICAgICAgICAgICAgICAgIF90aGlzLnRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCBfdGhpcy5iYXNlVHJhbnNwb3J0LCBob3N0QXR0ZW1wdENiKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9O1xuICAgICAgICBpZiAodGhpcy5mb3JjZUZhbGxiYWNrSG9zdCAmJiBjYW5kaWRhdGVIb3N0cy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHRoaXMuZm9yY2VGYWxsYmFja0hvc3QgPSBmYWxzZTtcbiAgICAgICAgICAgIHRyeUZhbGxiYWNrSG9zdHMoKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnRyeUFUcmFuc3BvcnQodHJhbnNwb3J0UGFyYW1zLCB0aGlzLmJhc2VUcmFuc3BvcnQsIGhvc3RBdHRlbXB0Q2IpO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmdldFVwZ3JhZGVQb3NzaWJpbGl0aWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAvKiByZXR1cm5zIHRoZSBzdWJzZXQgb2YgdXBncmFkZVRyYW5zcG9ydHMgdG8gdGhlIHJpZ2h0IG9mIHRoZSBjdXJyZW50XG4gICAgICAgICAqIHRyYW5zcG9ydCBpbiB1cGdyYWRlVHJhbnNwb3J0cyAoaWYgaXQncyBpbiB0aGVyZSAtIGlmIG5vdCwgY3VycmVudFNlcmlhbFxuICAgICAgICAgKiB3aWxsIGJlIC0xLCBzbyByZXR1cm4gdXBncmFkZVRyYW5zcG9ydHMuc2xpY2UoMCkgPT0gdXBncmFkZVRyYW5zcG9ydHMgKi9cbiAgICAgICAgdmFyIGN1cnJlbnQgPSB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLnNob3J0TmFtZTtcbiAgICAgICAgdmFyIGN1cnJlbnRTZXJpYWwgPSBVdGlscy5hcnJJbmRleE9mKHRoaXMudXBncmFkZVRyYW5zcG9ydHMsIGN1cnJlbnQpO1xuICAgICAgICByZXR1cm4gdGhpcy51cGdyYWRlVHJhbnNwb3J0cy5zbGljZShjdXJyZW50U2VyaWFsICsgMSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUudXBncmFkZUlmTmVlZGVkID0gZnVuY3Rpb24gKHRyYW5zcG9ydFBhcmFtcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgdXBncmFkZVBvc3NpYmlsaXRpZXMgPSB0aGlzLmdldFVwZ3JhZGVQb3NzaWJpbGl0aWVzKCk7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIudXBncmFkZUlmTmVlZGVkKCknLCAndXBncmFkZSBwb3NzaWJpbGl0aWVzOiAnICsgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5pbnNwZWN0KHVwZ3JhZGVQb3NzaWJpbGl0aWVzKSk7XG4gICAgICAgIGlmICghdXBncmFkZVBvc3NpYmlsaXRpZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgVXRpbHMuYXJyRm9yRWFjaCh1cGdyYWRlUG9zc2liaWxpdGllcywgZnVuY3Rpb24gKHVwZ3JhZGVUcmFuc3BvcnQpIHtcbiAgICAgICAgICAgIC8qIE5vdGU6IHRoZSB0cmFuc3BvcnQgbWF5IG11dGF0ZSB0aGUgcGFyYW1zLCBzbyBnaXZlIGVhY2ggdHJhbnNwb3J0IGEgZnJlc2ggb25lICovXG4gICAgICAgICAgICB2YXIgdXBncmFkZVRyYW5zcG9ydFBhcmFtcyA9IF90aGlzLmNyZWF0ZVRyYW5zcG9ydFBhcmFtcyh0cmFuc3BvcnRQYXJhbXMuaG9zdCwgJ3VwZ3JhZGUnKTtcbiAgICAgICAgICAgIF90aGlzLnRyeUFUcmFuc3BvcnQodXBncmFkZVRyYW5zcG9ydFBhcmFtcywgdXBncmFkZVRyYW5zcG9ydCwgbm9vcCk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLmNsb3NlSW1wbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5jbG9zZUltcGwoKScsICdjbG9zaW5nIGNvbm5lY3Rpb24nKTtcbiAgICAgICAgdGhpcy5jYW5jZWxTdXNwZW5kVGltZXIoKTtcbiAgICAgICAgdGhpcy5zdGFydFRyYW5zaXRpb25UaW1lcih0aGlzLnN0YXRlcy5jbG9zaW5nKTtcbiAgICAgICAgVXRpbHMuc2FmZUFyckZvckVhY2godGhpcy5wZW5kaW5nVHJhbnNwb3J0cywgZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5jbG9zZUltcGwoKScsICdDbG9zaW5nIHBlbmRpbmcgdHJhbnNwb3J0OiAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIGlmICh0cmFuc3BvcnQpXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmNsb3NlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICBVdGlscy5zYWZlQXJyRm9yRWFjaCh0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cywgZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5jbG9zZUltcGwoKScsICdEaXNwb3Npbmcgb2YgcHJvcG9zZWQgdHJhbnNwb3J0OiAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIGlmICh0cmFuc3BvcnQpXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVByb3RvY29sKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmNsb3NlSW1wbCgpJywgJ0Nsb3NpbmcgYWN0aXZlIHRyYW5zcG9ydDogJyArIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkpO1xuICAgICAgICAgICAgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5jbG9zZSgpO1xuICAgICAgICB9XG4gICAgICAgIC8qIElmIHRoZXJlIHdhcyBhbiBhY3RpdmUgdHJhbnNwb3J0LCB0aGlzIHdpbGwgcHJvYmFibHkgYmVcbiAgICAgICAgICogcHJlZW1wdGVkIGJ5IHRoZSBub3RpZnlTdGF0ZSBjYWxsIGluIGRlYWN0aXZhdGVUcmFuc3BvcnQgKi9cbiAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiAnY2xvc2VkJyB9KTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5vbkF1dGhVcGRhdGVkID0gZnVuY3Rpb24gKHRva2VuRGV0YWlscywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIF9hO1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6IHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLm9uQXV0aFVwZGF0ZWQoKScsICdTZW5kaW5nIEFVVEggbWVzc2FnZSBvbiBhY3RpdmUgdHJhbnNwb3J0Jyk7XG4gICAgICAgICAgICAgICAgLyogSWYgdGhlcmUgYXJlIGFueSBwcm9wb3NlZC9wZW5kaW5nIHRyYW5zcG9ydHMgKGVnIGFuIHVwZ3JhZGUgdGhhdFxuICAgICAgICAgICAgICAgICAqIGlzbid0IHlldCBzY2hlZHVsZWQgZm9yIGFjdGl2YXRpb24pIHRoYXQgaGFzbid0IHlldCBzdGFydGVkIHN5bmNpbmcsXG4gICAgICAgICAgICAgICAgICoganVzdCB0byBnZXQgcmlkIG9mIHRoZW0gJiByZXN0YXJ0IHRoZSB1cGdyYWRlIHdpdGggdGhlIG5ldyB0b2tlbiwgdG9cbiAgICAgICAgICAgICAgICAgKiBhdm9pZCBhIHJhY2UgY29uZGl0aW9uLiAoSWYgaXQgaGFzIHN0YXJ0ZWQgc3luY2luZywgdGhlIEFVVEggd2lsbCBiZVxuICAgICAgICAgICAgICAgICAqIHF1ZXVlZCB1bnRpbCB0aGUgdXBncmFkZSBpcyBjb21wbGV0ZSwgc28gZXZlcnl0aGluZydzIGZpbmUpICovXG4gICAgICAgICAgICAgICAgaWYgKCh0aGlzLnBlbmRpbmdUcmFuc3BvcnRzLmxlbmd0aCB8fCB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cy5sZW5ndGgpICYmXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgIT09IHRoaXMuc3RhdGVzLnN5bmNocm9uaXppbmcpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygvKiBleGNlcHRBY3RpdmU6ICovIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB2YXIgdHJhbnNwb3J0UGFyYW1zXzEgPSB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLnBhcmFtcztcbiAgICAgICAgICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUuc3RhdGUgPT09ICdjb25uZWN0ZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMudXBncmFkZUlmTmVlZGVkKHRyYW5zcG9ydFBhcmFtc18xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIC8qIERvIGFueSB0cmFuc3BvcnQtc3BlY2lmaWMgbmV3LXRva2VuIGFjdGlvbiAqL1xuICAgICAgICAgICAgICAgIHZhciBhY3RpdmVUcmFuc3BvcnQgPSAoX2EgPSB0aGlzLmFjdGl2ZVByb3RvY29sKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EuZ2V0VHJhbnNwb3J0KCk7XG4gICAgICAgICAgICAgICAgaWYgKGFjdGl2ZVRyYW5zcG9ydCAmJiBhY3RpdmVUcmFuc3BvcnQub25BdXRoVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBhY3RpdmVUcmFuc3BvcnQub25BdXRoVXBkYXRlZCh0b2tlbkRldGFpbHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgYXV0aE1zZyA9IHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyh7XG4gICAgICAgICAgICAgICAgICAgIGFjdGlvbjogYWN0aW9ucy5BVVRILFxuICAgICAgICAgICAgICAgICAgICBhdXRoOiB7XG4gICAgICAgICAgICAgICAgICAgICAgICBhY2Nlc3NUb2tlbjogdG9rZW5EZXRhaWxzLnRva2VuLFxuICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIHRoaXMuc2VuZChhdXRoTXNnKTtcbiAgICAgICAgICAgICAgICAvKiBUaGUgYW5zd2VyIHdpbGwgY29tZSBiYWNrIGFzIGVpdGhlciBhIGNvbm5lY3Rpb25kZXRhaWxzIGV2ZW50XG4gICAgICAgICAgICAgICAgICogKHJlYWx0aW1lIHNlbmRzIGEgQ09OTkVDVEVEIHRvIGFja25vd2xlZGdlIHRoZSByZWF1dGgpIG9yIGFcbiAgICAgICAgICAgICAgICAgKiBzdGF0ZWNoYW5nZSB0byBmYWlsZWQgKi9cbiAgICAgICAgICAgICAgICB2YXIgc3VjY2Vzc0xpc3RlbmVyXzEgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZihmYWlsdXJlTGlzdGVuZXJfMSk7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRva2VuRGV0YWlscyk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB2YXIgZmFpbHVyZUxpc3RlbmVyXzEgPSBmdW5jdGlvbiAoc3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHN0YXRlQ2hhbmdlLmN1cnJlbnQgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmYoc3VjY2Vzc0xpc3RlbmVyXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub2ZmKGZhaWx1cmVMaXN0ZW5lcl8xKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCBfdGhpcy5nZXRTdGF0ZUVycm9yKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoJ2Nvbm5lY3Rpb25kZXRhaWxzJywgc3VjY2Vzc0xpc3RlbmVyXzEpO1xuICAgICAgICAgICAgICAgIHRoaXMub24oJ2Nvbm5lY3Rpb25zdGF0ZScsIGZhaWx1cmVMaXN0ZW5lcl8xKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RpbmcnOlxuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIub25BdXRoVXBkYXRlZCgpJywgJ0Fib3J0aW5nIGN1cnJlbnQgY29ubmVjdGlvbiBhdHRlbXB0cyBpbiBvcmRlciB0byBzdGFydCBhZ2FpbiB3aXRoIHRoZSBuZXcgYXV0aCBkZXRhaWxzJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpO1xuICAgICAgICAgICAgLyogZmFsbHRocm91Z2ggdG8gYWRkIHN0YXRlY2hhbmdlIGxpc3RlbmVyICovXG4gICAgICAgICAgICBkZWZhdWx0OiB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5vbkF1dGhVcGRhdGVkKCknLCAnQ29ubmVjdGlvbiBzdGF0ZSBpcyAnICsgdGhpcy5zdGF0ZS5zdGF0ZSArICc7IHdhaXRpbmcgdW50aWwgZWl0aGVyIGNvbm5lY3RlZCBvciBmYWlsZWQnKTtcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJfMSA9IGZ1bmN0aW9uIChzdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKHN0YXRlQ2hhbmdlLmN1cnJlbnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2Nvbm5lY3RlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub2ZmKGxpc3RlbmVyXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRva2VuRGV0YWlscyk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnY2xvc2VkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ3N1c3BlbmRlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMub2ZmKGxpc3RlbmVyXzEpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKHN0YXRlQ2hhbmdlLnJlYXNvbiB8fCBfdGhpcy5nZXRTdGF0ZUVycm9yKCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAvKiBpZ25vcmUgdGlsbCB3ZSBnZXQgZWl0aGVyIGNvbm5lY3RlZCBvciBmYWlsZWQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgdGhpcy5vbignY29ubmVjdGlvbnN0YXRlJywgbGlzdGVuZXJfMSk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUuc3RhdGUgPT09ICdjb25uZWN0aW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvKiBjYW4gaGFwcGVuIGlmIGluIHRoZSBjb25uZWN0aW5nIHN0YXRlIGJ1dCBubyB0cmFuc3BvcnQgd2FzIHBlbmRpbmdcbiAgICAgICAgICAgICAgICAgICAgICogeWV0LCBzbyBkaXNjb25uZWN0QWxsVHJhbnNwb3J0cyBkaWQgbm90IHRyaWdnZXIgYSBkaXNjb25uZWN0ZWQgc3RhdGUgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5zdGFydENvbm5lY3QoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKHsgc3RhdGU6ICdjb25uZWN0aW5nJyB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cyA9IGZ1bmN0aW9uIChleGNlcHRBY3RpdmUpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5kaXNjb25uZWN0QWxsVHJhbnNwb3J0cygpJywgJ0Rpc2Nvbm5lY3RpbmcgYWxsIHRyYW5zcG9ydHMnICsgKGV4Y2VwdEFjdGl2ZSA/ICcgZXhjZXB0IHRoZSBhY3RpdmUgdHJhbnNwb3J0JyA6ICcnKSk7XG4gICAgICAgIC8qIFRoaXMgd2lsbCBwcmV2ZW50IGFueSBjb25uZWN0aW9uIHByb2NlZHVyZSBpbiBhbiBhc3luYyBwYXJ0IG9mIG9uZSBvZiBpdHMgZWFybHkgc3RhZ2VzIGZyb20gY29udGludWluZyAqL1xuICAgICAgICB0aGlzLmNvbm5lY3RDb3VudGVyKys7XG4gICAgICAgIFV0aWxzLnNhZmVBcnJGb3JFYWNoKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKScsICdEaXNjb25uZWN0aW5nIHBlbmRpbmcgdHJhbnNwb3J0OiAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIGlmICh0cmFuc3BvcnQpXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucGVuZGluZ1RyYW5zcG9ydHMgPSBbXTtcbiAgICAgICAgVXRpbHMuc2FmZUFyckZvckVhY2godGhpcy5wcm9wb3NlZFRyYW5zcG9ydHMsIGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKScsICdEaXNwb3Npbmcgb2YgcHJvcG9zZWQgdHJhbnNwb3J0OiAnICsgdHJhbnNwb3J0KTtcbiAgICAgICAgICAgIGlmICh0cmFuc3BvcnQpXG4gICAgICAgICAgICAgICAgdHJhbnNwb3J0LmRpc3Bvc2UoKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMucHJvcG9zZWRUcmFuc3BvcnRzID0gW107XG4gICAgICAgIGlmICh0aGlzLmFjdGl2ZVByb3RvY29sICYmICFleGNlcHRBY3RpdmUpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuZGlzY29ubmVjdEFsbFRyYW5zcG9ydHMoKScsICdEaXNjb25uZWN0aW5nIGFjdGl2ZSB0cmFuc3BvcnQ6ICcgKyB0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpKTtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCkuZGlzY29ubmVjdCgpO1xuICAgICAgICB9XG4gICAgICAgIC8qIE5vIG5lZWQgdG8gbm90aWZ5IHN0YXRlIGRpc2Nvbm5lY3RlZDsgZGlzY29ubmVjdGluZyB0aGUgYWN0aXZlIHRyYW5zcG9ydFxuICAgICAgICAgKiB3aWxsIGhhdmUgdGhhdCBlZmZlY3QgKi9cbiAgICB9O1xuICAgIC8qKioqKioqKioqKioqKioqKipcbiAgICAgKiBldmVudCBxdWV1ZWluZ1xuICAgICAqKioqKioqKioqKioqKioqKiovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobXNnLCBxdWV1ZUV2ZW50LCBjYWxsYmFjaykge1xuICAgICAgICBjYWxsYmFjayA9IGNhbGxiYWNrIHx8IG5vb3A7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIGlmIChzdGF0ZS5zZW5kRXZlbnRzKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNlbmQoKScsICdzZW5kaW5nIGV2ZW50Jyk7XG4gICAgICAgICAgICB0aGlzLnNlbmRJbXBsKG5ldyBwcm90b2NvbF8xLlBlbmRpbmdNZXNzYWdlKG1zZywgY2FsbGJhY2spKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgc2hvdWxkUXVldWUgPSAocXVldWVFdmVudCAmJiBzdGF0ZS5xdWV1ZUV2ZW50cykgfHwgc3RhdGUuZm9yY2VRdWV1ZUV2ZW50cztcbiAgICAgICAgaWYgKCFzaG91bGRRdWV1ZSkge1xuICAgICAgICAgICAgdmFyIGVyciA9ICdyZWplY3RpbmcgZXZlbnQsIHF1ZXVlRXZlbnQgd2FzICcgKyBxdWV1ZUV2ZW50ICsgJywgc3RhdGUgd2FzICcgKyBzdGF0ZS5zdGF0ZTtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2VuZCgpJywgZXJyKTtcbiAgICAgICAgICAgIGNhbGxiYWNrKHRoaXMuZXJyb3JSZWFzb24gfHwgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoZXJyLCA5MDAwMCwgNDAwKSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxvZ2dlcl8xLmRlZmF1bHQuc2hvdWxkTG9nKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPKSkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdDb25uZWN0aW9uTWFuYWdlci5zZW5kKCknLCAncXVldWVpbmcgbXNnOyAnICsgcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5zdHJpbmdpZnkobXNnKSk7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5xdWV1ZShtc2csIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5zZW5kSW1wbCA9IGZ1bmN0aW9uIChwZW5kaW5nTWVzc2FnZSkge1xuICAgICAgICB2YXIgbXNnID0gcGVuZGluZ01lc3NhZ2UubWVzc2FnZTtcbiAgICAgICAgLyogSWYgaGF2ZSBhbHJlYWR5IGF0dGVtcHRlZCB0byBzZW5kIHRoaXMsIHJlc2VuZCB3aXRoIHRoZSBzYW1lIG1zZ1NlcmlhbCxcbiAgICAgICAgICogc28gQWJseSBjYW4gZGVkdXAgaWYgdGhlIHByZXZpb3VzIHNlbmQgc3VjY2VlZGVkICovXG4gICAgICAgIGlmIChwZW5kaW5nTWVzc2FnZS5hY2tSZXF1aXJlZCAmJiAhcGVuZGluZ01lc3NhZ2Uuc2VuZEF0dGVtcHRlZCkge1xuICAgICAgICAgICAgbXNnLm1zZ1NlcmlhbCA9IHRoaXMubXNnU2VyaWFsKys7XG4gICAgICAgIH1cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHRoaXMuYWN0aXZlUHJvdG9jb2wuc2VuZChwZW5kaW5nTWVzc2FnZSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIuc2VuZEltcGwoKScsICdVbmV4cGVjdGVkIGV4Y2VwdGlvbiBpbiB0cmFuc3BvcnQuc2VuZCgpOiAnICsgZS5zdGFjayk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5xdWV1ZSA9IGZ1bmN0aW9uIChtc2csIGNhbGxiYWNrKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIucXVldWUoKScsICdxdWV1ZWluZyBldmVudCcpO1xuICAgICAgICB2YXIgbGFzdFF1ZXVlZCA9IHRoaXMucXVldWVkTWVzc2FnZXMubGFzdCgpO1xuICAgICAgICB2YXIgbWF4U2l6ZSA9IHRoaXMub3B0aW9ucy5tYXhNZXNzYWdlU2l6ZTtcbiAgICAgICAgLyogSWYgaGF2ZSBhbHJlYWR5IGF0dGVtcHRlZCB0byBzZW5kIGEgbWVzc2FnZSwgZG9uJ3QgbWVyZ2UgbW9yZSBtZXNzYWdlc1xuICAgICAgICAgKiBpbnRvIGl0LCBhcyBpZiB0aGUgcHJldmlvdXMgc2VuZCBhY3R1YWxseSBzdWNjZWVkZWQgYW5kIHJlYWx0aW1lIGlnbm9yZXNcbiAgICAgICAgICogdGhlIGR1cCwgdGhleSdsbCBiZSBsb3N0ICovXG4gICAgICAgIGlmIChsYXN0UXVldWVkICYmICFsYXN0UXVldWVkLnNlbmRBdHRlbXB0ZWQgJiYgYnVuZGxlV2l0aChsYXN0UXVldWVkLm1lc3NhZ2UsIG1zZywgbWF4U2l6ZSkpIHtcbiAgICAgICAgICAgIGlmICghbGFzdFF1ZXVlZC5tZXJnZWQpIHtcbiAgICAgICAgICAgICAgICBsYXN0UXVldWVkLmNhbGxiYWNrID0gbXVsdGljYXN0ZXJfMS5kZWZhdWx0LmNyZWF0ZShbbGFzdFF1ZXVlZC5jYWxsYmFja10pO1xuICAgICAgICAgICAgICAgIGxhc3RRdWV1ZWQubWVyZ2VkID0gdHJ1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxhc3RRdWV1ZWQuY2FsbGJhY2sucHVzaChjYWxsYmFjayk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLnF1ZXVlZE1lc3NhZ2VzLnB1c2gobmV3IHByb3RvY29sXzEuUGVuZGluZ01lc3NhZ2UobXNnLCBjYWxsYmFjaykpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuc2VuZFF1ZXVlZE1lc3NhZ2VzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnNlbmRRdWV1ZWRNZXNzYWdlcygpJywgJ3NlbmRpbmcgJyArIHRoaXMucXVldWVkTWVzc2FnZXMuY291bnQoKSArICcgcXVldWVkIG1lc3NhZ2VzJyk7XG4gICAgICAgIHZhciBwZW5kaW5nTWVzc2FnZTtcbiAgICAgICAgd2hpbGUgKChwZW5kaW5nTWVzc2FnZSA9IHRoaXMucXVldWVkTWVzc2FnZXMuc2hpZnQoKSkpXG4gICAgICAgICAgICB0aGlzLnNlbmRJbXBsKHBlbmRpbmdNZXNzYWdlKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5xdWV1ZVBlbmRpbmdNZXNzYWdlcyA9IGZ1bmN0aW9uIChwZW5kaW5nTWVzc2FnZXMpIHtcbiAgICAgICAgaWYgKHBlbmRpbmdNZXNzYWdlcyAmJiBwZW5kaW5nTWVzc2FnZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ0Nvbm5lY3Rpb25NYW5hZ2VyLnF1ZXVlUGVuZGluZ01lc3NhZ2VzKCknLCAncXVldWVpbmcgJyArIHBlbmRpbmdNZXNzYWdlcy5sZW5ndGggKyAnIHBlbmRpbmcgbWVzc2FnZXMnKTtcbiAgICAgICAgICAgIHRoaXMucXVldWVkTWVzc2FnZXMucHJlcGVuZChwZW5kaW5nTWVzc2FnZXMpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZmFpbFF1ZXVlZE1lc3NhZ2VzID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB2YXIgbnVtUXVldWVkID0gdGhpcy5xdWV1ZWRNZXNzYWdlcy5jb3VudCgpO1xuICAgICAgICBpZiAobnVtUXVldWVkID4gMCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdDb25uZWN0aW9uTWFuYWdlci5mYWlsUXVldWVkTWVzc2FnZXMoKScsICdmYWlsaW5nICcgKyBudW1RdWV1ZWQgKyAnIHF1ZXVlZCBtZXNzYWdlcywgZXJyID0gJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgICAgIHRoaXMucXVldWVkTWVzc2FnZXMuY29tcGxldGVBbGxNZXNzYWdlcyhlcnIpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25DaGFubmVsTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlLCB0cmFuc3BvcnQpIHtcbiAgICAgICAgdmFyIG9uQWN0aXZlVHJhbnNwb3J0ID0gdGhpcy5hY3RpdmVQcm90b2NvbCAmJiB0cmFuc3BvcnQgPT09IHRoaXMuYWN0aXZlUHJvdG9jb2wuZ2V0VHJhbnNwb3J0KCksIG9uVXBncmFkZVRyYW5zcG9ydCA9IFV0aWxzLmFyckluKHRoaXMucGVuZGluZ1RyYW5zcG9ydHMsIHRyYW5zcG9ydCkgJiYgdGhpcy5zdGF0ZSA9PSB0aGlzLnN0YXRlcy5zeW5jaHJvbml6aW5nO1xuICAgICAgICAvKiBBcyB0aGUgbGliIG5vdyBoYXMgYSBwZXJpb2Qgd2hlcmUgdGhlIHVwZ3JhZGUgdHJhbnNwb3J0IGlzIHN5bmNlZCBidXRcbiAgICAgICAgICogYmVmb3JlIGl0J3MgYmVjb21lIGFjdGl2ZSAod2hpbGUgd2FpdGluZyBmb3IgdGhlIG9sZCBvbmUgdG8gYmVjb21lXG4gICAgICAgICAqIGlkbGUpLCBtZXNzYWdlIGNhbiB2YWxpZGx5IGFycml2ZSBvbiBpdCBldmVuIHRob3VnaCBpdCBpc24ndCBhY3RpdmUgKi9cbiAgICAgICAgaWYgKG9uQWN0aXZlVHJhbnNwb3J0IHx8IG9uVXBncmFkZVRyYW5zcG9ydCkge1xuICAgICAgICAgICAgdGhpcy5yZWFsdGltZS5jaGFubmVscy5vbkNoYW5uZWxNZXNzYWdlKG1lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgLy8gTWVzc2FnZSBjYW1lIGluIG9uIGEgZGVmdW5jdCB0cmFuc3BvcnQuIEFsbG93IG9ubHkgYWNrcywgbmFja3MsICYgZXJyb3JzIGZvciBvdXRzdGFuZGluZ1xuICAgICAgICAgICAgLy8gbWVzc2FnZXMsICBubyBuZXcgbWVzc2FnZXMgKGFzIHN5bmMgaGFzIGJlZW4gc2VudCBvbiBuZXcgdHJhbnNwb3J0IHNvIG5ldyBtZXNzYWdlcyB3aWxsXG4gICAgICAgICAgICAvLyBiZSByZXNlbnQgdGhlcmUsIG9yIGNvbm5lY3Rpb24gaGFzIGJlZW4gY2xvc2VkIHNvIGRvbid0IHdhbnQgbmV3IG1lc3NhZ2VzKVxuICAgICAgICAgICAgaWYgKFV0aWxzLmFyckluZGV4T2YoW2FjdGlvbnMuQUNLLCBhY3Rpb25zLk5BQ0ssIGFjdGlvbnMuRVJST1JdLCBtZXNzYWdlLmFjdGlvbikgPiAtMSkge1xuICAgICAgICAgICAgICAgIHRoaXMucmVhbHRpbWUuY2hhbm5lbHMub25DaGFubmVsTWVzc2FnZShtZXNzYWdlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnQ29ubmVjdGlvbk1hbmFnZXIub25DaGFubmVsTWVzc2FnZSgpJywgJ3JlY2VpdmVkIG1lc3NhZ2UgJyArIEpTT04uc3RyaW5naWZ5KG1lc3NhZ2UpICsgJ29uIGRlZnVuY3QgdHJhbnNwb3J0OyBkaXNjYXJkaW5nJyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKHRyYW5zcG9ydCwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLyogaWYgdHJhbnNwb3J0IGlzIHNwZWNpZmllZCwgdHJ5IHRoYXQgKi9cbiAgICAgICAgaWYgKHRyYW5zcG9ydCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5waW5nKCknLCAndHJhbnNwb3J0ID0gJyArIHRyYW5zcG9ydCk7XG4gICAgICAgICAgICB2YXIgb25UaW1lb3V0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5vZmYoJ2hlYXJ0YmVhdCcsIG9uSGVhcnRiZWF0XzEpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdUaW1lb3V0IHdhaXRpbmcgZm9yIGhlYXJ0YmVhdCByZXNwb25zZScsIDUwMDAwLCA1MDApKTtcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgcGluZ1N0YXJ0XzEgPSBVdGlscy5ub3coKSwgaWRfMSA9IFV0aWxzLmNoZWFwUmFuZFN0cigpO1xuICAgICAgICAgICAgdmFyIG9uSGVhcnRiZWF0XzEgPSBmdW5jdGlvbiAocmVzcG9uc2VJZCkge1xuICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZUlkID09PSBpZF8xKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyYW5zcG9ydC5vZmYoJ2hlYXJ0YmVhdCcsIG9uSGVhcnRiZWF0XzEpO1xuICAgICAgICAgICAgICAgICAgICBjbGVhclRpbWVvdXQodGltZXJfMSk7XG4gICAgICAgICAgICAgICAgICAgIHZhciByZXNwb25zZVRpbWUgPSBVdGlscy5ub3coKSAtIHBpbmdTdGFydF8xO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhudWxsLCByZXNwb25zZVRpbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgdGltZXJfMSA9IHNldFRpbWVvdXQob25UaW1lb3V0LCB0aGlzLm9wdGlvbnMudGltZW91dHMucmVhbHRpbWVSZXF1ZXN0VGltZW91dCk7XG4gICAgICAgICAgICB0cmFuc3BvcnQub24oJ2hlYXJ0YmVhdCcsIG9uSGVhcnRiZWF0XzEpO1xuICAgICAgICAgICAgdHJhbnNwb3J0LnBpbmcoaWRfMSk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgLyogaWYgd2UncmUgbm90IGNvbm5lY3RlZCwgZG9uJ3QgYXR0ZW1wdCAqL1xuICAgICAgICBpZiAodGhpcy5zdGF0ZS5zdGF0ZSAhPT0gJ2Nvbm5lY3RlZCcpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdVbmFibGUgdG8gcGluZyBzZXJ2aWNlOyBub3QgY29ubmVjdGVkJywgNDAwMDAsIDQwMCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIC8qIG5vIHRyYW5zcG9ydCB3YXMgc3BlY2lmaWVkLCBzbyB1c2UgdGhlIGN1cnJlbnQgKGNvbm5lY3RlZCkgb25lXG4gICAgICAgICAqIGJ1dCBlbnN1cmUgdGhhdCB3ZSByZXRyeSBpZiB0aGUgdHJhbnNwb3J0IGlzIHN1cGVyc2VkZWQgYmVmb3JlIHdlIGNvbXBsZXRlICovXG4gICAgICAgIHZhciBjb21wbGV0ZWQgPSBmYWxzZTtcbiAgICAgICAgdmFyIG9uUGluZ0NvbXBsZXRlID0gZnVuY3Rpb24gKGVyciwgcmVzcG9uc2VUaW1lKSB7XG4gICAgICAgICAgICBfdGhpcy5vZmYoJ3RyYW5zcG9ydC5hY3RpdmUnLCBvblRyYW5zcG9ydEFjdGl2ZSk7XG4gICAgICAgICAgICBpZiAoIWNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgIGNvbXBsZXRlZCA9IHRydWU7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soZXJyLCByZXNwb25zZVRpbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICB2YXIgb25UcmFuc3BvcnRBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICBpZiAoIWNvbXBsZXRlZCkge1xuICAgICAgICAgICAgICAgIC8qIGVuc3VyZSB0aGF0IG5vIGNhbGxiYWNrIGhhcHBlbnMgZm9yIHRoZSBjdXJyZW50bHkgb3V0c3RhbmRpbmcgb3BlcmF0aW9uICovXG4gICAgICAgICAgICAgICAgY29tcGxldGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgICAvKiByZXBlYXQgYnV0IHBpY2tpbmcgdXAgdGhlIG5ldyB0cmFuc3BvcnQgKi9cbiAgICAgICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMucGluZyhudWxsLCBjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub24oJ3RyYW5zcG9ydC5hY3RpdmUnLCBvblRyYW5zcG9ydEFjdGl2ZSk7XG4gICAgICAgIHRoaXMucGluZyh0aGlzLmFjdGl2ZVByb3RvY29sLmdldFRyYW5zcG9ydCgpLCBvblBpbmdDb21wbGV0ZSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuYWJvcnQgPSBmdW5jdGlvbiAoZXJyb3IpIHtcbiAgICAgICAgdGhpcy5hY3RpdmVQcm90b2NvbC5nZXRUcmFuc3BvcnQoKS5mYWlsKGVycm9yKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5yZWdpc3RlclByb3Bvc2VkVHJhbnNwb3J0ID0gZnVuY3Rpb24gKHRyYW5zcG9ydCkge1xuICAgICAgICB0aGlzLnByb3Bvc2VkVHJhbnNwb3J0cy5wdXNoKHRyYW5zcG9ydCk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUuZ2V0VHJhbnNwb3J0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSB8fCAoaGF2ZVdlYlN0b3JhZ2UoKSAmJiAoKF9iID0gKF9hID0gcGxhdGZvcm1fMS5kZWZhdWx0LldlYlN0b3JhZ2UpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5nZXQpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5jYWxsKF9hLCB0cmFuc3BvcnRQcmVmZXJlbmNlTmFtZSkpKTtcbiAgICB9O1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uICh0cmFuc3BvcnQpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgaWYgKFV0aWxzLmFyckluKGRlZmF1bHRzXzEuZGVmYXVsdC51cGdyYWRlVHJhbnNwb3J0cywgdHJhbnNwb3J0LnNob3J0TmFtZSkpIHtcbiAgICAgICAgICAgIHRoaXMudHJhbnNwb3J0UHJlZmVyZW5jZSA9IHRyYW5zcG9ydC5zaG9ydE5hbWU7XG4gICAgICAgICAgICBpZiAoaGF2ZVdlYlN0b3JhZ2UoKSkge1xuICAgICAgICAgICAgICAgIChfYiA9IChfYSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5XZWJTdG9yYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euc2V0KSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUsIHRyYW5zcG9ydC5zaG9ydE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUudW5wZXJzaXN0VHJhbnNwb3J0UHJlZmVyZW5jZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hLCBfYjtcbiAgICAgICAgdGhpcy50cmFuc3BvcnRQcmVmZXJlbmNlID0gbnVsbDtcbiAgICAgICAgaWYgKGhhdmVXZWJTdG9yYWdlKCkpIHtcbiAgICAgICAgICAgIChfYiA9IChfYSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5XZWJTdG9yYWdlKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVtb3ZlKSA9PT0gbnVsbCB8fCBfYiA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2IuY2FsbChfYSwgdHJhbnNwb3J0UHJlZmVyZW5jZU5hbWUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiBUaGlzIG1ldGhvZCBpcyBvbmx5IHVzZWQgZHVyaW5nIGNvbm5lY3Rpb24gYXR0ZW1wdHMsIHNvIGltcGxlbWVudHMgUlNBNGMxLCBSU0E0YzIsXG4gICAgICogYW5kIFJTQTRkLiBJdCBpcyBnZW5lcmFsbHkgbm90IGludm9rZWQgZm9yIHNlcnZlcnNpZGUtdHJpZ2dlcmVkIHJlYXV0aHMgb3IgbWFudWFsXG4gICAgICogcmVhdXRocywgc28gUlNBNGMzIGRvZXMgbm90IGFwcGx5LCBleGNlcHQgKHBlciBwZXIgUlNBNGQxKSBpbiB0aGUgY2FzZSB0aGF0IHRoZSBhdXRoXG4gICAgICogc2VydmVyIHJldHVybnMgNDAzLiAqL1xuICAgIENvbm5lY3Rpb25NYW5hZ2VyLnByb3RvdHlwZS5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKGVyci5jb2RlID09PSA0MDE3MSkge1xuICAgICAgICAgICAgLyogTm8gd2F5IHRvIHJlYXV0aCAqL1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiAnZmFpbGVkJywgZXJyb3I6IGVyciB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChlcnIuY29kZSA9PT0gNDAxMDIpIHtcbiAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoeyBzdGF0ZTogJ2ZhaWxlZCcsIGVycm9yOiBlcnIgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoZXJyLnN0YXR1c0NvZGUgPT09IEh0dHBTdGF0dXNDb2Rlc18xLmRlZmF1bHQuRm9yYmlkZGVuKSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ0NsaWVudCBjb25maWd1cmVkIGF1dGhlbnRpY2F0aW9uIHByb3ZpZGVyIHJldHVybmVkIDQwMzsgZmFpbGluZyB0aGUgY29ubmVjdGlvbic7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0Nvbm5lY3Rpb25NYW5hZ2VyLmFjdE9uRXJyb3JGcm9tQXV0aG9yaXplKCknLCBtc2cpO1xuICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSh7IHN0YXRlOiAnZmFpbGVkJywgZXJyb3I6IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgODAwMTksIDQwMywgZXJyKSB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnQ2xpZW50IGNvbmZpZ3VyZWQgYXV0aGVudGljYXRpb24gcHJvdmlkZXIgcmVxdWVzdCBmYWlsZWQnO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uTWFuYWdlci5hY3RPbkVycm9yRnJvbUF1dGhvcml6ZScsIG1zZyk7XG4gICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHsgc3RhdGU6IHRoaXMuc3RhdGUuZmFpbFN0YXRlLCBlcnJvcjogbmV3IGVycm9yaW5mb18xLmRlZmF1bHQobXNnLCA4MDAxOSwgNDAxLCBlcnIpIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDb25uZWN0aW9uTWFuYWdlci5wcm90b3R5cGUub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZSA9IGZ1bmN0aW9uIChjb25uZWN0aW9uRGV0YWlscywgdHJhbnNwb3J0KSB7XG4gICAgICAgIGlmICghY29ubmVjdGlvbkRldGFpbHMpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmNvbm5lY3Rpb25EZXRhaWxzID0gY29ubmVjdGlvbkRldGFpbHM7XG4gICAgICAgIGlmIChjb25uZWN0aW9uRGV0YWlscy5tYXhNZXNzYWdlU2l6ZSkge1xuICAgICAgICAgICAgdGhpcy5vcHRpb25zLm1heE1lc3NhZ2VTaXplID0gY29ubmVjdGlvbkRldGFpbHMubWF4TWVzc2FnZVNpemU7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNsaWVudElkID0gY29ubmVjdGlvbkRldGFpbHMuY2xpZW50SWQ7XG4gICAgICAgIGlmIChjbGllbnRJZCkge1xuICAgICAgICAgICAgdmFyIGVyciA9IHRoaXMucmVhbHRpbWUuYXV0aC5fdW5jaGVja2VkU2V0Q2xpZW50SWQoY2xpZW50SWQpO1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnQ29ubmVjdGlvbk1hbmFnZXIub25Db25uZWN0aW9uRGV0YWlsc1VwZGF0ZSgpJywgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIC8qIEVycm9ycyBzZXR0aW5nIHRoZSBjbGllbnRJZCBhcmUgZmF0YWwgdG8gdGhlIGNvbm5lY3Rpb24gKi9cbiAgICAgICAgICAgICAgICB0cmFuc3BvcnQuZmFpbChlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ubmVjdGlvblN0YXRlVHRsID0gY29ubmVjdGlvbkRldGFpbHMuY29ubmVjdGlvblN0YXRlVHRsO1xuICAgICAgICBpZiAoY29ubmVjdGlvblN0YXRlVHRsKSB7XG4gICAgICAgICAgICB0aGlzLmNvbm5lY3Rpb25TdGF0ZVR0bCA9IGNvbm5lY3Rpb25TdGF0ZVR0bDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1heElkbGVJbnRlcnZhbCA9IGNvbm5lY3Rpb25EZXRhaWxzLm1heElkbGVJbnRlcnZhbDtcbiAgICAgICAgdGhpcy5lbWl0KCdjb25uZWN0aW9uZGV0YWlscycsIGNvbm5lY3Rpb25EZXRhaWxzKTtcbiAgICB9O1xuICAgIC8qKioqKioqKioqKioqKioqKioqKipcbiAgICAgKiB0cmFuc3BvcnQgbWFuYWdlbWVudFxuICAgICAqKioqKioqKioqKioqKioqKioqKiovXG4gICAgQ29ubmVjdGlvbk1hbmFnZXIuc3VwcG9ydGVkVHJhbnNwb3J0cyA9IHt9O1xuICAgIHJldHVybiBDb25uZWN0aW9uTWFuYWdlcjtcbn0oZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvbk1hbmFnZXI7XG5cbi8qIFdFQlBBQ0sgVkFSIElOSkVDVElPTiAqL30uY2FsbCh0aGlzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDEzKSkpXG5cbi8qKiovIH0pLFxuLyogMzYgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBldmVudGVtaXR0ZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNykpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgTWVzc2FnZVF1ZXVlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKE1lc3NhZ2VRdWV1ZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBNZXNzYWdlUXVldWUoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLm1lc3NhZ2VzID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgTWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5jb3VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXMubGVuZ3RoO1xuICAgIH07XG4gICAgTWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5wdXNoID0gZnVuY3Rpb24gKG1lc3NhZ2UpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuICAgIH07XG4gICAgTWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5zaGlmdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuc2hpZnQoKTtcbiAgICB9O1xuICAgIE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUubGFzdCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXNbdGhpcy5tZXNzYWdlcy5sZW5ndGggLSAxXTtcbiAgICB9O1xuICAgIE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuY29weUFsbCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZXMuc2xpY2UoKTtcbiAgICB9O1xuICAgIE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuYXBwZW5kID0gZnVuY3Rpb24gKG1lc3NhZ2VzKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMucHVzaC5hcHBseSh0aGlzLm1lc3NhZ2VzLCBtZXNzYWdlcyk7XG4gICAgfTtcbiAgICBNZXNzYWdlUXVldWUucHJvdG90eXBlLnByZXBlbmQgPSBmdW5jdGlvbiAobWVzc2FnZXMpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlcy51bnNoaWZ0LmFwcGx5KHRoaXMubWVzc2FnZXMsIG1lc3NhZ2VzKTtcbiAgICB9O1xuICAgIE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUuY29tcGxldGVNZXNzYWdlcyA9IGZ1bmN0aW9uIChzZXJpYWwsIGNvdW50LCBlcnIpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdNZXNzYWdlUXVldWUuY29tcGxldGVNZXNzYWdlcygpJywgJ3NlcmlhbCA9ICcgKyBzZXJpYWwgKyAnOyBjb3VudCA9ICcgKyBjb3VudCk7XG4gICAgICAgIGVyciA9IGVyciB8fCBudWxsO1xuICAgICAgICB2YXIgbWVzc2FnZXMgPSB0aGlzLm1lc3NhZ2VzO1xuICAgICAgICBpZiAobWVzc2FnZXMubGVuZ3RoID09PSAwKSB7XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ01lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKCk6IGNvbXBsZXRlTWVzc2FnZXMgY2FsbGVkIG9uIGFueSBlbXB0eSBNZXNzYWdlUXVldWUnKTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgZmlyc3QgPSBtZXNzYWdlc1swXTtcbiAgICAgICAgaWYgKGZpcnN0KSB7XG4gICAgICAgICAgICB2YXIgc3RhcnRTZXJpYWwgPSBmaXJzdC5tZXNzYWdlLm1zZ1NlcmlhbDtcbiAgICAgICAgICAgIHZhciBlbmRTZXJpYWwgPSBzZXJpYWwgKyBjb3VudDsgLyogdGhlIHNlcmlhbCBvZiB0aGUgZmlyc3QgbWVzc2FnZSB0aGF0IGlzICpub3QqIHRoZSBzdWJqZWN0IG9mIHRoaXMgY2FsbCAqL1xuICAgICAgICAgICAgaWYgKGVuZFNlcmlhbCA+IHN0YXJ0U2VyaWFsKSB7XG4gICAgICAgICAgICAgICAgdmFyIGNvbXBsZXRlTWVzc2FnZXMgPSBtZXNzYWdlcy5zcGxpY2UoMCwgZW5kU2VyaWFsIC0gc3RhcnRTZXJpYWwpO1xuICAgICAgICAgICAgICAgIGZvciAodmFyIF9pID0gMCwgY29tcGxldGVNZXNzYWdlc18xID0gY29tcGxldGVNZXNzYWdlczsgX2kgPCBjb21wbGV0ZU1lc3NhZ2VzXzEubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHZhciBtZXNzYWdlID0gY29tcGxldGVNZXNzYWdlc18xW19pXTtcbiAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5jYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChtZXNzYWdlcy5sZW5ndGggPT0gMClcbiAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ2lkbGUnKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgTWVzc2FnZVF1ZXVlLnByb3RvdHlwZS5jb21wbGV0ZUFsbE1lc3NhZ2VzID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICB0aGlzLmNvbXBsZXRlTWVzc2FnZXMoMCwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVIgfHwgTnVtYmVyLk1BWF9WQUxVRSwgZXJyKTtcbiAgICB9O1xuICAgIE1lc3NhZ2VRdWV1ZS5wcm90b3R5cGUucmVzZXRTZW5kQXR0ZW1wdGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAsIF9hID0gdGhpcy5tZXNzYWdlczsgX2kgPCBfYS5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSBfYVtfaV07XG4gICAgICAgICAgICBtc2cuc2VuZEF0dGVtcHRlZCA9IGZhbHNlO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBNZXNzYWdlUXVldWUucHJvdG90eXBlLmNsZWFyID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ01lc3NhZ2VRdWV1ZS5jbGVhcigpJywgJ2NsZWFyaW5nICcgKyB0aGlzLm1lc3NhZ2VzLmxlbmd0aCArICcgbWVzc2FnZXMnKTtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9IFtdO1xuICAgICAgICB0aGlzLmVtaXQoJ2lkbGUnKTtcbiAgICB9O1xuICAgIHJldHVybiBNZXNzYWdlUXVldWU7XG59KGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IE1lc3NhZ2VRdWV1ZTtcblxuXG4vKioqLyB9KSxcbi8qIDM3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbm5lY3Rpb25TdGF0ZUNoYW5nZShwcmV2aW91cywgY3VycmVudCwgcmV0cnlJbiwgcmVhc29uKSB7XG4gICAgICAgIHRoaXMucHJldmlvdXMgPSBwcmV2aW91cztcbiAgICAgICAgdGhpcy5jdXJyZW50ID0gY3VycmVudDtcbiAgICAgICAgaWYgKHJldHJ5SW4pXG4gICAgICAgICAgICB0aGlzLnJldHJ5SW4gPSByZXRyeUluO1xuICAgICAgICBpZiAocmVhc29uKVxuICAgICAgICAgICAgdGhpcy5yZWFzb24gPSByZWFzb247XG4gICAgfVxuICAgIHJldHVybiBDb25uZWN0aW9uU3RhdGVDaGFuZ2U7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gQ29ubmVjdGlvblN0YXRlQ2hhbmdlO1xuXG5cbi8qKiovIH0pLFxuLyogMzggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBwcm90b2NvbG1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTApKTtcbnZhciBldmVudGVtaXR0ZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNykpO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgY2hhbm5lbF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzMykpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgcmVhbHRpbWVwcmVzZW5jZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg1NCkpO1xudmFyIG1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOSkpO1xudmFyIGNoYW5uZWxzdGF0ZWNoYW5nZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzOSkpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgcHJlc2VuY2VtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDE1KSk7XG52YXIgY29ubmVjdGlvbmVycm9yc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyMCkpO1xudmFyIGFjdGlvbnMgPSBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LkFjdGlvbjtcbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xuZnVuY3Rpb24gdmFsaWRhdGVDaGFubmVsT3B0aW9ucyhvcHRpb25zKSB7XG4gICAgaWYgKG9wdGlvbnMgJiYgJ3BhcmFtcycgaW4gb3B0aW9ucyAmJiAhVXRpbHMuaXNPYmplY3Qob3B0aW9ucy5wYXJhbXMpKSB7XG4gICAgICAgIHJldHVybiBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnb3B0aW9ucy5wYXJhbXMgbXVzdCBiZSBhbiBvYmplY3QnLCA0MDAwMCwgNDAwKTtcbiAgICB9XG4gICAgaWYgKG9wdGlvbnMgJiYgJ21vZGVzJyBpbiBvcHRpb25zKSB7XG4gICAgICAgIGlmICghVXRpbHMuaXNBcnJheShvcHRpb25zLm1vZGVzKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdvcHRpb25zLm1vZGVzIG11c3QgYmUgYW4gYXJyYXknLCA0MDAwMCwgNDAwKTtcbiAgICAgICAgfVxuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9wdGlvbnMubW9kZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBjdXJyZW50TW9kZSA9IG9wdGlvbnMubW9kZXNbaV07XG4gICAgICAgICAgICBpZiAoIWN1cnJlbnRNb2RlIHx8XG4gICAgICAgICAgICAgICAgdHlwZW9mIGN1cnJlbnRNb2RlICE9PSAnc3RyaW5nJyB8fFxuICAgICAgICAgICAgICAgICFVdGlscy5hcnJJbihwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LmNoYW5uZWxNb2RlcywgU3RyaW5nLnByb3RvdHlwZS50b1VwcGVyQ2FzZS5jYWxsKGN1cnJlbnRNb2RlKSkpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0ludmFsaWQgY2hhbm5lbCBtb2RlOiAnICsgY3VycmVudE1vZGUsIDQwMDAwLCA0MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxufVxudmFyIFJlYWx0aW1lQ2hhbm5lbCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZWFsdGltZUNoYW5uZWwsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVhbHRpbWVDaGFubmVsKHJlYWx0aW1lLCBuYW1lLCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHJlYWx0aW1lLCBuYW1lLCBvcHRpb25zKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy5yZXRyeUNvdW50ID0gMDtcbiAgICAgICAgX3RoaXMuaGlzdG9yeSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5oaXN0b3J5KCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLm5hbWUpO1xuICAgICAgICAgICAgLyogcGFyYW1zIGFuZCBjYWxsYmFjayBhcmUgb3B0aW9uYWw7IHNlZSBpZiBwYXJhbXMgY29udGFpbnMgdGhlIGNhbGxiYWNrICovXG4gICAgICAgICAgICBpZiAoY2FsbGJhY2sgPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBwYXJhbXM7XG4gICAgICAgICAgICAgICAgICAgIHBhcmFtcyA9IG51bGw7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2hpc3RvcnknLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocGFyYW1zICYmIHBhcmFtcy51bnRpbEF0dGFjaCkge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLnN0YXRlICE9PSAnYXR0YWNoZWQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdvcHRpb24gdW50aWxBdHRhY2ggcmVxdWlyZXMgdGhlIGNoYW5uZWwgdG8gYmUgYXR0YWNoZWQnLCA0MDAwMCwgNDAwKSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKCF0aGlzLnByb3BlcnRpZXMuYXR0YWNoU2VyaWFsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCd1bnRpbEF0dGFjaCB3YXMgc3BlY2lmaWVkIGFuZCBjaGFubmVsIGlzIGF0dGFjaGVkLCBidXQgYXR0YWNoU2VyaWFsIGlzIG5vdCBkZWZpbmVkJywgNDAwMDAsIDQwMCkpO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGRlbGV0ZSBwYXJhbXMudW50aWxBdHRhY2g7XG4gICAgICAgICAgICAgICAgcGFyYW1zLmZyb21fc2VyaWFsID0gdGhpcy5wcm9wZXJ0aWVzLmF0dGFjaFNlcmlhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNoYW5uZWxfMS5kZWZhdWx0LnByb3RvdHlwZS5faGlzdG9yeS5jYWxsKHRoaXMsIHBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgICB9O1xuICAgICAgICBfdGhpcy53aGVuU3RhdGUgPSAoZnVuY3Rpb24gKHN0YXRlLCBsaXN0ZW5lcikge1xuICAgICAgICAgICAgcmV0dXJuIGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQucHJvdG90eXBlLndoZW5TdGF0ZS5jYWxsKF90aGlzLCBzdGF0ZSwgX3RoaXMuc3RhdGUsIGxpc3RlbmVyKTtcbiAgICAgICAgfSk7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsKCknLCAnc3RhcnRlZDsgbmFtZSA9ICcgKyBuYW1lKTtcbiAgICAgICAgX3RoaXMucmVhbHRpbWUgPSByZWFsdGltZTtcbiAgICAgICAgX3RoaXMucHJlc2VuY2UgPSBuZXcgcmVhbHRpbWVwcmVzZW5jZV8xLmRlZmF1bHQoX3RoaXMpO1xuICAgICAgICBfdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IHJlYWx0aW1lLmNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXI7XG4gICAgICAgIF90aGlzLnN0YXRlID0gJ2luaXRpYWxpemVkJztcbiAgICAgICAgX3RoaXMuc3Vic2NyaXB0aW9ucyA9IG5ldyBldmVudGVtaXR0ZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIF90aGlzLnN5bmNDaGFubmVsU2VyaWFsID0gdW5kZWZpbmVkO1xuICAgICAgICBfdGhpcy5wcm9wZXJ0aWVzID0ge1xuICAgICAgICAgICAgYXR0YWNoU2VyaWFsOiB1bmRlZmluZWQsXG4gICAgICAgICAgICBjaGFubmVsU2VyaWFsOiB1bmRlZmluZWQsXG4gICAgICAgIH07XG4gICAgICAgIF90aGlzLnNldE9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIF90aGlzLmVycm9yUmVhc29uID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX3JlcXVlc3RlZEZsYWdzID0gbnVsbDtcbiAgICAgICAgX3RoaXMuX21vZGUgPSBudWxsO1xuICAgICAgICBfdGhpcy5fYXR0YWNoUmVzdW1lID0gZmFsc2U7XG4gICAgICAgIF90aGlzLl9kZWNvZGluZ0NvbnRleHQgPSB7XG4gICAgICAgICAgICBjaGFubmVsT3B0aW9uczogX3RoaXMuY2hhbm5lbE9wdGlvbnMsXG4gICAgICAgICAgICBwbHVnaW5zOiByZWFsdGltZS5vcHRpb25zLnBsdWdpbnMgfHwge30sXG4gICAgICAgICAgICBiYXNlRW5jb2RlZFByZXZpb3VzUGF5bG9hZDogdW5kZWZpbmVkLFxuICAgICAgICB9O1xuICAgICAgICBfdGhpcy5fbGFzdFBheWxvYWQgPSB7XG4gICAgICAgICAgICBtZXNzYWdlSWQ6IG51bGwsXG4gICAgICAgICAgICBwcm90b2NvbE1lc3NhZ2VDaGFubmVsU2VyaWFsOiBudWxsLFxuICAgICAgICAgICAgZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzczogbnVsbCxcbiAgICAgICAgfTtcbiAgICAgICAgLyogT25seSBkaWZmZXJlbmNlcyBiZXR3ZWVuIHRoaXMgYW5kIHRoZSBwdWJsaWMgZXZlbnQgZW1pdHRlciBpcyB0aGF0IHRoaXMgZW1pdHMgYW5cbiAgICAgICAgICogdXBkYXRlIGV2ZW50IGZvciBhbGwgQVRUQUNIRURzLCB3aGV0aGVyIHJlc3VtZWQgb3Igbm90ICovXG4gICAgICAgIF90aGlzLl9hbGxDaGFubmVsQ2hhbmdlcyA9IG5ldyBldmVudGVtaXR0ZXJfMS5kZWZhdWx0KCk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5pbnZhbGlkU3RhdGVFcnJvciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdDaGFubmVsIG9wZXJhdGlvbiBmYWlsZWQgYXMgY2hhbm5lbCBzdGF0ZSBpcyAnICsgdGhpcy5zdGF0ZSwgOTAwMDEsIDQwMCwgdGhpcy5lcnJvclJlYXNvbiB8fCB1bmRlZmluZWQpO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb2Nlc3NMaXN0ZW5lckFyZ3MgPSBmdW5jdGlvbiAoYXJncykge1xuICAgICAgICAvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqL1xuICAgICAgICBhcmdzID0gQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoYXJncyk7XG4gICAgICAgIGlmICh0eXBlb2YgYXJnc1swXSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgYXJncy51bnNoaWZ0KG51bGwpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdzW2FyZ3MubGVuZ3RoIC0gMV0gPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBhcmdzLnBvcCgpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBhcmdzO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBwcmV2aW91c0NoYW5uZWxPcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnc2V0T3B0aW9ucycsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIF9jYWxsYmFjayA9IGNhbGxiYWNrIHx8XG4gICAgICAgICAgICBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5zZXRPcHRpb25zKCknLCAnU2V0IG9wdGlvbnMgZmFpbGVkOiAnICsgZXJyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIHZhciBlcnIgPSB2YWxpZGF0ZUNoYW5uZWxPcHRpb25zKG9wdGlvbnMpO1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICBfY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBjaGFubmVsXzEuZGVmYXVsdC5wcm90b3R5cGUuc2V0T3B0aW9ucy5jYWxsKHRoaXMsIG9wdGlvbnMpO1xuICAgICAgICBpZiAodGhpcy5fZGVjb2RpbmdDb250ZXh0KVxuICAgICAgICAgICAgdGhpcy5fZGVjb2RpbmdDb250ZXh0LmNoYW5uZWxPcHRpb25zID0gdGhpcy5jaGFubmVsT3B0aW9ucztcbiAgICAgICAgaWYgKHRoaXMuX3Nob3VsZFJlYXR0YWNoVG9TZXRPcHRpb25zKG9wdGlvbnMsIHByZXZpb3VzQ2hhbm5lbE9wdGlvbnMpKSB7XG4gICAgICAgICAgICAvKiBUaGlzIGRvZXMgbm90IGp1c3QgZG8gX2F0dGFjaCh0cnVlLCBudWxsLCBjYWxsYmFjaykgYmVjYXVzZSB0aGF0IHdvdWxkIHB1dCB1c1xuICAgICAgICAgICAgICogaW50byB0aGUgJ2F0dGFjaGluZycgc3RhdGUgdW50aWwgd2UgcmVjZWl2ZSB0aGUgbmV3IGF0dGFjaGVkLCB3aGljaCBpc1xuICAgICAgICAgICAgICogY29uY2VwdHVhbGx5IGluY29ycmVjdDogd2UgYXJlIHN0aWxsIGF0dGFjaGVkLCB3ZSBqdXN0IGhhdmUgYSBwZW5kaW5nIHJlcXVlc3QgdG9cbiAgICAgICAgICAgICAqIGNoYW5nZSBzb21lIGNoYW5uZWwgcGFyYW1zLiBQZXIgUlRMMTcgZ29pbmcgaW50byB0aGUgYXR0YWNoaW5nIHN0YXRlIHdvdWxkIG1lYW5cbiAgICAgICAgICAgICAqIHJlamVjdGluZyBtZXNzYWdlcyB1bnRpbCB3ZSBoYXZlIGNvbmZpcm1hdGlvbiB0aGF0IHRoZSBvcHRpb25zIGhhdmUgY2hhbmdlZCxcbiAgICAgICAgICAgICAqIHdoaWNoIHdvdWxkIHVubmVjZXNzYXJpbHkgbG9zZSBtZXNzYWdlIGNvbnRpbnVpdHkuICovXG4gICAgICAgICAgICB0aGlzLmF0dGFjaEltcGwoKTtcbiAgICAgICAgICAgIC8vIElnbm9yZSAnYXR0YWNoaW5nJyAtLSBjb3VsZCBiZSBqdXN0IGR1ZSB0byB0byBhIHJlc3VtZSAmIHJlYXR0YWNoLCBzaG91bGQgbm90XG4gICAgICAgICAgICAvLyBjYWxsIGJhY2sgc2V0T3B0aW9ucyB1bnRpbCB3ZSdyZSBkZWZpbml0ZWx5IGF0dGFjaGVkIHdpdGggdGhlIG5ldyBvcHRpb25zIChvclxuICAgICAgICAgICAgLy8gZWxzZSBpbiBhIHRlcm1pbmFsIHN0YXRlKVxuICAgICAgICAgICAgdGhpcy5fYWxsQ2hhbm5lbENoYW5nZXMub25jZShbJ2F0dGFjaGVkJywgJ3VwZGF0ZScsICdkZXRhY2hlZCcsICdmYWlsZWQnXSwgZnVuY3Rpb24gKHN0YXRlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgc3dpdGNoICh0aGlzLmV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ3VwZGF0ZSc6XG4gICAgICAgICAgICAgICAgICAgIGNhc2UgJ2F0dGFjaGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jYWxsYmFjayA9PT0gbnVsbCB8fCBfY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jYWxsYmFjayhudWxsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jYWxsYmFjayA9PT0gbnVsbCB8fCBfY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jYWxsYmFjayhzdGF0ZUNoYW5nZS5yZWFzb24pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2NhbGxiYWNrKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuX3Nob3VsZFJlYXR0YWNoVG9TZXRPcHRpb25zID0gZnVuY3Rpb24gKG9wdGlvbnMsIHByZXZPcHRpb25zKSB7XG4gICAgICAgIGlmICghKHRoaXMuc3RhdGUgPT09ICdhdHRhY2hlZCcgfHwgdGhpcy5zdGF0ZSA9PT0gJ2F0dGFjaGluZycpKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5wYXJhbXMpIHtcbiAgICAgICAgICAgIC8vIERvbid0IGNoZWNrIGFnYWluc3QgdGhlIGBhZ2VudGAgcGFyYW0gLSBpdCBpc24ndCByZXR1cm5lZCBpbiB0aGUgQVRUQUNIRUQgbWVzc2FnZVxuICAgICAgICAgICAgdmFyIHJlcXVlc3RlZFBhcmFtcyA9IG9taXRBZ2VudChvcHRpb25zLnBhcmFtcyk7XG4gICAgICAgICAgICB2YXIgZXhpc3RpbmdQYXJhbXMgPSBvbWl0QWdlbnQocHJldk9wdGlvbnMucGFyYW1zKTtcbiAgICAgICAgICAgIGlmIChPYmplY3Qua2V5cyhyZXF1ZXN0ZWRQYXJhbXMpLmxlbmd0aCAhPT0gT2JqZWN0LmtleXMoZXhpc3RpbmdQYXJhbXMpLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKCFVdGlscy5zaGFsbG93RXF1YWxzKGV4aXN0aW5nUGFyYW1zLCByZXF1ZXN0ZWRQYXJhbXMpKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5tb2Rlcykge1xuICAgICAgICAgICAgaWYgKCFwcmV2T3B0aW9ucy5tb2RlcyB8fCAhVXRpbHMuYXJyRXF1YWxzKG9wdGlvbnMubW9kZXMsIHByZXZPcHRpb25zLm1vZGVzKSkge1xuICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgbWVzc2FnZXMgPSBhcmdzWzBdO1xuICAgICAgICB2YXIgYXJnQ291bnQgPSBhcmdzLmxlbmd0aDtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1thcmdDb3VudCAtIDFdO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAncHVibGlzaCcsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgICAgICArK2FyZ0NvdW50O1xuICAgICAgICB9XG4gICAgICAgIGlmICghdGhpcy5jb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayh0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChhcmdDb3VudCA9PSAyKSB7XG4gICAgICAgICAgICBpZiAoVXRpbHMuaXNPYmplY3QobWVzc2FnZXMpKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzID0gW21lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMobWVzc2FnZXMpXTtcbiAgICAgICAgICAgIGVsc2UgaWYgKFV0aWxzLmlzQXJyYXkobWVzc2FnZXMpKVxuICAgICAgICAgICAgICAgIG1lc3NhZ2VzID0gbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlc0FycmF5KG1lc3NhZ2VzKTtcbiAgICAgICAgICAgIGVsc2VcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVGhlIHNpbmdsZS1hcmd1bWVudCBmb3JtIG9mIHB1Ymxpc2goKSBleHBlY3RzIGEgbWVzc2FnZSBvYmplY3Qgb3IgYW4gYXJyYXkgb2YgbWVzc2FnZSBvYmplY3RzJywgNDAwMTMsIDQwMCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBtZXNzYWdlcyA9IFttZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHsgbmFtZTogYXJnc1swXSwgZGF0YTogYXJnc1sxXSB9KV07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1heE1lc3NhZ2VTaXplID0gdGhpcy5yZWFsdGltZS5vcHRpb25zLm1heE1lc3NhZ2VTaXplO1xuICAgICAgICBtZXNzYWdlXzEuZGVmYXVsdC5lbmNvZGVBcnJheShtZXNzYWdlcywgdGhpcy5jaGFubmVsT3B0aW9ucywgZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLyogUlNMMWkgKi9cbiAgICAgICAgICAgIHZhciBzaXplID0gbWVzc2FnZV8xLmRlZmF1bHQuZ2V0TWVzc2FnZXNTaXplKG1lc3NhZ2VzKTtcbiAgICAgICAgICAgIGlmIChzaXplID4gbWF4TWVzc2FnZVNpemUpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnTWF4aW11bSBzaXplIG9mIG1lc3NhZ2VzIHRoYXQgY2FuIGJlIHB1Ymxpc2hlZCBhdCBvbmNlIGV4Y2VlZGVkICggd2FzICcgK1xuICAgICAgICAgICAgICAgICAgICBzaXplICtcbiAgICAgICAgICAgICAgICAgICAgJyBieXRlczsgbGltaXQgaXMgJyArXG4gICAgICAgICAgICAgICAgICAgIG1heE1lc3NhZ2VTaXplICtcbiAgICAgICAgICAgICAgICAgICAgJyBieXRlcyknLCA0MDAwOSwgNDAwKSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3RoaXMuX19wdWJsaXNoKG1lc3NhZ2VzLCBjYWxsYmFjayk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgLy8gRG91YmxlIHVuZGVyc2NvcmUgdXNlZCB0byBwcmV2ZW50IHR5cGUgY29uZmxpY3Qgd2l0aCB1bmRlcmx5aW5nIENoYW5uZWwuX3B1Ymxpc2ggbWV0aG9kXG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5fX3B1Ymxpc2ggPSBmdW5jdGlvbiAobWVzc2FnZXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWVDaGFubmVsLnB1Ymxpc2goKScsICdtZXNzYWdlIGNvdW50ID0gJyArIG1lc3NhZ2VzLmxlbmd0aCk7XG4gICAgICAgIHZhciBzdGF0ZSA9IHRoaXMuc3RhdGU7XG4gICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICBjYXNlICdzdXNwZW5kZWQnOlxuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyh0aGlzLmludmFsaWRTdGF0ZUVycm9yKCkpKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGRlZmF1bHQ6IHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5wdWJsaXNoKCknLCAnc2VuZGluZyBtZXNzYWdlOyBjaGFubmVsIHN0YXRlIGlzICcgKyBzdGF0ZSk7XG4gICAgICAgICAgICAgICAgdmFyIG1zZyA9IG5ldyBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0KCk7XG4gICAgICAgICAgICAgICAgbXNnLmFjdGlvbiA9IGFjdGlvbnMuTUVTU0FHRTtcbiAgICAgICAgICAgICAgICBtc2cuY2hhbm5lbCA9IHRoaXMubmFtZTtcbiAgICAgICAgICAgICAgICBtc2cubWVzc2FnZXMgPSBtZXNzYWdlcztcbiAgICAgICAgICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKG1zZywgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLm9uRXZlbnQgPSBmdW5jdGlvbiAobWVzc2FnZXMpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZWFsdGltZUNoYW5uZWwub25FdmVudCgpJywgJ3JlY2VpdmVkIG1lc3NhZ2UnKTtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbWVzc2FnZXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBtZXNzYWdlID0gbWVzc2FnZXNbaV07XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zLmVtaXQobWVzc2FnZS5uYW1lLCBtZXNzYWdlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5hdHRhY2ggPSBmdW5jdGlvbiAoZmxhZ3MsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfZmxhZ3M7XG4gICAgICAgIGlmICh0eXBlb2YgZmxhZ3MgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID0gZmxhZ3M7XG4gICAgICAgICAgICBfZmxhZ3MgPSBudWxsO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgX2ZsYWdzID0gZmxhZ3M7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2F0dGFjaCcsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01BSk9SLCAnUmVhbHRpbWVDaGFubmVsLmF0dGFjaCgpJywgJ0NoYW5uZWwgYXR0YWNoIGZhaWxlZDogJyArIGVyci50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChfZmxhZ3MpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQuZGVwcmVjYXRlZCgnY2hhbm5lbC5hdHRhY2goKSB3aXRoIGZsYWdzJywgJ2NoYW5uZWwuc2V0T3B0aW9ucygpIHdpdGggY2hhbm5lbE9wdGlvbnMucGFyYW1zJyk7XG4gICAgICAgICAgICAvKiBJZiBmbGFncyByZXF1ZXN0ZWQsIGFsd2F5cyBkbyBhIHJlLWF0dGFjaC4gVE9ETyBvbmx5IGRvIHRoaXMgaWZcbiAgICAgICAgICAgICAqIGN1cnJlbnQgbW9kZSBkaWZmZXJzIGZyb20gcmVxdWVzdGVkIG1vZGUgKi9cbiAgICAgICAgICAgIHRoaXMuX3JlcXVlc3RlZEZsYWdzID0gX2ZsYWdzO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIG51bGwpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuX2F0dGFjaChmYWxzZSwgbnVsbCwgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5fYXR0YWNoID0gZnVuY3Rpb24gKGZvcmNlUmVhdHRhY2gsIGF0dGFjaFJlYXNvbiwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPSBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5fYXR0YWNoKCknLCAnQ2hhbm5lbCBhdHRhY2ggZmFpbGVkOiAnICsgZXJyLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlcjtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5zdGF0ZSAhPT0gJ2F0dGFjaGluZycgfHwgZm9yY2VSZWF0dGFjaCkge1xuICAgICAgICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoJ2F0dGFjaGluZycsIGF0dGFjaFJlYXNvbik7XG4gICAgICAgIH1cbiAgICAgICAgdGhpcy5vbmNlKGZ1bmN0aW9uIChzdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgc3dpdGNoICh0aGlzLmV2ZW50KSB7XG4gICAgICAgICAgICAgICAgY2FzZSAnYXR0YWNoZWQnOlxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2sobnVsbCwgc3RhdGVDaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBjYXNlICdkZXRhY2hlZCc6XG4gICAgICAgICAgICAgICAgY2FzZSAnc3VzcGVuZGVkJzpcbiAgICAgICAgICAgICAgICBjYXNlICdmYWlsZWQnOlxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soc3RhdGVDaGFuZ2UucmVhc29uIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVW5hYmxlIHRvIGF0dGFjaDsgcmVhc29uIHVua25vd247IHN0YXRlID0gJyArIHRoaXMuZXZlbnQsIDkwMDAwLCA1MDApKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnZGV0YWNoaW5nJzpcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdBdHRhY2ggcmVxdWVzdCBzdXBlcnNlZGVkIGJ5IGEgc3Vic2VxdWVudCBkZXRhY2ggcmVxdWVzdCcsIDkwMDAwLCA0MDkpKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5hdHRhY2hJbXBsID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5hdHRhY2hJbXBsKCknLCAnc2VuZGluZyBBVFRBQ0ggbWVzc2FnZScpO1xuICAgICAgICB2YXIgYXR0YWNoTXNnID0gcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHtcbiAgICAgICAgICAgIGFjdGlvbjogYWN0aW9ucy5BVFRBQ0gsXG4gICAgICAgICAgICBjaGFubmVsOiB0aGlzLm5hbWUsXG4gICAgICAgICAgICBwYXJhbXM6IHRoaXMuY2hhbm5lbE9wdGlvbnMucGFyYW1zLFxuICAgICAgICAgICAgLy8gUlRMNGMxOiBJbmNsdWRlcyB0aGUgY2hhbm5lbCBzZXJpYWwgdG8gcmVzdW1lIGZyb20gYSBwcmV2aW91cyBtZXNzYWdlXG4gICAgICAgICAgICAvLyBvciBhdHRhY2htZW50LlxuICAgICAgICAgICAgY2hhbm5lbFNlcmlhbDogdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWwsXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAodGhpcy5fcmVxdWVzdGVkRmxhZ3MpIHtcbiAgICAgICAgICAgIGF0dGFjaE1zZy5lbmNvZGVNb2Rlc1RvRmxhZ3ModGhpcy5fcmVxdWVzdGVkRmxhZ3MpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuY2hhbm5lbE9wdGlvbnMubW9kZXMpIHtcbiAgICAgICAgICAgIGF0dGFjaE1zZy5lbmNvZGVNb2Rlc1RvRmxhZ3MoVXRpbHMuYWxsVG9VcHBlckNhc2UodGhpcy5jaGFubmVsT3B0aW9ucy5tb2RlcykpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLl9hdHRhY2hSZXN1bWUpIHtcbiAgICAgICAgICAgIGF0dGFjaE1zZy5zZXRGbGFnKCdBVFRBQ0hfUkVTVU1FJyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIGF0dGFjaE1zZy5jaGFubmVsU2VyaWFsID0gdGhpcy5fbGFzdFBheWxvYWQucHJvdG9jb2xNZXNzYWdlQ2hhbm5lbFNlcmlhbDtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnNlbmRNZXNzYWdlKGF0dGFjaE1zZywgbm9vcCk7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmRldGFjaCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBpZiAoIWNhbGxiYWNrKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnZGV0YWNoJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICB2YXIgY29ubmVjdGlvbk1hbmFnZXIgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyO1xuICAgICAgICBpZiAoIWNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHN3aXRjaCAodGhpcy5zdGF0ZSkge1xuICAgICAgICAgICAgY2FzZSAnc3VzcGVuZGVkJzpcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKCdkZXRhY2hlZCcpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkZXRhY2hlZCc6XG4gICAgICAgICAgICAgICAgY2FsbGJhY2soKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2ZhaWxlZCc6XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1VuYWJsZSB0byBkZXRhY2g7IGNoYW5uZWwgc3RhdGUgPSBmYWlsZWQnLCA5MDAwMSwgNDAwKSk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMucmVxdWVzdFN0YXRlKCdkZXRhY2hpbmcnKTtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSAnZGV0YWNoaW5nJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uY2UoZnVuY3Rpb24gKHN0YXRlQ2hhbmdlKSB7XG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAodGhpcy5ldmVudCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZGV0YWNoZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdhdHRhY2hlZCc6XG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlICdzdXNwZW5kZWQnOlxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhzdGF0ZUNoYW5nZS5yZWFzb24gfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29ubmVjdGlvbk1hbmFnZXIuZ2V0RXJyb3IoKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnVW5hYmxlIHRvIGRldGFjaDsgcmVhc29uIHVua25vd247IHN0YXRlID0gJyArIHRoaXMuZXZlbnQsIDkwMDAwLCA1MDApKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgJ2F0dGFjaGluZyc6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0RldGFjaCByZXF1ZXN0IHN1cGVyc2VkZWQgYnkgYSBzdWJzZXF1ZW50IGF0dGFjaCByZXF1ZXN0JywgOTAwMDAsIDQwOSkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuZGV0YWNoSW1wbCA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5kZXRhY2goKScsICdzZW5kaW5nIERFVEFDSCBtZXNzYWdlJyk7XG4gICAgICAgIHZhciBtc2cgPSBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoeyBhY3Rpb246IGFjdGlvbnMuREVUQUNILCBjaGFubmVsOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UobXNnLCBjYWxsYmFjayB8fCBub29wKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc3Vic2NyaWJlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgYXJncyA9IFtdOyAvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqL1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAgLyogW2V2ZW50XSwgbGlzdGVuZXIsIFtjYWxsYmFja10gKi87IF9pIDwgYXJndW1lbnRzLmxlbmd0aCAvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqLzsgX2krKyAvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqLykge1xuICAgICAgICAgICAgYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldOyAvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqL1xuICAgICAgICB9XG4gICAgICAgIHZhciBfYSA9IFJlYWx0aW1lQ2hhbm5lbC5wcm9jZXNzTGlzdGVuZXJBcmdzKGFyZ3MpLCBldmVudCA9IF9hWzBdLCBsaXN0ZW5lciA9IF9hWzFdLCBjYWxsYmFjayA9IF9hWzJdO1xuICAgICAgICBpZiAoIWNhbGxiYWNrICYmIHRoaXMucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnc3Vic2NyaWJlJywgW2V2ZW50LCBsaXN0ZW5lcl0pO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLnN0YXRlID09PSAnZmFpbGVkJykge1xuICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyh0aGlzLmludmFsaWRTdGF0ZUVycm9yKCkpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICAvLyBGaWx0ZXJlZFxuICAgICAgICBpZiAoZXZlbnQgJiYgdHlwZW9mIGV2ZW50ID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShldmVudCkpIHtcbiAgICAgICAgICAgIHRoaXMuX3N1YnNjcmliZUZpbHRlcihldmVudCwgbGlzdGVuZXIpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLm9uKGV2ZW50LCBsaXN0ZW5lcik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuYXR0YWNoKGNhbGxiYWNrIHx8IG5vb3ApO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5fc3Vic2NyaWJlRmlsdGVyID0gZnVuY3Rpb24gKGZpbHRlciwgbGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIGZpbHRlcmVkTGlzdGVuZXIgPSBmdW5jdGlvbiAobSkge1xuICAgICAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZSwgX2Y7XG4gICAgICAgICAgICB2YXIgbWFwcGluZyA9IHtcbiAgICAgICAgICAgICAgICBuYW1lOiBtLm5hbWUsXG4gICAgICAgICAgICAgICAgcmVmVGltZXNlcmlhbDogKF9iID0gKF9hID0gbS5leHRyYXMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5yZWYpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi50aW1lc2VyaWFsLFxuICAgICAgICAgICAgICAgIHJlZlR5cGU6IChfZCA9IChfYyA9IG0uZXh0cmFzKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmVmKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2QudHlwZSxcbiAgICAgICAgICAgICAgICBpc1JlZjogISEoKF9mID0gKF9lID0gbS5leHRyYXMpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5yZWYpID09PSBudWxsIHx8IF9mID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZi50aW1lc2VyaWFsKSxcbiAgICAgICAgICAgICAgICBjbGllbnRJZDogbS5jbGllbnRJZCxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICAvLyBDaGVjayBpZiBhbnkgdmFsdWVzIGFyZSBkZWZpbmVkIGluIHRoZSBmaWx0ZXIgYW5kIGlmIHRoZXkgbWF0Y2ggdGhlIHZhbHVlIGluIHRoZSBtZXNzYWdlIG9iamVjdFxuICAgICAgICAgICAgaWYgKE9iamVjdC5lbnRyaWVzKGZpbHRlcikuZmluZChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0gX2FbMF0sIHZhbHVlID0gX2FbMV07XG4gICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlICE9PSB1bmRlZmluZWQgPyBtYXBwaW5nW2tleV0gIT09IHZhbHVlIDogZmFsc2U7XG4gICAgICAgICAgICB9KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3RlbmVyKG0pO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLl9hZGRGaWx0ZXJlZFN1YnNjcmlwdGlvbihmaWx0ZXIsIGxpc3RlbmVyLCBmaWx0ZXJlZExpc3RlbmVyKTtcbiAgICAgICAgdGhpcy5zdWJzY3JpcHRpb25zLm9uKGZpbHRlcmVkTGlzdGVuZXIpO1xuICAgIH07XG4gICAgLy8gQWRkcyBhIG5ldyBmaWx0ZXJlZCBzdWJzY3JpcHRpb25cbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLl9hZGRGaWx0ZXJlZFN1YnNjcmlwdGlvbiA9IGZ1bmN0aW9uIChmaWx0ZXIsIHJlYWxMaXN0ZW5lciwgZmlsdGVyZWRMaXN0ZW5lcikge1xuICAgICAgICB2YXIgX2E7XG4gICAgICAgIGlmICghdGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRTdWJzY3JpcHRpb25zID0gbmV3IE1hcCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5oYXMocmVhbExpc3RlbmVyKSkge1xuICAgICAgICAgICAgdmFyIHJlYWxMaXN0ZW5lck1hcCA9IHRoaXMuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmdldChyZWFsTGlzdGVuZXIpO1xuICAgICAgICAgICAgLy8gQWRkIHRoZSBmaWx0ZXJlZCBsaXN0ZW5lciB0byB0aGUgbWFwLCBvciBhcHBlbmQgdG8gdGhlIGFycmF5IGlmIHRoaXMgZmlsdGVyIGhhcyBhbHJlYWR5IGJlZW4gdXNlZFxuICAgICAgICAgICAgcmVhbExpc3RlbmVyTWFwLnNldChmaWx0ZXIsICgoX2EgPSByZWFsTGlzdGVuZXJNYXAgPT09IG51bGwgfHwgcmVhbExpc3RlbmVyTWFwID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZWFsTGlzdGVuZXJNYXAuZ2V0KGZpbHRlcikpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5jb25jYXQoZmlsdGVyZWRMaXN0ZW5lcikpIHx8IFtmaWx0ZXJlZExpc3RlbmVyXSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5zZXQocmVhbExpc3RlbmVyLCBuZXcgTWFwKFtbZmlsdGVyLCBbZmlsdGVyZWRMaXN0ZW5lcl1dXSkpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLl9nZXRBbmREZWxldGVGaWx0ZXJlZFN1YnNjcmlwdGlvbnMgPSBmdW5jdGlvbiAoZmlsdGVyLCByZWFsTGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgLy8gTm8gZmlsdGVyZWQgc3Vic2NyaXB0aW9ucyBtYXAgbWVhbnMgdGhlcmUgaGFzIGJlZW4gbm8gZmlsdGVyZWQgc3Vic2NyaXB0aW9ucyB5ZXQsIHNvIHJldHVybiBub3RoaW5nXG4gICAgICAgIGlmICghdGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICAvLyBPbmx5IGEgZmlsdGVyIGlzIHBhc3NlZCBpbiB3aXRoIG5vIHNwZWNpZmljIGxpc3RlbmVyXG4gICAgICAgIGlmICghcmVhbExpc3RlbmVyICYmIGZpbHRlcikge1xuICAgICAgICAgICAgLy8gUmV0dXJuIGVhY2ggbGlzdGVuZXIgd2hpY2ggaXMgYXR0YWNoZWQgdG8gdGhlIHNwZWNpZmllZCBmaWx0ZXIgb2JqZWN0XG4gICAgICAgICAgICByZXR1cm4gQXJyYXkuZnJvbSh0aGlzLmZpbHRlcmVkU3Vic2NyaXB0aW9ucy5lbnRyaWVzKCkpXG4gICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoX2EpIHtcbiAgICAgICAgICAgICAgICB2YXIgX2I7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF9hWzBdLCBmaWx0ZXJNYXBzID0gX2FbMV07XG4gICAgICAgICAgICAgICAgLy8gR2V0ICh0aGVuIGRlbGV0ZSkgdGhlIG1hcHMgbWF0Y2hpbmcgdGhpcyBmaWx0ZXJcbiAgICAgICAgICAgICAgICB2YXIgbGlzdGVuZXJNYXBzID0gZmlsdGVyTWFwcy5nZXQoZmlsdGVyKTtcbiAgICAgICAgICAgICAgICBmaWx0ZXJNYXBzLmRlbGV0ZShmaWx0ZXIpO1xuICAgICAgICAgICAgICAgIC8vIENsZWFyIHRoZSBwYXJlbnQgaWYgbm90aGluZyBpcyBsZWZ0XG4gICAgICAgICAgICAgICAgaWYgKGZpbHRlck1hcHMuc2l6ZSA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAoX2IgPSBfdGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5kZWxldGUoa2V5KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyTWFwcztcbiAgICAgICAgICAgIH0pXG4gICAgICAgICAgICAgICAgLnJlZHVjZShmdW5jdGlvbiAocHJldiwgY3VyKSB7XG4gICAgICAgICAgICAgICAgdmFyIF9hO1xuICAgICAgICAgICAgICAgIHJldHVybiAoY3VyID8gKF9hID0gcHJldikuY29uY2F0LmFwcGx5KF9hLCBjdXIpIDogcHJldik7XG4gICAgICAgICAgICB9LCBbXSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gTm8gc3Vic2NyaXB0aW9ucyBmb3IgdGhpcyBsaXN0ZW5lclxuICAgICAgICBpZiAoIXJlYWxMaXN0ZW5lciB8fCAhdGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuaGFzKHJlYWxMaXN0ZW5lcikpIHtcbiAgICAgICAgICAgIHJldHVybiBbXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVhbExpc3RlbmVyTWFwID0gdGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMuZ2V0KHJlYWxMaXN0ZW5lcik7XG4gICAgICAgIC8vIElmIG5vIGZpbHRlciBpcyBzcGVjaWZpZWQgcmV0dXJuIGFsbCBsaXN0ZW5lcnMgdXNpbmcgdGhhdCBmdW5jdGlvblxuICAgICAgICBpZiAoIWZpbHRlcikge1xuICAgICAgICAgICAgLy8gYXJyYXkuZmxhdCBpcyBub3QgYXZhaWxhYmxlIHVubGVzcyB3ZSBzdXBwb3J0IGVzMjAxOSBvciBoaWdoZXJcbiAgICAgICAgICAgIHZhciBsaXN0ZW5lcnNfMSA9IEFycmF5LmZyb20ocmVhbExpc3RlbmVyTWFwLnZhbHVlcygpKS5yZWR1Y2UoZnVuY3Rpb24gKHByZXYsIGN1cikgeyByZXR1cm4gcHJldi5jb25jYXQuYXBwbHkocHJldiwgY3VyKTsgfSwgW10pO1xuICAgICAgICAgICAgLy8gcmVtb3ZlIHRoZSBsaXN0ZW5lciBmcm9tIHRoZSBtYXBcbiAgICAgICAgICAgIHRoaXMuZmlsdGVyZWRTdWJzY3JpcHRpb25zLmRlbGV0ZShyZWFsTGlzdGVuZXIpO1xuICAgICAgICAgICAgcmV0dXJuIGxpc3RlbmVyc18xO1xuICAgICAgICB9XG4gICAgICAgIHZhciBsaXN0ZW5lcnMgPSByZWFsTGlzdGVuZXJNYXAuZ2V0KGZpbHRlcik7XG4gICAgICAgIHJlYWxMaXN0ZW5lck1hcC5kZWxldGUoZmlsdGVyKTtcbiAgICAgICAgcmV0dXJuIGxpc3RlbmVycyB8fCBbXTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHZhciBfYTtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTsgLyogW2V2ZW50XSwgbGlzdGVuZXIgKi9cbiAgICAgICAgZm9yICh2YXIgX2kgPSAwIC8qIFtldmVudF0sIGxpc3RlbmVyICovOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGggLyogW2V2ZW50XSwgbGlzdGVuZXIgKi87IF9pKysgLyogW2V2ZW50XSwgbGlzdGVuZXIgKi8pIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTsgLyogW2V2ZW50XSwgbGlzdGVuZXIgKi9cbiAgICAgICAgfVxuICAgICAgICB2YXIgX2IgPSBSZWFsdGltZUNoYW5uZWwucHJvY2Vzc0xpc3RlbmVyQXJncyhhcmdzKSwgZXZlbnQgPSBfYlswXSwgbGlzdGVuZXIgPSBfYlsxXTtcbiAgICAgICAgLy8gSWYgd2UgZWl0aGVyIGhhdmUgYSBmaWx0ZXJlZCBsaXN0ZW5lciwgYSBmaWx0ZXIgb3IgYm90aCB3ZSBuZWVkIHRvIGRvIGFkZGl0aW9uYWwgcHJvY2Vzc2luZyB0byBmaW5kIHRoZSBvcmlnaW5hbCBmdW5jdGlvbihzKVxuICAgICAgICBpZiAoKHR5cGVvZiBldmVudCA9PT0gJ29iamVjdCcgJiYgIWxpc3RlbmVyKSB8fCAoKF9hID0gdGhpcy5maWx0ZXJlZFN1YnNjcmlwdGlvbnMpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5oYXMobGlzdGVuZXIpKSkge1xuICAgICAgICAgICAgdGhpcy5fZ2V0QW5kRGVsZXRlRmlsdGVyZWRTdWJzY3JpcHRpb25zKGV2ZW50LCBsaXN0ZW5lcikuZm9yRWFjaChmdW5jdGlvbiAobCkgeyByZXR1cm4gX3RoaXMuc3Vic2NyaXB0aW9ucy5vZmYobCk7IH0pO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc3luYyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyogY2hlY2sgcHJlY29uZGl0aW9ucyAqL1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2luaXRpYWxpemVkJzpcbiAgICAgICAgICAgIGNhc2UgJ2RldGFjaGluZyc6XG4gICAgICAgICAgICBjYXNlICdkZXRhY2hlZCc6XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ1VuYWJsZSB0byBzeW5jIHRvIGNoYW5uZWw7IG5vdCBhdHRhY2hlZCcsIDQwMDAwKTtcbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNvbm5lY3Rpb25NYW5hZ2VyID0gdGhpcy5jb25uZWN0aW9uTWFuYWdlcjtcbiAgICAgICAgaWYgKCFjb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICAgICAgICB0aHJvdyBjb25uZWN0aW9uTWFuYWdlci5nZXRFcnJvcigpO1xuICAgICAgICB9XG4gICAgICAgIC8qIHNlbmQgc3luYyByZXF1ZXN0ICovXG4gICAgICAgIHZhciBzeW5jTWVzc2FnZSA9IHByb3RvY29sbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyh7IGFjdGlvbjogYWN0aW9ucy5TWU5DLCBjaGFubmVsOiB0aGlzLm5hbWUgfSk7XG4gICAgICAgIGlmICh0aGlzLnN5bmNDaGFubmVsU2VyaWFsKSB7XG4gICAgICAgICAgICBzeW5jTWVzc2FnZS5jaGFubmVsU2VyaWFsID0gdGhpcy5zeW5jQ2hhbm5lbFNlcmlhbDtcbiAgICAgICAgfVxuICAgICAgICBjb25uZWN0aW9uTWFuYWdlci5zZW5kKHN5bmNNZXNzYWdlKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUuc2VuZE1lc3NhZ2UgPSBmdW5jdGlvbiAobXNnLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnNlbmQobXNnLCB0aGlzLnJlYWx0aW1lLm9wdGlvbnMucXVldWVNZXNzYWdlcywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zZW5kUHJlc2VuY2UgPSBmdW5jdGlvbiAocHJlc2VuY2UsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBtc2cgPSBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgYWN0aW9uOiBhY3Rpb25zLlBSRVNFTkNFLFxuICAgICAgICAgICAgY2hhbm5lbDogdGhpcy5uYW1lLFxuICAgICAgICAgICAgcHJlc2VuY2U6IFV0aWxzLmlzQXJyYXkocHJlc2VuY2UpXG4gICAgICAgICAgICAgICAgPyBwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXNBcnJheShwcmVzZW5jZSlcbiAgICAgICAgICAgICAgICA6IFtwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMocHJlc2VuY2UpXSxcbiAgICAgICAgfSk7XG4gICAgICAgIHRoaXMuc2VuZE1lc3NhZ2UobXNnLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLm9uTWVzc2FnZSA9IGZ1bmN0aW9uIChtZXNzYWdlKSB7XG4gICAgICAgIGlmIChtZXNzYWdlLmFjdGlvbiA9PT0gYWN0aW9ucy5BVFRBQ0hFRCB8fFxuICAgICAgICAgICAgbWVzc2FnZS5hY3Rpb24gPT09IGFjdGlvbnMuTUVTU0FHRSB8fFxuICAgICAgICAgICAgbWVzc2FnZS5hY3Rpb24gPT09IGFjdGlvbnMuUFJFU0VOQ0UpIHtcbiAgICAgICAgICAgIC8vIFJUTDE1YlxuICAgICAgICAgICAgdGhpcy5zZXRDaGFubmVsU2VyaWFsKG1lc3NhZ2UuY2hhbm5lbFNlcmlhbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIHN5bmNDaGFubmVsU2VyaWFsLCBpc1N5bmMgPSBmYWxzZTtcbiAgICAgICAgc3dpdGNoIChtZXNzYWdlLmFjdGlvbikge1xuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLkFUVEFDSEVEOiB7XG4gICAgICAgICAgICAgICAgdGhpcy5wcm9wZXJ0aWVzLmF0dGFjaFNlcmlhbCA9IG1lc3NhZ2UuY2hhbm5lbFNlcmlhbDtcbiAgICAgICAgICAgICAgICB0aGlzLl9tb2RlID0gbWVzc2FnZS5nZXRNb2RlKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5wYXJhbXMgPSBtZXNzYWdlLnBhcmFtcyB8fCB7fTtcbiAgICAgICAgICAgICAgICB2YXIgbW9kZXNGcm9tRmxhZ3MgPSBtZXNzYWdlLmRlY29kZU1vZGVzRnJvbUZsYWdzKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5tb2RlcyA9IChtb2Rlc0Zyb21GbGFncyAmJiBVdGlscy5hbGxUb0xvd2VyQ2FzZShtb2Rlc0Zyb21GbGFncykpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICB2YXIgcmVzdW1lZCA9IG1lc3NhZ2UuaGFzRmxhZygnUkVTVU1FRCcpO1xuICAgICAgICAgICAgICAgIHZhciBoYXNQcmVzZW5jZSA9IG1lc3NhZ2UuaGFzRmxhZygnSEFTX1BSRVNFTkNFJyk7XG4gICAgICAgICAgICAgICAgdmFyIGhhc0JhY2tsb2cgPSBtZXNzYWdlLmhhc0ZsYWcoJ0hBU19CQUNLTE9HJyk7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFyZXN1bWVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBPbiBhIGxvc3Mgb2YgY29udGludWl0eSwgdGhlIHByZXNlbmNlIHNldCBuZWVkcyB0byBiZSByZS1zeW5jZWQgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMucHJlc2VuY2Uub25BdHRhY2hlZChoYXNQcmVzZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgdmFyIGNoYW5nZSA9IG5ldyBjaGFubmVsc3RhdGVjaGFuZ2VfMS5kZWZhdWx0KHRoaXMuc3RhdGUsIHRoaXMuc3RhdGUsIHJlc3VtZWQsIGhhc0JhY2tsb2csIG1lc3NhZ2UuZXJyb3IpO1xuICAgICAgICAgICAgICAgICAgICB0aGlzLl9hbGxDaGFubmVsQ2hhbmdlcy5lbWl0KCd1cGRhdGUnLCBjaGFuZ2UpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoIXJlc3VtZWQgfHwgdGhpcy5jaGFubmVsT3B0aW9ucy51cGRhdGVPbkF0dGFjaGVkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmVtaXQoJ3VwZGF0ZScsIGNoYW5nZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAodGhpcy5zdGF0ZSA9PT0gJ2RldGFjaGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogUlRMNWk6IHJlLXNlbmQgREVUQUNIIGFuZCByZW1haW4gaW4gdGhlICdkZXRhY2hpbmcnIHN0YXRlICovXG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQZW5kaW5nU3RhdGUoKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoJ2F0dGFjaGVkJywgbWVzc2FnZS5lcnJvciwgcmVzdW1lZCwgaGFzUHJlc2VuY2UsIGhhc0JhY2tsb2cpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5ERVRBQ0hFRDoge1xuICAgICAgICAgICAgICAgIHZhciBkZXRhY2hFcnIgPSBtZXNzYWdlLmVycm9yXG4gICAgICAgICAgICAgICAgICAgID8gZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKG1lc3NhZ2UuZXJyb3IpXG4gICAgICAgICAgICAgICAgICAgIDogbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0NoYW5uZWwgZGV0YWNoZWQnLCA5MDAwMSwgNDA0KTtcbiAgICAgICAgICAgICAgICBpZiAodGhpcy5zdGF0ZSA9PT0gJ2RldGFjaGluZycpIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSgnZGV0YWNoZWQnLCBkZXRhY2hFcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmICh0aGlzLnN0YXRlID09PSAnYXR0YWNoaW5nJykge1xuICAgICAgICAgICAgICAgICAgICAvKiBPbmx5IHJldHJ5IGltbWVkaWF0ZWx5IGlmIHdlIHdlcmUgcHJldmlvdXNseSBhdHRhY2hlZC4gSWYgd2Ugd2VyZVxuICAgICAgICAgICAgICAgICAgICAgKiBhdHRhY2hpbmcsIGdvIGludG8gc3VzcGVuZGVkLCBmYWlsIG1lc3NhZ2VzLCBhbmQgd2FpdCBhIGZldyBzZWNvbmRzXG4gICAgICAgICAgICAgICAgICAgICAqIGJlZm9yZSByZXRyeWluZyAqL1xuICAgICAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKCdzdXNwZW5kZWQnLCBkZXRhY2hFcnIpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5yZXF1ZXN0U3RhdGUoJ2F0dGFjaGluZycsIGRldGFjaEVycik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLlNZTkM6XG4gICAgICAgICAgICAgICAgLyogc3luY3MgY2FuIGhhdmUgY2hhbm5lbFNlcmlhbHMsIGJ1dCBtaWdodCBub3QgaWYgdGhlIHN5bmMgaXMgb25lIHBhZ2UgbG9uZyAqL1xuICAgICAgICAgICAgICAgIGlzU3luYyA9IHRydWU7XG4gICAgICAgICAgICAgICAgc3luY0NoYW5uZWxTZXJpYWwgPSB0aGlzLnN5bmNDaGFubmVsU2VyaWFsID0gbWVzc2FnZS5jaGFubmVsU2VyaWFsO1xuICAgICAgICAgICAgICAgIC8qIHN5bmNzIGNhbiBoYXBwZW4gb24gY2hhbm5lbHMgd2l0aCBubyBwcmVzZW5jZSBkYXRhIGFzIHBhcnQgb2YgY29ubmVjdGlvblxuICAgICAgICAgICAgICAgICAqIHJlc3VtaW5nLCBpbiB3aGljaCBjYXNlIHByb3RvY29sIG1lc3NhZ2UgaGFzIG5vIHByZXNlbmNlIHByb3BlcnR5ICovXG4gICAgICAgICAgICAgICAgaWYgKCFtZXNzYWdlLnByZXNlbmNlKVxuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLlBSRVNFTkNFOiB7XG4gICAgICAgICAgICAgICAgdmFyIHByZXNlbmNlID0gbWVzc2FnZS5wcmVzZW5jZTtcbiAgICAgICAgICAgICAgICB2YXIgaWQgPSBtZXNzYWdlLmlkLCBjb25uZWN0aW9uSWQgPSBtZXNzYWdlLmNvbm5lY3Rpb25JZCwgdGltZXN0YW1wID0gbWVzc2FnZS50aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgdmFyIG9wdGlvbnMgPSB0aGlzLmNoYW5uZWxPcHRpb25zO1xuICAgICAgICAgICAgICAgIHZhciBwcmVzZW5jZU1zZyA9IHZvaWQgMDtcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHByZXNlbmNlLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZU1zZyA9IHByZXNlbmNlW2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdC5kZWNvZGUocHJlc2VuY2VNc2csIG9wdGlvbnMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmVzZW5jZU1zZy5jb25uZWN0aW9uSWQpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2VNc2cuY29ubmVjdGlvbklkID0gY29ubmVjdGlvbklkO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmVzZW5jZU1zZy50aW1lc3RhbXApXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcHJlc2VuY2VNc2cudGltZXN0YW1wID0gdGltZXN0YW1wO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFwcmVzZW5jZU1zZy5pZClcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZU1zZy5pZCA9IGlkICsgJzonICsgaTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYXRjaCAoZSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCBlLnRvU3RyaW5nKCkpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMucHJlc2VuY2Uuc2V0UHJlc2VuY2UocHJlc2VuY2UsIGlzU3luYywgc3luY0NoYW5uZWxTZXJpYWwpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FzZSBhY3Rpb25zLk1FU1NBR0U6IHtcbiAgICAgICAgICAgICAgICAvL1JUTDE3XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuc3RhdGUgIT09ICdhdHRhY2hlZCcpIHtcbiAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUFKT1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCAnTWVzc2FnZSBcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgbWVzc2FnZS5pZCArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXCIgc2tpcHBlZCBhcyB0aGlzIGNoYW5uZWwgXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubmFtZSArXG4gICAgICAgICAgICAgICAgICAgICAgICAnXCIgc3RhdGUgaXMgbm90IFwiYXR0YWNoZWRcIiAoc3RhdGUgaXMgXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuc3RhdGUgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1wiKS4nKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB2YXIgbWVzc2FnZXMgPSBtZXNzYWdlLm1lc3NhZ2VzLCBmaXJzdE1lc3NhZ2UgPSBtZXNzYWdlc1swXSwgbGFzdE1lc3NhZ2UgPSBtZXNzYWdlc1ttZXNzYWdlcy5sZW5ndGggLSAxXSwgaWQgPSBtZXNzYWdlLmlkLCBjb25uZWN0aW9uSWQgPSBtZXNzYWdlLmNvbm5lY3Rpb25JZCwgdGltZXN0YW1wID0gbWVzc2FnZS50aW1lc3RhbXA7XG4gICAgICAgICAgICAgICAgaWYgKGZpcnN0TWVzc2FnZS5leHRyYXMgJiZcbiAgICAgICAgICAgICAgICAgICAgZmlyc3RNZXNzYWdlLmV4dHJhcy5kZWx0YSAmJlxuICAgICAgICAgICAgICAgICAgICBmaXJzdE1lc3NhZ2UuZXh0cmFzLmRlbHRhLmZyb20gIT09IHRoaXMuX2xhc3RQYXlsb2FkLm1lc3NhZ2VJZCkge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gJ0RlbHRhIG1lc3NhZ2UgZGVjb2RlIGZhaWx1cmUgLSBwcmV2aW91cyBtZXNzYWdlIG5vdCBhdmFpbGFibGUgZm9yIG1lc3NhZ2UgXCInICtcbiAgICAgICAgICAgICAgICAgICAgICAgIG1lc3NhZ2UuaWQgK1xuICAgICAgICAgICAgICAgICAgICAgICAgJ1wiIG9uIHRoaXMgY2hhbm5lbCBcIicgK1xuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5uYW1lICtcbiAgICAgICAgICAgICAgICAgICAgICAgICdcIi4nO1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbk1lc3NhZ2UoKScsIG1zZyk7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuX3N0YXJ0RGVjb2RlRmFpbHVyZVJlY292ZXJ5KG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgNDAwMTgsIDQwMCkpO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBtZXNzYWdlcy5sZW5ndGg7IGkrKykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgbXNnID0gbWVzc2FnZXNbaV07XG4gICAgICAgICAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtZXNzYWdlXzEuZGVmYXVsdC5kZWNvZGUobXNnLCB0aGlzLl9kZWNvZGluZ0NvbnRleHQpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBkZWNyeXB0IGZhaWxlZCAuLiB0aGUgbW9zdCBsaWtlbHkgY2F1c2UgaXMgdGhhdCB3ZSBoYXZlIHRoZSB3cm9uZyBrZXkgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnUmVhbHRpbWVDaGFubmVsLm9uTWVzc2FnZSgpJywgZS50b1N0cmluZygpKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoZS5jb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0MDAxODpcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLyogZGVjb2RlIGZhaWx1cmUgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5fc3RhcnREZWNvZGVGYWlsdXJlUmVjb3ZlcnkoZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDQwMDE5OlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIE5vIHZjZGlmZiBwbHVnaW4gcGFzc2VkIGluIC0gbm8gcG9pbnQgcmVjb3ZlcmluZywgZ2l2ZSB1cCAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1mYWxsdGhyb3VnaFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgNDAwMjE6XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIEJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCBkZWx0YXMsIHNpbWlsYXJseSBubyBwb2ludCByZWNvdmVyaW5nICovXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoJ2ZhaWxlZCcsIGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtc2cuY29ubmVjdGlvbklkKVxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnLmNvbm5lY3Rpb25JZCA9IGNvbm5lY3Rpb25JZDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtc2cudGltZXN0YW1wKVxuICAgICAgICAgICAgICAgICAgICAgICAgbXNnLnRpbWVzdGFtcCA9IHRpbWVzdGFtcDtcbiAgICAgICAgICAgICAgICAgICAgaWYgKCFtc2cuaWQpXG4gICAgICAgICAgICAgICAgICAgICAgICBtc2cuaWQgPSBpZCArICc6JyArIGk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RQYXlsb2FkLm1lc3NhZ2VJZCA9IGxhc3RNZXNzYWdlLmlkO1xuICAgICAgICAgICAgICAgIHRoaXMuX2xhc3RQYXlsb2FkLnByb3RvY29sTWVzc2FnZUNoYW5uZWxTZXJpYWwgPSBtZXNzYWdlLmNoYW5uZWxTZXJpYWw7XG4gICAgICAgICAgICAgICAgdGhpcy5vbkV2ZW50KG1lc3NhZ2VzKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhc2UgYWN0aW9ucy5FUlJPUjoge1xuICAgICAgICAgICAgICAgIC8qIHRoZXJlIHdhcyBhIGNoYW5uZWwtc3BlY2lmaWMgZXJyb3IgKi9cbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gbWVzc2FnZS5lcnJvcjtcbiAgICAgICAgICAgICAgICBpZiAoZXJyICYmIGVyci5jb2RlID09IDgwMDE2KSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIGF0dGFjaC9kZXRhY2ggb3BlcmF0aW9uIGF0dGVtcHRlZCBvbiBzdXBlcnNlZGVkIHRyYW5zcG9ydCBoYW5kbGUgKi9cbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5ub3RpZnlTdGF0ZSgnZmFpbGVkJywgZXJyb3JpbmZvXzEuZGVmYXVsdC5mcm9tVmFsdWVzKGVycikpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCAnRmF0YWwgcHJvdG9jb2wgZXJyb3I6IHVucmVjb2duaXNlZCBhY3Rpb24gKCcgKyBtZXNzYWdlLmFjdGlvbiArICcpJyk7XG4gICAgICAgICAgICAgICAgdGhpcy5jb25uZWN0aW9uTWFuYWdlci5hYm9ydChjb25uZWN0aW9uZXJyb3JzXzEuZGVmYXVsdC51bmtub3duQ2hhbm5lbEVycigpKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5fc3RhcnREZWNvZGVGYWlsdXJlUmVjb3ZlcnkgPSBmdW5jdGlvbiAocmVhc29uKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5fbGFzdFBheWxvYWQuZGVjb2RlRmFpbHVyZVJlY292ZXJ5SW5Qcm9ncmVzcykge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUFKT1IsICdSZWFsdGltZUNoYW5uZWwub25NZXNzYWdlKCknLCAnU3RhcnRpbmcgZGVjb2RlIGZhaWx1cmUgcmVjb3ZlcnkgcHJvY2Vzcy4nKTtcbiAgICAgICAgICAgIHRoaXMuX2xhc3RQYXlsb2FkLmRlY29kZUZhaWx1cmVSZWNvdmVyeUluUHJvZ3Jlc3MgPSB0cnVlO1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoKHRydWUsIHJlYXNvbiwgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLl9sYXN0UGF5bG9hZC5kZWNvZGVGYWlsdXJlUmVjb3ZlcnlJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5vbkF0dGFjaGVkID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5vbkF0dGFjaGVkJywgJ2FjdGl2YXRpbmcgY2hhbm5lbDsgbmFtZSA9ICcgKyB0aGlzLm5hbWUpO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5ub3RpZnlTdGF0ZSA9IGZ1bmN0aW9uIChzdGF0ZSwgcmVhc29uLCByZXN1bWVkLCBoYXNQcmVzZW5jZSwgaGFzQmFja2xvZykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5ub3RpZnlTdGF0ZScsICduYW1lID0gJyArIHRoaXMubmFtZSArICcsIGN1cnJlbnQgc3RhdGUgPSAnICsgdGhpcy5zdGF0ZSArICcsIG5vdGlmeWluZyBzdGF0ZSAnICsgc3RhdGUpO1xuICAgICAgICB0aGlzLmNsZWFyU3RhdGVUaW1lcigpO1xuICAgICAgICAvLyBSVFA1YTFcbiAgICAgICAgaWYgKFV0aWxzLmFyckluKFsnZGV0YWNoZWQnLCAnc3VzcGVuZGVkJywgJ2ZhaWxlZCddLCBzdGF0ZSkpIHtcbiAgICAgICAgICAgIHRoaXMucHJvcGVydGllcy5jaGFubmVsU2VyaWFsID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoc3RhdGUgPT09IHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnByZXNlbmNlLmFjdE9uQ2hhbm5lbFN0YXRlKHN0YXRlLCBoYXNQcmVzZW5jZSwgcmVhc29uKTtcbiAgICAgICAgaWYgKHN0YXRlID09PSAnc3VzcGVuZGVkJyAmJiB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgICAgICAgIHRoaXMuc3RhcnRSZXRyeVRpbWVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLmNhbmNlbFJldHJ5VGltZXIoKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVhc29uKSB7XG4gICAgICAgICAgICB0aGlzLmVycm9yUmVhc29uID0gcmVhc29uO1xuICAgICAgICB9XG4gICAgICAgIHZhciBjaGFuZ2UgPSBuZXcgY2hhbm5lbHN0YXRlY2hhbmdlXzEuZGVmYXVsdCh0aGlzLnN0YXRlLCBzdGF0ZSwgcmVzdW1lZCwgaGFzQmFja2xvZywgcmVhc29uKTtcbiAgICAgICAgdmFyIGxvZ0xldmVsID0gc3RhdGUgPT09ICdmYWlsZWQnID8gbG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IgOiBsb2dnZXJfMS5kZWZhdWx0LkxPR19NQUpPUjtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nTGV2ZWwsICdDaGFubmVsIHN0YXRlIGZvciBjaGFubmVsIFwiJyArIHRoaXMubmFtZSArICdcIicsIHN0YXRlICsgKHJlYXNvbiA/ICc7IHJlYXNvbjogJyArIHJlYXNvbiA6ICcnKSk7XG4gICAgICAgIGlmIChzdGF0ZSAhPT0gJ2F0dGFjaGluZycgJiYgc3RhdGUgIT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgICAgICB0aGlzLnJldHJ5Q291bnQgPSAwO1xuICAgICAgICB9XG4gICAgICAgIC8qIE5vdGU6IHdlIGRvbid0IHNldCBpblByb2dyZXNzIGZvciBwZW5kaW5nIHN0YXRlcyB1bnRpbCB0aGUgcmVxdWVzdCBpcyBhY3R1YWxseSBpbiBwcm9ncmVzcyAqL1xuICAgICAgICBpZiAoc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcbiAgICAgICAgICAgIHRoaXMub25BdHRhY2hlZCgpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChzdGF0ZSA9PT0gJ2F0dGFjaGVkJykge1xuICAgICAgICAgICAgdGhpcy5fYXR0YWNoUmVzdW1lID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChzdGF0ZSA9PT0gJ2RldGFjaGluZycgfHwgc3RhdGUgPT09ICdmYWlsZWQnKSB7XG4gICAgICAgICAgICB0aGlzLl9hdHRhY2hSZXN1bWUgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN0YXRlID0gc3RhdGU7XG4gICAgICAgIHRoaXMuX2FsbENoYW5uZWxDaGFuZ2VzLmVtaXQoc3RhdGUsIGNoYW5nZSk7XG4gICAgICAgIHRoaXMuZW1pdChzdGF0ZSwgY2hhbmdlKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lQ2hhbm5lbC5wcm90b3R5cGUucmVxdWVzdFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCByZWFzb24pIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwucmVxdWVzdFN0YXRlJywgJ25hbWUgPSAnICsgdGhpcy5uYW1lICsgJywgc3RhdGUgPSAnICsgc3RhdGUpO1xuICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKHN0YXRlLCByZWFzb24pO1xuICAgICAgICAvKiBzZW5kIHRoZSBldmVudCBhbmQgYXdhaXQgcmVzcG9uc2UgKi9cbiAgICAgICAgdGhpcy5jaGVja1BlbmRpbmdTdGF0ZSgpO1xuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5jaGVja1BlbmRpbmdTdGF0ZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgLyogaWYgY2FuJ3Qgc2VuZCBldmVudHMsIGRvIG5vdGhpbmcgKi9cbiAgICAgICAgdmFyIGNtU3RhdGUgPSB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlO1xuICAgICAgICAvKiBBbGxvdyBhdHRhY2ggbWVzc2FnZXMgdG8gcXVldWUgdXAgd2hlbiBzeW5jaHJvbml6aW5nLCBzaW5jZSB0aGlzIHdpbGwgYmVcbiAgICAgICAgICogdGhlIHN0YXRlIHdlJ2xsIGJlIGluIHdoZW4gdXBncmFkZSB0cmFuc3BvcnQuYWN0aXZlIHRyaWdnZXJzIGEgY2hlY2twZW5kaW5nc3RhdGUgKi9cbiAgICAgICAgaWYgKCEoY21TdGF0ZS5zZW5kRXZlbnRzIHx8IGNtU3RhdGUuZm9yY2VRdWV1ZUV2ZW50cykpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUmVhbHRpbWVDaGFubmVsLmNoZWNrUGVuZGluZ1N0YXRlJywgJ3NlbmRFdmVudHMgaXMgZmFsc2U7IHN0YXRlIGlzICcgKyB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnN0YXRlKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5jaGVja1BlbmRpbmdTdGF0ZScsICduYW1lID0gJyArIHRoaXMubmFtZSArICcsIHN0YXRlID0gJyArIHRoaXMuc3RhdGUpO1xuICAgICAgICAvKiBPbmx5IHN0YXJ0IHRoZSBzdGF0ZSB0aW1lciBydW5uaW5nIHdoZW4gYWN0dWFsbHkgc2VuZGluZyB0aGUgZXZlbnQgKi9cbiAgICAgICAgc3dpdGNoICh0aGlzLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdhdHRhY2hpbmcnOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5hdHRhY2hJbXBsKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdkZXRhY2hpbmcnOlxuICAgICAgICAgICAgICAgIHRoaXMuc3RhcnRTdGF0ZVRpbWVySWZOb3RSdW5uaW5nKCk7XG4gICAgICAgICAgICAgICAgdGhpcy5kZXRhY2hJbXBsKCk7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICBjYXNlICdhdHRhY2hlZCc6XG4gICAgICAgICAgICAgICAgLyogcmVzdW1lIGFueSBzeW5jIG9wZXJhdGlvbiB0aGF0IHdhcyBpbiBwcm9ncmVzcyAqL1xuICAgICAgICAgICAgICAgIHRoaXMuc3luYygpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS50aW1lb3V0UGVuZGluZ1N0YXRlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBzd2l0Y2ggKHRoaXMuc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2F0dGFjaGluZyc6IHtcbiAgICAgICAgICAgICAgICB2YXIgZXJyID0gbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0NoYW5uZWwgYXR0YWNoIHRpbWVkIG91dCcsIDkwMDA3LCA0MDgpO1xuICAgICAgICAgICAgICAgIHRoaXMubm90aWZ5U3RhdGUoJ3N1c3BlbmRlZCcsIGVycik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXNlICdkZXRhY2hpbmcnOiB7XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdDaGFubmVsIGRldGFjaCB0aW1lZCBvdXQnLCA5MDAwNywgNDA4KTtcbiAgICAgICAgICAgICAgICB0aGlzLm5vdGlmeVN0YXRlKCdhdHRhY2hlZCcsIGVycik7XG4gICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tQZW5kaW5nU3RhdGUoKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghdGhpcy5zdGF0ZVRpbWVyKSB7XG4gICAgICAgICAgICB0aGlzLnN0YXRlVGltZXIgPSBzZXRUaW1lb3V0KGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbC5zdGFydFN0YXRlVGltZXJJZk5vdFJ1bm5pbmcnLCAndGltZXIgZXhwaXJlZCcpO1xuICAgICAgICAgICAgICAgIF90aGlzLnN0YXRlVGltZXIgPSBudWxsO1xuICAgICAgICAgICAgICAgIF90aGlzLnRpbWVvdXRQZW5kaW5nU3RhdGUoKTtcbiAgICAgICAgICAgIH0sIHRoaXMucmVhbHRpbWUub3B0aW9ucy50aW1lb3V0cy5yZWFsdGltZVJlcXVlc3RUaW1lb3V0KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5jbGVhclN0YXRlVGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzdGF0ZVRpbWVyID0gdGhpcy5zdGF0ZVRpbWVyO1xuICAgICAgICBpZiAoc3RhdGVUaW1lcikge1xuICAgICAgICAgICAgY2xlYXJUaW1lb3V0KHN0YXRlVGltZXIpO1xuICAgICAgICAgICAgdGhpcy5zdGF0ZVRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVDaGFubmVsLnByb3RvdHlwZS5zdGFydFJldHJ5VGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICh0aGlzLnJldHJ5VGltZXIpXG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIHRoaXMucmV0cnlDb3VudCsrO1xuICAgICAgICB2YXIgcmV0cnlEZWxheSA9IFV0aWxzLmdldFJldHJ5VGltZSh0aGlzLnJlYWx0aW1lLm9wdGlvbnMudGltZW91dHMuY2hhbm5lbFJldHJ5VGltZW91dCwgdGhpcy5yZXRyeUNvdW50KTtcbiAgICAgICAgdGhpcy5yZXRyeVRpbWVyID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAvKiBJZiBjb25uZWN0aW9uIGlzIG5vdCBjb25uZWN0ZWQsIGp1c3QgbGVhdmUgaW4gc3VzcGVuZGVkLCBhIHJlYXR0YWNoXG4gICAgICAgICAgICAgKiB3aWxsIGJlIHRyaWdnZXJlZCBvbmNlIGl0IGNvbm5lY3RzIGFnYWluICovXG4gICAgICAgICAgICBpZiAoX3RoaXMuc3RhdGUgPT09ICdzdXNwZW5kZWQnICYmIF90aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnN0YXRlLnNlbmRFdmVudHMpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5yZXRyeVRpbWVyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1JlYWx0aW1lQ2hhbm5lbCByZXRyeSB0aW1lciBleHBpcmVkJywgJ2F0dGVtcHRpbmcgYSBuZXcgYXR0YWNoJyk7XG4gICAgICAgICAgICAgICAgX3RoaXMucmVxdWVzdFN0YXRlKCdhdHRhY2hpbmcnKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSwgcmV0cnlEZWxheSk7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmNhbmNlbFJldHJ5VGltZXIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGlmICh0aGlzLnJldHJ5VGltZXIpIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aGlzLnJldHJ5VGltZXIpO1xuICAgICAgICAgICAgdGhpcy5yZXRyeVRpbWVyID0gbnVsbDtcbiAgICAgICAgfVxuICAgIH07XG4gICAgLyogQHJldHVybnMgbnVsbCAoaWYgY2FuIHNhZmVseSBiZSByZWxlYXNlZCkgfCBFcnJvckluZm8gKGlmIGNhbm5vdCkgKi9cbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLmdldFJlbGVhc2VFcnIgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBzID0gdGhpcy5zdGF0ZTtcbiAgICAgICAgaWYgKHMgPT09ICdpbml0aWFsaXplZCcgfHwgcyA9PT0gJ2RldGFjaGVkJyB8fCBzID09PSAnZmFpbGVkJykge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdDYW4gb25seSByZWxlYXNlIGEgY2hhbm5lbCBpbiBhIHN0YXRlIHdoZXJlIHRoZXJlIGlzIG5vIHBvc3NpYmlsaXR5IG9mIGZ1cnRoZXIgdXBkYXRlcyBmcm9tIHRoZSBzZXJ2ZXIgYmVpbmcgcmVjZWl2ZWQgKGluaXRpYWxpemVkLCBkZXRhY2hlZCwgb3IgZmFpbGVkKTsgd2FzICcgK1xuICAgICAgICAgICAgcywgOTAwMDEsIDQwMCk7XG4gICAgfTtcbiAgICBSZWFsdGltZUNoYW5uZWwucHJvdG90eXBlLnNldENoYW5uZWxTZXJpYWwgPSBmdW5jdGlvbiAoY2hhbm5lbFNlcmlhbCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1JlYWx0aW1lQ2hhbm5lbC5zZXRDaGFubmVsU2VyaWFsKCknLCAnVXBkYXRpbmcgY2hhbm5lbCBzZXJpYWw7IHNlcmlhbCA9ICcgKyBjaGFubmVsU2VyaWFsICsgJzsgcHJldmlvdXMgPSAnICsgdGhpcy5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWwpO1xuICAgICAgICAvLyBSVFAxN2g6IE9ubHkgdXBkYXRlIHRoZSBjaGFubmVsIHNlcmlhbCBpZiBpdHMgcHJlc2VudCAoaXQgd29uJ3QgYWx3YXlzXG4gICAgICAgIC8vIGJlIHNldCkuXG4gICAgICAgIGlmIChjaGFubmVsU2VyaWFsKSB7XG4gICAgICAgICAgICB0aGlzLnByb3BlcnRpZXMuY2hhbm5lbFNlcmlhbCA9IGNoYW5uZWxTZXJpYWw7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBSZWFsdGltZUNoYW5uZWw7XG59KGNoYW5uZWxfMS5kZWZhdWx0KSk7XG5mdW5jdGlvbiBvbWl0QWdlbnQoY2hhbm5lbFBhcmFtcykge1xuICAgIHZhciBfYSA9IGNoYW5uZWxQYXJhbXMgfHwge30sIF8gPSBfYS5hZ2VudCwgcGFyYW1zV2l0aG91dEFnZW50ID0gdHNsaWJfMS5fX3Jlc3QoX2EsIFtcImFnZW50XCJdKTtcbiAgICByZXR1cm4gcGFyYW1zV2l0aG91dEFnZW50O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gUmVhbHRpbWVDaGFubmVsO1xuXG5cbi8qKiovIH0pLFxuLyogMzkgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBDaGFubmVsU3RhdGVDaGFuZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gQ2hhbm5lbFN0YXRlQ2hhbmdlKHByZXZpb3VzLCBjdXJyZW50LCByZXN1bWVkLCBoYXNCYWNrbG9nLCByZWFzb24pIHtcbiAgICAgICAgdGhpcy5wcmV2aW91cyA9IHByZXZpb3VzO1xuICAgICAgICB0aGlzLmN1cnJlbnQgPSBjdXJyZW50O1xuICAgICAgICBpZiAoY3VycmVudCA9PT0gJ2F0dGFjaGVkJykge1xuICAgICAgICAgICAgdGhpcy5yZXN1bWVkID0gcmVzdW1lZDtcbiAgICAgICAgICAgIHRoaXMuaGFzQmFja2xvZyA9IGhhc0JhY2tsb2c7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlYXNvbilcbiAgICAgICAgICAgIHRoaXMucmVhc29uID0gcmVhc29uO1xuICAgIH1cbiAgICByZXR1cm4gQ2hhbm5lbFN0YXRlQ2hhbmdlO1xufSgpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENoYW5uZWxTdGF0ZUNoYW5nZTtcblxuXG4vKioqLyB9KSxcbi8qIDQwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHQoZnVuY3Rpb24gKCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIFJldXNhYmxlIG9iamVjdFxuXHQgICAgdmFyIFcgPSBbXTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTSEEtMSBoYXNoIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIFNIQTEgPSBDX2FsZ28uU0hBMSA9IEhhc2hlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2hhc2ggPSBuZXcgV29yZEFycmF5LmluaXQoW1xuXHQgICAgICAgICAgICAgICAgMHg2NzQ1MjMwMSwgMHhlZmNkYWI4OSxcblx0ICAgICAgICAgICAgICAgIDB4OThiYWRjZmUsIDB4MTAzMjU0NzYsXG5cdCAgICAgICAgICAgICAgICAweGMzZDJlMWYwXG5cdCAgICAgICAgICAgIF0pO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBfZG9Qcm9jZXNzQmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIC8vIFdvcmtpbmcgdmFyaWFibGVzXG5cdCAgICAgICAgICAgIHZhciBhID0gSFswXTtcblx0ICAgICAgICAgICAgdmFyIGIgPSBIWzFdO1xuXHQgICAgICAgICAgICB2YXIgYyA9IEhbMl07XG5cdCAgICAgICAgICAgIHZhciBkID0gSFszXTtcblx0ICAgICAgICAgICAgdmFyIGUgPSBIWzRdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgODA7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGkgPCAxNikge1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSBNW29mZnNldCArIGldIHwgMDtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIG4gPSBXW2kgLSAzXSBeIFdbaSAtIDhdIF4gV1tpIC0gMTRdIF4gV1tpIC0gMTZdO1xuXHQgICAgICAgICAgICAgICAgICAgIFdbaV0gPSAobiA8PCAxKSB8IChuID4+PiAzMSk7XG5cdCAgICAgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgICAgIHZhciB0ID0gKChhIDw8IDUpIHwgKGEgPj4+IDI3KSkgKyBlICsgV1tpXTtcblx0ICAgICAgICAgICAgICAgIGlmIChpIDwgMjApIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9ICgoYiAmIGMpIHwgKH5iICYgZCkpICsgMHg1YTgyNzk5OTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSBpZiAoaSA8IDQwKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCArPSAoYiBeIGMgXiBkKSArIDB4NmVkOWViYTE7XG5cdCAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGkgPCA2MCkge1xuXHQgICAgICAgICAgICAgICAgICAgIHQgKz0gKChiICYgYykgfCAoYiAmIGQpIHwgKGMgJiBkKSkgLSAweDcwZTQ0MzI0O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIC8qIGlmIChpIDwgODApICovIHtcblx0ICAgICAgICAgICAgICAgICAgICB0ICs9IChiIF4gYyBeIGQpIC0gMHgzNTlkM2UyYTtcblx0ICAgICAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAgICAgZSA9IGQ7XG5cdCAgICAgICAgICAgICAgICBkID0gYztcblx0ICAgICAgICAgICAgICAgIGMgPSAoYiA8PCAzMCkgfCAoYiA+Pj4gMik7XG5cdCAgICAgICAgICAgICAgICBiID0gYTtcblx0ICAgICAgICAgICAgICAgIGEgPSB0O1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gSW50ZXJtZWRpYXRlIGhhc2ggdmFsdWVcblx0ICAgICAgICAgICAgSFswXSA9IChIWzBdICsgYSkgfCAwO1xuXHQgICAgICAgICAgICBIWzFdID0gKEhbMV0gKyBiKSB8IDA7XG5cdCAgICAgICAgICAgIEhbMl0gPSAoSFsyXSArIGMpIHwgMDtcblx0ICAgICAgICAgICAgSFszXSA9IChIWzNdICsgZCkgfCAwO1xuXHQgICAgICAgICAgICBIWzRdID0gKEhbNF0gKyBlKSB8IDA7XG5cdCAgICAgICAgfSxcblxuXHQgICAgICAgIF9kb0ZpbmFsaXplOiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0c1xuXHQgICAgICAgICAgICB2YXIgZGF0YSA9IHRoaXMuX2RhdGE7XG5cdCAgICAgICAgICAgIHZhciBkYXRhV29yZHMgPSBkYXRhLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsID0gdGhpcy5fbkRhdGFCeXRlcyAqIDg7XG5cdCAgICAgICAgICAgIHZhciBuQml0c0xlZnQgPSBkYXRhLnNpZ0J5dGVzICogODtcblxuXHQgICAgICAgICAgICAvLyBBZGQgcGFkZGluZ1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbbkJpdHNMZWZ0ID4+PiA1XSB8PSAweDgwIDw8ICgyNCAtIG5CaXRzTGVmdCAlIDMyKTtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNF0gPSBNYXRoLmZsb29yKG5CaXRzVG90YWwgLyAweDEwMDAwMDAwMCk7XG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1soKChuQml0c0xlZnQgKyA2NCkgPj4+IDkpIDw8IDQpICsgMTVdID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IGRhdGFXb3Jkcy5sZW5ndGggKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gdGhpcy5faGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTEoJ21lc3NhZ2UnKTtcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLlNIQTEod29yZEFycmF5KTtcblx0ICAgICAqL1xuXHQgICAgQy5TSEExID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoU0hBMSk7XG5cblx0ICAgIC8qKlxuXHQgICAgICogU2hvcnRjdXQgZnVuY3Rpb24gdG8gdGhlIEhNQUMncyBvYmplY3QgaW50ZXJmYWNlLlxuXHQgICAgICpcblx0ICAgICAqIEBwYXJhbSB7V29yZEFycmF5fHN0cmluZ30gbWVzc2FnZSBUaGUgbWVzc2FnZSB0byBoYXNoLlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBrZXkgVGhlIHNlY3JldCBrZXkuXG5cdCAgICAgKlxuXHQgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgSE1BQy5cblx0ICAgICAqXG5cdCAgICAgKiBAc3RhdGljXG5cdCAgICAgKlxuXHQgICAgICogQGV4YW1wbGVcblx0ICAgICAqXG5cdCAgICAgKiAgICAgdmFyIGhtYWMgPSBDcnlwdG9KUy5IbWFjU0hBMShtZXNzYWdlLCBrZXkpO1xuXHQgICAgICovXG5cdCAgICBDLkhtYWNTSEExID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKFNIQTEpO1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLlNIQTE7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiA0MSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZnVuY3Rpb24gaW5zcGVjdChidWZmZXIpIHtcbiAgICBpZiAoYnVmZmVyID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiAndW5kZWZpbmVkJztcbiAgICB2YXIgdmlldztcbiAgICB2YXIgdHlwZTtcbiAgICBpZiAoYnVmZmVyIGluc3RhbmNlb2YgQXJyYXlCdWZmZXIpIHtcbiAgICAgICAgdHlwZSA9ICdBcnJheUJ1ZmZlcic7XG4gICAgICAgIHZpZXcgPSBuZXcgRGF0YVZpZXcoYnVmZmVyKTtcbiAgICB9XG4gICAgZWxzZSBpZiAoYnVmZmVyIGluc3RhbmNlb2YgRGF0YVZpZXcpIHtcbiAgICAgICAgdHlwZSA9ICdEYXRhVmlldyc7XG4gICAgICAgIHZpZXcgPSBidWZmZXI7XG4gICAgfVxuICAgIGlmICghdmlldylcbiAgICAgICAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KGJ1ZmZlcik7XG4gICAgdmFyIGJ5dGVzID0gW107XG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIuYnl0ZUxlbmd0aDsgaSsrKSB7XG4gICAgICAgIGlmIChpID4gMjApIHtcbiAgICAgICAgICAgIGJ5dGVzLnB1c2goJy4uLicpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGJ5dGVfID0gdmlldy5nZXRVaW50OChpKS50b1N0cmluZygxNik7XG4gICAgICAgIGlmIChieXRlXy5sZW5ndGggPT09IDEpXG4gICAgICAgICAgICBieXRlXyA9ICcwJyArIGJ5dGVfO1xuICAgICAgICBieXRlcy5wdXNoKGJ5dGVfKTtcbiAgICB9XG4gICAgcmV0dXJuICc8JyArIHR5cGUgKyAnICcgKyBieXRlcy5qb2luKCcgJykgKyAnPic7XG59XG4vLyBFbmNvZGUgc3RyaW5nIGFzIHV0ZjggaW50byBkYXRhdmlldyBhdCBvZmZzZXRcbmZ1bmN0aW9uIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQsIHN0cmluZykge1xuICAgIGZvciAodmFyIGkgPSAwLCBsID0gc3RyaW5nLmxlbmd0aDsgaSA8IGw7IGkrKykge1xuICAgICAgICB2YXIgY29kZVBvaW50ID0gc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgIC8vIE9uZSBieXRlIG9mIFVURi04XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDgwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAoKGNvZGVQb2ludCA+Pj4gMCkgJiAweDdmKSB8IDB4MDApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgLy8gVHdvIGJ5dGVzIG9mIFVURi04XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDgwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgKChjb2RlUG9pbnQgPj4+IDYpICYgMHgxZikgfCAweGMwKTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssICgoY29kZVBvaW50ID4+PiAwKSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaHJlZSBieXRlcyBvZiBVVEYtOC5cbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssICgoY29kZVBvaW50ID4+PiAxMikgJiAweDBmKSB8IDB4ZTApO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgKChjb2RlUG9pbnQgPj4+IDYpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssICgoY29kZVBvaW50ID4+PiAwKSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3VyIGJ5dGVzIG9mIFVURi04XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQrKywgKChjb2RlUG9pbnQgPj4+IDE4KSAmIDB4MDcpIHwgMHhmMCk7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAoKGNvZGVQb2ludCA+Pj4gMTIpICYgMHgzZikgfCAweDgwKTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0KyssICgoY29kZVBvaW50ID4+PiA2KSAmIDB4M2YpIHwgMHg4MCk7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCsrLCAoKGNvZGVQb2ludCA+Pj4gMCkgJiAweDNmKSB8IDB4ODApO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdiYWQgY29kZXBvaW50ICcgKyBjb2RlUG9pbnQpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHV0ZjhSZWFkKHZpZXcsIG9mZnNldCwgbGVuZ3RoKSB7XG4gICAgdmFyIHN0cmluZyA9ICcnO1xuICAgIGZvciAodmFyIGkgPSBvZmZzZXQsIGVuZCA9IG9mZnNldCArIGxlbmd0aDsgaSA8IGVuZDsgaSsrKSB7XG4gICAgICAgIHZhciBieXRlXyA9IHZpZXcuZ2V0VWludDgoaSk7XG4gICAgICAgIC8vIE9uZSBieXRlIGNoYXJhY3RlclxuICAgICAgICBpZiAoKGJ5dGVfICYgMHg4MCkgPT09IDB4MDApIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKGJ5dGVfKTtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIC8vIFR3byBieXRlIGNoYXJhY3RlclxuICAgICAgICBpZiAoKGJ5dGVfICYgMHhlMCkgPT09IDB4YzApIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYnl0ZV8gJiAweDBmKSA8PCA2KSB8ICh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBUaHJlZSBieXRlIGNoYXJhY3RlclxuICAgICAgICBpZiAoKGJ5dGVfICYgMHhmMCkgPT09IDB4ZTApIHtcbiAgICAgICAgICAgIHN0cmluZyArPSBTdHJpbmcuZnJvbUNoYXJDb2RlKCgoYnl0ZV8gJiAweDBmKSA8PCAxMikgfCAoKHZpZXcuZ2V0VWludDgoKytpKSAmIDB4M2YpIDw8IDYpIHwgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCAwKSk7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICAvLyBGb3VyIGJ5dGUgY2hhcmFjdGVyXG4gICAgICAgIGlmICgoYnl0ZV8gJiAweGY4KSA9PT0gMHhmMCkge1xuICAgICAgICAgICAgc3RyaW5nICs9IFN0cmluZy5mcm9tQ2hhckNvZGUoKChieXRlXyAmIDB4MDcpIDw8IDE4KSB8XG4gICAgICAgICAgICAgICAgKCh2aWV3LmdldFVpbnQ4KCsraSkgJiAweDNmKSA8PCAxMikgfFxuICAgICAgICAgICAgICAgICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgNikgfFxuICAgICAgICAgICAgICAgICgodmlldy5nZXRVaW50OCgrK2kpICYgMHgzZikgPDwgMCkpO1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGJ5dGUgJyArIGJ5dGVfLnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIHJldHVybiBzdHJpbmc7XG59XG5mdW5jdGlvbiB1dGY4Qnl0ZUNvdW50KHN0cmluZykge1xuICAgIHZhciBjb3VudCA9IDA7XG4gICAgZm9yICh2YXIgaSA9IDAsIGwgPSBzdHJpbmcubGVuZ3RoOyBpIDwgbDsgaSsrKSB7XG4gICAgICAgIHZhciBjb2RlUG9pbnQgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcbiAgICAgICAgaWYgKGNvZGVQb2ludCA8IDB4ODApIHtcbiAgICAgICAgICAgIGNvdW50ICs9IDE7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHg4MDApIHtcbiAgICAgICAgICAgIGNvdW50ICs9IDI7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29kZVBvaW50IDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgY291bnQgKz0gMztcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChjb2RlUG9pbnQgPCAweDExMDAwMCkge1xuICAgICAgICAgICAgY291bnQgKz0gNDtcbiAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignYmFkIGNvZGVwb2ludCAnICsgY29kZVBvaW50KTtcbiAgICB9XG4gICAgcmV0dXJuIGNvdW50O1xufVxuZnVuY3Rpb24gZW5jb2RlKHZhbHVlLCBzcGFyc2UpIHtcbiAgICB2YXIgc2l6ZSA9IHNpemVvZih2YWx1ZSwgc3BhcnNlKTtcbiAgICBpZiAoc2l6ZSA9PT0gMClcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB2YXIgYnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKHNpemUpO1xuICAgIHZhciB2aWV3ID0gbmV3IERhdGFWaWV3KGJ1ZmZlcik7XG4gICAgX2VuY29kZSh2YWx1ZSwgdmlldywgMCwgc3BhcnNlKTtcbiAgICByZXR1cm4gYnVmZmVyO1xufVxudmFyIFNIX0xfMzIgPSAoMSA8PCAxNikgKiAoMSA8PCAxNiksIFNIX1JfMzIgPSAxIC8gU0hfTF8zMjtcbmZ1bmN0aW9uIGdldEludDY0KHZpZXcsIG9mZnNldCkge1xuICAgIG9mZnNldCA9IG9mZnNldCB8fCAwO1xuICAgIHJldHVybiB2aWV3LmdldEludDMyKG9mZnNldCkgKiBTSF9MXzMyICsgdmlldy5nZXRVaW50MzIob2Zmc2V0ICsgNCk7XG59XG5mdW5jdGlvbiBnZXRVaW50NjQodmlldywgb2Zmc2V0KSB7XG4gICAgb2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgcmV0dXJuIHZpZXcuZ2V0VWludDMyKG9mZnNldCkgKiBTSF9MXzMyICsgdmlldy5nZXRVaW50MzIob2Zmc2V0ICsgNCk7XG59XG5mdW5jdGlvbiBzZXRJbnQ2NCh2aWV3LCBvZmZzZXQsIHZhbCkge1xuICAgIGlmICh2YWwgPCAweDgwMDAwMDAwMDAwMDAwMDApIHtcbiAgICAgICAgdmlldy5zZXRJbnQzMihvZmZzZXQsIE1hdGguZmxvb3IodmFsICogU0hfUl8zMikpO1xuICAgICAgICB2aWV3LnNldEludDMyKG9mZnNldCArIDQsIHZhbCAmIC0xKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgMHg3ZmZmZmZmZik7XG4gICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCArIDQsIDB4N2ZmZmZmZmYpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIHNldFVpbnQ2NCh2aWV3LCBvZmZzZXQsIHZhbCkge1xuICAgIGlmICh2YWwgPCAweDEwMDAwMDAwMDAwMDAwMDAwKSB7XG4gICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCwgTWF0aC5mbG9vcih2YWwgKiBTSF9SXzMyKSk7XG4gICAgICAgIHZpZXcuc2V0SW50MzIob2Zmc2V0ICsgNCwgdmFsICYgLTEpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0LCAweGZmZmZmZmZmKTtcbiAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0ICsgNCwgMHhmZmZmZmZmZik7XG4gICAgfVxufVxuLy8gaHR0cHM6Ly9naXN0LmdpdGh1Yi5jb20vZnJzeXVraS81NDMyNTU5IC0gdjUgc3BlY1xuLy9cbi8vIEkndmUgdXNlZCBvbmUgZXh0ZW5zaW9uIHBvaW50IGZyb20gYGZpeGV4dCAxYCB0byBzdG9yZSBgdW5kZWZpbmVkYC4gT24gdGhlIHdpcmUgdGhpc1xuLy8gc2hvdWxkIHRyYW5zbGF0ZSB0byBleGFjdGx5IDB4ZDQwMDAwXG4vL1xuLy8gKy0tLS0tLS0tKy0tLS0tLS0tKy0tLS0tLS0tK1xuLy8gfCAgMHhkNCAgfCAgMHgwMCAgfCAgMHgwMCAgfFxuLy8gKy0tLS0tLS0tKy0tLS0tLS0tKy0tLS0tLS0tK1xuLy8gICAgXiBmaXhleHQgfCAgICAgICAgXiB2YWx1ZSBwYXJ0IHVudXNlZCAoZml4ZWQgdG8gYmUgMClcbi8vICAgICAgICAgICAgIF4gaW5kaWNhdGVzIHVuZGVmaW5lZCB2YWx1ZVxuLy9cbnZhciBEZWNvZGVyID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERlY29kZXIodmlldywgb2Zmc2V0KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIHRoaXMubWFwID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0ge307XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFyIGtleSA9IF90aGlzLnBhcnNlKCk7XG4gICAgICAgICAgICAgICAgdmFsdWVba2V5XSA9IF90aGlzLnBhcnNlKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuYmluID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbmV3IEFycmF5QnVmZmVyKGxlbmd0aCk7XG4gICAgICAgICAgICBuZXcgVWludDhBcnJheSh2YWx1ZSkuc2V0KG5ldyBVaW50OEFycmF5KF90aGlzLnZpZXcuYnVmZmVyLCBfdGhpcy5vZmZzZXQsIGxlbmd0aCksIDApO1xuICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IGxlbmd0aDtcbiAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5idWYgPSB0aGlzLmJpbjtcbiAgICAgICAgdGhpcy5zdHIgPSBmdW5jdGlvbiAobGVuZ3RoKSB7XG4gICAgICAgICAgICB2YXIgdmFsdWUgPSB1dGY4UmVhZChfdGhpcy52aWV3LCBfdGhpcy5vZmZzZXQsIGxlbmd0aCk7XG4gICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gbGVuZ3RoO1xuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmFycmF5ID0gZnVuY3Rpb24gKGxlbmd0aCkge1xuICAgICAgICAgICAgdmFyIHZhbHVlID0gbmV3IEFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICAgICAgdmFsdWVbaV0gPSBfdGhpcy5wYXJzZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICB9O1xuICAgICAgICB0aGlzLmV4dCA9IGZ1bmN0aW9uIChsZW5ndGgpIHtcbiAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSBsZW5ndGg7XG4gICAgICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgICAgIHR5cGU6IF90aGlzLnZpZXcuZ2V0SW50OChfdGhpcy5vZmZzZXQpLFxuICAgICAgICAgICAgICAgIGRhdGE6IF90aGlzLmJ1ZihsZW5ndGgpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfTtcbiAgICAgICAgdGhpcy5wYXJzZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIHZhciB0eXBlID0gX3RoaXMudmlldy5nZXRVaW50OChfdGhpcy5vZmZzZXQpO1xuICAgICAgICAgICAgdmFyIHZhbHVlLCBsZW5ndGg7XG4gICAgICAgICAgICAvLyBQb3NpdGl2ZSBGaXhJbnQgLSAweHh4eHh4eFxuICAgICAgICAgICAgaWYgKCh0eXBlICYgMHg4MCkgPT09IDB4MDApIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gdHlwZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpeE1hcCAtIDEwMDB4eHh4XG4gICAgICAgICAgICBpZiAoKHR5cGUgJiAweGYwKSA9PT0gMHg4MCkge1xuICAgICAgICAgICAgICAgIGxlbmd0aCA9IHR5cGUgJiAweDBmO1xuICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5tYXAobGVuZ3RoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIEZpeEFycmF5IC0gMTAwMXh4eHhcbiAgICAgICAgICAgIGlmICgodHlwZSAmIDB4ZjApID09PSAweDkwKSB7XG4gICAgICAgICAgICAgICAgbGVuZ3RoID0gdHlwZSAmIDB4MGY7XG4gICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmFycmF5KGxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBGaXhTdHIgLSAxMDF4eHh4eFxuICAgICAgICAgICAgaWYgKCh0eXBlICYgMHhlMCkgPT09IDB4YTApIHtcbiAgICAgICAgICAgICAgICBsZW5ndGggPSB0eXBlICYgMHgxZjtcbiAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc3RyKGxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvLyBOZWdhdGl2ZSBGaXhJbnQgLSAxMTF4eHh4eFxuICAgICAgICAgICAgaWYgKCh0eXBlICYgMHhlMCkgPT09IDB4ZTApIHtcbiAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnZpZXcuZ2V0SW50OChfdGhpcy5vZmZzZXQpO1xuICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAodHlwZSkge1xuICAgICAgICAgICAgICAgIC8vIG5pbFxuICAgICAgICAgICAgICAgIGNhc2UgMHhjMDpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgICAgICAgIC8vIDB4YzEgbmV2ZXIgdXNlZCAtIHVzZSBmb3IgdW5kZWZpbmVkIChOT04tU1RBTkRBUkQpXG4gICAgICAgICAgICAgICAgY2FzZSAweGMxOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICAgICAgICAgICAgICAvLyBmYWxzZVxuICAgICAgICAgICAgICAgIGNhc2UgMHhjMjpcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgICAgICAvLyB0cnVlXG4gICAgICAgICAgICAgICAgY2FzZSAweGMzOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQrKztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgLy8gYmluIDhcbiAgICAgICAgICAgICAgICBjYXNlIDB4YzQ6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IF90aGlzLnZpZXcuZ2V0VWludDgoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYmluKGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gYmluIDE2XG4gICAgICAgICAgICAgICAgY2FzZSAweGM1OlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBfdGhpcy52aWV3LmdldFVpbnQxNihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5iaW4obGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBiaW4gMzJcbiAgICAgICAgICAgICAgICBjYXNlIDB4YzY6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IF90aGlzLnZpZXcuZ2V0VWludDMyKF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmJpbihsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIGV4dCA4XG4gICAgICAgICAgICAgICAgY2FzZSAweGM3OlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBfdGhpcy52aWV3LmdldFVpbnQ4KF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLmV4dChsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIGV4dCAxNlxuICAgICAgICAgICAgICAgIGNhc2UgMHhjODpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX3RoaXMudmlldy5nZXRVaW50MTYoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gZXh0IDMyXG4gICAgICAgICAgICAgICAgY2FzZSAweGM5OlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBfdGhpcy52aWV3LmdldFVpbnQzMihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5leHQobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBmbG9hdCAzMlxuICAgICAgICAgICAgICAgIGNhc2UgMHhjYTpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy52aWV3LmdldEZsb2F0MzIoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gZmxvYXQgNjRcbiAgICAgICAgICAgICAgICBjYXNlIDB4Y2I6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMudmlldy5nZXRGbG9hdDY0KF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gOTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIHVpbnQ4XG4gICAgICAgICAgICAgICAgY2FzZSAweGNjOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnZpZXcuZ2V0VWludDgoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSAyO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gdWludCAxNlxuICAgICAgICAgICAgICAgIGNhc2UgMHhjZDpcbiAgICAgICAgICAgICAgICAgICAgdmFsdWUgPSBfdGhpcy52aWV3LmdldFVpbnQxNihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyB1aW50IDMyXG4gICAgICAgICAgICAgICAgY2FzZSAweGNlOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnZpZXcuZ2V0VWludDMyKF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gNTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIHVpbnQgNjRcbiAgICAgICAgICAgICAgICBjYXNlIDB4Y2Y6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0VWludDY0KF90aGlzLnZpZXcsIF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gOTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgICAgICAgICAgIC8vIGludCA4XG4gICAgICAgICAgICAgICAgY2FzZSAweGQwOlxuICAgICAgICAgICAgICAgICAgICB2YWx1ZSA9IF90aGlzLnZpZXcuZ2V0SW50OChfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyBpbnQgMTZcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZDE6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMudmlldy5nZXRJbnQxNihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDM7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyBpbnQgMzJcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZDI6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gX3RoaXMudmlldy5nZXRJbnQzMihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZTtcbiAgICAgICAgICAgICAgICAvLyBpbnQgNjRcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZDM6XG4gICAgICAgICAgICAgICAgICAgIHZhbHVlID0gZ2V0SW50NjQoX3RoaXMudmlldywgX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSA5O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XG4gICAgICAgICAgICAgICAgLy8gZml4ZXh0IDFcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZDQ6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IDE7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gZml4ZXh0IDJcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZDU6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IDI7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gZml4ZXh0IDRcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZDY6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IDQ7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gZml4ZXh0IDhcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZDc6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IDg7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCsrO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuZXh0KGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gZml4ZXh0IDE2XG4gICAgICAgICAgICAgICAgY2FzZSAweGQ4OlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSAxNjtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0Kys7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5leHQobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBzdHI4XG4gICAgICAgICAgICAgICAgY2FzZSAweGQ5OlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBfdGhpcy52aWV3LmdldFVpbnQ4KF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLnN0cihsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIHN0ciAxNlxuICAgICAgICAgICAgICAgIGNhc2UgMHhkYTpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX3RoaXMudmlldy5nZXRVaW50MTYoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuc3RyKGxlbmd0aCk7XG4gICAgICAgICAgICAgICAgLy8gc3RyIDMyXG4gICAgICAgICAgICAgICAgY2FzZSAweGRiOlxuICAgICAgICAgICAgICAgICAgICBsZW5ndGggPSBfdGhpcy52aWV3LmdldFVpbnQzMihfdGhpcy5vZmZzZXQgKyAxKTtcbiAgICAgICAgICAgICAgICAgICAgX3RoaXMub2Zmc2V0ICs9IDU7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBfdGhpcy5zdHIobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBhcnJheSAxNlxuICAgICAgICAgICAgICAgIGNhc2UgMHhkYzpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX3RoaXMudmlldy5nZXRVaW50MTYoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSAzO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBhcnJheSAzMlxuICAgICAgICAgICAgICAgIGNhc2UgMHhkZDpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX3RoaXMudmlldy5nZXRVaW50MzIoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMuYXJyYXkobGVuZ3RoKTtcbiAgICAgICAgICAgICAgICAvLyBtYXAgMTZcbiAgICAgICAgICAgICAgICBjYXNlIDB4ZGU6XG4gICAgICAgICAgICAgICAgICAgIGxlbmd0aCA9IF90aGlzLnZpZXcuZ2V0VWludDE2KF90aGlzLm9mZnNldCArIDEpO1xuICAgICAgICAgICAgICAgICAgICBfdGhpcy5vZmZzZXQgKz0gMztcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIF90aGlzLm1hcChsZW5ndGgpO1xuICAgICAgICAgICAgICAgIC8vIG1hcCAzMlxuICAgICAgICAgICAgICAgIGNhc2UgMHhkZjpcbiAgICAgICAgICAgICAgICAgICAgbGVuZ3RoID0gX3RoaXMudmlldy5nZXRVaW50MzIoX3RoaXMub2Zmc2V0ICsgMSk7XG4gICAgICAgICAgICAgICAgICAgIF90aGlzLm9mZnNldCArPSA1O1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gX3RoaXMubWFwKGxlbmd0aCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZSAweCcgKyB0eXBlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIH07XG4gICAgICAgIHRoaXMub2Zmc2V0ID0gb2Zmc2V0IHx8IDA7XG4gICAgICAgIHRoaXMudmlldyA9IHZpZXc7XG4gICAgfVxuICAgIHJldHVybiBEZWNvZGVyO1xufSgpKTtcbmZ1bmN0aW9uIGRlY29kZShidWZmZXIpIHtcbiAgICB2YXIgdmlldyA9IG5ldyBEYXRhVmlldyhidWZmZXIpO1xuICAgIHZhciBkZWNvZGVyID0gbmV3IERlY29kZXIodmlldyk7XG4gICAgdmFyIHZhbHVlID0gZGVjb2Rlci5wYXJzZSgpO1xuICAgIGlmIChkZWNvZGVyLm9mZnNldCAhPT0gYnVmZmVyLmJ5dGVMZW5ndGgpXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihidWZmZXIuYnl0ZUxlbmd0aCAtIGRlY29kZXIub2Zmc2V0ICsgJyB0cmFpbGluZyBieXRlcycpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGVuY29kZWFibGVLZXlzKHZhbHVlLCBzcGFyc2UpIHtcbiAgICByZXR1cm4gT2JqZWN0LmtleXModmFsdWUpLmZpbHRlcihmdW5jdGlvbiAoZSkge1xuICAgICAgICB2YXIgdmFsID0gdmFsdWVbZV0sIHR5cGUgPSB0eXBlb2YgdmFsO1xuICAgICAgICByZXR1cm4gKCFzcGFyc2UgfHwgKHZhbCAhPT0gdW5kZWZpbmVkICYmIHZhbCAhPT0gbnVsbCkpICYmICgnZnVuY3Rpb24nICE9PSB0eXBlIHx8ICEhdmFsLnRvSlNPTik7XG4gICAgfSk7XG59XG5mdW5jdGlvbiBfZW5jb2RlKHZhbHVlLCB2aWV3LCBvZmZzZXQsIHNwYXJzZSkge1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlO1xuICAgIC8vIFN0cmluZ3MgQnl0ZXNcbiAgICAvLyBUaGVyZSBhcmUgZm91ciBzdHJpbmcgdHlwZXM6IGZpeHN0ci9zdHI4L3N0cjE2L3N0cjMyXG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdmFyIGxlbmd0aF8xID0gdXRmOEJ5dGVDb3VudCh2YWx1ZSk7XG4gICAgICAgIC8vIGZpeHN0clxuICAgICAgICBpZiAobGVuZ3RoXzEgPCAweDIwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgbGVuZ3RoXzEgfCAweGEwKTtcbiAgICAgICAgICAgIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gMSArIGxlbmd0aF8xO1xuICAgICAgICB9XG4gICAgICAgIC8vIHN0cjhcbiAgICAgICAgaWYgKGxlbmd0aF8xIDwgMHgxMDApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGQ5KTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0ICsgMSwgbGVuZ3RoXzEpO1xuICAgICAgICAgICAgdXRmOFdyaXRlKHZpZXcsIG9mZnNldCArIDIsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAyICsgbGVuZ3RoXzE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RyMTZcbiAgICAgICAgaWYgKGxlbmd0aF8xIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZGEpO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50MTYob2Zmc2V0ICsgMSwgbGVuZ3RoXzEpO1xuICAgICAgICAgICAgdXRmOFdyaXRlKHZpZXcsIG9mZnNldCArIDMsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAzICsgbGVuZ3RoXzE7XG4gICAgICAgIH1cbiAgICAgICAgLy8gc3RyMzJcbiAgICAgICAgaWYgKGxlbmd0aF8xIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGRiKTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCArIDEsIGxlbmd0aF8xKTtcbiAgICAgICAgICAgIHV0ZjhXcml0ZSh2aWV3LCBvZmZzZXQgKyA1LCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gNSArIGxlbmd0aF8xO1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgICAgICAvLyBleHRyYWN0IHRoZSBhcnJheWJ1ZmZlciBhbmQgZmFsbHRocm91Z2hcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5idWZmZXI7XG4gICAgfVxuICAgIC8vIFRoZXJlIGFyZSB0aHJlZSBiaW4gdHlwZXM6IGJpbjgvYmluMTYvYmluMzJcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICB2YXIgbGVuZ3RoXzIgPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICAvLyBiaW44XG4gICAgICAgIGlmIChsZW5ndGhfMiA8IDB4MTAwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjNCk7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIDEsIGxlbmd0aF8yKTtcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHZpZXcuYnVmZmVyKS5zZXQobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCBvZmZzZXQgKyAyKTtcbiAgICAgICAgICAgIHJldHVybiAyICsgbGVuZ3RoXzI7XG4gICAgICAgIH1cbiAgICAgICAgLy8gYmluMTZcbiAgICAgICAgaWYgKGxlbmd0aF8yIDwgMHgxMDAwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4YzUpO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50MTYob2Zmc2V0ICsgMSwgbGVuZ3RoXzIpO1xuICAgICAgICAgICAgbmV3IFVpbnQ4QXJyYXkodmlldy5idWZmZXIpLnNldChuZXcgVWludDhBcnJheSh2YWx1ZSksIG9mZnNldCArIDMpO1xuICAgICAgICAgICAgcmV0dXJuIDMgKyBsZW5ndGhfMjtcbiAgICAgICAgfVxuICAgICAgICAvLyBiaW4gMzJcbiAgICAgICAgaWYgKGxlbmd0aF8yIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGM2KTtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDMyKG9mZnNldCArIDEsIGxlbmd0aF8yKTtcbiAgICAgICAgICAgIG5ldyBVaW50OEFycmF5KHZpZXcuYnVmZmVyKS5zZXQobmV3IFVpbnQ4QXJyYXkodmFsdWUpLCBvZmZzZXQgKyA1KTtcbiAgICAgICAgICAgIHJldHVybiA1ICsgbGVuZ3RoXzI7XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicpIHtcbiAgICAgICAgLy8gRmxvYXRpbmcgUG9pbnRcbiAgICAgICAgLy8gTk9URTogV2UncmUgYWx3YXlzIHVzaW5nIGZsb2F0NjRcbiAgICAgICAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4Y2IpO1xuICAgICAgICAgICAgdmlldy5zZXRGbG9hdDY0KG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICB9XG4gICAgICAgIC8vIEludGVnZXJzXG4gICAgICAgIGlmICh2YWx1ZSA+PSAwKSB7XG4gICAgICAgICAgICAvLyBwb3NpdGl2ZSBmaXhudW1cbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4ODApIHtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdWludCA4XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAweDEwMCkge1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGNjKTtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8vIHVpbnQgMTZcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjZCk7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRVaW50MTYob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiAzO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdWludCAzMlxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHgxMDAwMDAwMDApIHtcbiAgICAgICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhjZSk7XG4gICAgICAgICAgICAgICAgdmlldy5zZXRVaW50MzIob2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgLy8gdWludCA2NFxuICAgICAgICAgICAgaWYgKHZhbHVlIDwgMHgxMDAwMDAwMDAwMDAwMDAwMCkge1xuICAgICAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGNmKTtcbiAgICAgICAgICAgICAgICBzZXRVaW50NjQodmlldywgb2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgdG9vIGJpZyAweCcgKyB2YWx1ZS50b1N0cmluZygxNikpO1xuICAgICAgICB9XG4gICAgICAgIC8vIG5lZ2F0aXZlIGZpeG51bVxuICAgICAgICBpZiAodmFsdWUgPj0gLTB4MjApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0SW50OChvZmZzZXQsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICB9XG4gICAgICAgIC8vIGludCA4XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMHg4MCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDApO1xuICAgICAgICAgICAgdmlldy5zZXRJbnQ4KG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiAyO1xuICAgICAgICB9XG4gICAgICAgIC8vIGludCAxNlxuICAgICAgICBpZiAodmFsdWUgPj0gLTB4ODAwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDEpO1xuICAgICAgICAgICAgdmlldy5zZXRJbnQxNihvZmZzZXQgKyAxLCB2YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4gMztcbiAgICAgICAgfVxuICAgICAgICAvLyBpbnQgMzJcbiAgICAgICAgaWYgKHZhbHVlID49IC0weDgwMDAwMDAwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgMHhkMik7XG4gICAgICAgICAgICB2aWV3LnNldEludDMyKG9mZnNldCArIDEsIHZhbHVlKTtcbiAgICAgICAgICAgIHJldHVybiA1O1xuICAgICAgICB9XG4gICAgICAgIC8vIGludCA2NFxuICAgICAgICBpZiAodmFsdWUgPj0gLTB4ODAwMDAwMDAwMDAwMDAwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDMpO1xuICAgICAgICAgICAgc2V0SW50NjQodmlldywgb2Zmc2V0ICsgMSwgdmFsdWUpO1xuICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgIH1cbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdOdW1iZXIgdG9vIHNtYWxsIC0weCcgKyAoLXZhbHVlKS50b1N0cmluZygxNikuc3Vic3RyKDEpKTtcbiAgICB9XG4gICAgLy8gdW5kZWZpbmVkIC0gdXNlIGQ0IChOT04tU1RBTkRBUkQpXG4gICAgaWYgKHR5cGUgPT09ICd1bmRlZmluZWQnKSB7XG4gICAgICAgIGlmIChzcGFyc2UpXG4gICAgICAgICAgICByZXR1cm4gMDtcbiAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIDB4ZDQpO1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIDEsIDB4MDApO1xuICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCArIDIsIDB4MDApO1xuICAgICAgICByZXR1cm4gMztcbiAgICB9XG4gICAgLy8gbnVsbFxuICAgIGlmICh2YWx1ZSA9PT0gbnVsbCkge1xuICAgICAgICBpZiAoc3BhcnNlKVxuICAgICAgICAgICAgcmV0dXJuIDA7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCAweGMwKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIC8vIEJvb2xlYW5cbiAgICBpZiAodHlwZSA9PT0gJ2Jvb2xlYW4nKSB7XG4gICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCB2YWx1ZSA/IDB4YzMgOiAweGMyKTtcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgfVxuICAgIGlmICgnZnVuY3Rpb24nID09PSB0eXBlb2YgdmFsdWUudG9KU09OKVxuICAgICAgICByZXR1cm4gX2VuY29kZSh2YWx1ZS50b0pTT04oKSwgdmlldywgb2Zmc2V0LCBzcGFyc2UpO1xuICAgIC8vIENvbnRhaW5lciBUeXBlc1xuICAgIGlmICh0eXBlID09PSAnb2JqZWN0Jykge1xuICAgICAgICB2YXIgbGVuZ3RoXzMsIHNpemUgPSAwO1xuICAgICAgICB2YXIga2V5cyA9IHZvaWQgMDtcbiAgICAgICAgdmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KHZhbHVlKTtcbiAgICAgICAgaWYgKGlzQXJyYXkpIHtcbiAgICAgICAgICAgIGxlbmd0aF8zID0gdmFsdWUubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAga2V5cyA9IGVuY29kZWFibGVLZXlzKHZhbHVlLCBzcGFyc2UpO1xuICAgICAgICAgICAgbGVuZ3RoXzMgPSBrZXlzLmxlbmd0aDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoXzMgPCAweDEwKSB7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQ4KG9mZnNldCwgbGVuZ3RoXzMgfCAoaXNBcnJheSA/IDB4OTAgOiAweDgwKSk7XG4gICAgICAgICAgICBzaXplID0gMTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChsZW5ndGhfMyA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIHZpZXcuc2V0VWludDgob2Zmc2V0LCBpc0FycmF5ID8gMHhkYyA6IDB4ZGUpO1xuICAgICAgICAgICAgdmlldy5zZXRVaW50MTYob2Zmc2V0ICsgMSwgbGVuZ3RoXzMpO1xuICAgICAgICAgICAgc2l6ZSA9IDM7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAobGVuZ3RoXzMgPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgdmlldy5zZXRVaW50OChvZmZzZXQsIGlzQXJyYXkgPyAweGRkIDogMHhkZik7XG4gICAgICAgICAgICB2aWV3LnNldFVpbnQzMihvZmZzZXQgKyAxLCBsZW5ndGhfMyk7XG4gICAgICAgICAgICBzaXplID0gNTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoaXNBcnJheSkge1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW5ndGhfMzsgaSsrKSB7XG4gICAgICAgICAgICAgICAgc2l6ZSArPSBfZW5jb2RlKHZhbHVlW2ldLCB2aWV3LCBvZmZzZXQgKyBzaXplLCBzcGFyc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGtleXMpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoXzM7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuICAgICAgICAgICAgICAgIHNpemUgKz0gX2VuY29kZShrZXksIHZpZXcsIG9mZnNldCArIHNpemUpO1xuICAgICAgICAgICAgICAgIHNpemUgKz0gX2VuY29kZSh2YWx1ZVtrZXldLCB2aWV3LCBvZmZzZXQgKyBzaXplLCBzcGFyc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBzaXplO1xuICAgIH1cbiAgICBpZiAodHlwZSA9PT0gJ2Z1bmN0aW9uJylcbiAgICAgICAgcmV0dXJuIDA7XG4gICAgdGhyb3cgbmV3IEVycm9yKCdVbmtub3duIHR5cGUgJyArIHR5cGUpO1xufVxuZnVuY3Rpb24gc2l6ZW9mKHZhbHVlLCBzcGFyc2UpIHtcbiAgICB2YXIgdHlwZSA9IHR5cGVvZiB2YWx1ZTtcbiAgICAvLyBmaXhzdHIgb3Igc3RyOCBvciBzdHIxNiBvciBzdHIzMlxuICAgIGlmICh0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgICB2YXIgbGVuZ3RoXzQgPSB1dGY4Qnl0ZUNvdW50KHZhbHVlKTtcbiAgICAgICAgaWYgKGxlbmd0aF80IDwgMHgyMCkge1xuICAgICAgICAgICAgcmV0dXJuIDEgKyBsZW5ndGhfNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoXzQgPCAweDEwMCkge1xuICAgICAgICAgICAgcmV0dXJuIDIgKyBsZW5ndGhfNDtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoXzQgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMyArIGxlbmd0aF80O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGhfNCA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gNSArIGxlbmd0aF80O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmIChBcnJheUJ1ZmZlci5pc1ZpZXcgJiYgQXJyYXlCdWZmZXIuaXNWaWV3KHZhbHVlKSkge1xuICAgICAgICAvLyBleHRyYWN0IHRoZSBhcnJheWJ1ZmZlciBhbmQgZmFsbHRocm91Z2hcbiAgICAgICAgdmFsdWUgPSB2YWx1ZS5idWZmZXI7XG4gICAgfVxuICAgIC8vIGJpbjggb3IgYmluMTYgb3IgYmluMzJcbiAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlcikge1xuICAgICAgICB2YXIgbGVuZ3RoXzUgPSB2YWx1ZS5ieXRlTGVuZ3RoO1xuICAgICAgICBpZiAobGVuZ3RoXzUgPCAweDEwMCkge1xuICAgICAgICAgICAgcmV0dXJuIDIgKyBsZW5ndGhfNTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoXzUgPCAweDEwMDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gMyArIGxlbmd0aF81O1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGhfNSA8IDB4MTAwMDAwMDAwKSB7XG4gICAgICAgICAgICByZXR1cm4gNSArIGxlbmd0aF81O1xuICAgICAgICB9XG4gICAgfVxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIEZsb2F0aW5nIFBvaW50ICgzMiBiaXRzKVxuICAgICAgICAvLyBkb3VibGVcbiAgICAgICAgaWYgKE1hdGguZmxvb3IodmFsdWUpICE9PSB2YWx1ZSlcbiAgICAgICAgICAgIHJldHVybiA5O1xuICAgICAgICAvLyBJbnRlZ2Vyc1xuICAgICAgICBpZiAodmFsdWUgPj0gMCkge1xuICAgICAgICAgICAgLy8gcG9zaXRpdmUgZml4aW50XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAweDgwKVxuICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgLy8gdWludCA4XG4gICAgICAgICAgICBpZiAodmFsdWUgPCAweDEwMClcbiAgICAgICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgICAgIC8vIHVpbnQgMTZcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4MTAwMDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgICAgICAvLyB1aW50IDMyXG4gICAgICAgICAgICBpZiAodmFsdWUgPCAweDEwMDAwMDAwMClcbiAgICAgICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgICAgIC8vIHVpbnQgNjRcbiAgICAgICAgICAgIGlmICh2YWx1ZSA8IDB4MTAwMDAwMDAwMDAwMDAwMDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgICAgICAvLyBUb28gYmlnXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlciB0b28gYmlnIDB4JyArIHZhbHVlLnRvU3RyaW5nKDE2KSk7XG4gICAgICAgIH1cbiAgICAgICAgLy8gbmVnYXRpdmUgZml4aW50XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMHgyMClcbiAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAvLyBpbnQgOFxuICAgICAgICBpZiAodmFsdWUgPj0gLTB4ODApXG4gICAgICAgICAgICByZXR1cm4gMjtcbiAgICAgICAgLy8gaW50IDE2XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMHg4MDAwKVxuICAgICAgICAgICAgcmV0dXJuIDM7XG4gICAgICAgIC8vIGludCAzMlxuICAgICAgICBpZiAodmFsdWUgPj0gLTB4ODAwMDAwMDApXG4gICAgICAgICAgICByZXR1cm4gNTtcbiAgICAgICAgLy8gaW50IDY0XG4gICAgICAgIGlmICh2YWx1ZSA+PSAtMHg4MDAwMDAwMDAwMDAwMDAwKVxuICAgICAgICAgICAgcmV0dXJuIDk7XG4gICAgICAgIC8vIFRvbyBzbWFsbFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ051bWJlciB0b28gc21hbGwgLTB4JyArIHZhbHVlLnRvU3RyaW5nKDE2KS5zdWJzdHIoMSkpO1xuICAgIH1cbiAgICAvLyBCb29sZWFuXG4gICAgaWYgKHR5cGUgPT09ICdib29sZWFuJylcbiAgICAgICAgcmV0dXJuIDE7XG4gICAgLy8gdW5kZWZpbmVkLCBudWxsXG4gICAgaWYgKHZhbHVlID09PSBudWxsKVxuICAgICAgICByZXR1cm4gc3BhcnNlID8gMCA6IDE7XG4gICAgaWYgKHZhbHVlID09PSB1bmRlZmluZWQpXG4gICAgICAgIHJldHVybiBzcGFyc2UgPyAwIDogMztcbiAgICBpZiAoJ2Z1bmN0aW9uJyA9PT0gdHlwZW9mIHZhbHVlLnRvSlNPTilcbiAgICAgICAgcmV0dXJuIHNpemVvZih2YWx1ZS50b0pTT04oKSwgc3BhcnNlKTtcbiAgICAvLyBDb250YWluZXIgVHlwZXNcbiAgICBpZiAodHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgdmFyIGxlbmd0aF82LCBzaXplID0gMDtcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XG4gICAgICAgICAgICBsZW5ndGhfNiA9IHZhbHVlLmxlbmd0aDtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbGVuZ3RoXzY7IGkrKykge1xuICAgICAgICAgICAgICAgIHNpemUgKz0gc2l6ZW9mKHZhbHVlW2ldLCBzcGFyc2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdmFyIGtleXMgPSBlbmNvZGVhYmxlS2V5cyh2YWx1ZSwgc3BhcnNlKTtcbiAgICAgICAgICAgIGxlbmd0aF82ID0ga2V5cy5sZW5ndGg7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbmd0aF82OyBpKyspIHtcbiAgICAgICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tpXTtcbiAgICAgICAgICAgICAgICBzaXplICs9IHNpemVvZihrZXkpICsgc2l6ZW9mKHZhbHVlW2tleV0sIHNwYXJzZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKGxlbmd0aF82IDwgMHgxMCkge1xuICAgICAgICAgICAgcmV0dXJuIDEgKyBzaXplO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsZW5ndGhfNiA8IDB4MTAwMDApIHtcbiAgICAgICAgICAgIHJldHVybiAzICsgc2l6ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAobGVuZ3RoXzYgPCAweDEwMDAwMDAwMCkge1xuICAgICAgICAgICAgcmV0dXJuIDUgKyBzaXplO1xuICAgICAgICB9XG4gICAgICAgIHRocm93IG5ldyBFcnJvcignQXJyYXkgb3Igb2JqZWN0IHRvbyBsb25nIDB4JyArIGxlbmd0aF82LnRvU3RyaW5nKDE2KSk7XG4gICAgfVxuICAgIGlmICh0eXBlID09PSAnZnVuY3Rpb24nKVxuICAgICAgICByZXR1cm4gMDtcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gdHlwZSAnICsgdHlwZSk7XG59XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgZW5jb2RlOiBlbmNvZGUsXG4gICAgZGVjb2RlOiBkZWNvZGUsXG4gICAgaW5zcGVjdDogaW5zcGVjdCxcbiAgICB1dGY4V3JpdGU6IHV0ZjhXcml0ZSxcbiAgICB1dGY4UmVhZDogdXRmOFJlYWQsXG4gICAgdXRmOEJ5dGVDb3VudDogdXRmOEJ5dGVDb3VudCxcbn07XG5cblxuLyoqKi8gfSksXG4vKiA0MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xuLy8gQ29tbW9uXG52YXIgcmVzdF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzMCkpO1xudmFyIHJlYWx0aW1lXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDUwKSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG4vLyBQbGF0Zm9ybSBTcGVjaWZpY1xudmFyIGJ1ZmZlcnV0aWxzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDU1KSk7XG4vLyBAdHMtaWdub3JlXG52YXIgY3J5cHRvXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDU3KSk7XG52YXIgaHR0cF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg2MikpO1xudmFyIGNvbmZpZ18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg2NCkpO1xuLy8gQHRzLWlnbm9yZVxudmFyIHRyYW5zcG9ydF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg2OCkpO1xudmFyIGxvZ2dlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygyKSk7XG52YXIgZGVmYXVsdHNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oOCk7XG52YXIgd2Vic3RvcmFnZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg2NSkpO1xudmFyIGRlZmF1bHRzXzIgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDY2KSk7XG52YXIgbXNncGFja18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0MSkpO1xudmFyIENyeXB0byA9ICgwLCBjcnlwdG9fMS5kZWZhdWx0KShjb25maWdfMS5kZWZhdWx0LCBidWZmZXJ1dGlsc18xLmRlZmF1bHQpO1xucGxhdGZvcm1fMS5kZWZhdWx0LkNyeXB0byA9IENyeXB0bztcbnBsYXRmb3JtXzEuZGVmYXVsdC5CdWZmZXJVdGlscyA9IGJ1ZmZlcnV0aWxzXzEuZGVmYXVsdDtcbnBsYXRmb3JtXzEuZGVmYXVsdC5IdHRwID0gaHR0cF8xLmRlZmF1bHQ7XG5wbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnID0gY29uZmlnXzEuZGVmYXVsdDtcbnBsYXRmb3JtXzEuZGVmYXVsdC5UcmFuc3BvcnRzID0gdHJhbnNwb3J0XzEuZGVmYXVsdDtcbnBsYXRmb3JtXzEuZGVmYXVsdC5XZWJTdG9yYWdlID0gd2Vic3RvcmFnZV8xLmRlZmF1bHQ7XG5yZXN0XzEuZGVmYXVsdC5DcnlwdG8gPSBDcnlwdG87XG5yZWFsdGltZV8xLmRlZmF1bHQuQ3J5cHRvID0gQ3J5cHRvO1xubG9nZ2VyXzEuZGVmYXVsdC5pbml0TG9nSGFuZGxlcnMoKTtcbnBsYXRmb3JtXzEuZGVmYXVsdC5EZWZhdWx0cyA9ICgwLCBkZWZhdWx0c18xLmdldERlZmF1bHRzKShkZWZhdWx0c18yLmRlZmF1bHQpO1xuaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuYWdlbnQpIHtcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgcGxhdGZvcm1fMS5kZWZhdWx0LkRlZmF1bHRzLmFnZW50ICs9ICcgJyArIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuYWdlbnQ7XG59XG4vKiBJZiB1c2luZyBJRTgsIGRvbid0IGF0dGVtcHQgdG8gdXBncmFkZSBmcm9tIHhocl9wb2xsaW5nIHRvIHhocl9zdHJlYW1pbmcgLVxuICogd2hpbGUgaXQgY2FuIGRvIHN0cmVhbWluZywgdGhlIGxvdyBtYXggaHR0cC1jb25uZWN0aW9ucy1wZXItaG9zdCBsaW1pdCBtZWFuc1xuICogdGhhdCB0aGUgcG9sbGluZyB0cmFuc3BvcnQgaXMgY3JpcHBsZWQgZHVyaW5nIHRoZSB1cGdyYWRlIHByb2Nlc3MuIFNvIGp1c3RcbiAqIGxlYXZlIGl0IGF0IHRoZSBiYXNlIHRyYW5zcG9ydCAqL1xuaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubm9VcGdyYWRlKSB7XG4gICAgcGxhdGZvcm1fMS5kZWZhdWx0LkRlZmF1bHRzLnVwZ3JhZGVUcmFuc3BvcnRzID0gW107XG59XG5leHBvcnRzLmRlZmF1bHQgPSB7XG4gICAgRXJyb3JJbmZvOiBlcnJvcmluZm9fMS5kZWZhdWx0LFxuICAgIFJlc3Q6IHJlc3RfMS5kZWZhdWx0LFxuICAgIFJlYWx0aW1lOiByZWFsdGltZV8xLmRlZmF1bHQsXG4gICAgbXNncGFjazogbXNncGFja18xLmRlZmF1bHQsXG59O1xuXG5cbi8qKiovIH0pLFxuLyogNDMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUpIHtcblxubW9kdWxlLmV4cG9ydHMgPSBKU09OLnBhcnNlKFwie1xcXCJuYW1lXFxcIjpcXFwiYWJseVxcXCIsXFxcImRlc2NyaXB0aW9uXFxcIjpcXFwiUmVhbHRpbWUgY2xpZW50IGxpYnJhcnkgZm9yIEFibHksIHRoZSByZWFsdGltZSBtZXNzYWdpbmcgc2VydmljZVxcXCIsXFxcInZlcnNpb25cXFwiOlxcXCIxLjIuNDlcXFwiLFxcXCJsaWNlbnNlXFxcIjpcXFwiQXBhY2hlLTIuMFxcXCIsXFxcImJ1Z3NcXFwiOntcXFwidXJsXFxcIjpcXFwiaHR0cHM6Ly9naXRodWIuY29tL2FibHkvYWJseS1qcy9pc3N1ZXNcXFwiLFxcXCJlbWFpbFxcXCI6XFxcInN1cHBvcnRAYWJseS5jb21cXFwifSxcXFwibWFpblxcXCI6XFxcIi4vYnVpbGQvYWJseS1ub2RlLmpzXFxcIixcXFwidHlwaW5nc1xcXCI6XFxcIi4vYWJseS5kLnRzXFxcIixcXFwicmVhY3QtbmF0aXZlXFxcIjp7XFxcIi4vYnVpbGQvYWJseS1ub2RlLmpzXFxcIjpcXFwiLi9idWlsZC9hYmx5LXJlYWN0bmF0aXZlLmpzXFxcIn0sXFxcImJyb3dzZXJcXFwiOntcXFwiLi9idWlsZC9hYmx5LW5vZGUuanNcXFwiOlxcXCIuL2J1aWxkL2FibHktY29tbW9uanMuanNcXFwifSxcXFwiZmlsZXNcXFwiOltcXFwiYnVpbGQvKipcXFwiLFxcXCJhYmx5LmQudHNcXFwiLFxcXCJjYWxsYmFja3MuZC50c1xcXCIsXFxcImNhbGxiYWNrcy5qc1xcXCIsXFxcInByb21pc2VzLmQudHNcXFwiLFxcXCJwcm9taXNlcy5qc1xcXCIsXFxcInJlc291cmNlcy8qKlxcXCIsXFxcInNyYy8qKlxcXCIsXFxcInJlYWN0LyoqXFxcIl0sXFxcImRlcGVuZGVuY2llc1xcXCI6e1xcXCJAYWJseS9tc2dwYWNrLWpzXFxcIjpcXFwiXjAuNC4wXFxcIixcXFwiZ290XFxcIjpcXFwiXjExLjguNVxcXCIsXFxcIndzXFxcIjpcXFwiXjguMTQuMlxcXCJ9LFxcXCJwZWVyRGVwZW5kZW5jaWVzXFxcIjp7XFxcInJlYWN0XFxcIjpcXFwiPj0xNi44LjBcXFwiLFxcXCJyZWFjdC1kb21cXFwiOlxcXCI+PTE2LjguMFxcXCJ9LFxcXCJwZWVyRGVwZW5kZW5jaWVzTWV0YVxcXCI6e1xcXCJyZWFjdFxcXCI6e1xcXCJvcHRpb25hbFxcXCI6dHJ1ZX0sXFxcInJlYWN0LWRvbVxcXCI6e1xcXCJvcHRpb25hbFxcXCI6dHJ1ZX19LFxcXCJkZXZEZXBlbmRlbmNpZXNcXFwiOntcXFwiQGFibHkvdmNkaWZmLWRlY29kZXJcXFwiOlxcXCIxLjAuNFxcXCIsXFxcIkBhcmV0aGV0eXBlc3dyb25nL2NsaVxcXCI6XFxcIl4wLjEzLjFcXFwiLFxcXCJAYmFiZWwvcHJlc2V0LWVudlxcXCI6XFxcIl43LjIzLjZcXFwiLFxcXCJAdGVzdGluZy1saWJyYXJ5L3JlYWN0XFxcIjpcXFwiXjEzLjMuMFxcXCIsXFxcIkB0eXBlcy9jcnlwdG8tanNcXFwiOlxcXCJeNC4wLjFcXFwiLFxcXCJAdHlwZXMvam1lc3BhdGhcXFwiOlxcXCJeMC4xNS4yXFxcIixcXFwiQHR5cGVzL25vZGVcXFwiOlxcXCJeMTUuMC4wXFxcIixcXFwiQHR5cGVzL3JlcXVlc3RcXFwiOlxcXCJeMi40OC43XFxcIixcXFwiQHR5cGVzL3dzXFxcIjpcXFwiXjguMi4wXFxcIixcXFwiQHR5cGVzY3JpcHQtZXNsaW50L2VzbGludC1wbHVnaW5cXFwiOlxcXCJeNS4xNC4wXFxcIixcXFwiQHR5cGVzY3JpcHQtZXNsaW50L3BhcnNlclxcXCI6XFxcIl41LjE0LjBcXFwiLFxcXCJAdml0ZWpzL3BsdWdpbi1yZWFjdFxcXCI6XFxcIl4xLjMuMlxcXCIsXFxcImFzeW5jXFxcIjpcXFwiYWJseS1mb3Jrcy9hc3luYyNyZXF1aXJlanNcXFwiLFxcXCJhd3Mtc2RrXFxcIjpcXFwiXjIuMTQxMy4wXFxcIixcXFwiYmFiZWwtbG9hZGVyXFxcIjpcXFwiXjguMy4wXFxcIixcXFwiY2hhaVxcXCI6XFxcIl40LjIuMFxcXCIsXFxcImNvcHktd2VicGFjay1wbHVnaW5cXFwiOlxcXCJeNi40LjFcXFwiLFxcXCJjb3JzXFxcIjpcXFwiXjIuOC41XFxcIixcXFwiY3J5cHRvLWpzXFxcIjpcXFwiYWJseS1mb3Jrcy9jcnlwdG8tanMjY3J5cHRvLWxpdGVcXFwiLFxcXCJlc2xpbnRcXFwiOlxcXCJeNy4xMy4wXFxcIixcXFwiZXNsaW50LXBsdWdpbi1pbXBvcnRcXFwiOlxcXCJeMi4yOC4wXFxcIixcXFwiZXNsaW50LXBsdWdpbi1qc2RvY1xcXCI6XFxcIl40MC4wLjBcXFwiLFxcXCJlc2xpbnQtcGx1Z2luLXJlYWN0XFxcIjpcXFwiXjcuMzIuMlxcXCIsXFxcImVzbGludC1wbHVnaW4tcmVhY3QtaG9va3NcXFwiOlxcXCJeNC42LjBcXFwiLFxcXCJlc2xpbnQtcGx1Z2luLXNlY3VyaXR5XFxcIjpcXFwiXjEuNC4wXFxcIixcXFwiZXhwcmVzc1xcXCI6XFxcIl40LjE3LjFcXFwiLFxcXCJnbG9iXFxcIjpcXFwifjQuNFxcXCIsXFxcImdvb2dsZS1jbG9zdXJlLWNvbXBpbGVyXFxcIjpcXFwiXjIwMTgwNjEwLjAuMVxcXCIsXFxcImdydW50XFxcIjpcXFwiXjEuNi4xXFxcIixcXFwiZ3J1bnQtYnVtcFxcXCI6XFxcIl4wLjMuMVxcXCIsXFxcImdydW50LWNsaVxcXCI6XFxcIn4xLjIuMFxcXCIsXFxcImdydW50LWNsb3N1cmUtdG9vbHNcXFwiOlxcXCJeMS4wLjBcXFwiLFxcXCJncnVudC1jb250cmliLWNvbmNhdFxcXCI6XFxcIn4wLjVcXFwiLFxcXCJncnVudC1zaGVsbFxcXCI6XFxcIn4xLjFcXFwiLFxcXCJncnVudC13ZWJwYWNrXFxcIjpcXFwiXjQuMC4yXFxcIixcXFwiaGV4eVxcXCI6XFxcIn4wLjJcXFwiLFxcXCJqbWVzcGF0aFxcXCI6XFxcIl4wLjE2LjBcXFwiLFxcXCJqc2RvbVxcXCI6XFxcIl4yMC4wLjBcXFwiLFxcXCJrZXhlY1xcXCI6XFxcImFibHktZm9ya3Mvbm9kZS1rZXhlYyN1cGRhdGUtZm9yLW5vZGUtMTJcXFwiLFxcXCJtaW5pbWlzdFxcXCI6XFxcIl4xLjIuNVxcXCIsXFxcIm1vY2hhXFxcIjpcXFwiXjguMS4zXFxcIixcXFwibW9jaGEtanVuaXQtcmVwb3J0ZXJcXFwiOlxcXCJeMi4yLjFcXFwiLFxcXCJudWxsLWxvYWRlclxcXCI6XFxcIl40LjAuMVxcXCIsXFxcInBsYXl3cmlnaHRcXFwiOlxcXCJeMS4zOS4wXFxcIixcXFwicHJldHRpZXJcXFwiOlxcXCJeMi41LjFcXFwiLFxcXCJyZWFjdFxcXCI6XFxcIj49MTguMS4wXFxcIixcXFwicmVhY3QtZG9tXFxcIjpcXFwiPj0xOC4xLjBcXFwiLFxcXCJyZXF1aXJlanNcXFwiOlxcXCJ+Mi4xXFxcIixcXFwic2hlbGxqc1xcXCI6XFxcIn4wLjhcXFwiLFxcXCJzb3VyY2UtbWFwLWV4cGxvcmVyXFxcIjpcXFwiXjIuNS4yXFxcIixcXFwidHMtbG9hZGVyXFxcIjpcXFwiXjguMi4wXFxcIixcXFwidHNjb25maWctcGF0aHMtd2VicGFjay1wbHVnaW5cXFwiOlxcXCJeNC4wLjFcXFwiLFxcXCJ0c2xpYlxcXCI6XFxcIl4yLjMuMVxcXCIsXFxcInR5cGVkb2NcXFwiOlxcXCJeMC4yMy44XFxcIixcXFwidHlwZXNjcmlwdFxcXCI6XFxcIl40LjYuNFxcXCIsXFxcInZpdGVcXFwiOlxcXCJeNC40LjlcXFwiLFxcXCJ2aXRlc3RcXFwiOlxcXCJeMC4xOC4wXFxcIixcXFwid2VicGFja1xcXCI6XFxcIl40LjQ0LjJcXFwiLFxcXCJ3ZWJwYWNrLWNsaVxcXCI6XFxcIl40LjIuMFxcXCIsXFxcIndlYnBhY2stbm9kZS1leHRlcm5hbHNcXFwiOlxcXCJeMy4wLjBcXFwifSxcXFwiZW5naW5lc1xcXCI6e1xcXCJub2RlXFxcIjpcXFwiPj01LjEwLnhcXFwifSxcXFwicmVwb3NpdG9yeVxcXCI6XFxcImFibHkvYWJseS1qc1xcXCIsXFxcImpzcG1cXFwiOntcXFwicmVnaXN0cnlcXFwiOlxcXCJucG1cXFwiLFxcXCJkaXJlY3Rvcmllc1xcXCI6e1xcXCJsaWJcXFwiOlxcXCJidWlsZFxcXCJ9LFxcXCJtYWluXFxcIjpcXFwiYWJseVxcXCJ9LFxcXCJzY3JpcHRzXFxcIjp7XFxcInN0YXJ0OnJlYWN0XFxcIjpcXFwibnB4IHZpdGUgc2VydmVcXFwiLFxcXCJncnVudFxcXCI6XFxcImdydW50XFxcIixcXFwidGVzdFxcXCI6XFxcImdydW50IHRlc3RcXFwiLFxcXCJ0ZXN0Om5vZGVcXFwiOlxcXCJncnVudCB0ZXN0Om5vZGVcXFwiLFxcXCJ0ZXN0Om5vZGU6c2tpcC1idWlsZFxcXCI6XFxcImdydW50IG1vY2hhXFxcIixcXFwidGVzdDp3ZWJzZXJ2ZXJcXFwiOlxcXCJncnVudCB0ZXN0OndlYnNlcnZlclxcXCIsXFxcInRlc3Q6cGxheXdyaWdodFxcXCI6XFxcIm5vZGUgdGVzdC9zdXBwb3J0L3J1blBsYXl3cmlnaHRUZXN0cy5qc1xcXCIsXFxcInRlc3Q6cmVhY3RcXFwiOlxcXCJ2aXRlc3QgcnVuXFxcIixcXFwiY29uY2F0XFxcIjpcXFwiZ3J1bnQgY29uY2F0XFxcIixcXFwiYnVpbGRcXFwiOlxcXCJncnVudCBidWlsZDphbGwgJiYgbnBtIHJ1biBidWlsZDpyZWFjdFxcXCIsXFxcImJ1aWxkOm5vZGVcXFwiOlxcXCJncnVudCBidWlsZDpub2RlXFxcIixcXFwiYnVpbGQ6YnJvd3NlclxcXCI6XFxcImdydW50IGJ1aWxkOmJyb3dzZXJcXFwiLFxcXCJidWlsZDpyZWFjdFxcXCI6XFxcIm5wbSBydW4gYnVpbGQ6cmVhY3Q6bWpzICYmIG5wbSBydW4gYnVpbGQ6cmVhY3Q6Y2pzICYmIGNwIHNyYy9wbGF0Zm9ybS9yZWFjdC1ob29rcy9yZXMvcGFja2FnZS5yZWFjdC5qc29uIHJlYWN0L3BhY2thZ2UuanNvblxcXCIsXFxcImJ1aWxkOnJlYWN0Om1qc1xcXCI6XFxcInRzYyAtLXByb2plY3Qgc3JjL3BsYXRmb3JtL3JlYWN0LWhvb2tzL3RzY29uZmlnLm1qcy5qc29uICYmIGNwIHNyYy9wbGF0Zm9ybS9yZWFjdC1ob29rcy9yZXMvcGFja2FnZS5tanMuanNvbiByZWFjdC9tanMvcGFja2FnZS5qc29uXFxcIixcXFwiYnVpbGQ6cmVhY3Q6Y2pzXFxcIjpcXFwidHNjIC0tcHJvamVjdCBzcmMvcGxhdGZvcm0vcmVhY3QtaG9va3MvdHNjb25maWcuY2pzLmpzb24gJiYgY3Agc3JjL3BsYXRmb3JtL3JlYWN0LWhvb2tzL3Jlcy9wYWNrYWdlLmNqcy5qc29uIHJlYWN0L2Nqcy9wYWNrYWdlLmpzb25cXFwiLFxcXCJyZXF1aXJlanNcXFwiOlxcXCJncnVudCByZXF1aXJlanNcXFwiLFxcXCJsaW50XFxcIjpcXFwiZXNsaW50IC5cXFwiLFxcXCJsaW50OmZpeFxcXCI6XFxcImVzbGludCAtLWZpeCAuXFxcIixcXFwiY2hlY2stY2xvc3VyZS1jb21waWxlclxcXCI6XFxcImdydW50IGNoZWNrLWNsb3N1cmUtY29tcGlsZXJcXFwiLFxcXCJwcmVwYXJlXFxcIjpcXFwibnBtIHJ1biBidWlsZFxcXCIsXFxcImZvcm1hdFxcXCI6XFxcInByZXR0aWVyIC0td3JpdGUgLS1pZ25vcmUtcGF0aCAuZ2l0aWdub3JlIC0taWdub3JlLXBhdGggLnByZXR0aWVyaWdub3JlIHNyYyB0ZXN0IGFibHkuZC50cyB3ZWJwYWNrLmNvbmZpZy5qcyBHcnVudGZpbGUuanMgc2NyaXB0cy9jZG5fZGVwbG95LmpzIGRvY3MvY2hyb21lLW12My5tZFxcXCIsXFxcImZvcm1hdDpjaGVja1xcXCI6XFxcInByZXR0aWVyIC0tY2hlY2sgLS1pZ25vcmUtcGF0aCAuZ2l0aWdub3JlIC0taWdub3JlLXBhdGggLnByZXR0aWVyaWdub3JlIHNyYyB0ZXN0IGFibHkuZC50cyB3ZWJwYWNrLmNvbmZpZy5qcyBHcnVudGZpbGUuanMgc2NyaXB0cy9jZG5fZGVwbG95LmpzXFxcIixcXFwic291cmNlbWFwXFxcIjpcXFwic291cmNlLW1hcC1leHBsb3JlciBidWlsZC9hYmx5Lm1pbi5qc1xcXCIsXFxcInNvdXJjZW1hcDpub2VuY3J5cHRpb25cXFwiOlxcXCJzb3VyY2UtbWFwLWV4cGxvcmVyIGJ1aWxkL2FibHkubm9lbmNyeXB0aW9uLm1pbi5qc1xcXCIsXFxcImRvY3NcXFwiOlxcXCJ0eXBlZG9jIC0tZW50cnlQb2ludHMgYWJseS5kLnRzIC0tb3V0IGRvY3MvZ2VuZXJhdGVkL2RlZmF1bHQgLS1yZWFkbWUgZG9jcy9sYW5kaW5nLXBhZ2VzL2RlZmF1bHQubWQgJiYgdHlwZWRvYyAtLWVudHJ5UG9pbnRzIHByb21pc2VzLmQudHMgLS1vdXQgZG9jcy9nZW5lcmF0ZWQvcHJvbWlzZXMgLS1uYW1lIFxcXFxcXFwiYWJseSAoUHJvbWlzZS1iYXNlZClcXFxcXFxcIiAtLXJlYWRtZSBkb2NzL2xhbmRpbmctcGFnZXMvcHJvbWlzZXMubWQgJiYgY3AgZG9jcy9sYW5kaW5nLXBhZ2VzL2Nob29zZS1saWJyYXJ5Lmh0bWwgZG9jcy9nZW5lcmF0ZWQvaW5kZXguaHRtbFxcXCJ9fVwiKTtcblxuLyoqKi8gfSksXG4vKiA0NCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cykge1xuXG5cblxuLyoqKi8gfSksXG4vKiA0NSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNiksIF9fd2VicGFja19yZXF1aXJlX18oMzIpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDI0KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHRyZXR1cm4gQ3J5cHRvSlMuSG1hY1NIQTI1NjtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDQ2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBkZXZpY2VkZXRhaWxzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQ3KSk7XG52YXIgcmVzb3VyY2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTQpKTtcbnZhciBwYWdpbmF0ZWRyZXNvdXJjZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxOSkpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgcHVzaGNoYW5uZWxzdWJzY3JpcHRpb25fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNDgpKTtcbnZhciBub29wID0gZnVuY3Rpb24gKCkgeyB9O1xudmFyIFB1c2ggPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gUHVzaChyZXN0KSB7XG4gICAgICAgIHRoaXMucmVzdCA9IHJlc3Q7XG4gICAgICAgIHRoaXMuYWRtaW4gPSBuZXcgQWRtaW4ocmVzdCk7XG4gICAgfVxuICAgIHJldHVybiBQdXNoO1xufSgpKTtcbnZhciBBZG1pbiA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBBZG1pbihyZXN0KSB7XG4gICAgICAgIHRoaXMucmVzdCA9IHJlc3Q7XG4gICAgICAgIHRoaXMuZGV2aWNlUmVnaXN0cmF0aW9ucyA9IG5ldyBEZXZpY2VSZWdpc3RyYXRpb25zKHJlc3QpO1xuICAgICAgICB0aGlzLmNoYW5uZWxTdWJzY3JpcHRpb25zID0gbmV3IENoYW5uZWxTdWJzY3JpcHRpb25zKHJlc3QpO1xuICAgIH1cbiAgICBBZG1pbi5wcm90b3R5cGUucHVibGlzaCA9IGZ1bmN0aW9uIChyZWNpcGllbnQsIHBheWxvYWQsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5yZXN0O1xuICAgICAgICB2YXIgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRQb3N0SGVhZGVycyhyZXN0Lm9wdGlvbnMsIGZvcm1hdCksIHBhcmFtcyA9IHt9O1xuICAgICAgICB2YXIgYm9keSA9IFV0aWxzLm1peGluKHsgcmVjaXBpZW50OiByZWNpcGllbnQgfSwgcGF5bG9hZCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3B1Ymxpc2gnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICAgICAgICBVdGlscy5taXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6ICd0cnVlJyB9KTtcbiAgICAgICAgdmFyIHJlcXVlc3RCb2R5ID0gVXRpbHMuZW5jb2RlQm9keShib2R5LCBmb3JtYXQpO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQucG9zdChyZXN0LCAnL3B1c2gvcHVibGlzaCcsIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMsIG51bGwsIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycik7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIEFkbWluO1xufSgpKTtcbnZhciBEZXZpY2VSZWdpc3RyYXRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIERldmljZVJlZ2lzdHJhdGlvbnMocmVzdCkge1xuICAgICAgICB0aGlzLnJlc3QgPSByZXN0O1xuICAgIH1cbiAgICBEZXZpY2VSZWdpc3RyYXRpb25zLnByb3RvdHlwZS5zYXZlID0gZnVuY3Rpb24gKGRldmljZSwgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnJlc3Q7XG4gICAgICAgIHZhciBib2R5ID0gZGV2aWNlZGV0YWlsc18xLmRlZmF1bHQuZnJvbVZhbHVlcyhkZXZpY2UpO1xuICAgICAgICB2YXIgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRQb3N0SGVhZGVycyhyZXN0Lm9wdGlvbnMsIGZvcm1hdCksIHBhcmFtcyA9IHt9O1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdzYXZlJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgICAgICAgVXRpbHMubWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiAndHJ1ZScgfSk7XG4gICAgICAgIHZhciByZXF1ZXN0Qm9keSA9IFV0aWxzLmVuY29kZUJvZHkoYm9keSwgZm9ybWF0KTtcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0LnB1dChyZXN0LCAnL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZS5pZCksIHJlcXVlc3RCb2R5LCBoZWFkZXJzLCBwYXJhbXMsIG51bGwsIGZ1bmN0aW9uIChlcnIsIGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhlcnIsICFlcnJcbiAgICAgICAgICAgICAgICA/IGRldmljZWRldGFpbHNfMS5kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoYm9keSwgdW5wYWNrZWQgPyB1bmRlZmluZWQgOiBmb3JtYXQpXG4gICAgICAgICAgICAgICAgOiB1bmRlZmluZWQpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIERldmljZVJlZ2lzdHJhdGlvbnMucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChkZXZpY2VJZE9yRGV0YWlscywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnJlc3QsIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0R2V0SGVhZGVycyhyZXN0Lm9wdGlvbnMsIGZvcm1hdCksIGRldmljZUlkID0gZGV2aWNlSWRPckRldGFpbHMuaWQgfHwgZGV2aWNlSWRPckRldGFpbHM7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2dldCcsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHR5cGVvZiBkZXZpY2VJZCAhPT0gJ3N0cmluZycgfHwgIWRldmljZUlkLmxlbmd0aCkge1xuICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0ZpcnN0IGFyZ3VtZW50IHRvIERldmljZVJlZ2lzdHJhdGlvbnMjZ2V0IG11c3QgYmUgYSBkZXZpY2VJZCBzdHJpbmcgb3IgRGV2aWNlRGV0YWlscycsIDQwMDAwLCA0MDApKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdC5nZXQocmVzdCwgJy9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMvJyArIGVuY29kZVVSSUNvbXBvbmVudChkZXZpY2VJZCksIGhlYWRlcnMsIHt9LCBudWxsLCBmdW5jdGlvbiAoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCAhZXJyXG4gICAgICAgICAgICAgICAgPyBkZXZpY2VkZXRhaWxzXzEuZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIHVucGFja2VkID8gdW5kZWZpbmVkIDogZm9ybWF0KVxuICAgICAgICAgICAgICAgIDogdW5kZWZpbmVkKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBEZXZpY2VSZWdpc3RyYXRpb25zLnByb3RvdHlwZS5saXN0ID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnJlc3QsIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGVudmVsb3BlID0gdGhpcy5yZXN0Lmh0dHAuc3VwcG9ydHNMaW5rSGVhZGVycyA/IHVuZGVmaW5lZCA6IGZvcm1hdCwgaGVhZGVycyA9IFV0aWxzLmRlZmF1bHRHZXRIZWFkZXJzKHJlc3Qub3B0aW9ucywgZm9ybWF0KTtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnbGlzdCcsIGFyZ3VtZW50cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5oZWFkZXJzKVxuICAgICAgICAgICAgVXRpbHMubWl4aW4oaGVhZGVycywgcmVzdC5vcHRpb25zLmhlYWRlcnMpO1xuICAgICAgICBuZXcgcGFnaW5hdGVkcmVzb3VyY2VfMS5kZWZhdWx0KHJlc3QsICcvcHVzaC9kZXZpY2VSZWdpc3RyYXRpb25zJywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uIChib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIGRldmljZWRldGFpbHNfMS5kZWZhdWx0LmZyb21SZXNwb25zZUJvZHkoYm9keSwgdW5wYWNrZWQgPyB1bmRlZmluZWQgOiBmb3JtYXQpO1xuICAgICAgICB9KS5nZXQocGFyYW1zLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBEZXZpY2VSZWdpc3RyYXRpb25zLnByb3RvdHlwZS5yZW1vdmUgPSBmdW5jdGlvbiAoZGV2aWNlSWRPckRldGFpbHMsIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5yZXN0LCBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdEdldEhlYWRlcnMocmVzdC5vcHRpb25zLCBmb3JtYXQpLCBwYXJhbXMgPSB7fSwgZGV2aWNlSWQgPSBkZXZpY2VJZE9yRGV0YWlscy5pZCB8fCBkZXZpY2VJZE9yRGV0YWlscztcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgaWYgKHRoaXMucmVzdC5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAncmVtb3ZlJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAodHlwZW9mIGRldmljZUlkICE9PSAnc3RyaW5nJyB8fCAhZGV2aWNlSWQubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnRmlyc3QgYXJndW1lbnQgdG8gRGV2aWNlUmVnaXN0cmF0aW9ucyNyZW1vdmUgbXVzdCBiZSBhIGRldmljZUlkIHN0cmluZyBvciBEZXZpY2VEZXRhaWxzJywgNDAwMDAsIDQwMCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICAgICAgICBVdGlscy5taXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6ICd0cnVlJyB9KTtcbiAgICAgICAgcmVzb3VyY2VfMS5kZWZhdWx0WydkZWxldGUnXShyZXN0LCAnL3B1c2gvZGV2aWNlUmVnaXN0cmF0aW9ucy8nICsgZW5jb2RlVVJJQ29tcG9uZW50KGRldmljZUlkKSwgaGVhZGVycywgcGFyYW1zLCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9KTtcbiAgICB9O1xuICAgIERldmljZVJlZ2lzdHJhdGlvbnMucHJvdG90eXBlLnJlbW92ZVdoZXJlID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnJlc3QsIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0R2V0SGVhZGVycyhyZXN0Lm9wdGlvbnMsIGZvcm1hdCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3JlbW92ZVdoZXJlJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgICAgICAgVXRpbHMubWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiAndHJ1ZScgfSk7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdFsnZGVsZXRlJ10ocmVzdCwgJy9wdXNoL2RldmljZVJlZ2lzdHJhdGlvbnMnLCBoZWFkZXJzLCBwYXJhbXMsIG51bGwsIGZ1bmN0aW9uIChlcnIpIHsgcmV0dXJuIGNhbGxiYWNrKGVycik7IH0pO1xuICAgIH07XG4gICAgcmV0dXJuIERldmljZVJlZ2lzdHJhdGlvbnM7XG59KCkpO1xudmFyIENoYW5uZWxTdWJzY3JpcHRpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENoYW5uZWxTdWJzY3JpcHRpb25zKHJlc3QpIHtcbiAgICAgICAgLyogQ2hhbm5lbFN1YnNjcmlwdGlvbnMgaGF2ZSBubyB1bmlxdWUgaWQ7IHJlbW92aW5nIG9uZSBpcyBlcXVpdmFsZW50IHRvIHJlbW92ZVdoZXJlIGJ5IGl0cyBwcm9wZXJ0aWVzICovXG4gICAgICAgIHRoaXMucmVtb3ZlID0gQ2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnJlbW92ZVdoZXJlO1xuICAgICAgICB0aGlzLnJlc3QgPSByZXN0O1xuICAgIH1cbiAgICBDaGFubmVsU3Vic2NyaXB0aW9ucy5wcm90b3R5cGUuc2F2ZSA9IGZ1bmN0aW9uIChzdWJzY3JpcHRpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciByZXN0ID0gdGhpcy5yZXN0O1xuICAgICAgICB2YXIgYm9keSA9IHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uXzEuZGVmYXVsdC5mcm9tVmFsdWVzKHN1YnNjcmlwdGlvbik7XG4gICAgICAgIHZhciBmb3JtYXQgPSByZXN0Lm9wdGlvbnMudXNlQmluYXJ5UHJvdG9jb2wgPyBVdGlscy5Gb3JtYXQubXNncGFjayA6IFV0aWxzLkZvcm1hdC5qc29uLCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdFBvc3RIZWFkZXJzKHJlc3Qub3B0aW9ucywgZm9ybWF0KSwgcGFyYW1zID0ge307XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3NhdmUnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICAgICAgICBVdGlscy5taXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6ICd0cnVlJyB9KTtcbiAgICAgICAgdmFyIHJlcXVlc3RCb2R5ID0gVXRpbHMuZW5jb2RlQm9keShib2R5LCBmb3JtYXQpO1xuICAgICAgICByZXNvdXJjZV8xLmRlZmF1bHQucG9zdChyZXN0LCAnL3B1c2gvY2hhbm5lbFN1YnNjcmlwdGlvbnMnLCByZXF1ZXN0Qm9keSwgaGVhZGVycywgcGFyYW1zLCBudWxsLCBmdW5jdGlvbiAoZXJyLCBib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyLCAhZXJyICYmIHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uXzEuZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIHVucGFja2VkID8gdW5kZWZpbmVkIDogZm9ybWF0KSk7XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgQ2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLmxpc3QgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucmVzdCwgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgZW52ZWxvcGUgPSB0aGlzLnJlc3QuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0LCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdEdldEhlYWRlcnMocmVzdC5vcHRpb25zLCBmb3JtYXQpO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdsaXN0JywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIG5ldyBwYWdpbmF0ZWRyZXNvdXJjZV8xLmRlZmF1bHQocmVzdCwgJy9wdXNoL2NoYW5uZWxTdWJzY3JpcHRpb25zJywgaGVhZGVycywgZW52ZWxvcGUsIGZ1bmN0aW9uIChib2R5LCBoZWFkZXJzLCB1bnBhY2tlZCkge1xuICAgICAgICAgICAgcmV0dXJuIHB1c2hjaGFubmVsc3Vic2NyaXB0aW9uXzEuZGVmYXVsdC5mcm9tUmVzcG9uc2VCb2R5KGJvZHksIHVucGFja2VkID8gdW5kZWZpbmVkIDogZm9ybWF0KTtcbiAgICAgICAgfSkuZ2V0KHBhcmFtcywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgQ2hhbm5lbFN1YnNjcmlwdGlvbnMucHJvdG90eXBlLnJlbW92ZVdoZXJlID0gZnVuY3Rpb24gKHBhcmFtcywgY2FsbGJhY2spIHtcbiAgICAgICAgdmFyIHJlc3QgPSB0aGlzLnJlc3QsIGZvcm1hdCA9IHJlc3Qub3B0aW9ucy51c2VCaW5hcnlQcm90b2NvbCA/IFV0aWxzLkZvcm1hdC5tc2dwYWNrIDogVXRpbHMuRm9ybWF0Lmpzb24sIGhlYWRlcnMgPSBVdGlscy5kZWZhdWx0R2V0SGVhZGVycyhyZXN0Lm9wdGlvbnMsIGZvcm1hdCk7XG4gICAgICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLnJlc3Qub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3JlbW92ZVdoZXJlJywgYXJndW1lbnRzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdC5vcHRpb25zLmhlYWRlcnMpXG4gICAgICAgICAgICBVdGlscy5taXhpbihoZWFkZXJzLCByZXN0Lm9wdGlvbnMuaGVhZGVycyk7XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMucHVzaEZ1bGxXYWl0KVxuICAgICAgICAgICAgVXRpbHMubWl4aW4ocGFyYW1zLCB7IGZ1bGxXYWl0OiAndHJ1ZScgfSk7XG4gICAgICAgIHJlc291cmNlXzEuZGVmYXVsdFsnZGVsZXRlJ10ocmVzdCwgJy9wdXNoL2NoYW5uZWxTdWJzY3JpcHRpb25zJywgaGVhZGVycywgcGFyYW1zLCBudWxsLCBmdW5jdGlvbiAoZXJyKSB7IHJldHVybiBjYWxsYmFjayhlcnIpOyB9KTtcbiAgICB9O1xuICAgIENoYW5uZWxTdWJzY3JpcHRpb25zLnByb3RvdHlwZS5saXN0Q2hhbm5lbHMgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgcmVzdCA9IHRoaXMucmVzdCwgZm9ybWF0ID0gcmVzdC5vcHRpb25zLnVzZUJpbmFyeVByb3RvY29sID8gVXRpbHMuRm9ybWF0Lm1zZ3BhY2sgOiBVdGlscy5Gb3JtYXQuanNvbiwgZW52ZWxvcGUgPSB0aGlzLnJlc3QuaHR0cC5zdXBwb3J0c0xpbmtIZWFkZXJzID8gdW5kZWZpbmVkIDogZm9ybWF0LCBoZWFkZXJzID0gVXRpbHMuZGVmYXVsdEdldEhlYWRlcnMocmVzdC5vcHRpb25zLCBmb3JtYXQpO1xuICAgICAgICBpZiAodHlwZW9mIGNhbGxiYWNrICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBpZiAodGhpcy5yZXN0Lm9wdGlvbnMucHJvbWlzZXMpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdsaXN0Q2hhbm5lbHMnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN0Lm9wdGlvbnMuaGVhZGVycylcbiAgICAgICAgICAgIFV0aWxzLm1peGluKGhlYWRlcnMsIHJlc3Qub3B0aW9ucy5oZWFkZXJzKTtcbiAgICAgICAgaWYgKHJlc3Qub3B0aW9ucy5wdXNoRnVsbFdhaXQpXG4gICAgICAgICAgICBVdGlscy5taXhpbihwYXJhbXMsIHsgZnVsbFdhaXQ6ICd0cnVlJyB9KTtcbiAgICAgICAgbmV3IHBhZ2luYXRlZHJlc291cmNlXzEuZGVmYXVsdChyZXN0LCAnL3B1c2gvY2hhbm5lbHMnLCBoZWFkZXJzLCBlbnZlbG9wZSwgZnVuY3Rpb24gKGJvZHksIGhlYWRlcnMsIHVucGFja2VkKSB7XG4gICAgICAgICAgICB2YXIgcGFyc2VkQm9keSA9ICghdW5wYWNrZWQgJiYgZm9ybWF0ID8gVXRpbHMuZGVjb2RlQm9keShib2R5LCBmb3JtYXQpIDogYm9keSk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhcnNlZEJvZHkubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgICBwYXJzZWRCb2R5W2ldID0gU3RyaW5nKHBhcnNlZEJvZHlbaV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHBhcnNlZEJvZHk7XG4gICAgICAgIH0pLmdldChwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIHJldHVybiBDaGFubmVsU3Vic2NyaXB0aW9ucztcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQdXNoO1xuXG5cbi8qKiovIH0pLFxuLyogNDcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgRGV2aWNlRm9ybUZhY3RvcjtcbihmdW5jdGlvbiAoRGV2aWNlRm9ybUZhY3Rvcikge1xuICAgIERldmljZUZvcm1GYWN0b3JbXCJQaG9uZVwiXSA9IFwicGhvbmVcIjtcbiAgICBEZXZpY2VGb3JtRmFjdG9yW1wiVGFibGV0XCJdID0gXCJ0YWJsZXRcIjtcbiAgICBEZXZpY2VGb3JtRmFjdG9yW1wiRGVza3RvcFwiXSA9IFwiZGVza3RvcFwiO1xuICAgIERldmljZUZvcm1GYWN0b3JbXCJUVlwiXSA9IFwidHZcIjtcbiAgICBEZXZpY2VGb3JtRmFjdG9yW1wiV2F0Y2hcIl0gPSBcIndhdGNoXCI7XG4gICAgRGV2aWNlRm9ybUZhY3RvcltcIkNhclwiXSA9IFwiY2FyXCI7XG4gICAgRGV2aWNlRm9ybUZhY3RvcltcIkVtYmVkZGVkXCJdID0gXCJlbWJlZGRlZFwiO1xuICAgIERldmljZUZvcm1GYWN0b3JbXCJPdGhlclwiXSA9IFwib3RoZXJcIjtcbn0pKERldmljZUZvcm1GYWN0b3IgfHwgKERldmljZUZvcm1GYWN0b3IgPSB7fSkpO1xudmFyIERldmljZVBsYXRmb3JtO1xuKGZ1bmN0aW9uIChEZXZpY2VQbGF0Zm9ybSkge1xuICAgIERldmljZVBsYXRmb3JtW1wiQW5kcm9pZFwiXSA9IFwiYW5kcm9pZFwiO1xuICAgIERldmljZVBsYXRmb3JtW1wiSU9TXCJdID0gXCJpb3NcIjtcbiAgICBEZXZpY2VQbGF0Zm9ybVtcIkJyb3dzZXJcIl0gPSBcImJyb3dzZXJcIjtcbn0pKERldmljZVBsYXRmb3JtIHx8IChEZXZpY2VQbGF0Zm9ybSA9IHt9KSk7XG52YXIgRGV2aWNlRGV0YWlscyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBEZXZpY2VEZXRhaWxzKCkge1xuICAgIH1cbiAgICBEZXZpY2VEZXRhaWxzLnByb3RvdHlwZS50b0pTT04gPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgaWQ6IHRoaXMuaWQsXG4gICAgICAgICAgICBkZXZpY2VTZWNyZXQ6IHRoaXMuZGV2aWNlU2VjcmV0LFxuICAgICAgICAgICAgcGxhdGZvcm06IHRoaXMucGxhdGZvcm0sXG4gICAgICAgICAgICBmb3JtRmFjdG9yOiB0aGlzLmZvcm1GYWN0b3IsXG4gICAgICAgICAgICBjbGllbnRJZDogdGhpcy5jbGllbnRJZCxcbiAgICAgICAgICAgIG1ldGFkYXRhOiB0aGlzLm1ldGFkYXRhLFxuICAgICAgICAgICAgZGV2aWNlSWRlbnRpdHlUb2tlbjogdGhpcy5kZXZpY2VJZGVudGl0eVRva2VuLFxuICAgICAgICAgICAgcHVzaDoge1xuICAgICAgICAgICAgICAgIHJlY2lwaWVudDogKF9hID0gdGhpcy5wdXNoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVjaXBpZW50LFxuICAgICAgICAgICAgICAgIHN0YXRlOiAoX2IgPSB0aGlzLnB1c2gpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5zdGF0ZSxcbiAgICAgICAgICAgICAgICBlcnJvcjogKF9jID0gdGhpcy5wdXNoKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MuZXJyb3IsXG4gICAgICAgICAgICB9LFxuICAgICAgICB9O1xuICAgIH07XG4gICAgRGV2aWNlRGV0YWlscy5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYSwgX2IsIF9jLCBfZDtcbiAgICAgICAgdmFyIHJlc3VsdCA9ICdbRGV2aWNlRGV0YWlscyc7XG4gICAgICAgIGlmICh0aGlzLmlkKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGlkPScgKyB0aGlzLmlkO1xuICAgICAgICBpZiAodGhpcy5wbGF0Zm9ybSlcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBwbGF0Zm9ybT0nICsgdGhpcy5wbGF0Zm9ybTtcbiAgICAgICAgaWYgKHRoaXMuZm9ybUZhY3RvcilcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBmb3JtRmFjdG9yPScgKyB0aGlzLmZvcm1GYWN0b3I7XG4gICAgICAgIGlmICh0aGlzLmNsaWVudElkKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGNsaWVudElkPScgKyB0aGlzLmNsaWVudElkO1xuICAgICAgICBpZiAodGhpcy5tZXRhZGF0YSlcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBtZXRhZGF0YT0nICsgdGhpcy5tZXRhZGF0YTtcbiAgICAgICAgaWYgKHRoaXMuZGV2aWNlSWRlbnRpdHlUb2tlbilcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBkZXZpY2VJZGVudGl0eVRva2VuPScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLmRldmljZUlkZW50aXR5VG9rZW4pO1xuICAgICAgICBpZiAoKF9hID0gdGhpcy5wdXNoKSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2EucmVjaXBpZW50KVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IHB1c2gucmVjaXBpZW50PScgKyBKU09OLnN0cmluZ2lmeSh0aGlzLnB1c2gucmVjaXBpZW50KTtcbiAgICAgICAgaWYgKChfYiA9IHRoaXMucHVzaCkgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnN0YXRlKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IHB1c2guc3RhdGU9JyArIHRoaXMucHVzaC5zdGF0ZTtcbiAgICAgICAgaWYgKChfYyA9IHRoaXMucHVzaCkgPT09IG51bGwgfHwgX2MgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9jLmVycm9yKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IHB1c2guZXJyb3I9JyArIEpTT04uc3RyaW5naWZ5KHRoaXMucHVzaC5lcnJvcik7XG4gICAgICAgIGlmICgoX2QgPSB0aGlzLnB1c2gpID09PSBudWxsIHx8IF9kID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZC5tZXRhZGF0YSlcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBwdXNoLm1ldGFkYXRhPScgKyB0aGlzLnB1c2gubWV0YWRhdGE7XG4gICAgICAgIHJlc3VsdCArPSAnXSc7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBEZXZpY2VEZXRhaWxzLmZyb21SZXNwb25zZUJvZHkgPSBmdW5jdGlvbiAoYm9keSwgZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGJvZHkgPSBVdGlscy5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWxzLmlzQXJyYXkoYm9keSkpIHtcbiAgICAgICAgICAgIHJldHVybiBEZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXNBcnJheShib2R5KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHJldHVybiBEZXZpY2VEZXRhaWxzLmZyb21WYWx1ZXMoYm9keSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIERldmljZURldGFpbHMuZnJvbVZhbHVlcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgdmFsdWVzLmVycm9yID0gdmFsdWVzLmVycm9yICYmIGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyh2YWx1ZXMuZXJyb3IpO1xuICAgICAgICByZXR1cm4gT2JqZWN0LmFzc2lnbihuZXcgRGV2aWNlRGV0YWlscygpLCB2YWx1ZXMpO1xuICAgIH07XG4gICAgRGV2aWNlRGV0YWlscy5mcm9tVmFsdWVzQXJyYXkgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IERldmljZURldGFpbHMuZnJvbVZhbHVlcyh2YWx1ZXNbaV0pO1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH07XG4gICAgRGV2aWNlRGV0YWlscy50b1JlcXVlc3RCb2R5ID0gVXRpbHMuZW5jb2RlQm9keTtcbiAgICByZXR1cm4gRGV2aWNlRGV0YWlscztcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBEZXZpY2VEZXRhaWxzO1xuXG5cbi8qKiovIH0pLFxuLyogNDggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uKCkge1xuICAgIH1cbiAgICAvKipcbiAgICAgKiBPdmVybG9hZCB0b0pTT04oKSB0byBpbnRlcmNlcHQgSlNPTi5zdHJpbmdpZnkoKVxuICAgICAqIEByZXR1cm4geyp9XG4gICAgICovXG4gICAgUHVzaENoYW5uZWxTdWJzY3JpcHRpb24ucHJvdG90eXBlLnRvSlNPTiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIGNoYW5uZWw6IHRoaXMuY2hhbm5lbCxcbiAgICAgICAgICAgIGRldmljZUlkOiB0aGlzLmRldmljZUlkLFxuICAgICAgICAgICAgY2xpZW50SWQ6IHRoaXMuY2xpZW50SWQsXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciByZXN1bHQgPSAnW1B1c2hDaGFubmVsU3Vic2NyaXB0aW9uJztcbiAgICAgICAgaWYgKHRoaXMuY2hhbm5lbClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBjaGFubmVsPScgKyB0aGlzLmNoYW5uZWw7XG4gICAgICAgIGlmICh0aGlzLmRldmljZUlkKVxuICAgICAgICAgICAgcmVzdWx0ICs9ICc7IGRldmljZUlkPScgKyB0aGlzLmRldmljZUlkO1xuICAgICAgICBpZiAodGhpcy5jbGllbnRJZClcbiAgICAgICAgICAgIHJlc3VsdCArPSAnOyBjbGllbnRJZD0nICsgdGhpcy5jbGllbnRJZDtcbiAgICAgICAgcmVzdWx0ICs9ICddJztcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21SZXNwb25zZUJvZHkgPSBmdW5jdGlvbiAoYm9keSwgZm9ybWF0KSB7XG4gICAgICAgIGlmIChmb3JtYXQpIHtcbiAgICAgICAgICAgIGJvZHkgPSBVdGlscy5kZWNvZGVCb2R5KGJvZHksIGZvcm1hdCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFV0aWxzLmlzQXJyYXkoYm9keSkpIHtcbiAgICAgICAgICAgIHJldHVybiBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzQXJyYXkoYm9keSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlcyhib2R5KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHVzaENoYW5uZWxTdWJzY3JpcHRpb24uZnJvbVZhbHVlcyA9IGZ1bmN0aW9uICh2YWx1ZXMpIHtcbiAgICAgICAgcmV0dXJuIE9iamVjdC5hc3NpZ24obmV3IFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uKCksIHZhbHVlcyk7XG4gICAgfTtcbiAgICBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbi5mcm9tVmFsdWVzQXJyYXkgPSBmdW5jdGlvbiAodmFsdWVzKSB7XG4gICAgICAgIHZhciBjb3VudCA9IHZhbHVlcy5sZW5ndGgsIHJlc3VsdCA9IG5ldyBBcnJheShjb3VudCk7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY291bnQ7IGkrKylcbiAgICAgICAgICAgIHJlc3VsdFtpXSA9IFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLmZyb21WYWx1ZXModmFsdWVzW2ldKTtcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFB1c2hDaGFubmVsU3Vic2NyaXB0aW9uLnRvUmVxdWVzdEJvZHkgPSBVdGlscy5lbmNvZGVCb2R5O1xuICAgIHJldHVybiBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbjtcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBQdXNoQ2hhbm5lbFN1YnNjcmlwdGlvbjtcblxuXG4vKioqLyB9KSxcbi8qIDQ5ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBNZXNzYWdlQ291bnQgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVzc2FnZUNvdW50KHZhbHVlcykge1xuICAgICAgICB0aGlzLmNvdW50ID0gKHZhbHVlcyAmJiB2YWx1ZXMuY291bnQpIHx8IDA7XG4gICAgICAgIHRoaXMuZGF0YSA9ICh2YWx1ZXMgJiYgdmFsdWVzLmRhdGEpIHx8IDA7XG4gICAgICAgIHRoaXMudW5jb21wcmVzc2VkRGF0YSA9ICh2YWx1ZXMgJiYgdmFsdWVzLnVuY29tcHJlc3NlZERhdGEpIHx8IDA7XG4gICAgICAgIHRoaXMuZmFpbGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuZmFpbGVkKSB8fCAwO1xuICAgICAgICB0aGlzLnJlZnVzZWQgPSAodmFsdWVzICYmIHZhbHVlcy5yZWZ1c2VkKSB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gTWVzc2FnZUNvdW50O1xufSgpKTtcbnZhciBNZXNzYWdlQ2F0ZWdvcnkgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoTWVzc2FnZUNhdGVnb3J5LCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VDYXRlZ29yeSh2YWx1ZXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgdmFsdWVzKSB8fCB0aGlzO1xuICAgICAgICBpZiAodmFsdWVzICYmIHZhbHVlcy5jYXRlZ29yeSkge1xuICAgICAgICAgICAgX3RoaXMuY2F0ZWdvcnkgPSB7fTtcbiAgICAgICAgICAgIFV0aWxzLmZvckluT3duTm9uTnVsbFByb3BlcnRpZXModmFsdWVzLmNhdGVnb3J5LCBmdW5jdGlvbiAocHJvcCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmNhdGVnb3J5W3Byb3BdID0gbmV3IE1lc3NhZ2VDb3VudCh2YWx1ZXMuY2F0ZWdvcnlbcHJvcF0pO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICByZXR1cm4gTWVzc2FnZUNhdGVnb3J5O1xufShNZXNzYWdlQ291bnQpKTtcbnZhciBSZXNvdXJjZUNvdW50ID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFJlc291cmNlQ291bnQodmFsdWVzKSB7XG4gICAgICAgIHRoaXMucGVhayA9ICh2YWx1ZXMgJiYgdmFsdWVzLnBlYWspIHx8IDA7XG4gICAgICAgIHRoaXMubWluID0gKHZhbHVlcyAmJiB2YWx1ZXMubWluKSB8fCAwO1xuICAgICAgICB0aGlzLm1lYW4gPSAodmFsdWVzICYmIHZhbHVlcy5tZWFuKSB8fCAwO1xuICAgICAgICB0aGlzLm9wZW5lZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLm9wZW5lZCkgfHwgMDtcbiAgICAgICAgdGhpcy5yZWZ1c2VkID0gKHZhbHVlcyAmJiB2YWx1ZXMucmVmdXNlZCkgfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIFJlc291cmNlQ291bnQ7XG59KCkpO1xudmFyIFJlcXVlc3RDb3VudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBSZXF1ZXN0Q291bnQodmFsdWVzKSB7XG4gICAgICAgIHRoaXMuc3VjY2VlZGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuc3VjY2VlZGVkKSB8fCAwO1xuICAgICAgICB0aGlzLmZhaWxlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLmZhaWxlZCkgfHwgMDtcbiAgICAgICAgdGhpcy5yZWZ1c2VkID0gKHZhbHVlcyAmJiB2YWx1ZXMucmVmdXNlZCkgfHwgMDtcbiAgICB9XG4gICAgcmV0dXJuIFJlcXVlc3RDb3VudDtcbn0oKSk7XG52YXIgQ29ubmVjdGlvblR5cGVzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIENvbm5lY3Rpb25UeXBlcyh2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5wbGFpbiA9IG5ldyBSZXNvdXJjZUNvdW50KHZhbHVlcyAmJiB2YWx1ZXMucGxhaW4pO1xuICAgICAgICB0aGlzLnRscyA9IG5ldyBSZXNvdXJjZUNvdW50KHZhbHVlcyAmJiB2YWx1ZXMudGxzKTtcbiAgICAgICAgdGhpcy5hbGwgPSBuZXcgUmVzb3VyY2VDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLmFsbCk7XG4gICAgfVxuICAgIHJldHVybiBDb25uZWN0aW9uVHlwZXM7XG59KCkpO1xudmFyIE1lc3NhZ2VUeXBlcyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBNZXNzYWdlVHlwZXModmFsdWVzKSB7XG4gICAgICAgIHRoaXMubWVzc2FnZXMgPSBuZXcgTWVzc2FnZUNhdGVnb3J5KHZhbHVlcyAmJiB2YWx1ZXMubWVzc2FnZXMpO1xuICAgICAgICB0aGlzLnByZXNlbmNlID0gbmV3IE1lc3NhZ2VDYXRlZ29yeSh2YWx1ZXMgJiYgdmFsdWVzLnByZXNlbmNlKTtcbiAgICAgICAgdGhpcy5hbGwgPSBuZXcgTWVzc2FnZUNhdGVnb3J5KHZhbHVlcyAmJiB2YWx1ZXMuYWxsKTtcbiAgICB9XG4gICAgcmV0dXJuIE1lc3NhZ2VUeXBlcztcbn0oKSk7XG52YXIgTWVzc2FnZVRyYWZmaWMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gTWVzc2FnZVRyYWZmaWModmFsdWVzKSB7XG4gICAgICAgIHRoaXMucmVhbHRpbWUgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMucmVhbHRpbWUpO1xuICAgICAgICB0aGlzLnJlc3QgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMucmVzdCk7XG4gICAgICAgIHRoaXMud2ViaG9vayA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy53ZWJob29rKTtcbiAgICAgICAgdGhpcy5zaGFyZWRRdWV1ZSA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5zaGFyZWRRdWV1ZSk7XG4gICAgICAgIHRoaXMuZXh0ZXJuYWxRdWV1ZSA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5leHRlcm5hbFF1ZXVlKTtcbiAgICAgICAgdGhpcy5odHRwRXZlbnQgPSBuZXcgTWVzc2FnZVR5cGVzKHZhbHVlcyAmJiB2YWx1ZXMuaHR0cEV2ZW50KTtcbiAgICAgICAgdGhpcy5wdXNoID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLnB1c2gpO1xuICAgICAgICB0aGlzLmFsbCA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5hbGwpO1xuICAgIH1cbiAgICByZXR1cm4gTWVzc2FnZVRyYWZmaWM7XG59KCkpO1xudmFyIE1lc3NhZ2VEaXJlY3Rpb25zID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIE1lc3NhZ2VEaXJlY3Rpb25zKHZhbHVlcykge1xuICAgICAgICB0aGlzLmFsbCA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5hbGwpO1xuICAgICAgICB0aGlzLmluYm91bmQgPSBuZXcgTWVzc2FnZVRyYWZmaWModmFsdWVzICYmIHZhbHVlcy5pbmJvdW5kKTtcbiAgICAgICAgdGhpcy5vdXRib3VuZCA9IG5ldyBNZXNzYWdlVHJhZmZpYyh2YWx1ZXMgJiYgdmFsdWVzLm91dGJvdW5kKTtcbiAgICB9XG4gICAgcmV0dXJuIE1lc3NhZ2VEaXJlY3Rpb25zO1xufSgpKTtcbnZhciBYY2hnTWVzc2FnZXMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gWGNoZ01lc3NhZ2VzKHZhbHVlcykge1xuICAgICAgICB0aGlzLmFsbCA9IG5ldyBNZXNzYWdlVHlwZXModmFsdWVzICYmIHZhbHVlcy5hbGwpO1xuICAgICAgICB0aGlzLnByb2R1Y2VyUGFpZCA9IG5ldyBNZXNzYWdlRGlyZWN0aW9ucyh2YWx1ZXMgJiYgdmFsdWVzLnByb2R1Y2VyUGFpZCk7XG4gICAgICAgIHRoaXMuY29uc3VtZXJQYWlkID0gbmV3IE1lc3NhZ2VEaXJlY3Rpb25zKHZhbHVlcyAmJiB2YWx1ZXMuY29uc3VtZXJQYWlkKTtcbiAgICB9XG4gICAgcmV0dXJuIFhjaGdNZXNzYWdlcztcbn0oKSk7XG52YXIgUHVzaFN0YXRzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFB1c2hTdGF0cyh2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5tZXNzYWdlcyA9ICh2YWx1ZXMgJiYgdmFsdWVzLm1lc3NhZ2VzKSB8fCAwO1xuICAgICAgICB2YXIgbm90aWZpY2F0aW9ucyA9IHZhbHVlcyAmJiB2YWx1ZXMubm90aWZpY2F0aW9ucztcbiAgICAgICAgdGhpcy5ub3RpZmljYXRpb25zID0ge1xuICAgICAgICAgICAgaW52YWxpZDogKG5vdGlmaWNhdGlvbnMgJiYgbm90aWZpY2F0aW9ucy5pbnZhbGlkKSB8fCAwLFxuICAgICAgICAgICAgYXR0ZW1wdGVkOiAobm90aWZpY2F0aW9ucyAmJiBub3RpZmljYXRpb25zLmF0dGVtcHRlZCkgfHwgMCxcbiAgICAgICAgICAgIHN1Y2Nlc3NmdWw6IChub3RpZmljYXRpb25zICYmIG5vdGlmaWNhdGlvbnMuc3VjY2Vzc2Z1bCkgfHwgMCxcbiAgICAgICAgICAgIGZhaWxlZDogKG5vdGlmaWNhdGlvbnMgJiYgbm90aWZpY2F0aW9ucy5mYWlsZWQpIHx8IDAsXG4gICAgICAgIH07XG4gICAgICAgIHRoaXMuZGlyZWN0UHVibGlzaGVzID0gKHZhbHVlcyAmJiB2YWx1ZXMuZGlyZWN0UHVibGlzaGVzKSB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gUHVzaFN0YXRzO1xufSgpKTtcbnZhciBQcm9jZXNzZWRDb3VudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQcm9jZXNzZWRDb3VudCh2YWx1ZXMpIHtcbiAgICAgICAgdGhpcy5zdWNjZWVkZWQgPSAodmFsdWVzICYmIHZhbHVlcy5zdWNjZWVkZWQpIHx8IDA7XG4gICAgICAgIHRoaXMuc2tpcHBlZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLnNraXBwZWQpIHx8IDA7XG4gICAgICAgIHRoaXMuZmFpbGVkID0gKHZhbHVlcyAmJiB2YWx1ZXMuZmFpbGVkKSB8fCAwO1xuICAgIH1cbiAgICByZXR1cm4gUHJvY2Vzc2VkQ291bnQ7XG59KCkpO1xudmFyIFByb2Nlc3NlZE1lc3NhZ2VzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIFByb2Nlc3NlZE1lc3NhZ2VzKHZhbHVlcykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB0aGlzLmRlbHRhID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAodmFsdWVzICYmIHZhbHVlcy5kZWx0YSkge1xuICAgICAgICAgICAgdGhpcy5kZWx0YSA9IHt9O1xuICAgICAgICAgICAgVXRpbHMuZm9ySW5Pd25Ob25OdWxsUHJvcGVydGllcyh2YWx1ZXMuZGVsdGEsIGZ1bmN0aW9uIChwcm9wKSB7XG4gICAgICAgICAgICAgICAgX3RoaXMuZGVsdGFbcHJvcF0gPSBuZXcgUHJvY2Vzc2VkQ291bnQodmFsdWVzLmRlbHRhW3Byb3BdKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBQcm9jZXNzZWRNZXNzYWdlcztcbn0oKSk7XG52YXIgU3RhdHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoU3RhdHMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gU3RhdHModmFsdWVzKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIHZhbHVlcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucGVyc2lzdGVkID0gbmV3IE1lc3NhZ2VUeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLnBlcnNpc3RlZCk7XG4gICAgICAgIF90aGlzLmNvbm5lY3Rpb25zID0gbmV3IENvbm5lY3Rpb25UeXBlcyh2YWx1ZXMgJiYgdmFsdWVzLmNvbm5lY3Rpb25zKTtcbiAgICAgICAgX3RoaXMuY2hhbm5lbHMgPSBuZXcgUmVzb3VyY2VDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLmNoYW5uZWxzKTtcbiAgICAgICAgX3RoaXMuYXBpUmVxdWVzdHMgPSBuZXcgUmVxdWVzdENvdW50KHZhbHVlcyAmJiB2YWx1ZXMuYXBpUmVxdWVzdHMpO1xuICAgICAgICBfdGhpcy50b2tlblJlcXVlc3RzID0gbmV3IFJlcXVlc3RDb3VudCh2YWx1ZXMgJiYgdmFsdWVzLnRva2VuUmVxdWVzdHMpO1xuICAgICAgICBfdGhpcy54Y2hnUHJvZHVjZXIgPSBuZXcgWGNoZ01lc3NhZ2VzKHZhbHVlcyAmJiB2YWx1ZXMueGNoZ1Byb2R1Y2VyKTtcbiAgICAgICAgX3RoaXMueGNoZ0NvbnN1bWVyID0gbmV3IFhjaGdNZXNzYWdlcyh2YWx1ZXMgJiYgdmFsdWVzLnhjaGdDb25zdW1lcik7XG4gICAgICAgIF90aGlzLnB1c2ggPSBuZXcgUHVzaFN0YXRzKHZhbHVlcyAmJiB2YWx1ZXMucHVzaFN0YXRzKTtcbiAgICAgICAgX3RoaXMucHJvY2Vzc2VkID0gbmV3IFByb2Nlc3NlZE1lc3NhZ2VzKHZhbHVlcyAmJiB2YWx1ZXMucHJvY2Vzc2VkKTtcbiAgICAgICAgX3RoaXMuaW5Qcm9ncmVzcyA9ICh2YWx1ZXMgJiYgdmFsdWVzLmluUHJvZ3Jlc3MpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMudW5pdCA9ICh2YWx1ZXMgJiYgdmFsdWVzLnVuaXQpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMuaW50ZXJ2YWxJZCA9ICh2YWx1ZXMgJiYgdmFsdWVzLmludGVydmFsSWQpIHx8IHVuZGVmaW5lZDtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBTdGF0cy5mcm9tVmFsdWVzID0gZnVuY3Rpb24gKHZhbHVlcykge1xuICAgICAgICByZXR1cm4gbmV3IFN0YXRzKHZhbHVlcyk7XG4gICAgfTtcbiAgICByZXR1cm4gU3RhdHM7XG59KE1lc3NhZ2VEaXJlY3Rpb25zKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBTdGF0cztcblxuXG4vKioqLyB9KSxcbi8qIDUwICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciByZXN0XzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMwKSk7XG52YXIgZXZlbnRlbWl0dGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDcpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIGNvbm5lY3Rpb25fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNTEpKTtcbnZhciByZWFsdGltZWNoYW5uZWxfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzgpKTtcbnZhciBkZWZhdWx0c18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg4KSk7XG52YXIgZXJyb3JpbmZvXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDQpKTtcbnZhciBwcm90b2NvbG1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTApKTtcbnZhciBjb25uZWN0aW9ubWFuYWdlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzNSkpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbnZhciBtZXNzYWdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDkpKTtcbnZhciBSZWFsdGltZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhSZWFsdGltZSwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBSZWFsdGltZShvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG9wdGlvbnMpIHx8IHRoaXM7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUmVhbHRpbWUoKScsICcnKTtcbiAgICAgICAgX3RoaXMuY29ubmVjdGlvbiA9IG5ldyBjb25uZWN0aW9uXzEuZGVmYXVsdChfdGhpcywgX3RoaXMub3B0aW9ucyk7XG4gICAgICAgIF90aGlzLmNoYW5uZWxzID0gbmV3IENoYW5uZWxzKF90aGlzKTtcbiAgICAgICAgaWYgKG9wdGlvbnMuYXV0b0Nvbm5lY3QgIT09IGZhbHNlKVxuICAgICAgICAgICAgX3RoaXMuY29ubmVjdCgpO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFJlYWx0aW1lLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1JlYWx0aW1lLmNvbm5lY3QoKScsICcnKTtcbiAgICAgICAgdGhpcy5jb25uZWN0aW9uLmNvbm5lY3QoKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdSZWFsdGltZS5jbG9zZSgpJywgJycpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb24uY2xvc2UoKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lLlByb21pc2UgPSBmdW5jdGlvbiAob3B0aW9ucykge1xuICAgICAgICBvcHRpb25zID0gZGVmYXVsdHNfMS5kZWZhdWx0Lm9iamVjdGlmeU9wdGlvbnMob3B0aW9ucyk7XG4gICAgICAgIG9wdGlvbnMucHJvbWlzZXMgPSB0cnVlO1xuICAgICAgICByZXR1cm4gbmV3IFJlYWx0aW1lKG9wdGlvbnMpO1xuICAgIH07XG4gICAgUmVhbHRpbWUuQ2FsbGJhY2tzID0gUmVhbHRpbWU7XG4gICAgUmVhbHRpbWUuVXRpbHMgPSBVdGlscztcbiAgICBSZWFsdGltZS5Db25uZWN0aW9uTWFuYWdlciA9IGNvbm5lY3Rpb25tYW5hZ2VyXzEuZGVmYXVsdDtcbiAgICBSZWFsdGltZS5QbGF0Zm9ybSA9IHBsYXRmb3JtXzEuZGVmYXVsdDtcbiAgICBSZWFsdGltZS5Qcm90b2NvbE1lc3NhZ2UgPSBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0O1xuICAgIFJlYWx0aW1lLk1lc3NhZ2UgPSBtZXNzYWdlXzEuZGVmYXVsdDtcbiAgICByZXR1cm4gUmVhbHRpbWU7XG59KHJlc3RfMS5kZWZhdWx0KSk7XG52YXIgQ2hhbm5lbHMgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XG4gICAgdHNsaWJfMS5fX2V4dGVuZHMoQ2hhbm5lbHMsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ2hhbm5lbHMocmVhbHRpbWUpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMucmVhbHRpbWUgPSByZWFsdGltZTtcbiAgICAgICAgX3RoaXMuYWxsID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICAgICAgcmVhbHRpbWUuY29ubmVjdGlvbi5jb25uZWN0aW9uTWFuYWdlci5vbigndHJhbnNwb3J0LmFjdGl2ZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgIF90aGlzLm9uVHJhbnNwb3J0QWN0aXZlKCk7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIENoYW5uZWxzLnByb3RvdHlwZS5jaGFubmVsU2VyaWFscyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIHNlcmlhbHMgPSB7fTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IFV0aWxzLmtleXNBcnJheSh0aGlzLmFsbCwgdHJ1ZSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZV8xID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtuYW1lXzFdO1xuICAgICAgICAgICAgaWYgKGNoYW5uZWwucHJvcGVydGllcy5jaGFubmVsU2VyaWFsKSB7XG4gICAgICAgICAgICAgICAgc2VyaWFsc1tuYW1lXzFdID0gY2hhbm5lbC5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWw7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNlcmlhbHM7XG4gICAgfTtcbiAgICAvLyByZWNvdmVyQ2hhbm5lbHMgZ2V0cyB0aGUgZ2l2ZW4gY2hhbm5lbHMgYW5kIHNldHMgdGhlaXIgY2hhbm5lbCBzZXJpYWxzLlxuICAgIENoYW5uZWxzLnByb3RvdHlwZS5yZWNvdmVyQ2hhbm5lbHMgPSBmdW5jdGlvbiAoY2hhbm5lbFNlcmlhbHMpIHtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwLCBfYSA9IFV0aWxzLmtleXNBcnJheShjaGFubmVsU2VyaWFscywgdHJ1ZSk7IF9pIDwgX2EubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICB2YXIgbmFtZV8yID0gX2FbX2ldO1xuICAgICAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmdldChuYW1lXzIpO1xuICAgICAgICAgICAgY2hhbm5lbC5wcm9wZXJ0aWVzLmNoYW5uZWxTZXJpYWwgPSBjaGFubmVsU2VyaWFsc1tuYW1lXzJdO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBDaGFubmVscy5wcm90b3R5cGUub25DaGFubmVsTWVzc2FnZSA9IGZ1bmN0aW9uIChtc2cpIHtcbiAgICAgICAgdmFyIGNoYW5uZWxOYW1lID0gbXNnLmNoYW5uZWw7XG4gICAgICAgIGlmIChjaGFubmVsTmFtZSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ0NoYW5uZWxzLm9uQ2hhbm5lbE1lc3NhZ2UoKScsICdyZWNlaXZlZCBldmVudCB1bnNwZWNpZmllZCBjaGFubmVsLCBhY3Rpb24gPSAnICsgbXNnLmFjdGlvbik7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmFsbFtjaGFubmVsTmFtZV07XG4gICAgICAgIGlmICghY2hhbm5lbCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdDaGFubmVscy5vbkNoYW5uZWxNZXNzYWdlKCknLCAncmVjZWl2ZWQgZXZlbnQgZm9yIG5vbi1leGlzdGVudCBjaGFubmVsOiAnICsgY2hhbm5lbE5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGNoYW5uZWwub25NZXNzYWdlKG1zZyk7XG4gICAgfTtcbiAgICAvKiBjYWxsZWQgd2hlbiBhIHRyYW5zcG9ydCBiZWNvbWVzIGNvbm5lY3RlZDsgcmVhdHRlbXB0IGF0dGFjaC9kZXRhY2hcbiAgICAgKiBmb3IgY2hhbm5lbHMgdGhhdCBhcmUgYXR0YWNoaW5nIG9yIGRldGFjaGluZy4gKi9cbiAgICBDaGFubmVscy5wcm90b3R5cGUub25UcmFuc3BvcnRBY3RpdmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZvciAodmFyIGNoYW5uZWxOYW1lIGluIHRoaXMuYWxsKSB7XG4gICAgICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW2NoYW5uZWxOYW1lXTtcbiAgICAgICAgICAgIGlmIChjaGFubmVsLnN0YXRlID09PSAnYXR0YWNoaW5nJyB8fCBjaGFubmVsLnN0YXRlID09PSAnZGV0YWNoaW5nJykge1xuICAgICAgICAgICAgICAgIGNoYW5uZWwuY2hlY2tQZW5kaW5nU3RhdGUoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5uZWwuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5fYXR0YWNoKGZhbHNlLCBudWxsKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKGNoYW5uZWwuc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcbiAgICAgICAgICAgICAgICAvLyBOb3RlIGV4cGxpY2l0eSByZXF1ZXN0IHRoZSBzdGF0ZSwgY2hhbm5lbC5hdHRhY2goKSB3b3VsZCBkbyBub3RoaW5nXG4gICAgICAgICAgICAgICAgLy8gYXMgaXRzIGFscmVhZHkgYXR0YWNoZWQuXG4gICAgICAgICAgICAgICAgY2hhbm5lbC5yZXF1ZXN0U3RhdGUoJ2F0dGFjaGluZycpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICAvKiBDb25uZWN0aW9uIGludGVycnVwdGlvbnMgKGllIHdoZW4gdGhlIGNvbm5lY3Rpb24gd2lsbCBubyBsb25nZXIgcXVldWVcbiAgICAgKiBldmVudHMpIGltcGx5IGNvbm5lY3Rpb24gc3RhdGUgY2hhbmdlcyBmb3IgYW55IGNoYW5uZWwgd2hpY2ggaXMgZWl0aGVyXG4gICAgICogYXR0YWNoZWQsIHBlbmRpbmcsIG9yIHdpbGwgYXR0ZW1wdCB0byBiZWNvbWUgYXR0YWNoZWQgaW4gdGhlIGZ1dHVyZSAqL1xuICAgIENoYW5uZWxzLnByb3RvdHlwZS5wcm9wb2dhdGVDb25uZWN0aW9uSW50ZXJydXB0aW9uID0gZnVuY3Rpb24gKGNvbm5lY3Rpb25TdGF0ZSwgcmVhc29uKSB7XG4gICAgICAgIHZhciBjb25uZWN0aW9uU3RhdGVUb0NoYW5uZWxTdGF0ZSA9IHtcbiAgICAgICAgICAgIGNsb3Npbmc6ICdkZXRhY2hlZCcsXG4gICAgICAgICAgICBjbG9zZWQ6ICdkZXRhY2hlZCcsXG4gICAgICAgICAgICBmYWlsZWQ6ICdmYWlsZWQnLFxuICAgICAgICAgICAgc3VzcGVuZGVkOiAnc3VzcGVuZGVkJyxcbiAgICAgICAgfTtcbiAgICAgICAgdmFyIGZyb21DaGFubmVsU3RhdGVzID0gWydhdHRhY2hpbmcnLCAnYXR0YWNoZWQnLCAnZGV0YWNoaW5nJywgJ3N1c3BlbmRlZCddO1xuICAgICAgICB2YXIgdG9DaGFubmVsU3RhdGUgPSBjb25uZWN0aW9uU3RhdGVUb0NoYW5uZWxTdGF0ZVtjb25uZWN0aW9uU3RhdGVdO1xuICAgICAgICBmb3IgKHZhciBjaGFubmVsSWQgaW4gdGhpcy5hbGwpIHtcbiAgICAgICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5hbGxbY2hhbm5lbElkXTtcbiAgICAgICAgICAgIGlmIChVdGlscy5hcnJJbihmcm9tQ2hhbm5lbFN0YXRlcywgY2hhbm5lbC5zdGF0ZSkpIHtcbiAgICAgICAgICAgICAgICBjaGFubmVsLm5vdGlmeVN0YXRlKHRvQ2hhbm5lbFN0YXRlLCByZWFzb24pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBDaGFubmVscy5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKG5hbWUsIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgICAgIG5hbWUgPSBTdHJpbmcobmFtZSk7XG4gICAgICAgIHZhciBjaGFubmVsID0gdGhpcy5hbGxbbmFtZV07XG4gICAgICAgIGlmICghY2hhbm5lbCkge1xuICAgICAgICAgICAgY2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdID0gbmV3IHJlYWx0aW1lY2hhbm5lbF8xLmRlZmF1bHQodGhpcy5yZWFsdGltZSwgbmFtZSwgY2hhbm5lbE9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGNoYW5uZWxPcHRpb25zKSB7XG4gICAgICAgICAgICBpZiAoY2hhbm5lbC5fc2hvdWxkUmVhdHRhY2hUb1NldE9wdGlvbnMoY2hhbm5lbE9wdGlvbnMsIGNoYW5uZWwuY2hhbm5lbE9wdGlvbnMpKSB7XG4gICAgICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ0NoYW5uZWxzLmdldCgpIGNhbm5vdCBiZSB1c2VkIHRvIHNldCBjaGFubmVsIG9wdGlvbnMgdGhhdCB3b3VsZCBjYXVzZSB0aGUgY2hhbm5lbCB0byByZWF0dGFjaC4gUGxlYXNlLCB1c2UgUmVhbHRpbWVDaGFubmVsLnNldE9wdGlvbnMoKSBpbnN0ZWFkLicsIDQwMDAwLCA0MDApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2hhbm5lbC5zZXRPcHRpb25zKGNoYW5uZWxPcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gY2hhbm5lbDtcbiAgICB9O1xuICAgIENoYW5uZWxzLnByb3RvdHlwZS5nZXREZXJpdmVkID0gZnVuY3Rpb24gKG5hbWUsIGRlcml2ZU9wdGlvbnMsIGNoYW5uZWxPcHRpb25zKSB7XG4gICAgICAgIGlmIChkZXJpdmVPcHRpb25zLmZpbHRlcikge1xuICAgICAgICAgICAgdmFyIGZpbHRlciA9IFV0aWxzLnRvQmFzZTY0KGRlcml2ZU9wdGlvbnMuZmlsdGVyKTtcbiAgICAgICAgICAgIHZhciBtYXRjaCA9IFV0aWxzLm1hdGNoRGVyaXZlZENoYW5uZWwobmFtZSk7XG4gICAgICAgICAgICBuYW1lID0gXCJbZmlsdGVyPVwiLmNvbmNhdChmaWx0ZXIpLmNvbmNhdChtYXRjaC5xdWFsaWZpZXJQYXJhbSwgXCJdXCIpLmNvbmNhdChtYXRjaC5jaGFubmVsTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuZ2V0KG5hbWUsIGNoYW5uZWxPcHRpb25zKTtcbiAgICB9O1xuICAgIC8qIEluY2x1ZGVkIHRvIHN1cHBvcnQgY2VydGFpbiBuaWNoZSB1c2UtY2FzZXM7IG1vc3QgdXNlcnMgc2hvdWxkIGlnbm9yZSB0aGlzLlxuICAgICAqIFBsZWFzZSBkbyBub3QgdXNlIHRoaXMgdW5sZXNzIHlvdSBrbm93IHdoYXQgeW91J3JlIGRvaW5nICovXG4gICAgQ2hhbm5lbHMucHJvdG90eXBlLnJlbGVhc2UgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICBuYW1lID0gU3RyaW5nKG5hbWUpO1xuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuYWxsW25hbWVdO1xuICAgICAgICBpZiAoIWNoYW5uZWwpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB2YXIgcmVsZWFzZUVyciA9IGNoYW5uZWwuZ2V0UmVsZWFzZUVycigpO1xuICAgICAgICBpZiAocmVsZWFzZUVycikge1xuICAgICAgICAgICAgdGhyb3cgcmVsZWFzZUVycjtcbiAgICAgICAgfVxuICAgICAgICBkZWxldGUgdGhpcy5hbGxbbmFtZV07XG4gICAgfTtcbiAgICByZXR1cm4gQ2hhbm5lbHM7XG59KGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFJlYWx0aW1lO1xuXG5cbi8qKiovIH0pLFxuLyogNTEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGV2ZW50ZW1pdHRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg3KSk7XG52YXIgY29ubmVjdGlvbm1hbmFnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzUpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIGNvbm5lY3Rpb25zdGF0ZWNoYW5nZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzNykpO1xudmFyIHBsYXRmb3JtXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDMpKTtcbmZ1bmN0aW9uIG5vb3AoKSB7IH1cbnZhciBDb25uZWN0aW9uID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKENvbm5lY3Rpb24sIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gQ29ubmVjdGlvbihhYmx5LCBvcHRpb25zKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLndoZW5TdGF0ZSA9IChmdW5jdGlvbiAoc3RhdGUsIGxpc3RlbmVyKSB7XG4gICAgICAgICAgICByZXR1cm4gZXZlbnRlbWl0dGVyXzEuZGVmYXVsdC5wcm90b3R5cGUud2hlblN0YXRlLmNhbGwoX3RoaXMsIHN0YXRlLCBfdGhpcy5zdGF0ZSwgbGlzdGVuZXIsIG5ldyBjb25uZWN0aW9uc3RhdGVjaGFuZ2VfMS5kZWZhdWx0KHVuZGVmaW5lZCwgc3RhdGUpKTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLmFibHkgPSBhYmx5O1xuICAgICAgICBfdGhpcy5jb25uZWN0aW9uTWFuYWdlciA9IG5ldyBjb25uZWN0aW9ubWFuYWdlcl8xLmRlZmF1bHQoYWJseSwgb3B0aW9ucyk7XG4gICAgICAgIF90aGlzLnN0YXRlID0gX3RoaXMuY29ubmVjdGlvbk1hbmFnZXIuc3RhdGUuc3RhdGU7XG4gICAgICAgIF90aGlzLmtleSA9IHVuZGVmaW5lZDtcbiAgICAgICAgX3RoaXMuaWQgPSB1bmRlZmluZWQ7XG4gICAgICAgIF90aGlzLmVycm9yUmVhc29uID0gbnVsbDtcbiAgICAgICAgX3RoaXMuY29ubmVjdGlvbk1hbmFnZXIub24oJ2Nvbm5lY3Rpb25zdGF0ZScsIGZ1bmN0aW9uIChzdGF0ZUNoYW5nZSkge1xuICAgICAgICAgICAgdmFyIHN0YXRlID0gKF90aGlzLnN0YXRlID0gc3RhdGVDaGFuZ2UuY3VycmVudCk7XG4gICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICBfdGhpcy5lbWl0KHN0YXRlLCBzdGF0ZUNoYW5nZSk7XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgICAgIF90aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLm9uKCd1cGRhdGUnLCBmdW5jdGlvbiAoc3RhdGVDaGFuZ2UpIHtcbiAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIF90aGlzLmVtaXQoJ3VwZGF0ZScsIHN0YXRlQ2hhbmdlKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5jb25uZWN0ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ0Nvbm5lY3Rpb24uY29ubmVjdCgpJywgJycpO1xuICAgICAgICB0aGlzLmNvbm5lY3Rpb25NYW5hZ2VyLnJlcXVlc3RTdGF0ZSh7IHN0YXRlOiAnY29ubmVjdGluZycgfSk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5waW5nID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnQ29ubmVjdGlvbi5waW5nKCknLCAnJyk7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmFibHkub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3BpbmcnLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgY2FsbGJhY2sgPSBub29wO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucGluZyhudWxsLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBDb25uZWN0aW9uLnByb3RvdHlwZS5jbG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdDb25uZWN0aW9uLmNsb3NlKCknLCAnY29ubmVjdGlvbktleSA9ICcgKyB0aGlzLmtleSk7XG4gICAgICAgIHRoaXMuY29ubmVjdGlvbk1hbmFnZXIucmVxdWVzdFN0YXRlKHsgc3RhdGU6ICdjbG9zaW5nJyB9KTtcbiAgICB9O1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShDb25uZWN0aW9uLnByb3RvdHlwZSwgXCJyZWNvdmVyeUtleVwiLCB7XG4gICAgICAgIGdldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuY3JlYXRlUmVjb3ZlcnlLZXkoKTtcbiAgICAgICAgfSxcbiAgICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICAgIENvbm5lY3Rpb24ucHJvdG90eXBlLmNyZWF0ZVJlY292ZXJ5S2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uTWFuYWdlci5jcmVhdGVSZWNvdmVyeUtleSgpO1xuICAgIH07XG4gICAgcmV0dXJuIENvbm5lY3Rpb247XG59KGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IENvbm5lY3Rpb247XG5cblxuLyoqKi8gfSksXG4vKiA1MiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xuZXhwb3J0cy5QZW5kaW5nTWVzc2FnZSA9IHZvaWQgMDtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBwcm90b2NvbG1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTApKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIGV2ZW50ZW1pdHRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg3KSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBtZXNzYWdlcXVldWVfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMzYpKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIGFjdGlvbnMgPSBwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LkFjdGlvbjtcbnZhciBQZW5kaW5nTWVzc2FnZSA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcbiAgICBmdW5jdGlvbiBQZW5kaW5nTWVzc2FnZShtZXNzYWdlLCBjYWxsYmFjaykge1xuICAgICAgICB0aGlzLm1lc3NhZ2UgPSBtZXNzYWdlO1xuICAgICAgICB0aGlzLmNhbGxiYWNrID0gY2FsbGJhY2s7XG4gICAgICAgIHRoaXMubWVyZ2VkID0gZmFsc2U7XG4gICAgICAgIHZhciBhY3Rpb24gPSBtZXNzYWdlLmFjdGlvbjtcbiAgICAgICAgdGhpcy5zZW5kQXR0ZW1wdGVkID0gZmFsc2U7XG4gICAgICAgIHRoaXMuYWNrUmVxdWlyZWQgPSBhY3Rpb24gPT0gYWN0aW9ucy5NRVNTQUdFIHx8IGFjdGlvbiA9PSBhY3Rpb25zLlBSRVNFTkNFO1xuICAgIH1cbiAgICByZXR1cm4gUGVuZGluZ01lc3NhZ2U7XG59KCkpO1xuZXhwb3J0cy5QZW5kaW5nTWVzc2FnZSA9IFBlbmRpbmdNZXNzYWdlO1xudmFyIFByb3RvY29sID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFByb3RvY29sLCBfc3VwZXIpO1xuICAgIGZ1bmN0aW9uIFByb3RvY29sKHRyYW5zcG9ydCkge1xuICAgICAgICB2YXIgX3RoaXMgPSBfc3VwZXIuY2FsbCh0aGlzKSB8fCB0aGlzO1xuICAgICAgICBfdGhpcy50cmFuc3BvcnQgPSB0cmFuc3BvcnQ7XG4gICAgICAgIF90aGlzLm1lc3NhZ2VRdWV1ZSA9IG5ldyBtZXNzYWdlcXVldWVfMS5kZWZhdWx0KCk7XG4gICAgICAgIHRyYW5zcG9ydC5vbignYWNrJywgZnVuY3Rpb24gKHNlcmlhbCwgY291bnQpIHtcbiAgICAgICAgICAgIF90aGlzLm9uQWNrKHNlcmlhbCwgY291bnQpO1xuICAgICAgICB9KTtcbiAgICAgICAgdHJhbnNwb3J0Lm9uKCduYWNrJywgZnVuY3Rpb24gKHNlcmlhbCwgY291bnQsIGVycikge1xuICAgICAgICAgICAgX3RoaXMub25OYWNrKHNlcmlhbCwgY291bnQsIGVycik7XG4gICAgICAgIH0pO1xuICAgICAgICByZXR1cm4gX3RoaXM7XG4gICAgfVxuICAgIFByb3RvY29sLnByb3RvdHlwZS5vbkFjayA9IGZ1bmN0aW9uIChzZXJpYWwsIGNvdW50KSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUHJvdG9jb2wub25BY2soKScsICdzZXJpYWwgPSAnICsgc2VyaWFsICsgJzsgY291bnQgPSAnICsgY291bnQpO1xuICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKHNlcmlhbCwgY291bnQpO1xuICAgIH07XG4gICAgUHJvdG9jb2wucHJvdG90eXBlLm9uTmFjayA9IGZ1bmN0aW9uIChzZXJpYWwsIGNvdW50LCBlcnIpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdQcm90b2NvbC5vbk5hY2soKScsICdzZXJpYWwgPSAnICsgc2VyaWFsICsgJzsgY291bnQgPSAnICsgY291bnQgKyAnOyBlcnIgPSAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGVycikpO1xuICAgICAgICBpZiAoIWVycikge1xuICAgICAgICAgICAgZXJyID0gbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ1VuYWJsZSB0byBzZW5kIG1lc3NhZ2U7IGNoYW5uZWwgbm90IHJlc3BvbmRpbmcnLCA1MDAwMSwgNTAwKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLm1lc3NhZ2VRdWV1ZS5jb21wbGV0ZU1lc3NhZ2VzKHNlcmlhbCwgY291bnQsIGVycik7XG4gICAgfTtcbiAgICBQcm90b2NvbC5wcm90b3R5cGUub25jZUlkbGUgPSBmdW5jdGlvbiAobGlzdGVuZXIpIHtcbiAgICAgICAgdmFyIG1lc3NhZ2VRdWV1ZSA9IHRoaXMubWVzc2FnZVF1ZXVlO1xuICAgICAgICBpZiAobWVzc2FnZVF1ZXVlLmNvdW50KCkgPT09IDApIHtcbiAgICAgICAgICAgIGxpc3RlbmVyKCk7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgbWVzc2FnZVF1ZXVlLm9uY2UoJ2lkbGUnLCBsaXN0ZW5lcik7XG4gICAgfTtcbiAgICBQcm90b2NvbC5wcm90b3R5cGUuc2VuZCA9IGZ1bmN0aW9uIChwZW5kaW5nTWVzc2FnZSkge1xuICAgICAgICBpZiAocGVuZGluZ01lc3NhZ2UuYWNrUmVxdWlyZWQpIHtcbiAgICAgICAgICAgIHRoaXMubWVzc2FnZVF1ZXVlLnB1c2gocGVuZGluZ01lc3NhZ2UpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChsb2dnZXJfMS5kZWZhdWx0LnNob3VsZExvZyhsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTykpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUHJvdG9jb2wuc2VuZCgpJywgJ3NlbmRpbmcgbXNnOyAnICsgcHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5zdHJpbmdpZnkocGVuZGluZ01lc3NhZ2UubWVzc2FnZSkpO1xuICAgICAgICB9XG4gICAgICAgIHBlbmRpbmdNZXNzYWdlLnNlbmRBdHRlbXB0ZWQgPSB0cnVlO1xuICAgICAgICB0aGlzLnRyYW5zcG9ydC5zZW5kKHBlbmRpbmdNZXNzYWdlLm1lc3NhZ2UpO1xuICAgIH07XG4gICAgUHJvdG9jb2wucHJvdG90eXBlLmdldFRyYW5zcG9ydCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMudHJhbnNwb3J0O1xuICAgIH07XG4gICAgUHJvdG9jb2wucHJvdG90eXBlLmdldFBlbmRpbmdNZXNzYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZVF1ZXVlLmNvcHlBbGwoKTtcbiAgICB9O1xuICAgIFByb3RvY29sLnByb3RvdHlwZS5jbGVhclBlbmRpbmdNZXNzYWdlcyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMubWVzc2FnZVF1ZXVlLmNsZWFyKCk7XG4gICAgfTtcbiAgICBQcm90b2NvbC5wcm90b3R5cGUuZmluaXNoID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgdHJhbnNwb3J0ID0gdGhpcy50cmFuc3BvcnQ7XG4gICAgICAgIHRoaXMub25jZUlkbGUoZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgdHJhbnNwb3J0LmRpc2Nvbm5lY3QoKTtcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICByZXR1cm4gUHJvdG9jb2w7XG59KGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQpKTtcbmV4cG9ydHMuZGVmYXVsdCA9IFByb3RvY29sO1xuXG5cbi8qKiovIH0pLFxuLyogNTMgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciB0c2xpYl8xID0gX193ZWJwYWNrX3JlcXVpcmVfXygwKTtcbnZhciBwbGF0Zm9ybV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzKSk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciB0cmFuc3BvcnRfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjYpKTtcbnZhciBkZWZhdWx0c18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg4KSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBwcm90b2NvbG1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTApKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIHNob3J0TmFtZSA9ICd3ZWJfc29ja2V0JztcbmZ1bmN0aW9uIGlzTm9kZVdlYlNvY2tldCh3cykge1xuICAgIHJldHVybiAhIXdzLm9uO1xufVxudmFyIFdlYlNvY2tldFRyYW5zcG9ydCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhXZWJTb2NrZXRUcmFuc3BvcnQsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gV2ViU29ja2V0VHJhbnNwb3J0KGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpIHtcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcykgfHwgdGhpcztcbiAgICAgICAgX3RoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lO1xuICAgICAgICAvKiBJZiBpcyBhIGJyb3dzZXIsIGNhbid0IGRldGVjdCBwaW5ncywgc28gcmVxdWVzdCBwcm90b2NvbCBoZWFydGJlYXRzICovXG4gICAgICAgIHBhcmFtcy5oZWFydGJlYXRzID0gcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy51c2VQcm90b2NvbEhlYXJ0YmVhdHM7XG4gICAgICAgIF90aGlzLndzSG9zdCA9IGRlZmF1bHRzXzEuZGVmYXVsdC5nZXRIb3N0KHBhcmFtcy5vcHRpb25zLCBwYXJhbXMuaG9zdCwgdHJ1ZSk7XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgV2ViU29ja2V0VHJhbnNwb3J0LmlzQXZhaWxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICByZXR1cm4gISFwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLldlYlNvY2tldDtcbiAgICB9O1xuICAgIFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuY3JlYXRlV2ViU29ja2V0ID0gZnVuY3Rpb24gKHVyaSwgY29ubmVjdFBhcmFtcykge1xuICAgICAgICB0aGlzLnVyaSA9IHVyaSArIFV0aWxzLnRvUXVlcnlTdHJpbmcoY29ubmVjdFBhcmFtcyk7XG4gICAgICAgIHJldHVybiBuZXcgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5XZWJTb2NrZXQodGhpcy51cmkpO1xuICAgIH07XG4gICAgV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuICdXZWJTb2NrZXRUcmFuc3BvcnQ7IHVyaT0nICsgdGhpcy51cmk7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLmNvbm5lY3QgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdzdGFydGluZycpO1xuICAgICAgICB0cmFuc3BvcnRfMS5kZWZhdWx0LnByb3RvdHlwZS5jb25uZWN0LmNhbGwodGhpcyk7XG4gICAgICAgIHZhciBzZWxmID0gdGhpcywgcGFyYW1zID0gdGhpcy5wYXJhbXMsIG9wdGlvbnMgPSBwYXJhbXMub3B0aW9ucztcbiAgICAgICAgdmFyIHdzU2NoZW1lID0gb3B0aW9ucy50bHMgPyAnd3NzOi8vJyA6ICd3czovLyc7XG4gICAgICAgIHZhciB3c1VyaSA9IHdzU2NoZW1lICsgdGhpcy53c0hvc3QgKyAnOicgKyBkZWZhdWx0c18xLmRlZmF1bHQuZ2V0UG9ydChvcHRpb25zKSArICcvJztcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpJywgJ3VyaTogJyArIHdzVXJpKTtcbiAgICAgICAgdGhpcy5hdXRoLmdldEF1dGhQYXJhbXMoZnVuY3Rpb24gKGVyciwgYXV0aFBhcmFtcykge1xuICAgICAgICAgICAgaWYgKHNlbGYuaXNEaXNwb3NlZCkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBwYXJhbVN0ciA9ICcnO1xuICAgICAgICAgICAgZm9yICh2YXIgcGFyYW0gaW4gYXV0aFBhcmFtcylcbiAgICAgICAgICAgICAgICBwYXJhbVN0ciArPSAnICcgKyBwYXJhbSArICc6ICcgKyBhdXRoUGFyYW1zW3BhcmFtXSArICc7JztcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0LmNvbm5lY3QoKScsICdhdXRoUGFyYW1zOicgKyBwYXJhbVN0ciArICcgZXJyOiAnICsgZXJyKTtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBzZWxmLmRpc2Nvbm5lY3QoZXJyKTtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB2YXIgY29ubmVjdFBhcmFtcyA9IHBhcmFtcy5nZXRDb25uZWN0UGFyYW1zKGF1dGhQYXJhbXMpO1xuICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICB2YXIgd3NDb25uZWN0aW9uID0gKHNlbGYud3NDb25uZWN0aW9uID0gc2VsZi5jcmVhdGVXZWJTb2NrZXQod3NVcmksIGNvbm5lY3RQYXJhbXMpKTtcbiAgICAgICAgICAgICAgICB3c0Nvbm5lY3Rpb24uYmluYXJ5VHlwZSA9IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuYmluYXJ5VHlwZTtcbiAgICAgICAgICAgICAgICB3c0Nvbm5lY3Rpb24ub25vcGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9uV3NPcGVuKCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3c0Nvbm5lY3Rpb24ub25jbG9zZSA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9uV3NDbG9zZShldik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3c0Nvbm5lY3Rpb24ub25tZXNzYWdlID0gZnVuY3Rpb24gKGV2KSB7XG4gICAgICAgICAgICAgICAgICAgIHNlbGYub25Xc0RhdGEoZXYuZGF0YSk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3c0Nvbm5lY3Rpb24ub25lcnJvciA9IGZ1bmN0aW9uIChldikge1xuICAgICAgICAgICAgICAgICAgICBzZWxmLm9uV3NFcnJvcihldik7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICBpZiAoaXNOb2RlV2ViU29ja2V0KHdzQ29ubmVjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgLyogbm9kZTsgYnJvd3NlcnMgY3VycmVudGx5IGRvbid0IGhhdmUgYSBnZW5lcmFsIGV2ZW50ZW1pdHRlciBhbmQgY2FuJ3QgZGV0ZWN0XG4gICAgICAgICAgICAgICAgICAgICAqIHBpbmdzLiBBbHNvLCBubyBuZWVkIHRvIHJlcGx5IHdpdGggYSBwb25nIGV4cGxpY2l0bHksIHdzIGxpYiBoYW5kbGVzIHRoYXQgKi9cbiAgICAgICAgICAgICAgICAgICAgd3NDb25uZWN0aW9uLm9uKCdwaW5nJywgZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgc2VsZi5vbkFjdGl2aXR5KCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuY29ubmVjdCgpJywgJ1VuZXhwZWN0ZWQgZXhjZXB0aW9uIGNyZWF0aW5nIHdlYnNvY2tldDogZXJyID0gJyArIChlLnN0YWNrIHx8IGUubWVzc2FnZSkpO1xuICAgICAgICAgICAgICAgIHNlbGYuZGlzY29ubmVjdChlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLnNlbmQgPSBmdW5jdGlvbiAobWVzc2FnZSkge1xuICAgICAgICB2YXIgd3NDb25uZWN0aW9uID0gdGhpcy53c0Nvbm5lY3Rpb247XG4gICAgICAgIGlmICghd3NDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19FUlJPUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5zZW5kKCknLCAnTm8gc29ja2V0IGNvbm5lY3Rpb24nKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgd3NDb25uZWN0aW9uLnNlbmQocHJvdG9jb2xtZXNzYWdlXzEuZGVmYXVsdC5zZXJpYWxpemUobWVzc2FnZSwgdGhpcy5wYXJhbXMuZm9ybWF0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHZhciBtc2cgPSAnRXhjZXB0aW9uIGZyb20gd3MgY29ubmVjdGlvbiB3aGVuIHRyeWluZyB0byBzZW5kOiAnICsgVXRpbHMuaW5zcGVjdEVycm9yKGUpO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuc2VuZCgpJywgbXNnKTtcbiAgICAgICAgICAgIC8qIERvbid0IHRyeSB0byByZXF1ZXN0IGEgZGlzY29ubmVjdCwgdGhhdCdsbCBqdXN0IGludm9sdmUgc2VuZGluZyBkYXRhXG4gICAgICAgICAgICAgKiBkb3duIHRoZSB3ZWJzb2NrZXQgYWdhaW4uIEp1c3QgZmluaXNoIHRoZSB0cmFuc3BvcnQuICovXG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQobXNnLCA1MDAwMCwgNTAwKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUub25Xc0RhdGEgPSBmdW5jdGlvbiAoZGF0YSkge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1dlYlNvY2tldFRyYW5zcG9ydC5vbldzRGF0YSgpJywgJ2RhdGEgcmVjZWl2ZWQ7IGxlbmd0aCA9ICcgKyBkYXRhLmxlbmd0aCArICc7IHR5cGUgPSAnICsgdHlwZW9mIGRhdGEpO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgdGhpcy5vblByb3RvY29sTWVzc2FnZShwcm90b2NvbG1lc3NhZ2VfMS5kZWZhdWx0LmRlc2VyaWFsaXplKGRhdGEsIHRoaXMuZm9ybWF0KSk7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX0VSUk9SLCAnV2ViU29ja2V0VHJhbnNwb3J0Lm9uV3NEYXRhKCknLCAnVW5leHBlY3RlZCBleGNlcHRpb24gaGFuZGluZyBjaGFubmVsIG1lc3NhZ2U6ICcgKyBlLnN0YWNrKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5vbldzT3BlbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25Xc09wZW4oKScsICdvcGVuZWQgV2ViU29ja2V0Jyk7XG4gICAgICAgIHRoaXMuZW1pdCgncHJlY29ubmVjdCcpO1xuICAgIH07XG4gICAgV2ViU29ja2V0VHJhbnNwb3J0LnByb3RvdHlwZS5vbldzQ2xvc2UgPSBmdW5jdGlvbiAoZXYpIHtcbiAgICAgICAgdmFyIHdhc0NsZWFuLCBjb2RlO1xuICAgICAgICBpZiAodHlwZW9mIGV2ID09ICdvYmplY3QnKSB7XG4gICAgICAgICAgICAvKiBXM0Mgc3BlYy1jb21wYXRpYmxlICovXG4gICAgICAgICAgICBjb2RlID0gZXYuY29kZTtcbiAgICAgICAgICAgIC8vIGV2Lndhc0NsZWFuIGlzIHVuZGVmaW5lZCBpbiByZWFjdG5hdGl2ZVxuICAgICAgICAgICAgd2FzQ2xlYW4gPSBldi53YXNDbGVhbiB8fCBjb2RlID09PSAxMDAwO1xuICAgICAgICB9IC8qaWYodHlwZW9mKGV2KSA9PSAnbnVtYmVyJykqL1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIC8qIHdzIGluIG5vZGUgKi9cbiAgICAgICAgICAgIGNvZGUgPSBldjtcbiAgICAgICAgICAgIHdhc0NsZWFuID0gY29kZSA9PSAxMDAwO1xuICAgICAgICB9XG4gICAgICAgIGRlbGV0ZSB0aGlzLndzQ29ubmVjdGlvbjtcbiAgICAgICAgaWYgKHdhc0NsZWFuKSB7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5vbldzQ2xvc2UoKScsICdDbGVhbmx5IGNsb3NlZCBXZWJTb2NrZXQnKTtcbiAgICAgICAgICAgIHZhciBlcnIgPSBuZXcgZXJyb3JpbmZvXzEuZGVmYXVsdCgnV2Vic29ja2V0IGNsb3NlZCcsIDgwMDAzLCA0MDApO1xuICAgICAgICAgICAgdGhpcy5maW5pc2goJ2Rpc2Nvbm5lY3RlZCcsIGVycik7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB2YXIgbXNnID0gJ1VuY2xlYW4gZGlzY29ubmVjdGlvbiBvZiBXZWJTb2NrZXQgOyBjb2RlID0gJyArIGNvZGUsIGVyciA9IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgODAwMDMsIDQwMCk7XG4gICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1dlYlNvY2tldFRyYW5zcG9ydC5vbldzQ2xvc2UoKScsIG1zZyk7XG4gICAgICAgICAgICB0aGlzLmZpbmlzaCgnZGlzY29ubmVjdGVkJywgZXJyKTtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLmVtaXQoJ2Rpc3Bvc2VkJyk7XG4gICAgfTtcbiAgICBXZWJTb2NrZXRUcmFuc3BvcnQucHJvdG90eXBlLm9uV3NFcnJvciA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQub25FcnJvcigpJywgJ0Vycm9yIGZyb20gV2ViU29ja2V0OiAnICsgZXJyLm1lc3NhZ2UpO1xuICAgICAgICAvKiBXYWl0IGEgdGljayBiZWZvcmUgYWJvcnRpbmc6IGlmIHRoZSB3ZWJzb2NrZXQgd2FzIGNvbm5lY3RlZCwgdGhpcyBldmVudFxuICAgICAgICAgKiB3aWxsIGJlIGltbWVkaWF0ZWx5IGZvbGxvd2VkIGJ5IGFuIG9uY2xvc2UgZXZlbnQgd2l0aCBhIGNsb3NlIGNvZGUuIEFsbG93XG4gICAgICAgICAqIHRoYXQgdG8gY2xvc2UgaXQgKHNvIHdlIHNlZSB0aGUgY2xvc2UgY29kZSkgcmF0aGVyIHRoYW4gYW50aWNpcGF0aW5nIGl0ICovXG4gICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgX3RoaXMuZGlzY29ubmVjdChFcnJvcihlcnIubWVzc2FnZSkpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFdlYlNvY2tldFRyYW5zcG9ydC5wcm90b3R5cGUuZGlzcG9zZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdXZWJTb2NrZXRUcmFuc3BvcnQuZGlzcG9zZSgpJywgJycpO1xuICAgICAgICB0aGlzLmlzRGlzcG9zZWQgPSB0cnVlO1xuICAgICAgICB2YXIgd3NDb25uZWN0aW9uID0gdGhpcy53c0Nvbm5lY3Rpb247XG4gICAgICAgIGlmICh3c0Nvbm5lY3Rpb24pIHtcbiAgICAgICAgICAgIC8qIElnbm9yZSBhbnkgbWVzc2FnZXMgdGhhdCBjb21lIHRocm91Z2ggYWZ0ZXIgZGlzcG9zZSgpIGlzIGNhbGxlZCBidXQgYmVmb3JlXG4gICAgICAgICAgICAgKiB3ZWJzb2NrZXQgaXMgYWN0dWFsbHkgY2xvc2VkLiAobW9zdGx5IHdvdWxkIGJlIGhhcm1sZXNzLCBidXQgaWYgaXQncyBhXG4gICAgICAgICAgICAgKiBDT05ORUNURUQsIGl0J2xsIHJlLXRpY2sgaXNDb25uZWN0ZWQgYW5kIGNhdXNlIGFsbCBzb3J0cyBvZiBoYXZvYykgKi9cbiAgICAgICAgICAgIHdzQ29ubmVjdGlvbi5vbm1lc3NhZ2UgPSBmdW5jdGlvbiAoKSB7IH07XG4gICAgICAgICAgICBkZWxldGUgdGhpcy53c0Nvbm5lY3Rpb247XG4gICAgICAgICAgICAvKiBkZWZlciB1bnRpbCB0aGUgbmV4dCBldmVudCBsb29wIGN5Y2xlIGJlZm9yZSBjbG9zaW5nIHRoZSBzb2NrZXQsXG4gICAgICAgICAgICAgKiBnaXZpbmcgc29tZSBpbXBsZW1lbnRhdGlvbnMgdGhlIG9wcG9ydHVuaXR5IHRvIHNlbmQgYW55IG91dHN0YW5kaW5nIGNsb3NlIG1lc3NhZ2UgKi9cbiAgICAgICAgICAgIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcubmV4dFRpY2soZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnV2ViU29ja2V0VHJhbnNwb3J0LmRpc3Bvc2UoKScsICdjbG9zaW5nIHdlYnNvY2tldCcpO1xuICAgICAgICAgICAgICAgIGlmICghd3NDb25uZWN0aW9uKSB7XG4gICAgICAgICAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignV2ViU29ja2V0VHJhbnNwb3J0LmRpc3Bvc2UoKTogd3NDb25uZWN0aW9uIGlzIG5vdCBkZWZpbmVkJyk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIHdzQ29ubmVjdGlvbi5jbG9zZSgpO1xuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIHJldHVybiBXZWJTb2NrZXRUcmFuc3BvcnQ7XG59KHRyYW5zcG9ydF8xLmRlZmF1bHQpKTtcbmZ1bmN0aW9uIGluaXRpYWxpc2VUcmFuc3BvcnQoY29ubmVjdGlvbk1hbmFnZXIpIHtcbiAgICBpZiAoV2ViU29ja2V0VHJhbnNwb3J0LmlzQXZhaWxhYmxlKCkpXG4gICAgICAgIGNvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHNbc2hvcnROYW1lXSA9IFdlYlNvY2tldFRyYW5zcG9ydDtcbiAgICByZXR1cm4gV2ViU29ja2V0VHJhbnNwb3J0O1xufVxuZXhwb3J0cy5kZWZhdWx0ID0gaW5pdGlhbGlzZVRyYW5zcG9ydDtcblxuXG4vKioqLyB9KSxcbi8qIDU0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciBwcmVzZW5jZV8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzNCkpO1xudmFyIGV2ZW50ZW1pdHRlcl8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg3KSk7XG52YXIgbG9nZ2VyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIpKTtcbnZhciBwcmVzZW5jZW1lc3NhZ2VfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTUpKTtcbnZhciBlcnJvcmluZm9fMSA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oNCkpO1xudmFyIHJlYWx0aW1lY2hhbm5lbF8xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygzOCkpO1xudmFyIG11bHRpY2FzdGVyXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDIzKSk7XG52YXIgY2hhbm5lbHN0YXRlY2hhbmdlXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDM5KSk7XG52YXIgbm9vcCA9IGZ1bmN0aW9uICgpIHsgfTtcbmZ1bmN0aW9uIGdldENsaWVudElkKHJlYWx0aW1lUHJlc2VuY2UpIHtcbiAgICByZXR1cm4gcmVhbHRpbWVQcmVzZW5jZS5jaGFubmVsLnJlYWx0aW1lLmF1dGguY2xpZW50SWQ7XG59XG5mdW5jdGlvbiBpc0Fub255bW91c09yV2lsZGNhcmQocmVhbHRpbWVQcmVzZW5jZSkge1xuICAgIHZhciByZWFsdGltZSA9IHJlYWx0aW1lUHJlc2VuY2UuY2hhbm5lbC5yZWFsdGltZTtcbiAgICAvKiBJZiBub3QgY3VycmVudGx5IGNvbm5lY3RlZCwgd2UgY2FuJ3QgYXNzdW1lIHRoYXQgd2UncmUgYW4gYW5vbnltb3VzXG4gICAgICogY2xpZW50LCBhcyByZWFsdGltZSBtYXkgaW5mb3JtIHVzIG9mIG91ciBjbGllbnRJZCBpbiB0aGUgQ09OTkVDVEVEXG4gICAgICogbWVzc2FnZS4gU28gYXNzdW1lIHdlJ3JlIG5vdCBhbm9ueW1vdXMgYW5kIGxlYXZlIGl0IHRvIHJlYWx0aW1lIHRvXG4gICAgICogcmV0dXJuIGFuIGVycm9yIGlmIHdlIGFyZSAqL1xuICAgIHZhciBjbGllbnRJZCA9IHJlYWx0aW1lLmF1dGguY2xpZW50SWQ7XG4gICAgcmV0dXJuICghY2xpZW50SWQgfHwgY2xpZW50SWQgPT09ICcqJykgJiYgcmVhbHRpbWUuY29ubmVjdGlvbi5zdGF0ZSA9PT0gJ2Nvbm5lY3RlZCc7XG59XG4vKiBDYWxsYmFjayBpcyBjYWxsZWQgb25seSBpbiB0aGUgZXZlbnQgb2YgYW4gZXJyb3IgKi9cbmZ1bmN0aW9uIHdhaXRBdHRhY2hlZChjaGFubmVsLCBjYWxsYmFjaywgYWN0aW9uKSB7XG4gICAgc3dpdGNoIChjaGFubmVsLnN0YXRlKSB7XG4gICAgICAgIGNhc2UgJ2F0dGFjaGVkJzpcbiAgICAgICAgY2FzZSAnc3VzcGVuZGVkJzpcbiAgICAgICAgICAgIGFjdGlvbigpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ2luaXRpYWxpemVkJzpcbiAgICAgICAgY2FzZSAnZGV0YWNoZWQnOlxuICAgICAgICBjYXNlICdkZXRhY2hpbmcnOlxuICAgICAgICBjYXNlICdhdHRhY2hpbmcnOlxuICAgICAgICAgICAgY2hhbm5lbC5hdHRhY2goZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgICAgIGlmIChlcnIpXG4gICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVycik7XG4gICAgICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICAgICAgICBhY3Rpb24oKTtcbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICBjYWxsYmFjayhlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMoY2hhbm5lbC5pbnZhbGlkU3RhdGVFcnJvcigpKSk7XG4gICAgfVxufVxuZnVuY3Rpb24gbmV3ZXJUaGFuKGl0ZW0sIGV4aXN0aW5nKSB7XG4gICAgLyogUlRQMmIxOiBpZiBlaXRoZXIgaXMgc3ludGhlc2lzZWQsIGNvbXBhcmUgYnkgdGltZXN0YW1wICovXG4gICAgaWYgKGl0ZW0uaXNTeW50aGVzaXplZCgpIHx8IGV4aXN0aW5nLmlzU3ludGhlc2l6ZWQoKSkge1xuICAgICAgICAvLyBSVFAyYjFhOiBpZiBlcXVhbCwgcHJlZmVyIHRoZSBuZXdseS1hcnJpdmVkIG9uZVxuICAgICAgICByZXR1cm4gaXRlbS50aW1lc3RhbXAgPj0gZXhpc3RpbmcudGltZXN0YW1wO1xuICAgIH1cbiAgICAvKiBSVFAyYjIgKi9cbiAgICB2YXIgaXRlbU9yZGVyaW5ncyA9IGl0ZW0ucGFyc2VJZCgpLCBleGlzdGluZ09yZGVyaW5ncyA9IGV4aXN0aW5nLnBhcnNlSWQoKTtcbiAgICBpZiAoaXRlbU9yZGVyaW5ncy5tc2dTZXJpYWwgPT09IGV4aXN0aW5nT3JkZXJpbmdzLm1zZ1NlcmlhbCkge1xuICAgICAgICByZXR1cm4gaXRlbU9yZGVyaW5ncy5pbmRleCA+IGV4aXN0aW5nT3JkZXJpbmdzLmluZGV4O1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGl0ZW1PcmRlcmluZ3MubXNnU2VyaWFsID4gZXhpc3RpbmdPcmRlcmluZ3MubXNnU2VyaWFsO1xuICAgIH1cbn1cbnZhciBSZWFsdGltZVByZXNlbmNlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xuICAgIHRzbGliXzEuX19leHRlbmRzKFJlYWx0aW1lUHJlc2VuY2UsIF9zdXBlcik7XG4gICAgZnVuY3Rpb24gUmVhbHRpbWVQcmVzZW5jZShjaGFubmVsKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNoYW5uZWwpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLmNoYW5uZWwgPSBjaGFubmVsO1xuICAgICAgICBfdGhpcy5zeW5jQ29tcGxldGUgPSBmYWxzZTtcbiAgICAgICAgX3RoaXMubWVtYmVycyA9IG5ldyBQcmVzZW5jZU1hcChfdGhpcywgZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uY2xpZW50SWQgKyAnOicgKyBpdGVtLmNvbm5lY3Rpb25JZDsgfSk7XG4gICAgICAgIC8vIFJUUDE3aDogU3RvcmUgb3duIG1lbWJlcnMgYnkgY2xpZW50SWQgb25seS5cbiAgICAgICAgX3RoaXMuX215TWVtYmVycyA9IG5ldyBQcmVzZW5jZU1hcChfdGhpcywgZnVuY3Rpb24gKGl0ZW0pIHsgcmV0dXJuIGl0ZW0uY2xpZW50SWQ7IH0pO1xuICAgICAgICBfdGhpcy5zdWJzY3JpcHRpb25zID0gbmV3IGV2ZW50ZW1pdHRlcl8xLmRlZmF1bHQoKTtcbiAgICAgICAgX3RoaXMucGVuZGluZ1ByZXNlbmNlID0gW107XG4gICAgICAgIHJldHVybiBfdGhpcztcbiAgICB9XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuZW50ZXIgPSBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGlzQW5vbnltb3VzT3JXaWxkY2FyZCh0aGlzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ2NsaWVudElkIG11c3QgYmUgc3BlY2lmaWVkIHRvIGVudGVyIGEgcHJlc2VuY2UgY2hhbm5lbCcsIDQwMDEyLCA0MDApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkYXRhLCAnZW50ZXInLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS51cGRhdGUgPSBmdW5jdGlvbiAoZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKGlzQW5vbnltb3VzT3JXaWxkY2FyZCh0aGlzKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IGVycm9yaW5mb18xLmRlZmF1bHQoJ2NsaWVudElkIG11c3QgYmUgc3BlY2lmaWVkIHRvIHVwZGF0ZSBwcmVzZW5jZSBkYXRhJywgNDAwMTIsIDQwMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQodW5kZWZpbmVkLCB1bmRlZmluZWQsIGRhdGEsICd1cGRhdGUnLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5lbnRlckNsaWVudCA9IGZ1bmN0aW9uIChjbGllbnRJZCwgZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX2VudGVyT3JVcGRhdGVDbGllbnQodW5kZWZpbmVkLCBjbGllbnRJZCwgZGF0YSwgJ2VudGVyJywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUudXBkYXRlQ2xpZW50ID0gZnVuY3Rpb24gKGNsaWVudElkLCBkYXRhLCBjYWxsYmFjaykge1xuICAgICAgICByZXR1cm4gdGhpcy5fZW50ZXJPclVwZGF0ZUNsaWVudCh1bmRlZmluZWQsIGNsaWVudElkLCBkYXRhLCAndXBkYXRlJywgY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuX2VudGVyT3JVcGRhdGVDbGllbnQgPSBmdW5jdGlvbiAoaWQsIGNsaWVudElkLCBkYXRhLCBhY3Rpb24sIGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBfdGhpcyA9IHRoaXM7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgZGF0YSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gZGF0YTtcbiAgICAgICAgICAgICAgICBkYXRhID0gbnVsbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWwucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gVXRpbHMucHJvbWlzaWZ5KHRoaXMsICdfZW50ZXJPclVwZGF0ZUNsaWVudCcsIFtpZCwgY2xpZW50SWQsIGRhdGEsIGFjdGlvbl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG4gICAgICAgIGlmICghY2hhbm5lbC5jb25uZWN0aW9uTWFuYWdlci5hY3RpdmVTdGF0ZSgpKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS4nICsgYWN0aW9uICsgJ0NsaWVudCgpJywgJ2NoYW5uZWwgPSAnICsgY2hhbm5lbC5uYW1lICsgJywgaWQgPSAnICsgaWQgKyAnLCBjbGllbnQgPSAnICsgKGNsaWVudElkIHx8ICcoaW1wbGljaXQpICcgKyBnZXRDbGllbnRJZCh0aGlzKSkpO1xuICAgICAgICB2YXIgcHJlc2VuY2UgPSBwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0LmZyb21EYXRhKGRhdGEpO1xuICAgICAgICBwcmVzZW5jZS5hY3Rpb24gPSBhY3Rpb247XG4gICAgICAgIGlmIChpZCkge1xuICAgICAgICAgICAgcHJlc2VuY2UuaWQgPSBpZDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2xpZW50SWQpIHtcbiAgICAgICAgICAgIHByZXNlbmNlLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgIH1cbiAgICAgICAgcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdC5lbmNvZGUocHJlc2VuY2UsIGNoYW5uZWwuY2hhbm5lbE9wdGlvbnMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgIGlmIChlcnIpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHN3aXRjaCAoY2hhbm5lbC5zdGF0ZSkge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2F0dGFjaGVkJzpcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5zZW5kUHJlc2VuY2UocHJlc2VuY2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgY2FzZSAnaW5pdGlhbGl6ZWQnOlxuICAgICAgICAgICAgICAgIGNhc2UgJ2RldGFjaGVkJzpcbiAgICAgICAgICAgICAgICAgICAgY2hhbm5lbC5hdHRhY2goKTtcbiAgICAgICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tZmFsbHRocm91Z2hcbiAgICAgICAgICAgICAgICBjYXNlICdhdHRhY2hpbmcnOlxuICAgICAgICAgICAgICAgICAgICBfdGhpcy5wZW5kaW5nUHJlc2VuY2UucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgICAgICBwcmVzZW5jZTogcHJlc2VuY2UsXG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjazogY2FsbGJhY2ssXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICBkZWZhdWx0OlxuICAgICAgICAgICAgICAgICAgICBlcnIgPSBuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygnVW5hYmxlIHRvICcgKyBhY3Rpb24gKyAnIHByZXNlbmNlIGNoYW5uZWwgd2hpbGUgaW4gJyArIGNoYW5uZWwuc3RhdGUgKyAnIHN0YXRlJywgOTAwMDEpO1xuICAgICAgICAgICAgICAgICAgICBlcnIuY29kZSA9IDkwMDAxO1xuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmxlYXZlID0gZnVuY3Rpb24gKGRhdGEsIGNhbGxiYWNrKSB7XG4gICAgICAgIGlmIChpc0Fub255bW91c09yV2lsZGNhcmQodGhpcykpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdjbGllbnRJZCBtdXN0IGhhdmUgYmVlbiBzcGVjaWZpZWQgdG8gZW50ZXIgb3IgbGVhdmUgYSBwcmVzZW5jZSBjaGFubmVsJywgNDAwMTIsIDQwMCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMubGVhdmVDbGllbnQodW5kZWZpbmVkLCBkYXRhLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5sZWF2ZUNsaWVudCA9IGZ1bmN0aW9uIChjbGllbnRJZCwgZGF0YSwgY2FsbGJhY2spIHtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHR5cGVvZiBkYXRhID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPSBkYXRhO1xuICAgICAgICAgICAgICAgIGRhdGEgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbC5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2xlYXZlQ2xpZW50JywgW2NsaWVudElkLCBkYXRhXSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICB2YXIgY2hhbm5lbCA9IHRoaXMuY2hhbm5lbDtcbiAgICAgICAgaWYgKCFjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmFjdGl2ZVN0YXRlKCkpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhjaGFubmVsLmNvbm5lY3Rpb25NYW5hZ2VyLmdldEVycm9yKCkpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS5sZWF2ZUNsaWVudCgpJywgJ2xlYXZpbmc7IGNoYW5uZWwgPSAnICsgdGhpcy5jaGFubmVsLm5hbWUgKyAnLCBjbGllbnQgPSAnICsgY2xpZW50SWQpO1xuICAgICAgICB2YXIgcHJlc2VuY2UgPSBwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0LmZyb21EYXRhKGRhdGEpO1xuICAgICAgICBwcmVzZW5jZS5hY3Rpb24gPSAnbGVhdmUnO1xuICAgICAgICBpZiAoY2xpZW50SWQpIHtcbiAgICAgICAgICAgIHByZXNlbmNlLmNsaWVudElkID0gY2xpZW50SWQ7XG4gICAgICAgIH1cbiAgICAgICAgc3dpdGNoIChjaGFubmVsLnN0YXRlKSB7XG4gICAgICAgICAgICBjYXNlICdhdHRhY2hlZCc6XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5zZW5kUHJlc2VuY2UocHJlc2VuY2UsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIGNhc2UgJ2F0dGFjaGluZyc6XG4gICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUHJlc2VuY2UucHVzaCh7XG4gICAgICAgICAgICAgICAgICAgIHByZXNlbmNlOiBwcmVzZW5jZSxcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnaW5pdGlhbGl6ZWQnOlxuICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzoge1xuICAgICAgICAgICAgICAgIC8qIHdlJ3JlIG5vdCBhdHRhY2hlZDsgdGhlcmVmb3JlIHdlIGxldCBhbnkgZW50ZXJlZCBzdGF0dXNcbiAgICAgICAgICAgICAgICAgKiB0aW1lb3V0IGJ5IGl0c2VsZiBpbnN0ZWFkIG9mIGF0dGFjaGluZyBqdXN0IGluIG9yZGVyIHRvIGxlYXZlICovXG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IG5ldyBlcnJvcmluZm9fMS5QYXJ0aWFsRXJyb3JJbmZvKCdVbmFibGUgdG8gbGVhdmUgcHJlc2VuY2UgY2hhbm5lbCAoaW5jb21wYXRpYmxlIHN0YXRlKScsIDkwMDAxKTtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sgPT09IG51bGwgfHwgY2FsbGJhY2sgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGNhbGxiYWNrKGNoYW5uZWwuaW52YWxpZFN0YXRlRXJyb3IoKSk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIC8vIFJldHVybiB0eXBlIGlzIGFueSB0byBhdm9pZCBjb25mbGljdCB3aXRoIGJhc2UgUHJlc2VuY2UgY2xhc3NcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAocGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICB2YXIgYXJncyA9IEFycmF5LnByb3RvdHlwZS5zbGljZS5jYWxsKGFyZ3VtZW50cyk7XG4gICAgICAgIGlmIChhcmdzLmxlbmd0aCA9PSAxICYmIHR5cGVvZiBhcmdzWzBdID09ICdmdW5jdGlvbicpXG4gICAgICAgICAgICBhcmdzLnVuc2hpZnQobnVsbCk7XG4gICAgICAgIHBhcmFtcyA9IGFyZ3NbMF07XG4gICAgICAgIGNhbGxiYWNrID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIHdhaXRGb3JTeW5jID0gIXBhcmFtcyB8fCAoJ3dhaXRGb3JTeW5jJyBpbiBwYXJhbXMgPyBwYXJhbXMud2FpdEZvclN5bmMgOiB0cnVlKTtcbiAgICAgICAgaWYgKCFjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbC5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIFV0aWxzLnByb21pc2lmeSh0aGlzLCAnZ2V0JywgYXJncyk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgIH1cbiAgICAgICAgZnVuY3Rpb24gcmV0dXJuTWVtYmVycyhtZW1iZXJzKSB7XG4gICAgICAgICAgICBjYWxsYmFjayhudWxsLCBwYXJhbXMgPyBtZW1iZXJzLmxpc3QocGFyYW1zKSA6IG1lbWJlcnMudmFsdWVzKCkpO1xuICAgICAgICB9XG4gICAgICAgIC8qIFNwZWNpYWwtY2FzZSB0aGUgc3VzcGVuZGVkIHN0YXRlOiBjYW4gc3RpbGwgZ2V0IChzdGFsZSkgcHJlc2VuY2Ugc2V0IGlmIHdhaXRGb3JTeW5jIGlzIGZhbHNlICovXG4gICAgICAgIGlmICh0aGlzLmNoYW5uZWwuc3RhdGUgPT09ICdzdXNwZW5kZWQnKSB7XG4gICAgICAgICAgICBpZiAod2FpdEZvclN5bmMpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhlcnJvcmluZm9fMS5kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgICAgICAgICBzdGF0dXNDb2RlOiA0MDAsXG4gICAgICAgICAgICAgICAgICAgIGNvZGU6IDkxMDA1LFxuICAgICAgICAgICAgICAgICAgICBtZXNzYWdlOiAnUHJlc2VuY2Ugc3RhdGUgaXMgb3V0IG9mIHN5bmMgZHVlIHRvIGNoYW5uZWwgYmVpbmcgaW4gdGhlIFNVU1BFTkRFRCBzdGF0ZScsXG4gICAgICAgICAgICAgICAgfSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuTWVtYmVycyh0aGlzLm1lbWJlcnMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHdhaXRBdHRhY2hlZCh0aGlzLmNoYW5uZWwsIGNhbGxiYWNrLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB2YXIgbWVtYmVycyA9IF90aGlzLm1lbWJlcnM7XG4gICAgICAgICAgICBpZiAod2FpdEZvclN5bmMpIHtcbiAgICAgICAgICAgICAgICBtZW1iZXJzLndhaXRTeW5jKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuTWVtYmVycyhtZW1iZXJzKTtcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIHJldHVybk1lbWJlcnMobWVtYmVycyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuaGlzdG9yeSA9IGZ1bmN0aW9uIChwYXJhbXMsIGNhbGxiYWNrKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS5oaXN0b3J5KCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLm5hbWUpO1xuICAgICAgICAvKiBwYXJhbXMgYW5kIGNhbGxiYWNrIGFyZSBvcHRpb25hbDsgc2VlIGlmIHBhcmFtcyBjb250YWlucyB0aGUgY2FsbGJhY2sgKi9cbiAgICAgICAgaWYgKGNhbGxiYWNrID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICh0eXBlb2YgcGFyYW1zID09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IHBhcmFtcztcbiAgICAgICAgICAgICAgICBwYXJhbXMgPSBudWxsO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMuY2hhbm5lbC5yZWFsdGltZS5vcHRpb25zLnByb21pc2VzKSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ2hpc3RvcnknLCBhcmd1bWVudHMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYWxsYmFjayA9IG5vb3A7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHBhcmFtcyAmJiBwYXJhbXMudW50aWxBdHRhY2gpIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWwuc3RhdGUgPT09ICdhdHRhY2hlZCcpIHtcbiAgICAgICAgICAgICAgICBkZWxldGUgcGFyYW1zLnVudGlsQXR0YWNoO1xuICAgICAgICAgICAgICAgIHBhcmFtcy5mcm9tX3NlcmlhbCA9IHRoaXMuY2hhbm5lbC5wcm9wZXJ0aWVzLmF0dGFjaFNlcmlhbDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KCdvcHRpb24gdW50aWxBdHRhY2ggcmVxdWlyZXMgdGhlIGNoYW5uZWwgdG8gYmUgYXR0YWNoZWQsIHdhczogJyArIHRoaXMuY2hhbm5lbC5zdGF0ZSwgNDAwMDAsIDQwMCkpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHByZXNlbmNlXzEuZGVmYXVsdC5wcm90b3R5cGUuX2hpc3RvcnkuY2FsbCh0aGlzLCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLnNldFByZXNlbmNlID0gZnVuY3Rpb24gKHByZXNlbmNlU2V0LCBpc1N5bmMsIHN5bmNDaGFubmVsU2VyaWFsKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnUmVhbHRpbWVQcmVzZW5jZS5zZXRQcmVzZW5jZSgpJywgJ3JlY2VpdmVkIHByZXNlbmNlIGZvciAnICsgcHJlc2VuY2VTZXQubGVuZ3RoICsgJyBwYXJ0aWNpcGFudHM7IHN5bmNDaGFubmVsU2VyaWFsID0gJyArIHN5bmNDaGFubmVsU2VyaWFsKTtcbiAgICAgICAgdmFyIHN5bmNDdXJzb3IsIG1hdGNoO1xuICAgICAgICB2YXIgbWVtYmVycyA9IHRoaXMubWVtYmVycywgbXlNZW1iZXJzID0gdGhpcy5fbXlNZW1iZXJzLCBicm9hZGNhc3RNZXNzYWdlcyA9IFtdLCBjb25uSWQgPSB0aGlzLmNoYW5uZWwuY29ubmVjdGlvbk1hbmFnZXIuY29ubmVjdGlvbklkO1xuICAgICAgICBpZiAoaXNTeW5jKSB7XG4gICAgICAgICAgICB0aGlzLm1lbWJlcnMuc3RhcnRTeW5jKCk7XG4gICAgICAgICAgICBpZiAoc3luY0NoYW5uZWxTZXJpYWwgJiYgKG1hdGNoID0gc3luY0NoYW5uZWxTZXJpYWwubWF0Y2goL15bXFx3LV0rOiguKikkLykpKSB7XG4gICAgICAgICAgICAgICAgc3luY0N1cnNvciA9IG1hdGNoWzFdO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgcHJlc2VuY2VTZXQubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIHZhciBwcmVzZW5jZSA9IHByZXNlbmNlbWVzc2FnZV8xLmRlZmF1bHQuZnJvbVZhbHVlcyhwcmVzZW5jZVNldFtpXSk7XG4gICAgICAgICAgICBzd2l0Y2ggKHByZXNlbmNlLmFjdGlvbikge1xuICAgICAgICAgICAgICAgIGNhc2UgJ2xlYXZlJzpcbiAgICAgICAgICAgICAgICAgICAgaWYgKG1lbWJlcnMucmVtb3ZlKHByZXNlbmNlKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJvYWRjYXN0TWVzc2FnZXMucHVzaChwcmVzZW5jZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHByZXNlbmNlLmNvbm5lY3Rpb25JZCA9PT0gY29ubklkICYmICFwcmVzZW5jZS5pc1N5bnRoZXNpemVkKCkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG15TWVtYmVycy5yZW1vdmUocHJlc2VuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgIGNhc2UgJ2VudGVyJzpcbiAgICAgICAgICAgICAgICBjYXNlICdwcmVzZW50JzpcbiAgICAgICAgICAgICAgICBjYXNlICd1cGRhdGUnOlxuICAgICAgICAgICAgICAgICAgICBpZiAobWVtYmVycy5wdXQocHJlc2VuY2UpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBicm9hZGNhc3RNZXNzYWdlcy5wdXNoKHByZXNlbmNlKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAocHJlc2VuY2UuY29ubmVjdGlvbklkID09PSBjb25uSWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG15TWVtYmVycy5wdXQocHJlc2VuY2UpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIC8qIGlmIHRoaXMgaXMgdGhlIGxhc3QgKG9yIG9ubHkpIG1lc3NhZ2UgaW4gYSBzZXF1ZW5jZSBvZiBzeW5jIHVwZGF0ZXMsIGVuZCB0aGUgc3luYyAqL1xuICAgICAgICBpZiAoaXNTeW5jICYmICFzeW5jQ3Vyc29yKSB7XG4gICAgICAgICAgICBtZW1iZXJzLmVuZFN5bmMoKTtcbiAgICAgICAgICAgIHRoaXMuY2hhbm5lbC5zeW5jQ2hhbm5lbFNlcmlhbCA9IG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgLyogYnJvYWRjYXN0IHRvIGxpc3RlbmVycyAqL1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJyb2FkY2FzdE1lc3NhZ2VzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgcHJlc2VuY2UgPSBicm9hZGNhc3RNZXNzYWdlc1tpXTtcbiAgICAgICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5lbWl0KHByZXNlbmNlLmFjdGlvbiwgcHJlc2VuY2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5vbkF0dGFjaGVkID0gZnVuY3Rpb24gKGhhc1ByZXNlbmNlKSB7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUmVhbHRpbWVQcmVzZW5jZS5vbkF0dGFjaGVkKCknLCAnY2hhbm5lbCA9ICcgKyB0aGlzLmNoYW5uZWwubmFtZSArICcsIGhhc1ByZXNlbmNlID0gJyArIGhhc1ByZXNlbmNlKTtcbiAgICAgICAgaWYgKGhhc1ByZXNlbmNlKSB7XG4gICAgICAgICAgICB0aGlzLm1lbWJlcnMuc3RhcnRTeW5jKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICB0aGlzLl9zeW50aGVzaXplTGVhdmVzKHRoaXMubWVtYmVycy52YWx1ZXMoKSk7XG4gICAgICAgICAgICB0aGlzLm1lbWJlcnMuY2xlYXIoKTtcbiAgICAgICAgfVxuICAgICAgICAvLyBSVFAxN2Y6IFJlLWVudGVyIG93biBtZW1iZXJzIHdoZW4gbW92aW5nIGludG8gdGhlIGF0dGFjaGVkIHN0YXRlLlxuICAgICAgICB0aGlzLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KCk7XG4gICAgICAgIC8qIE5CIHRoaXMgbXVzdCBiZSBhZnRlciB0aGUgX2Vuc3VyZU15TWVtYmVyc1ByZXNlbnQgY2FsbCwgd2hpY2ggbWF5IGFkZCBpdGVtcyB0byBwZW5kaW5nUHJlc2VuY2UgKi9cbiAgICAgICAgdmFyIHBlbmRpbmdQcmVzZW5jZSA9IHRoaXMucGVuZGluZ1ByZXNlbmNlLCBwZW5kaW5nUHJlc0NvdW50ID0gcGVuZGluZ1ByZXNlbmNlLmxlbmd0aDtcbiAgICAgICAgaWYgKHBlbmRpbmdQcmVzQ291bnQpIHtcbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1ByZXNlbmNlID0gW107XG4gICAgICAgICAgICB2YXIgcHJlc2VuY2VBcnJheSA9IFtdO1xuICAgICAgICAgICAgdmFyIG11bHRpY2FzdGVyID0gbXVsdGljYXN0ZXJfMS5kZWZhdWx0LmNyZWF0ZSgpO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZWFsdGltZVByZXNlbmNlLm9uQXR0YWNoZWQnLCAnc2VuZGluZyAnICsgcGVuZGluZ1ByZXNDb3VudCArICcgcXVldWVkIHByZXNlbmNlIG1lc3NhZ2VzJyk7XG4gICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBlbmRpbmdQcmVzQ291bnQ7IGkrKykge1xuICAgICAgICAgICAgICAgIHZhciBldmVudF8xID0gcGVuZGluZ1ByZXNlbmNlW2ldO1xuICAgICAgICAgICAgICAgIHByZXNlbmNlQXJyYXkucHVzaChldmVudF8xLnByZXNlbmNlKTtcbiAgICAgICAgICAgICAgICBtdWx0aWNhc3Rlci5wdXNoKGV2ZW50XzEuY2FsbGJhY2spO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgdGhpcy5jaGFubmVsLnNlbmRQcmVzZW5jZShwcmVzZW5jZUFycmF5LCBtdWx0aWNhc3Rlcik7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLmFjdE9uQ2hhbm5lbFN0YXRlID0gZnVuY3Rpb24gKHN0YXRlLCBoYXNQcmVzZW5jZSwgZXJyKSB7XG4gICAgICAgIHN3aXRjaCAoc3RhdGUpIHtcbiAgICAgICAgICAgIGNhc2UgJ2F0dGFjaGVkJzpcbiAgICAgICAgICAgICAgICB0aGlzLm9uQXR0YWNoZWQoaGFzUHJlc2VuY2UpO1xuICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgY2FzZSAnZGV0YWNoZWQnOlxuICAgICAgICAgICAgY2FzZSAnZmFpbGVkJzpcbiAgICAgICAgICAgICAgICB0aGlzLl9jbGVhck15TWVtYmVycygpO1xuICAgICAgICAgICAgICAgIHRoaXMubWVtYmVycy5jbGVhcigpO1xuICAgICAgICAgICAgLyogZmFsbHMgdGhyb3VnaCAqL1xuICAgICAgICAgICAgY2FzZSAnc3VzcGVuZGVkJzpcbiAgICAgICAgICAgICAgICB0aGlzLmZhaWxQZW5kaW5nUHJlc2VuY2UoZXJyKTtcbiAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuZmFpbFBlbmRpbmdQcmVzZW5jZSA9IGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKHRoaXMucGVuZGluZ1ByZXNlbmNlLmxlbmd0aCkge1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlOT1IsICdSZWFsdGltZUNoYW5uZWwuZmFpbFBlbmRpbmdQcmVzZW5jZScsICdjaGFubmVsOyBuYW1lID0gJyArIHRoaXMuY2hhbm5lbC5uYW1lICsgJywgZXJyID0gJyArIFV0aWxzLmluc3BlY3RFcnJvcihlcnIpKTtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdGhpcy5wZW5kaW5nUHJlc2VuY2UubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5wZW5kaW5nUHJlc2VuY2VbaV0uY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWVtcHR5XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGNhdGNoIChlKSB7IH1cbiAgICAgICAgICAgIHRoaXMucGVuZGluZ1ByZXNlbmNlID0gW107XG4gICAgICAgIH1cbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLl9jbGVhck15TWVtYmVycyA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5fbXlNZW1iZXJzLmNsZWFyKCk7XG4gICAgfTtcbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5fZW5zdXJlTXlNZW1iZXJzUHJlc2VudCA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgdmFyIG15TWVtYmVycyA9IHRoaXMuX215TWVtYmVycywgcmVlbnRlckNiID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgICAgIHZhciBtc2cgPSAnUHJlc2VuY2UgYXV0by1yZS1lbnRlciBmYWlsZWQ6ICcgKyBlcnIudG9TdHJpbmcoKTtcbiAgICAgICAgICAgICAgICB2YXIgd3JhcHBlZEVyciA9IG5ldyBlcnJvcmluZm9fMS5kZWZhdWx0KG1zZywgOTEwMDQsIDQwMCk7XG4gICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfRVJST1IsICdSZWFsdGltZVByZXNlbmNlLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KCknLCBtc2cpO1xuICAgICAgICAgICAgICAgIHZhciBjaGFuZ2UgPSBuZXcgY2hhbm5lbHN0YXRlY2hhbmdlXzEuZGVmYXVsdChfdGhpcy5jaGFubmVsLnN0YXRlLCBfdGhpcy5jaGFubmVsLnN0YXRlLCB0cnVlLCBmYWxzZSwgd3JhcHBlZEVycik7XG4gICAgICAgICAgICAgICAgX3RoaXMuY2hhbm5lbC5lbWl0KCd1cGRhdGUnLCBjaGFuZ2UpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgICAgICBmb3IgKHZhciBtZW1iZXJLZXkgaW4gbXlNZW1iZXJzLm1hcCkge1xuICAgICAgICAgICAgdmFyIGVudHJ5ID0gbXlNZW1iZXJzLm1hcFttZW1iZXJLZXldO1xuICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICdSZWFsdGltZVByZXNlbmNlLl9lbnN1cmVNeU1lbWJlcnNQcmVzZW50KCknLCAnQXV0by1yZWVudGVyaW5nIGNsaWVudElkIFwiJyArIGVudHJ5LmNsaWVudElkICsgJ1wiIGludG8gdGhlIHByZXNlbmNlIHNldCcpO1xuICAgICAgICAgICAgLy8gUlRQMTdnOiBTZW5kIEVOVEVSIGNvbnRhaW5pbmcgdGhlIG1lbWJlciBpZCwgY2xpZW50SWQgYW5kIGRhdGFcbiAgICAgICAgICAgIC8vIGF0dHJpYnV0ZXMuXG4gICAgICAgICAgICB0aGlzLl9lbnRlck9yVXBkYXRlQ2xpZW50KGVudHJ5LmlkLCBlbnRyeS5jbGllbnRJZCwgZW50cnkuZGF0YSwgJ2VudGVyJywgcmVlbnRlckNiKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUuX3N5bnRoZXNpemVMZWF2ZXMgPSBmdW5jdGlvbiAoaXRlbXMpIHtcbiAgICAgICAgdmFyIHN1YnNjcmlwdGlvbnMgPSB0aGlzLnN1YnNjcmlwdGlvbnM7XG4gICAgICAgIFV0aWxzLmFyckZvckVhY2goaXRlbXMsIGZ1bmN0aW9uIChpdGVtKSB7XG4gICAgICAgICAgICB2YXIgcHJlc2VuY2UgPSBwcmVzZW5jZW1lc3NhZ2VfMS5kZWZhdWx0LmZyb21WYWx1ZXMoe1xuICAgICAgICAgICAgICAgIGFjdGlvbjogJ2xlYXZlJyxcbiAgICAgICAgICAgICAgICBjb25uZWN0aW9uSWQ6IGl0ZW0uY29ubmVjdGlvbklkLFxuICAgICAgICAgICAgICAgIGNsaWVudElkOiBpdGVtLmNsaWVudElkLFxuICAgICAgICAgICAgICAgIGRhdGE6IGl0ZW0uZGF0YSxcbiAgICAgICAgICAgICAgICBlbmNvZGluZzogaXRlbS5lbmNvZGluZyxcbiAgICAgICAgICAgICAgICB0aW1lc3RhbXA6IFV0aWxzLm5vdygpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBzdWJzY3JpcHRpb25zLmVtaXQoJ2xlYXZlJywgcHJlc2VuY2UpO1xuICAgICAgICB9KTtcbiAgICB9O1xuICAgIC8qIERlcHJlY2F0ZWQgKi9cbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5vbiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgX2kgPSAwOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgIGFyZ3NbX2ldID0gYXJndW1lbnRzW19pXTtcbiAgICAgICAgfVxuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmRlcHJlY2F0ZWQoJ3ByZXNlbmNlLm9uJywgJ3ByZXNlbmNlLnN1YnNjcmliZScpO1xuICAgICAgICB0aGlzLnN1YnNjcmliZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuICAgIC8qIERlcHJlY2F0ZWQgKi9cbiAgICBSZWFsdGltZVByZXNlbmNlLnByb3RvdHlwZS5vZmYgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBhcmdzID0gW107XG4gICAgICAgIGZvciAodmFyIF9pID0gMDsgX2kgPCBhcmd1bWVudHMubGVuZ3RoOyBfaSsrKSB7XG4gICAgICAgICAgICBhcmdzW19pXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgIH1cbiAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5kZXByZWNhdGVkKCdwcmVzZW5jZS5vZmYnLCAncHJlc2VuY2UudW5zdWJzY3JpYmUnKTtcbiAgICAgICAgdGhpcy51bnN1YnNjcmliZS5hcHBseSh0aGlzLCBhcmdzKTtcbiAgICB9O1xuICAgIFJlYWx0aW1lUHJlc2VuY2UucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdmFyIF9hcmdzID0gW107IC8qIFtldmVudF0sIGxpc3RlbmVyLCBbY2FsbGJhY2tdICovXG4gICAgICAgIGZvciAodmFyIF9pID0gMCAvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqLzsgX2kgPCBhcmd1bWVudHMubGVuZ3RoIC8qIFtldmVudF0sIGxpc3RlbmVyLCBbY2FsbGJhY2tdICovOyBfaSsrIC8qIFtldmVudF0sIGxpc3RlbmVyLCBbY2FsbGJhY2tdICovKSB7XG4gICAgICAgICAgICBfYXJnc1tfaV0gPSBhcmd1bWVudHNbX2ldOyAvKiBbZXZlbnRdLCBsaXN0ZW5lciwgW2NhbGxiYWNrXSAqL1xuICAgICAgICB9XG4gICAgICAgIHZhciBhcmdzID0gcmVhbHRpbWVjaGFubmVsXzEuZGVmYXVsdC5wcm9jZXNzTGlzdGVuZXJBcmdzKF9hcmdzKTtcbiAgICAgICAgdmFyIGV2ZW50ID0gYXJnc1swXTtcbiAgICAgICAgdmFyIGxpc3RlbmVyID0gYXJnc1sxXTtcbiAgICAgICAgdmFyIGNhbGxiYWNrID0gYXJnc1syXTtcbiAgICAgICAgdmFyIGNoYW5uZWwgPSB0aGlzLmNoYW5uZWw7XG4gICAgICAgIGlmICghY2FsbGJhY2spIHtcbiAgICAgICAgICAgIGlmICh0aGlzLmNoYW5uZWwucmVhbHRpbWUub3B0aW9ucy5wcm9taXNlcykge1xuICAgICAgICAgICAgICAgIHJldHVybiBVdGlscy5wcm9taXNpZnkodGhpcywgJ3N1YnNjcmliZScsIFtldmVudCwgbGlzdGVuZXJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNhbGxiYWNrID0gbm9vcDtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hhbm5lbC5zdGF0ZSA9PT0gJ2ZhaWxlZCcpIHtcbiAgICAgICAgICAgIGNhbGxiYWNrKGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyhjaGFubmVsLmludmFsaWRTdGF0ZUVycm9yKCkpKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICB0aGlzLnN1YnNjcmlwdGlvbnMub24oZXZlbnQsIGxpc3RlbmVyKTtcbiAgICAgICAgY2hhbm5lbC5hdHRhY2goY2FsbGJhY2spO1xuICAgIH07XG4gICAgUmVhbHRpbWVQcmVzZW5jZS5wcm90b3R5cGUudW5zdWJzY3JpYmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBfYXJncyA9IFtdOyAvKiBbZXZlbnRdLCBsaXN0ZW5lciAqL1xuICAgICAgICBmb3IgKHZhciBfaSA9IDAgLyogW2V2ZW50XSwgbGlzdGVuZXIgKi87IF9pIDwgYXJndW1lbnRzLmxlbmd0aCAvKiBbZXZlbnRdLCBsaXN0ZW5lciAqLzsgX2krKyAvKiBbZXZlbnRdLCBsaXN0ZW5lciAqLykge1xuICAgICAgICAgICAgX2FyZ3NbX2ldID0gYXJndW1lbnRzW19pXTsgLyogW2V2ZW50XSwgbGlzdGVuZXIgKi9cbiAgICAgICAgfVxuICAgICAgICB2YXIgYXJncyA9IHJlYWx0aW1lY2hhbm5lbF8xLmRlZmF1bHQucHJvY2Vzc0xpc3RlbmVyQXJncyhfYXJncyk7XG4gICAgICAgIHZhciBldmVudCA9IGFyZ3NbMF07XG4gICAgICAgIHZhciBsaXN0ZW5lciA9IGFyZ3NbMV07XG4gICAgICAgIHRoaXMuc3Vic2NyaXB0aW9ucy5vZmYoZXZlbnQsIGxpc3RlbmVyKTtcbiAgICB9O1xuICAgIHJldHVybiBSZWFsdGltZVByZXNlbmNlO1xufShwcmVzZW5jZV8xLmRlZmF1bHQpKTtcbnZhciBQcmVzZW5jZU1hcCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcbiAgICB0c2xpYl8xLl9fZXh0ZW5kcyhQcmVzZW5jZU1hcCwgX3N1cGVyKTtcbiAgICBmdW5jdGlvbiBQcmVzZW5jZU1hcChwcmVzZW5jZSwgbWVtYmVyS2V5KSB7XG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMpIHx8IHRoaXM7XG4gICAgICAgIF90aGlzLnByZXNlbmNlID0gcHJlc2VuY2U7XG4gICAgICAgIF90aGlzLm1hcCA9IE9iamVjdC5jcmVhdGUobnVsbCk7XG4gICAgICAgIF90aGlzLnN5bmNJblByb2dyZXNzID0gZmFsc2U7XG4gICAgICAgIF90aGlzLnJlc2lkdWFsTWVtYmVycyA9IG51bGw7XG4gICAgICAgIF90aGlzLm1lbWJlcktleSA9IG1lbWJlcktleTtcbiAgICAgICAgcmV0dXJuIF90aGlzO1xuICAgIH1cbiAgICBQcmVzZW5jZU1hcC5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXBba2V5XTtcbiAgICB9O1xuICAgIFByZXNlbmNlTWFwLnByb3RvdHlwZS5nZXRDbGllbnQgPSBmdW5jdGlvbiAoY2xpZW50SWQpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMubWFwLCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG1hcCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBtYXBba2V5XTtcbiAgICAgICAgICAgIGlmIChpdGVtLmNsaWVudElkID09IGNsaWVudElkICYmIGl0ZW0uYWN0aW9uICE9ICdhYnNlbnQnKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1hcC5wcm90b3R5cGUubGlzdCA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMubWFwLCBjbGllbnRJZCA9IHBhcmFtcyAmJiBwYXJhbXMuY2xpZW50SWQsIGNvbm5lY3Rpb25JZCA9IHBhcmFtcyAmJiBwYXJhbXMuY29ubmVjdGlvbklkLCByZXN1bHQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG1hcCkge1xuICAgICAgICAgICAgdmFyIGl0ZW0gPSBtYXBba2V5XTtcbiAgICAgICAgICAgIGlmIChpdGVtLmFjdGlvbiA9PT0gJ2Fic2VudCcpXG4gICAgICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgICAgICBpZiAoY2xpZW50SWQgJiYgY2xpZW50SWQgIT0gaXRlbS5jbGllbnRJZClcbiAgICAgICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgICAgIGlmIChjb25uZWN0aW9uSWQgJiYgY29ubmVjdGlvbklkICE9IGl0ZW0uY29ubmVjdGlvbklkKVxuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgcmVzdWx0LnB1c2goaXRlbSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9O1xuICAgIFByZXNlbmNlTWFwLnByb3RvdHlwZS5wdXQgPSBmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgICBpZiAoaXRlbS5hY3Rpb24gPT09ICdlbnRlcicgfHwgaXRlbS5hY3Rpb24gPT09ICd1cGRhdGUnKSB7XG4gICAgICAgICAgICBpdGVtID0gcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKGl0ZW0pO1xuICAgICAgICAgICAgaXRlbS5hY3Rpb24gPSAncHJlc2VudCc7XG4gICAgICAgIH1cbiAgICAgICAgdmFyIG1hcCA9IHRoaXMubWFwLCBrZXkgPSB0aGlzLm1lbWJlcktleShpdGVtKTtcbiAgICAgICAgLyogd2UndmUgc2VlbiB0aGlzIG1lbWJlciwgc28gZG8gbm90IHJlbW92ZSBpdCBhdCB0aGUgZW5kIG9mIHN5bmMgKi9cbiAgICAgICAgaWYgKHRoaXMucmVzaWR1YWxNZW1iZXJzKVxuICAgICAgICAgICAgZGVsZXRlIHRoaXMucmVzaWR1YWxNZW1iZXJzW2tleV07XG4gICAgICAgIC8qIGNvbXBhcmUgdGhlIHRpbWVzdGFtcCBvZiB0aGUgbmV3IGl0ZW0gd2l0aCBhbnkgZXhpc3RpbmcgbWVtYmVyIChvciBBQlNFTlQgd2l0bmVzcykgKi9cbiAgICAgICAgdmFyIGV4aXN0aW5nSXRlbSA9IG1hcFtrZXldO1xuICAgICAgICBpZiAoZXhpc3RpbmdJdGVtICYmICFuZXdlclRoYW4oaXRlbSwgZXhpc3RpbmdJdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIG1hcFtrZXldID0gaXRlbTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1hcC5wcm90b3R5cGUudmFsdWVzID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB2YXIgbWFwID0gdGhpcy5tYXAsIHJlc3VsdCA9IFtdO1xuICAgICAgICBmb3IgKHZhciBrZXkgaW4gbWFwKSB7XG4gICAgICAgICAgICB2YXIgaXRlbSA9IG1hcFtrZXldO1xuICAgICAgICAgICAgaWYgKGl0ZW0uYWN0aW9uICE9ICdhYnNlbnQnKVxuICAgICAgICAgICAgICAgIHJlc3VsdC5wdXNoKGl0ZW0pO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBQcmVzZW5jZU1hcC5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgICAgdmFyIG1hcCA9IHRoaXMubWFwLCBrZXkgPSB0aGlzLm1lbWJlcktleShpdGVtKTtcbiAgICAgICAgdmFyIGV4aXN0aW5nSXRlbSA9IG1hcFtrZXldO1xuICAgICAgICBpZiAoZXhpc3RpbmdJdGVtICYmICFuZXdlclRoYW4oaXRlbSwgZXhpc3RpbmdJdGVtKSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIC8qIFJUUDJmICovXG4gICAgICAgIGlmICh0aGlzLnN5bmNJblByb2dyZXNzKSB7XG4gICAgICAgICAgICBpdGVtID0gcHJlc2VuY2VtZXNzYWdlXzEuZGVmYXVsdC5mcm9tVmFsdWVzKGl0ZW0pO1xuICAgICAgICAgICAgaXRlbS5hY3Rpb24gPSAnYWJzZW50JztcbiAgICAgICAgICAgIG1hcFtrZXldID0gaXRlbTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGRlbGV0ZSBtYXBba2V5XTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9O1xuICAgIFByZXNlbmNlTWFwLnByb3RvdHlwZS5zdGFydFN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLm1hcCwgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1ByZXNlbmNlTWFwLnN0YXJ0U3luYygpJywgJ2NoYW5uZWwgPSAnICsgdGhpcy5wcmVzZW5jZS5jaGFubmVsLm5hbWUgKyAnOyBzeW5jSW5Qcm9ncmVzcyA9ICcgKyBzeW5jSW5Qcm9ncmVzcyk7XG4gICAgICAgIC8qIHdlIG1pZ2h0IGJlIGNhbGxlZCBtdWx0aXBsZSB0aW1lcyB3aGlsZSBhIHN5bmMgaXMgaW4gcHJvZ3Jlc3MgKi9cbiAgICAgICAgaWYgKCF0aGlzLnN5bmNJblByb2dyZXNzKSB7XG4gICAgICAgICAgICB0aGlzLnJlc2lkdWFsTWVtYmVycyA9IFV0aWxzLmNvcHkobWFwKTtcbiAgICAgICAgICAgIHRoaXMuc2V0SW5Qcm9ncmVzcyh0cnVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUHJlc2VuY2VNYXAucHJvdG90eXBlLmVuZFN5bmMgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBtYXAgPSB0aGlzLm1hcCwgc3luY0luUHJvZ3Jlc3MgPSB0aGlzLnN5bmNJblByb2dyZXNzO1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSU5PUiwgJ1ByZXNlbmNlTWFwLmVuZFN5bmMoKScsICdjaGFubmVsID0gJyArIHRoaXMucHJlc2VuY2UuY2hhbm5lbC5uYW1lICsgJzsgc3luY0luUHJvZ3Jlc3MgPSAnICsgc3luY0luUHJvZ3Jlc3MpO1xuICAgICAgICBpZiAoc3luY0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgIC8qIHdlIGNhbiBub3cgc3RyaXAgb3V0IHRoZSBBQlNFTlQgbWVtYmVycywgYXMgd2UgaGF2ZVxuICAgICAgICAgICAgICogcmVjZWl2ZWQgYWxsIG9mIHRoZSBvdXQtb2Ytb3JkZXIgc3luYyBtZXNzYWdlcyAqL1xuICAgICAgICAgICAgZm9yICh2YXIgbWVtYmVyS2V5IGluIG1hcCkge1xuICAgICAgICAgICAgICAgIHZhciBlbnRyeSA9IG1hcFttZW1iZXJLZXldO1xuICAgICAgICAgICAgICAgIGlmIChlbnRyeS5hY3Rpb24gPT09ICdhYnNlbnQnKSB7XG4gICAgICAgICAgICAgICAgICAgIGRlbGV0ZSBtYXBbbWVtYmVyS2V5XTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAvKiBhbnkgbWVtYmVycyB0aGF0IHdlcmUgcHJlc2VudCBhdCB0aGUgc3RhcnQgb2YgdGhlIHN5bmMsXG4gICAgICAgICAgICAgKiBhbmQgaGF2ZSBub3QgYmVlbiBzZWVuIGluIHN5bmMsIGNhbiBiZSByZW1vdmVkLCBhbmQgbGVhdmUgZXZlbnRzIGVtaXR0ZWQgKi9cbiAgICAgICAgICAgIHRoaXMucHJlc2VuY2UuX3N5bnRoZXNpemVMZWF2ZXMoVXRpbHMudmFsdWVzQXJyYXkodGhpcy5yZXNpZHVhbE1lbWJlcnMpKTtcbiAgICAgICAgICAgIGZvciAodmFyIG1lbWJlcktleSBpbiB0aGlzLnJlc2lkdWFsTWVtYmVycykge1xuICAgICAgICAgICAgICAgIGRlbGV0ZSBtYXBbbWVtYmVyS2V5XTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMucmVzaWR1YWxNZW1iZXJzID0gbnVsbDtcbiAgICAgICAgICAgIC8qIGZpbmlzaCwgbm90aWZ5aW5nIGFueSB3YWl0ZXJzICovXG4gICAgICAgICAgICB0aGlzLnNldEluUHJvZ3Jlc3MoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMuZW1pdCgnc3luYycpO1xuICAgIH07XG4gICAgUHJlc2VuY2VNYXAucHJvdG90eXBlLndhaXRTeW5jID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgIHZhciBzeW5jSW5Qcm9ncmVzcyA9IHRoaXMuc3luY0luUHJvZ3Jlc3M7XG4gICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JTk9SLCAnUHJlc2VuY2VNYXAud2FpdFN5bmMoKScsICdjaGFubmVsID0gJyArIHRoaXMucHJlc2VuY2UuY2hhbm5lbC5uYW1lICsgJzsgc3luY0luUHJvZ3Jlc3MgPSAnICsgc3luY0luUHJvZ3Jlc3MpO1xuICAgICAgICBpZiAoIXN5bmNJblByb2dyZXNzKSB7XG4gICAgICAgICAgICBjYWxsYmFjaygpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICB9XG4gICAgICAgIHRoaXMub25jZSgnc3luYycsIGNhbGxiYWNrKTtcbiAgICB9O1xuICAgIFByZXNlbmNlTWFwLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgdGhpcy5tYXAgPSB7fTtcbiAgICAgICAgdGhpcy5zZXRJblByb2dyZXNzKGZhbHNlKTtcbiAgICAgICAgdGhpcy5yZXNpZHVhbE1lbWJlcnMgPSBudWxsO1xuICAgIH07XG4gICAgUHJlc2VuY2VNYXAucHJvdG90eXBlLnNldEluUHJvZ3Jlc3MgPSBmdW5jdGlvbiAoaW5Qcm9ncmVzcykge1xuICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJ1ByZXNlbmNlTWFwLnNldEluUHJvZ3Jlc3MoKScsICdpblByb2dyZXNzID0gJyArIGluUHJvZ3Jlc3MpO1xuICAgICAgICB0aGlzLnN5bmNJblByb2dyZXNzID0gaW5Qcm9ncmVzcztcbiAgICAgICAgdGhpcy5wcmVzZW5jZS5zeW5jQ29tcGxldGUgPSAhaW5Qcm9ncmVzcztcbiAgICB9O1xuICAgIHJldHVybiBQcmVzZW5jZU1hcDtcbn0oZXZlbnRlbWl0dGVyXzEuZGVmYXVsdCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gUmVhbHRpbWVQcmVzZW5jZTtcblxuXG4vKioqLyB9KSxcbi8qIDU1ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgZW5jX2hleF8xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg1Nik7XG52YXIgZW5jX3V0ZjhfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMzEpO1xudmFyIGVuY19iYXNlNjRfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xudmFyIGxpYl90eXBlZGFycmF5c18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg1KSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIEJ1ZmZlclV0aWxzID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xuICAgIGZ1bmN0aW9uIEJ1ZmZlclV0aWxzKCkge1xuICAgICAgICB0aGlzLmJhc2U2NENoYXJTZXQgPSAnQUJDREVGR0hJSktMTU5PUFFSU1RVVldYWVphYmNkZWZnaGlqa2xtbm9wcXJzdHV2d3h5ejAxMjM0NTY3ODkrLyc7XG4gICAgICAgIHRoaXMuaGV4Q2hhclNldCA9ICcwMTIzNDU2Nzg5YWJjZGVmJztcbiAgICB9XG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLmlzV29yZEFycmF5ID0gZnVuY3Rpb24gKG9iKSB7XG4gICAgICAgIHJldHVybiBvYiAhPT0gbnVsbCAmJiBvYiAhPT0gdW5kZWZpbmVkICYmIG9iLnNpZ0J5dGVzICE9PSB1bmRlZmluZWQ7XG4gICAgfTtcbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUuaXNBcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIChvYikge1xuICAgICAgICByZXR1cm4gb2IgIT09IG51bGwgJiYgb2IgIT09IHVuZGVmaW5lZCAmJiBvYi5jb25zdHJ1Y3RvciA9PT0gQXJyYXlCdWZmZXI7XG4gICAgfTtcbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUuaXNUeXBlZEFycmF5ID0gZnVuY3Rpb24gKG9iKSB7XG4gICAgICAgIHJldHVybiAhIUFycmF5QnVmZmVyICYmIEFycmF5QnVmZmVyLmlzVmlldyAmJiBBcnJheUJ1ZmZlci5pc1ZpZXcob2IpO1xuICAgIH07XG4gICAgLy8gLy8gaHR0cHM6Ly9naXN0LmdpdGh1YnVzZXJjb250ZW50LmNvbS9qb25sZWlnaHRvbi85NTg4NDEvcmF3L2YyMDBlMzBkZmU5NTIxMmMwMTY1Y2NmMWFlMDAwY2E1MWU5ZGU4MDMvZ2lzdGZpbGUxLmpzXG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLnVpbnQ4Vmlld1RvQmFzZTY0ID0gZnVuY3Rpb24gKGJ5dGVzKSB7XG4gICAgICAgIHZhciBiYXNlNjQgPSAnJztcbiAgICAgICAgdmFyIGVuY29kaW5ncyA9IHRoaXMuYmFzZTY0Q2hhclNldDtcbiAgICAgICAgdmFyIGJ5dGVMZW5ndGggPSBieXRlcy5ieXRlTGVuZ3RoO1xuICAgICAgICB2YXIgYnl0ZVJlbWFpbmRlciA9IGJ5dGVMZW5ndGggJSAzO1xuICAgICAgICB2YXIgbWFpbkxlbmd0aCA9IGJ5dGVMZW5ndGggLSBieXRlUmVtYWluZGVyO1xuICAgICAgICB2YXIgYSwgYiwgYywgZDtcbiAgICAgICAgdmFyIGNodW5rO1xuICAgICAgICAvLyBNYWluIGxvb3AgZGVhbHMgd2l0aCBieXRlcyBpbiBjaHVua3Mgb2YgM1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG1haW5MZW5ndGg7IGkgPSBpICsgMykge1xuICAgICAgICAgICAgLy8gQ29tYmluZSB0aGUgdGhyZWUgYnl0ZXMgaW50byBhIHNpbmdsZSBpbnRlZ2VyXG4gICAgICAgICAgICBjaHVuayA9IChieXRlc1tpXSA8PCAxNikgfCAoYnl0ZXNbaSArIDFdIDw8IDgpIHwgYnl0ZXNbaSArIDJdO1xuICAgICAgICAgICAgLy8gVXNlIGJpdG1hc2tzIHRvIGV4dHJhY3QgNi1iaXQgc2VnbWVudHMgZnJvbSB0aGUgdHJpcGxldFxuICAgICAgICAgICAgYSA9IChjaHVuayAmIDE2NTE1MDcyKSA+PiAxODsgLy8gMTY1MTUwNzIgPSAoMl42IC0gMSkgPDwgMThcbiAgICAgICAgICAgIGIgPSAoY2h1bmsgJiAyNTgwNDgpID4+IDEyOyAvLyAyNTgwNDggICA9ICgyXjYgLSAxKSA8PCAxMlxuICAgICAgICAgICAgYyA9IChjaHVuayAmIDQwMzIpID4+IDY7IC8vIDQwMzIgICAgID0gKDJeNiAtIDEpIDw8IDZcbiAgICAgICAgICAgIGQgPSBjaHVuayAmIDYzOyAvLyA2MyAgICAgICA9IDJeNiAtIDFcbiAgICAgICAgICAgIC8vIENvbnZlcnQgdGhlIHJhdyBiaW5hcnkgc2VnbWVudHMgdG8gdGhlIGFwcHJvcHJpYXRlIEFTQ0lJIGVuY29kaW5nXG4gICAgICAgICAgICBiYXNlNjQgKz0gZW5jb2RpbmdzW2FdICsgZW5jb2RpbmdzW2JdICsgZW5jb2RpbmdzW2NdICsgZW5jb2RpbmdzW2RdO1xuICAgICAgICB9XG4gICAgICAgIC8vIERlYWwgd2l0aCB0aGUgcmVtYWluaW5nIGJ5dGVzIGFuZCBwYWRkaW5nXG4gICAgICAgIGlmIChieXRlUmVtYWluZGVyID09IDEpIHtcbiAgICAgICAgICAgIGNodW5rID0gYnl0ZXNbbWFpbkxlbmd0aF07XG4gICAgICAgICAgICBhID0gKGNodW5rICYgMjUyKSA+PiAyOyAvLyAyNTIgPSAoMl42IC0gMSkgPDwgMlxuICAgICAgICAgICAgLy8gU2V0IHRoZSA0IGxlYXN0IHNpZ25pZmljYW50IGJpdHMgdG8gemVyb1xuICAgICAgICAgICAgYiA9IChjaHVuayAmIDMpIDw8IDQ7IC8vIDMgICA9IDJeMiAtIDFcbiAgICAgICAgICAgIGJhc2U2NCArPSBlbmNvZGluZ3NbYV0gKyBlbmNvZGluZ3NbYl0gKyAnPT0nO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGJ5dGVSZW1haW5kZXIgPT0gMikge1xuICAgICAgICAgICAgY2h1bmsgPSAoYnl0ZXNbbWFpbkxlbmd0aF0gPDwgOCkgfCBieXRlc1ttYWluTGVuZ3RoICsgMV07XG4gICAgICAgICAgICBhID0gKGNodW5rICYgNjQ1MTIpID4+IDEwOyAvLyA2NDUxMiA9ICgyXjYgLSAxKSA8PCAxMFxuICAgICAgICAgICAgYiA9IChjaHVuayAmIDEwMDgpID4+IDQ7IC8vIDEwMDggID0gKDJeNiAtIDEpIDw8IDRcbiAgICAgICAgICAgIC8vIFNldCB0aGUgMiBsZWFzdCBzaWduaWZpY2FudCBiaXRzIHRvIHplcm9cbiAgICAgICAgICAgIGMgPSAoY2h1bmsgJiAxNSkgPDwgMjsgLy8gMTUgICAgPSAyXjQgLSAxXG4gICAgICAgICAgICBiYXNlNjQgKz0gZW5jb2RpbmdzW2FdICsgZW5jb2RpbmdzW2JdICsgZW5jb2RpbmdzW2NdICsgJz0nO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBiYXNlNjQ7XG4gICAgfTtcbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUuYmFzZTY0VG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIChiYXNlNjQpIHtcbiAgICAgICAgdmFyIGJpbmFyeV9zdHJpbmcgPSBhdG9iID09PSBudWxsIHx8IGF0b2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGF0b2IoYmFzZTY0KTsgLy8gdGhpcyB3aWxsIGFsd2F5cyBiZSBkZWZpbmVkIGluIGJyb3dzZXIgc28gaXQncyBzYWZlIHRvIGNhc3RcbiAgICAgICAgdmFyIGxlbiA9IGJpbmFyeV9zdHJpbmcubGVuZ3RoO1xuICAgICAgICB2YXIgYnl0ZXMgPSBuZXcgVWludDhBcnJheShsZW4pO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgICAgICAgICB2YXIgYXNjaWkgPSBiaW5hcnlfc3RyaW5nLmNoYXJDb2RlQXQoaSk7XG4gICAgICAgICAgICBieXRlc1tpXSA9IGFzY2lpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBieXRlcy5idWZmZXI7XG4gICAgfTtcbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUuaXNCdWZmZXIgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIHJldHVybiB0aGlzLmlzQXJyYXlCdWZmZXIoYnVmZmVyKSB8fCB0aGlzLmlzV29yZEFycmF5KGJ1ZmZlcikgfHwgdGhpcy5pc1R5cGVkQXJyYXkoYnVmZmVyKTtcbiAgICB9O1xuICAgIC8qIEluIGJyb3dzZXJzLCByZXR1cm5zIGEgVWludDhBcnJheSAqL1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS50b0J1ZmZlciA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgaWYgKCFBcnJheUJ1ZmZlcikge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwiQ2FuJ3QgY29udmVydCB0byBCdWZmZXI6IGJyb3dzZXIgZG9lcyBub3Qgc3VwcG9ydCB0aGUgbmVjZXNzYXJ5IHR5cGVzXCIpO1xuICAgICAgICB9XG4gICAgICAgIGlmICh0aGlzLmlzQXJyYXlCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIG5ldyBVaW50OEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHRoaXMuaXNUeXBlZEFycmF5KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVWludDhBcnJheShidWZmZXIuYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAodGhpcy5pc1dvcmRBcnJheShidWZmZXIpKSB7XG4gICAgICAgICAgICAvKiBCYWNrcG9ydGVkIGZyb20gdW5yZWxlYXNlZCBDcnlwdG9KU1xuICAgICAgICAgICAgICogaHR0cHM6Ly9jb2RlLmdvb2dsZS5jb20vcC9jcnlwdG8tanMvc291cmNlL2Jyb3dzZS9icmFuY2hlcy8zLngvc3JjL2xpYi10eXBlZGFycmF5cy5qcz9yPTY2MSAqL1xuICAgICAgICAgICAgdmFyIGFycmF5QnVmZmVyID0gbmV3IEFycmF5QnVmZmVyKGJ1ZmZlci5zaWdCeXRlcyk7XG4gICAgICAgICAgICB2YXIgdWludDhWaWV3ID0gbmV3IFVpbnQ4QXJyYXkoYXJyYXlCdWZmZXIpO1xuICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBidWZmZXIuc2lnQnl0ZXM7IGkrKykge1xuICAgICAgICAgICAgICAgIHVpbnQ4Vmlld1tpXSA9IChidWZmZXIud29yZHNbaSA+Pj4gMl0gPj4+ICgyNCAtIChpICUgNCkgKiA4KSkgJiAweGZmO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIHVpbnQ4VmlldztcbiAgICAgICAgfVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0J1ZmZlclV0aWxzLnRvQnVmZmVyIGV4cGVjdGVkIGFuIGFycmF5YnVmZmVyLCB0eXBlZCBhcnJheSwgb3IgQ3J5cHRvSlMgd29yZGFycmF5Jyk7XG4gICAgfTtcbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUudG9BcnJheUJ1ZmZlciA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgaWYgKHRoaXMuaXNBcnJheUJ1ZmZlcihidWZmZXIpKSB7XG4gICAgICAgICAgICByZXR1cm4gYnVmZmVyO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiB0aGlzLnRvQnVmZmVyKGJ1ZmZlcikuYnVmZmVyO1xuICAgIH07XG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLnRvV29yZEFycmF5ID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICBpZiAodGhpcy5pc1R5cGVkQXJyYXkoYnVmZmVyKSkge1xuICAgICAgICAgICAgYnVmZmVyID0gYnVmZmVyLmJ1ZmZlcjtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy5pc1dvcmRBcnJheShidWZmZXIpID8gYnVmZmVyIDogbGliX3R5cGVkYXJyYXlzXzEuZGVmYXVsdC5jcmVhdGUoYnVmZmVyKTtcbiAgICB9O1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS5iYXNlNjRFbmNvZGUgPSBmdW5jdGlvbiAoYnVmZmVyKSB7XG4gICAgICAgIGlmICh0aGlzLmlzV29yZEFycmF5KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHJldHVybiAoMCwgZW5jX2Jhc2U2NF8xLnN0cmluZ2lmeSkoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gdGhpcy51aW50OFZpZXdUb0Jhc2U2NCh0aGlzLnRvQnVmZmVyKGJ1ZmZlcikpO1xuICAgIH07XG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLmJhc2U2NERlY29kZSA9IGZ1bmN0aW9uIChzdHIpIHtcbiAgICAgICAgaWYgKEFycmF5QnVmZmVyICYmIHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuYXRvYikge1xuICAgICAgICAgICAgcmV0dXJuIHRoaXMuYmFzZTY0VG9BcnJheUJ1ZmZlcihzdHIpO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiAoMCwgZW5jX2Jhc2U2NF8xLnBhcnNlKShzdHIpO1xuICAgIH07XG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLmhleEVuY29kZSA9IGZ1bmN0aW9uIChidWZmZXIpIHtcbiAgICAgICAgcmV0dXJuICgwLCBlbmNfaGV4XzEuc3RyaW5naWZ5KSh0aGlzLnRvV29yZEFycmF5KGJ1ZmZlcikpO1xuICAgIH07XG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLmhleERlY29kZSA9IGZ1bmN0aW9uIChzdHJpbmcpIHtcbiAgICAgICAgdmFyIHdvcmRBcnJheSA9ICgwLCBlbmNfaGV4XzEucGFyc2UpKHN0cmluZyk7XG4gICAgICAgIHJldHVybiBBcnJheUJ1ZmZlciA/IHRoaXMudG9BcnJheUJ1ZmZlcih3b3JkQXJyYXkpIDogd29yZEFycmF5O1xuICAgIH07XG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLnV0ZjhFbmNvZGUgPSBmdW5jdGlvbiAoc3RyaW5nKSB7XG4gICAgICAgIGlmIChwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLlRleHRFbmNvZGVyKSB7XG4gICAgICAgICAgICByZXR1cm4gbmV3IHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuVGV4dEVuY29kZXIoKS5lbmNvZGUoc3RyaW5nKS5idWZmZXI7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuICgwLCBlbmNfdXRmOF8xLnBhcnNlKShzdHJpbmcpO1xuICAgIH07XG4gICAgLyogRm9yIHV0ZjggZGVjb2Rpbmcgd2UgYXBwbHkgc2xpZ2h0bHkgc3RyaWN0ZXIgaW5wdXQgdmFsaWRhdGlvbiB0aGFuIHRvXG4gICAgICogaGV4RW5jb2RlL2Jhc2U2NEVuY29kZS9ldGM6IGluIHRob3NlIHdlIGFjY2VwdCBhbnl0aGluZyB0aGF0IEJ1ZmZlci5mcm9tXG4gICAgICogY2FuIHRha2UgKGluIHBhcnRpY3VsYXIgYWxsb3dpbmcgc3RyaW5ncywgd2hpY2ggYXJlIGp1c3QgaW50ZXJwcmV0ZWQgYXNcbiAgICAgKiBiaW5hcnkpOyBoZXJlIHdlIGVuc3VyZSB0aGF0IHRoZSBpbnB1dCBpcyBhY3R1YWxseSBhIGJ1ZmZlciBzaW5jZSB0cnlpbmdcbiAgICAgKiB0byB1dGY4LWRlY29kZSBhIHN0cmluZyB0byBhbm90aGVyIHN0cmluZyBpcyBhbG1vc3QgY2VydGFpbmx5IGEgbWlzdGFrZSAqL1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS51dGY4RGVjb2RlID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICBpZiAoIXRoaXMuaXNCdWZmZXIoYnVmZmVyKSkge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdFeHBlY3RlZCBpbnB1dCBvZiB1dGY4ZGVjb2RlIHRvIGJlIGFuIGFycmF5YnVmZmVyLCB0eXBlZCBhcnJheSwgb3IgQ3J5cHRvSlMgd29yZGFycmF5Jyk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKFRleHREZWNvZGVyICYmICF0aGlzLmlzV29yZEFycmF5KGJ1ZmZlcikpIHtcbiAgICAgICAgICAgIHJldHVybiBuZXcgVGV4dERlY29kZXIoKS5kZWNvZGUoYnVmZmVyKTtcbiAgICAgICAgfVxuICAgICAgICBidWZmZXIgPSB0aGlzLnRvV29yZEFycmF5KGJ1ZmZlcik7XG4gICAgICAgIHJldHVybiAoMCwgZW5jX3V0ZjhfMS5zdHJpbmdpZnkpKGJ1ZmZlcik7XG4gICAgfTtcbiAgICBCdWZmZXJVdGlscy5wcm90b3R5cGUuYnVmZmVyQ29tcGFyZSA9IGZ1bmN0aW9uIChidWZmZXIxLCBidWZmZXIyKSB7XG4gICAgICAgIGlmICghYnVmZmVyMSlcbiAgICAgICAgICAgIHJldHVybiAtMTtcbiAgICAgICAgaWYgKCFidWZmZXIyKVxuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIHZhciB3b3JkQXJyYXkxID0gdGhpcy50b1dvcmRBcnJheShidWZmZXIxKTtcbiAgICAgICAgdmFyIHdvcmRBcnJheTIgPSB0aGlzLnRvV29yZEFycmF5KGJ1ZmZlcjIpO1xuICAgICAgICB3b3JkQXJyYXkxLmNsYW1wKCk7XG4gICAgICAgIHdvcmRBcnJheTIuY2xhbXAoKTtcbiAgICAgICAgdmFyIGNtcCA9IHdvcmRBcnJheTEuc2lnQnl0ZXMgLSB3b3JkQXJyYXkyLnNpZ0J5dGVzO1xuICAgICAgICBpZiAoY21wICE9IDApXG4gICAgICAgICAgICByZXR1cm4gY21wO1xuICAgICAgICB2YXIgd29yZHMxID0gd29yZEFycmF5MS53b3JkcztcbiAgICAgICAgdmFyIHdvcmRzMiA9IHdvcmRBcnJheTIud29yZHM7XG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHMxLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgICBjbXAgPSB3b3JkczFbaV0gLSB3b3JkczJbaV07XG4gICAgICAgICAgICBpZiAoY21wICE9IDApXG4gICAgICAgICAgICAgICAgcmV0dXJuIGNtcDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gMDtcbiAgICB9O1xuICAgIEJ1ZmZlclV0aWxzLnByb3RvdHlwZS5ieXRlTGVuZ3RoID0gZnVuY3Rpb24gKGJ1ZmZlcikge1xuICAgICAgICBpZiAodGhpcy5pc0FycmF5QnVmZmVyKGJ1ZmZlcikgfHwgdGhpcy5pc1R5cGVkQXJyYXkoYnVmZmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5ieXRlTGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKHRoaXMuaXNXb3JkQXJyYXkoYnVmZmVyKSkge1xuICAgICAgICAgICAgcmV0dXJuIGJ1ZmZlci5zaWdCeXRlcztcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gLTE7XG4gICAgfTtcbiAgICAvKiBSZXR1cm5zIEFycmF5QnVmZmVyIG9uIGJyb3dzZXIgYW5kIEJ1ZmZlciBvbiBOb2RlLmpzICovXG4gICAgQnVmZmVyVXRpbHMucHJvdG90eXBlLnR5cGVkQXJyYXlUb0J1ZmZlciA9IGZ1bmN0aW9uICh0eXBlZEFycmF5KSB7XG4gICAgICAgIHJldHVybiB0eXBlZEFycmF5LmJ1ZmZlcjtcbiAgICB9O1xuICAgIHJldHVybiBCdWZmZXJVdGlscztcbn0oKSk7XG5leHBvcnRzLmRlZmF1bHQgPSBuZXcgQnVmZmVyVXRpbHMoKTtcblxuXG4vKioqLyB9KSxcbi8qIDU2ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cbjsoZnVuY3Rpb24gKHJvb3QsIGZhY3RvcnkpIHtcblx0aWYgKHRydWUpIHtcblx0XHQvLyBDb21tb25KU1xuXHRcdG1vZHVsZS5leHBvcnRzID0gZXhwb3J0cyA9IGZhY3RvcnkoX193ZWJwYWNrX3JlcXVpcmVfXyg2KSk7XG5cdH1cblx0ZWxzZSB7fVxufSh0aGlzLCBmdW5jdGlvbiAoQ3J5cHRvSlMpIHtcblxuXHRyZXR1cm4gQ3J5cHRvSlMuZW5jLkhleDtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDU3ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oNSk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMTEpO1xuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY3J5cHRvX2pzX2J1aWxkX2VuY19iYXNlNjRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgY3J5cHRvX2pzX2J1aWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDIyKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjcnlwdG9fanNfYnVpbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihjcnlwdG9fanNfYnVpbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyk7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oMik7XG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fKTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGNvbW1vbl9saWJfdHlwZXNfZXJyb3JpbmZvX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18pO1xuXG5cblxuXG5cblxudmFyIENyeXB0b0ZhY3RvcnkgPSBmdW5jdGlvbiAoY29uZmlnLCBidWZmZXJVdGlscykge1xuICB2YXIgREVGQVVMVF9BTEdPUklUSE0gPSAnYWVzJztcbiAgdmFyIERFRkFVTFRfS0VZTEVOR1RIID0gMjU2OyAvLyBiaXRzXG4gIHZhciBERUZBVUxUX01PREUgPSAnY2JjJztcbiAgdmFyIERFRkFVTFRfQkxPQ0tMRU5HVEggPSAxNjsgLy8gYnl0ZXNcbiAgdmFyIERFRkFVTFRfQkxPQ0tMRU5HVEhfV09SRFMgPSA0OyAvLyAzMi1iaXQgd29yZHNcbiAgdmFyIFVJTlQzMl9TVVAgPSAweDEwMDAwMDAwMDtcbiAgdmFyIElOVDMyX1NVUCA9IDB4ODAwMDAwMDA7XG5cbiAgLyoqXG4gICAqIEludGVybmFsOiBnZW5lcmF0ZSBhbiBhcnJheSBvZiBzZWN1cmUgcmFuZG9tIHdvcmRzIGNvcnJlc3BvbmRpbmcgdG8gdGhlIGdpdmVuIGxlbmd0aCBvZiBieXRlc1xuICAgKiBAcGFyYW0gYnl0ZXNcbiAgICogQHBhcmFtIGNhbGxiYWNrXG4gICAqL1xuICB2YXIgZ2VuZXJhdGVSYW5kb207XG4gIGlmIChjb25maWcuZ2V0UmFuZG9tV29yZEFycmF5KSB7XG4gICAgZ2VuZXJhdGVSYW5kb20gPSBjb25maWcuZ2V0UmFuZG9tV29yZEFycmF5O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBVaW50MzJBcnJheSAhPT0gJ3VuZGVmaW5lZCcgJiYgY29uZmlnLmdldFJhbmRvbVZhbHVlcykge1xuICAgIHZhciBibG9ja1JhbmRvbUFycmF5ID0gbmV3IFVpbnQzMkFycmF5KERFRkFVTFRfQkxPQ0tMRU5HVEhfV09SRFMpO1xuICAgIGdlbmVyYXRlUmFuZG9tID0gZnVuY3Rpb24gKGJ5dGVzLCBjYWxsYmFjaykge1xuICAgICAgdmFyIHdvcmRzID0gYnl0ZXMgLyA0LFxuICAgICAgICBuYXRpdmVBcnJheSA9IHdvcmRzID09IERFRkFVTFRfQkxPQ0tMRU5HVEhfV09SRFMgPyBibG9ja1JhbmRvbUFycmF5IDogbmV3IFVpbnQzMkFycmF5KHdvcmRzKTtcbiAgICAgIGNvbmZpZy5nZXRSYW5kb21WYWx1ZXMobmF0aXZlQXJyYXksIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBjYWxsYmFjayAhPT0gJ3VuZGVmaW5lZCcpIHtcbiAgICAgICAgICBjYWxsYmFjayhlcnIsIGJ1ZmZlclV0aWxzLnRvV29yZEFycmF5KG5hdGl2ZUFycmF5KSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH07XG4gIH0gZWxzZSB7XG4gICAgZ2VuZXJhdGVSYW5kb20gPSBmdW5jdGlvbiAoYnl0ZXMsIGNhbGxiYWNrKSB7XG4gICAgICBfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQuYS5sb2dBY3Rpb24oXG4gICAgICAgIF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdC5hLkxPR19NQUpPUixcbiAgICAgICAgJ0FibHkuQ3J5cHRvLmdlbmVyYXRlUmFuZG9tKCknLFxuICAgICAgICAnV2FybmluZzogdGhlIGJyb3dzZXIgeW91IGFyZSB1c2luZyBkb2VzIG5vdCBzdXBwb3J0IHNlY3VyZSBjcnlwdG9ncmFwaGljYWxseSBzZWN1cmUgcmFuZG9tbmVzcyBnZW5lcmF0aW9uOyBmYWxsaW5nIGJhY2sgdG8gaW5zZWN1cmUgTWF0aC5yYW5kb20oKSdcbiAgICAgICk7XG4gICAgICB2YXIgd29yZHMgPSBieXRlcyAvIDQsXG4gICAgICAgIGFycmF5ID0gbmV3IEFycmF5KHdvcmRzKTtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgd29yZHM7IGkrKykge1xuICAgICAgICAvKiBjcnlwdG9qcyB3b3JkYXJyYXlzIHVzZSBzaWduZWQgaW50cy4gV2hlbiBXb3JkQXJyYXkuY3JlYXRlIGlzIGZlZCBhXG4gICAgICAgICAqIFVpbnQzMkFycmF5IHVuc2lnbmVkIGFyZSBjb252ZXJ0ZWQgdG8gc2lnbmVkIGF1dG9tYXRpY2FsbHksIGJ1dCB3aGVuXG4gICAgICAgICAqIGZlZCBhIG5vcm1hbCBhcnJheSB0aGV5IGFyZW4ndCwgc28gbmVlZCB0byBkbyBzbyBvdXJzZWx2ZXMgYnlcbiAgICAgICAgICogc3VidHJhY3RpbmcgSU5UMzJfU1VQICovXG4gICAgICAgIGFycmF5W2ldID0gTWF0aC5mbG9vcihNYXRoLnJhbmRvbSgpICogVUlOVDMyX1NVUCkgLSBJTlQzMl9TVVA7XG4gICAgICB9XG5cbiAgICAgIGNhbGxiYWNrKG51bGwsIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKGFycmF5KSk7XG4gICAgfTtcbiAgfVxuXG4gIC8qKlxuICAgKiBJbnRlcm5hbDogY2FsY3VsYXRlIHRoZSBwYWRkZWQgbGVuZ3RoIG9mIGEgZ2l2ZW4gcGxhaW50ZXh0XG4gICAqIHVzaW5nIFBLQ1M1LlxuICAgKiBAcGFyYW0gcGxhaW50ZXh0TGVuZ3RoXG4gICAqIEByZXR1cm5cbiAgICovXG4gIGZ1bmN0aW9uIGdldFBhZGRlZExlbmd0aChwbGFpbnRleHRMZW5ndGgpIHtcbiAgICByZXR1cm4gKHBsYWludGV4dExlbmd0aCArIERFRkFVTFRfQkxPQ0tMRU5HVEgpICYgLURFRkFVTFRfQkxPQ0tMRU5HVEg7XG4gIH1cblxuICAvKipcbiAgICogSW50ZXJuYWw6IGNoZWNrcyB0aGF0IHRoZSBjaXBoZXJQYXJhbXMgYXJlIGEgdmFsaWQgY29tYmluYXRpb24uIEN1cnJlbnRseVxuICAgKiBqdXN0IGNoZWNrcyB0aGF0IHRoZSBjYWxjdWxhdGVkIGtleUxlbmd0aCBpcyBhIHZhbGlkIG9uZSBmb3IgYWVzLWNiY1xuICAgKi9cbiAgZnVuY3Rpb24gdmFsaWRhdGVDaXBoZXJQYXJhbXMocGFyYW1zKSB7XG4gICAgaWYgKHBhcmFtcy5hbGdvcml0aG0gPT09ICdhZXMnICYmIHBhcmFtcy5tb2RlID09PSAnY2JjJykge1xuICAgICAgaWYgKHBhcmFtcy5rZXlMZW5ndGggPT09IDEyOCB8fCBwYXJhbXMua2V5TGVuZ3RoID09PSAyNTYpIHtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgdGhyb3cgbmV3IEVycm9yKFxuICAgICAgICAnVW5zdXBwb3J0ZWQga2V5IGxlbmd0aCAnICtcbiAgICAgICAgICBwYXJhbXMua2V5TGVuZ3RoICtcbiAgICAgICAgICAnIGZvciBhZXMtY2JjIGVuY3J5cHRpb24uIEVuY3J5cHRpb24ga2V5IG11c3QgYmUgMTI4IG9yIDI1NiBiaXRzICgxNiBvciAzMiBBU0NJSSBjaGFyYWN0ZXJzKSdcbiAgICAgICk7XG4gICAgfVxuICB9XG5cbiAgZnVuY3Rpb24gbm9ybWFsaXNlQmFzZTY0KHN0cmluZykge1xuICAgIC8qIHVybC1zYWZlIGJhc2U2NCBzdHJpbmdzIHVzZSBfIGFuZCAtIGluc3RyZWFkIG9mIC8gYW5kICsgKi9cbiAgICByZXR1cm4gc3RyaW5nLnJlcGxhY2UoJ18nLCAnLycpLnJlcGxhY2UoJy0nLCAnKycpO1xuICB9XG5cbiAgLyoqXG4gICAqIEludGVybmFsOiBvYnRhaW4gdGhlIHBrY3M1IHBhZGRpbmcgc3RyaW5nIGZvciBhIGdpdmVuIHBhZGRlZCBsZW5ndGg7XG4gICAqL1xuICB2YXIgcGtjczVQYWRkaW5nID0gW1xuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDEwMTAxMDEwLCAweDEwMTAxMDEwLCAweDEwMTAxMDEwLCAweDEwMTAxMDEwXSwgMTYpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDAxMDAwMDAwXSwgMSksXG4gICAgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDIwMjAwMDBdLCAyKSxcbiAgICBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwMzAzMDMwMF0sIDMpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDA0MDQwNDA0XSwgNCksXG4gICAgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDUwNTA1MDUsIDB4MDUwMDAwMDBdLCA1KSxcbiAgICBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwNjA2MDYwNiwgMHgwNjA2MDAwMF0sIDYpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDA3MDcwNzA3LCAweDA3MDcwNzAwXSwgNyksXG4gICAgY3J5cHRvX2pzX2J1aWxkX2xpYl90eXBlZGFycmF5c19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQuYS5jcmVhdGUoWzB4MDgwODA4MDgsIDB4MDgwODA4MDhdLCA4KSxcbiAgICBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShbMHgwOTA5MDkwOSwgMHgwOTA5MDkwOSwgMHgwOTAwMDAwMF0sIDkpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBhMGEwYTBhLCAweDBhMGEwYTBhLCAweDBhMGEwMDAwXSwgMTApLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBiMGIwYjBiLCAweDBiMGIwYjBiLCAweDBiMGIwYjAwXSwgMTEpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBjMGMwYzBjLCAweDBjMGMwYzBjLCAweDBjMGMwYzBjXSwgMTIpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBkMGQwZDBkLCAweDBkMGQwZDBkLCAweDBkMGQwZDBkLCAweDBkMDAwMDAwXSwgMTMpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBlMGUwZTBlLCAweDBlMGUwZTBlLCAweDBlMGUwZTBlLCAweDBlMGUwMDAwXSwgMTQpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDBmMGYwZjBmLCAweDBmMGYwZjBmLCAweDBmMGYwZjBmLCAweDBmMGYwZjBmXSwgMTUpLFxuICAgIGNyeXB0b19qc19idWlsZF9saWJfdHlwZWRhcnJheXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0LmEuY3JlYXRlKFsweDEwMTAxMDEwLCAweDEwMTAxMDEwLCAweDEwMTAxMDEwLCAweDEwMTAxMDEwXSwgMTYpLFxuICBdO1xuXG4gIC8qKlxuICAgKiBVdGlsaXR5IGNsYXNzZXMgYW5kIGludGVyZmFjZXMgZm9yIG1lc3NhZ2UgcGF5bG9hZCBlbmNyeXB0aW9uLlxuICAgKlxuICAgKiBUaGlzIGNsYXNzIHN1cHBvcnRzIEFFUy9DQkMvUEtDUzUgd2l0aCBhIGRlZmF1bHQga2V5bGVuZ3RoIG9mIDEyOCBiaXRzXG4gICAqIGJ1dCBzdXBwb3J0aW5nIG90aGVyIGtleWxlbmd0aHMuIE90aGVyIGFsZ29yaXRobXMgYW5kIGNoYWluaW5nIG1vZGVzIGFyZVxuICAgKiBub3Qgc3VwcG9ydGVkIGRpcmVjdGx5LCBidXQgc3VwcG9ydGFibGUgYnkgZXh0ZW5kaW5nL2ltcGxlbWVudGluZyB0aGUgYmFzZVxuICAgKiBjbGFzc2VzIGFuZCBpbnRlcmZhY2VzIGhlcmUuXG4gICAqLVxuICAgKiBTZWN1cmUgcmFuZG9tIGRhdGEgZm9yIGNyZWF0aW9uIG9mIEluaXRpYWxpemF0aW9uIFZlY3RvcnMgKElWcykgYW5kIGtleXNcbiAgICogaXMgb2J0YWluZWQgZnJvbSB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyBpZiBhdmFpbGFibGUsIG9yIGZyb21cbiAgICogTWF0aC5yYW5kb20oKSBpZiBub3QuIENsaWVudHMgd2hvIGRvIG5vdCB3YW50IHRvIGRlcGVuZCBvbiBNYXRoLnJhbmRvbSgpXG4gICAqIHNob3VsZCBwb2x5ZmlsbCB3aW5kb3cuY3J5cHRvLmdldFJhbmRvbVZhbHVlcyB3aXRoIGEgbGlicmFyeSB0aGF0IHNlZWRzXG4gICAqIGEgUFJORyB3aXRoIHJlYWwgZW50cm9weS5cbiAgICpcbiAgICogRWFjaCBtZXNzYWdlIHBheWxvYWQgaXMgZW5jcnlwdGVkIHdpdGggYW4gSVYgaW4gQ0JDIG1vZGUsIGFuZCB0aGUgSVYgaXNcbiAgICogY29uY2F0ZW5hdGVkIHdpdGggdGhlIHJlc3VsdGluZyByYXcgY2lwaGVydGV4dCB0byBjb25zdHJ1Y3QgdGhlIFwiY2lwaGVydGV4dFwiXG4gICAqIGRhdGEgcGFzc2VkIHRvIHRoZSByZWNpcGllbnQuXG4gICAqL1xuICBmdW5jdGlvbiBDcnlwdG8oKSB7fVxuXG4gIC8qKlxuICAgKiBBIGNsYXNzIGVuY2Fwc3VsYXRpbmcgdGhlIGNsaWVudC1zcGVjaWZpYWJsZSBwYXJhbWV0ZXJzIGZvclxuICAgKiB0aGUgY2lwaGVyLlxuICAgKlxuICAgKiBhbGdvcml0aG0gaXMgdGhlIG5hbWUgb2YgdGhlIGFsZ29yaXRobSBpbiB0aGUgZGVmYXVsdCBzeXN0ZW0gcHJvdmlkZXIsXG4gICAqIG9yIHRoZSBsb3dlci1jYXNlZCB2ZXJzaW9uIG9mIGl0OyBlZyBcImFlc1wiIG9yIFwiQUVTXCIuXG4gICAqXG4gICAqIENsaWVudHMgYXJlIHJlY29tbWVuZGVkIHRvIG5vdCBjYWxsIHRoaXMgZGlyZWN0bHksIGJ1dCBpbnN0ZWFkIHRvIHVzZSB0aGVcbiAgICogQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMgaGVscGVyLCB3aGljaCB3aWxsIGZpbGwgaW4gYW55IGZpZWxkcyBub3Qgc3VwcGxpZWRcbiAgICogd2l0aCBkZWZhdWx0IHZhbHVlcyBhbmQgdmFsaWRhdGlvbiB0aGUgcmVzdWx0LlxuICAgKi9cbiAgZnVuY3Rpb24gQ2lwaGVyUGFyYW1zKCkge1xuICAgIHRoaXMuYWxnb3JpdGhtID0gbnVsbDtcbiAgICB0aGlzLmtleUxlbmd0aCA9IG51bGw7XG4gICAgdGhpcy5tb2RlID0gbnVsbDtcbiAgICB0aGlzLmtleSA9IG51bGw7XG4gIH1cbiAgQ3J5cHRvLkNpcGhlclBhcmFtcyA9IENpcGhlclBhcmFtcztcblxuICAvKipcbiAgICogT2J0YWluIGEgY29tcGxldGUgQ2lwaGVyUGFyYW1zIGluc3RhbmNlIGZyb20gdGhlIHByb3ZpZGVkIHBhcmFtcywgZmlsbGluZ1xuICAgKiBpbiBhbnkgbm90IHByb3ZpZGVkIHdpdGggZGVmYXVsdCB2YWx1ZXMsIGNhbGN1bGF0aW5nIGEga2V5TGVuZ3RoIGZyb21cbiAgICogdGhlIHN1cHBsaWVkIGtleSwgYW5kIHZhbGlkYXRpbmcgdGhlIHJlc3VsdC5cbiAgICogQHBhcmFtIHBhcmFtcyBhbiBvYmplY3QgY29udGFpbmluZyBhdCBhIG1pbmltdW0gYSBga2V5YCBrZXkgd2l0aCB2YWx1ZSB0aGVcbiAgICoga2V5LCBhcyBlaXRoZXIgYSBiaW5hcnkgKEFycmF5QnVmZmVyLCBBcnJheSwgV29yZEFycmF5KSBvciBhXG4gICAqIGJhc2U2NC1lbmNvZGVkIHN0cmluZy4gTWF5IG9wdGlvbmFsbHkgYWxzbyBjb250YWluOiBhbGdvcml0aG0gKGRlZmF1bHRzIHRvXG4gICAqIEFFUyksIG1vZGUgKGRlZmF1bHRzIHRvICdjYmMnKVxuICAgKi9cbiAgQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMgPSBmdW5jdGlvbiAocGFyYW1zKSB7XG4gICAgdmFyIGtleTtcbiAgICAvKiBCYWNrd2FyZCBjb21wYXRpYmlsaXR5ICovXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMgPT09ICdmdW5jdGlvbicgfHwgdHlwZW9mIHBhcmFtcyA9PT0gJ3N0cmluZycpIHtcbiAgICAgIF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdC5hLmRlcHJlY2F0ZWQoJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zKGtleSwgY2FsbGJhY2spJywgJ0NyeXB0by5nZXREZWZhdWx0UGFyYW1zKHtrZXk6IGtleX0pJyk7XG4gICAgICBpZiAodHlwZW9mIHBhcmFtcyA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICBDcnlwdG8uZ2VuZXJhdGVSYW5kb21LZXkoZnVuY3Rpb24gKGtleSkge1xuICAgICAgICAgIHBhcmFtcyhudWxsLCBDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtcyh7IGtleToga2V5IH0pKTtcbiAgICAgICAgfSk7XG4gICAgICB9IGVsc2UgaWYgKHR5cGVvZiBhcmd1bWVudHNbMV0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgYXJndW1lbnRzWzFdKG51bGwsIENyeXB0by5nZXREZWZhdWx0UGFyYW1zKHsga2V5OiBwYXJhbXMgfSkpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdJbnZhbGlkIGFyZ3VtZW50cyBmb3IgQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMnKTtcbiAgICAgIH1cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICBpZiAoIXBhcmFtcy5rZXkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignQ3J5cHRvLmdldERlZmF1bHRQYXJhbXM6IGEga2V5IGlzIHJlcXVpcmVkJyk7XG4gICAgfVxuXG4gICAgaWYgKHR5cGVvZiBwYXJhbXMua2V5ID09PSAnc3RyaW5nJykge1xuICAgICAga2V5ID0gT2JqZWN0KGNyeXB0b19qc19idWlsZF9lbmNfYmFzZTY0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXCJwYXJzZVwiXSkobm9ybWFsaXNlQmFzZTY0KHBhcmFtcy5rZXkpKTtcbiAgICB9IGVsc2Uge1xuICAgICAga2V5ID0gYnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkocGFyYW1zLmtleSk7IC8vIEV4cGVjdCBrZXkgdG8gYmUgYW4gQXJyYXksIEFycmF5QnVmZmVyLCBvciBXb3JkQXJyYXkgYXQgdGhpcyBwb2ludFxuICAgIH1cblxuICAgIHZhciBjaXBoZXJQYXJhbXMgPSBuZXcgQ2lwaGVyUGFyYW1zKCk7XG4gICAgY2lwaGVyUGFyYW1zLmtleSA9IGtleTtcbiAgICBjaXBoZXJQYXJhbXMuYWxnb3JpdGhtID0gcGFyYW1zLmFsZ29yaXRobSB8fCBERUZBVUxUX0FMR09SSVRITTtcbiAgICBjaXBoZXJQYXJhbXMua2V5TGVuZ3RoID0ga2V5LndvcmRzLmxlbmd0aCAqICg0ICogOCk7XG4gICAgY2lwaGVyUGFyYW1zLm1vZGUgPSBwYXJhbXMubW9kZSB8fCBERUZBVUxUX01PREU7XG5cbiAgICBpZiAocGFyYW1zLmtleUxlbmd0aCAmJiBwYXJhbXMua2V5TGVuZ3RoICE9PSBjaXBoZXJQYXJhbXMua2V5TGVuZ3RoKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXG4gICAgICAgICdDcnlwdG8uZ2V0RGVmYXVsdFBhcmFtczogYSBrZXlMZW5ndGggb2YgJyArXG4gICAgICAgICAgcGFyYW1zLmtleUxlbmd0aCArXG4gICAgICAgICAgJyB3YXMgc3BlY2lmaWVkLCBidXQgdGhlIGtleSBhY3R1YWxseSBoYXMgbGVuZ3RoICcgK1xuICAgICAgICAgIGNpcGhlclBhcmFtcy5rZXlMZW5ndGhcbiAgICAgICk7XG4gICAgfVxuXG4gICAgdmFsaWRhdGVDaXBoZXJQYXJhbXMoY2lwaGVyUGFyYW1zKTtcbiAgICByZXR1cm4gY2lwaGVyUGFyYW1zO1xuICB9O1xuXG4gIC8qKlxuICAgKiBHZW5lcmF0ZSBhIHJhbmRvbSBlbmNyeXB0aW9uIGtleSBmcm9tIHRoZSBzdXBwbGllZCBrZXlsZW5ndGggKG9yIHRoZVxuICAgKiBkZWZhdWx0IGtleUxlbmd0aCBpZiBub25lIHN1cHBsaWVkKSBhcyBhIENyeXB0b0pTIFdvcmRBcnJheVxuICAgKiBAcGFyYW0ga2V5TGVuZ3RoIChvcHRpb25hbCkgdGhlIHJlcXVpcmVkIGtleUxlbmd0aCBpbiBiaXRzXG4gICAqIEBwYXJhbSBjYWxsYmFjayAob3B0aW9uYWwpIChlcnIsIGtleSlcbiAgICovXG4gIENyeXB0by5nZW5lcmF0ZVJhbmRvbUtleSA9IGZ1bmN0aW9uIChrZXlMZW5ndGgsIGNhbGxiYWNrKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT0gMSAmJiB0eXBlb2Yga2V5TGVuZ3RoID09ICdmdW5jdGlvbicpIHtcbiAgICAgIGNhbGxiYWNrID0ga2V5TGVuZ3RoO1xuICAgICAga2V5TGVuZ3RoID0gdW5kZWZpbmVkO1xuICAgIH1cblxuICAgIGdlbmVyYXRlUmFuZG9tKChrZXlMZW5ndGggfHwgREVGQVVMVF9LRVlMRU5HVEgpIC8gOCwgZnVuY3Rpb24gKGVyciwgYnVmKSB7XG4gICAgICBpZiAoY2FsbGJhY2sgIT09IHVuZGVmaW5lZCkge1xuICAgICAgICBjYWxsYmFjayhlcnIgPyBjb21tb25fbGliX3R5cGVzX2Vycm9yaW5mb19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQuYS5mcm9tVmFsdWVzKGVycikgOiBudWxsLCBidWYpO1xuICAgICAgfVxuICAgIH0pO1xuICB9O1xuXG4gIC8qKlxuICAgKiBJbnRlcm5hbDsgZ2V0IGEgQ2hhbm5lbENpcGhlciBpbnN0YW5jZSBiYXNlZCBvbiB0aGUgZ2l2ZW4gY2lwaGVyUGFyYW1zXG4gICAqIEBwYXJhbSBwYXJhbXMgZWl0aGVyIGEgQ2lwaGVyUGFyYW1zIGluc3RhbmNlIG9yIHNvbWUgc3Vic2V0IG9mIGl0c1xuICAgKiBmaWVsZHMgdGhhdCBpbmNsdWRlcyBhIGtleVxuICAgKi9cbiAgQ3J5cHRvLmdldENpcGhlciA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcbiAgICB2YXIgY2lwaGVyUGFyYW1zID0gcGFyYW1zIGluc3RhbmNlb2YgQ2lwaGVyUGFyYW1zID8gcGFyYW1zIDogQ3J5cHRvLmdldERlZmF1bHRQYXJhbXMocGFyYW1zKTtcblxuICAgIHJldHVybiB7IGNpcGhlclBhcmFtczogY2lwaGVyUGFyYW1zLCBjaXBoZXI6IG5ldyBDQkNDaXBoZXIoY2lwaGVyUGFyYW1zLCBERUZBVUxUX0JMT0NLTEVOR1RIX1dPUkRTLCBwYXJhbXMuaXYpIH07XG4gIH07XG5cbiAgZnVuY3Rpb24gQ0JDQ2lwaGVyKHBhcmFtcywgYmxvY2tMZW5ndGhXb3JkcywgaXYpIHtcbiAgICB0aGlzLmFsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0gKyAnLScgKyBTdHJpbmcocGFyYW1zLmtleUxlbmd0aCkgKyAnLScgKyBwYXJhbXMubW9kZTtcbiAgICB0aGlzLmNqc0FsZ29yaXRobSA9IHBhcmFtcy5hbGdvcml0aG0udG9VcHBlckNhc2UoKS5yZXBsYWNlKC8tXFxkKyQvLCAnJyk7XG4gICAgdGhpcy5rZXkgPSBidWZmZXJVdGlscy50b1dvcmRBcnJheShwYXJhbXMua2V5KTtcbiAgICBpZiAoaXYpIHtcbiAgICAgIHRoaXMuaXYgPSBidWZmZXJVdGlscy50b1dvcmRBcnJheShpdikuY2xvbmUoKTtcbiAgICB9XG4gICAgdGhpcy5ibG9ja0xlbmd0aFdvcmRzID0gYmxvY2tMZW5ndGhXb3JkcztcbiAgfVxuXG4gIENCQ0NpcGhlci5wcm90b3R5cGUuZW5jcnlwdCA9IGZ1bmN0aW9uIChwbGFpbnRleHQsIGNhbGxiYWNrKSB7XG4gICAgX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0LmEubG9nQWN0aW9uKF9jb21tb25fbGliX3V0aWxfbG9nZ2VyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdC5hLkxPR19NSUNSTywgJ0NCQ0NpcGhlci5lbmNyeXB0KCknLCAnJyk7XG4gICAgcGxhaW50ZXh0ID0gYnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkocGxhaW50ZXh0KTtcbiAgICB2YXIgcGxhaW50ZXh0TGVuZ3RoID0gcGxhaW50ZXh0LnNpZ0J5dGVzLFxuICAgICAgcGFkZGVkTGVuZ3RoID0gZ2V0UGFkZGVkTGVuZ3RoKHBsYWludGV4dExlbmd0aCksXG4gICAgICBzZWxmID0gdGhpcztcblxuICAgIHZhciB0aGVuID0gZnVuY3Rpb24gKCkge1xuICAgICAgc2VsZi5nZXRJdihmdW5jdGlvbiAoZXJyLCBpdikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgdmFyIGNpcGhlck91dCA9IHNlbGYuZW5jcnlwdENpcGhlci5wcm9jZXNzKHBsYWludGV4dC5jb25jYXQocGtjczVQYWRkaW5nW3BhZGRlZExlbmd0aCAtIHBsYWludGV4dExlbmd0aF0pKTtcbiAgICAgICAgdmFyIGNpcGhlcnRleHQgPSBpdi5jb25jYXQoY2lwaGVyT3V0KTtcbiAgICAgICAgY2FsbGJhY2sobnVsbCwgY2lwaGVydGV4dCk7XG4gICAgICB9KTtcbiAgICB9O1xuXG4gICAgaWYgKCF0aGlzLmVuY3J5cHRDaXBoZXIpIHtcbiAgICAgIGlmICh0aGlzLml2KSB7XG4gICAgICAgIHRoaXMuZW5jcnlwdENpcGhlciA9IGNyeXB0b19qc19idWlsZF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fX2RlZmF1bHQuYS5hbGdvW3RoaXMuY2pzQWxnb3JpdGhtXS5jcmVhdGVFbmNyeXB0b3IodGhpcy5rZXksIHsgaXY6IHRoaXMuaXYgfSk7XG4gICAgICAgIHRoZW4oKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGdlbmVyYXRlUmFuZG9tKERFRkFVTFRfQkxPQ0tMRU5HVEgsIGZ1bmN0aW9uIChlcnIsIGl2KSB7XG4gICAgICAgICAgaWYgKGVycikge1xuICAgICAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICB9XG4gICAgICAgICAgc2VsZi5lbmNyeXB0Q2lwaGVyID0gY3J5cHRvX2pzX2J1aWxkX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdC5hLmFsZ29bc2VsZi5janNBbGdvcml0aG1dLmNyZWF0ZUVuY3J5cHRvcihzZWxmLmtleSwgeyBpdjogaXYgfSk7XG4gICAgICAgICAgc2VsZi5pdiA9IGl2O1xuICAgICAgICAgIHRoZW4oKTtcbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIHRoZW4oKTtcbiAgICB9XG4gIH07XG5cbiAgQ0JDQ2lwaGVyLnByb3RvdHlwZS5kZWNyeXB0ID0gZnVuY3Rpb24gKGNpcGhlcnRleHQpIHtcbiAgICBfY29tbW9uX2xpYl91dGlsX2xvZ2dlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fX2RlZmF1bHQuYS5sb2dBY3Rpb24oX2NvbW1vbl9saWJfdXRpbF9sb2dnZXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX19kZWZhdWx0LmEuTE9HX01JQ1JPLCAnQ0JDQ2lwaGVyLmRlY3J5cHQoKScsICcnKTtcbiAgICBjaXBoZXJ0ZXh0ID0gYnVmZmVyVXRpbHMudG9Xb3JkQXJyYXkoY2lwaGVydGV4dCk7XG4gICAgdmFyIGJsb2NrTGVuZ3RoV29yZHMgPSB0aGlzLmJsb2NrTGVuZ3RoV29yZHMsXG4gICAgICBjaXBoZXJ0ZXh0V29yZHMgPSBjaXBoZXJ0ZXh0LndvcmRzLFxuICAgICAgaXYgPSBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoMCwgYmxvY2tMZW5ndGhXb3JkcykpLFxuICAgICAgY2lwaGVydGV4dEJvZHkgPSBjcnlwdG9fanNfYnVpbGRfbGliX3R5cGVkYXJyYXlzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdC5hLmNyZWF0ZShjaXBoZXJ0ZXh0V29yZHMuc2xpY2UoYmxvY2tMZW5ndGhXb3JkcykpO1xuXG4gICAgdmFyIGRlY3J5cHRDaXBoZXIgPSBjcnlwdG9fanNfYnVpbGRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0LmEuYWxnb1t0aGlzLmNqc0FsZ29yaXRobV0uY3JlYXRlRGVjcnlwdG9yKHRoaXMua2V5LCB7IGl2OiBpdiB9KTtcbiAgICB2YXIgcGxhaW50ZXh0ID0gZGVjcnlwdENpcGhlci5wcm9jZXNzKGNpcGhlcnRleHRCb2R5KTtcbiAgICB2YXIgZXBpbG9ndWUgPSBkZWNyeXB0Q2lwaGVyLmZpbmFsaXplKCk7XG4gICAgZGVjcnlwdENpcGhlci5yZXNldCgpO1xuICAgIGlmIChlcGlsb2d1ZSAmJiBlcGlsb2d1ZS5zaWdCeXRlcykgcGxhaW50ZXh0LmNvbmNhdChlcGlsb2d1ZSk7XG4gICAgcmV0dXJuIHBsYWludGV4dDtcbiAgfTtcblxuICBDQkNDaXBoZXIucHJvdG90eXBlLmdldEl2ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgaWYgKHRoaXMuaXYpIHtcbiAgICAgIHZhciBpdiA9IHRoaXMuaXY7XG4gICAgICB0aGlzLml2ID0gbnVsbDtcbiAgICAgIGNhbGxiYWNrKG51bGwsIGl2KTtcbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICAvKiBTaW5jZSB0aGUgaXYgZm9yIGEgbmV3IGJsb2NrIGlzIHRoZSBjaXBoZXJ0ZXh0IG9mIHRoZSBsYXN0LCB0aGlzXG4gICAgICogc2V0cyBhIG5ldyBpdiAoPSBhZXMocmFuZG9tQmxvY2sgWE9SIGxhc3RDaXBoZXJUZXh0KSkgYXMgd2VsbCBhc1xuICAgICAqIHJldHVybmluZyBpdCAqL1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBnZW5lcmF0ZVJhbmRvbShERUZBVUxUX0JMT0NLTEVOR1RILCBmdW5jdGlvbiAoZXJyLCByYW5kb21CbG9jaykge1xuICAgICAgaWYgKGVycikge1xuICAgICAgICBjYWxsYmFjayhlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBjYWxsYmFjayhudWxsLCBzZWxmLmVuY3J5cHRDaXBoZXIucHJvY2VzcyhyYW5kb21CbG9jaykpO1xuICAgIH0pO1xuICB9O1xuXG4gIHJldHVybiBDcnlwdG87XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKENyeXB0b0ZhY3RvcnkpO1xuXG5cbi8qKiovIH0pLFxuLyogNTggKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDYpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBXb3JkQXJyYXkgPSBDX2xpYi5Xb3JkQXJyYXk7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblxuXHQgICAgLyoqXG5cdCAgICAgKiBVVEYtMTYgQkUgZW5jb2Rpbmcgc3RyYXRlZ3kuXG5cdCAgICAgKi9cblx0ICAgIHZhciBVdGYxNkJFID0gQ19lbmMuVXRmMTYgPSBDX2VuYy5VdGYxNkJFID0ge1xuXHQgICAgICAgIC8qKlxuXHQgICAgICAgICAqIENvbnZlcnRzIGEgd29yZCBhcnJheSB0byBhIFVURi0xNiBCRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAcGFyYW0ge1dvcmRBcnJheX0gd29yZEFycmF5IFRoZSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgVVRGLTE2IEJFIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHV0ZjE2U3RyaW5nID0gQ3J5cHRvSlMuZW5jLlV0ZjE2LnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSAod29yZHNbaSA+Pj4gMl0gPj4+ICgxNiAtIChpICUgNCkgKiA4KSkgJiAweGZmZmY7XG5cdCAgICAgICAgICAgICAgICB1dGYxNkNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB1dGYxNkNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi0xNiBCRSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjE2U3RyIFRoZSBVVEYtMTYgQkUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGYxNi5wYXJzZSh1dGYxNlN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uICh1dGYxNlN0cikge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZTdHJMZW5ndGggPSB1dGYxNlN0ci5sZW5ndGg7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgd29yZHMgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCB1dGYxNlN0ckxlbmd0aDsgaSsrKSB7XG5cdCAgICAgICAgICAgICAgICB3b3Jkc1tpID4+PiAxXSB8PSB1dGYxNlN0ci5jaGFyQ29kZUF0KGkpIDw8ICgxNiAtIChpICUgMikgKiAxNik7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICByZXR1cm4gV29yZEFycmF5LmNyZWF0ZSh3b3JkcywgdXRmMTZTdHJMZW5ndGggKiAyKTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXG5cdCAgICAvKipcblx0ICAgICAqIFVURi0xNiBMRSBlbmNvZGluZyBzdHJhdGVneS5cblx0ICAgICAqL1xuXHQgICAgQ19lbmMuVXRmMTZMRSA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIHdvcmQgYXJyYXkgdG8gYSBVVEYtMTYgTEUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtXb3JkQXJyYXl9IHdvcmRBcnJheSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEByZXR1cm4ge3N0cmluZ30gVGhlIFVURi0xNiBMRSBzdHJpbmcuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciB1dGYxNlN0ciA9IENyeXB0b0pTLmVuYy5VdGYxNkxFLnN0cmluZ2lmeSh3b3JkQXJyYXkpO1xuXHQgICAgICAgICAqL1xuXHQgICAgICAgIHN0cmluZ2lmeTogZnVuY3Rpb24gKHdvcmRBcnJheSkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIHdvcmRzID0gd29yZEFycmF5LndvcmRzO1xuXHQgICAgICAgICAgICB2YXIgc2lnQnl0ZXMgPSB3b3JkQXJyYXkuc2lnQnl0ZXM7XG5cblx0ICAgICAgICAgICAgLy8gQ29udmVydFxuXHQgICAgICAgICAgICB2YXIgdXRmMTZDaGFycyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHNpZ0J5dGVzOyBpICs9IDIpIHtcblx0ICAgICAgICAgICAgICAgIHZhciBjb2RlUG9pbnQgPSBzd2FwRW5kaWFuKCh3b3Jkc1tpID4+PiAyXSA+Pj4gKDE2IC0gKGkgJSA0KSAqIDgpKSAmIDB4ZmZmZik7XG5cdCAgICAgICAgICAgICAgICB1dGYxNkNoYXJzLnB1c2goU3RyaW5nLmZyb21DaGFyQ29kZShjb2RlUG9pbnQpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiB1dGYxNkNoYXJzLmpvaW4oJycpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIFVURi0xNiBMRSBzdHJpbmcgdG8gYSB3b3JkIGFycmF5LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IHV0ZjE2U3RyIFRoZSBVVEYtMTYgTEUgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7V29yZEFycmF5fSBUaGUgd29yZCBhcnJheS5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIHdvcmRBcnJheSA9IENyeXB0b0pTLmVuYy5VdGYxNkxFLnBhcnNlKHV0ZjE2U3RyKTtcblx0ICAgICAgICAgKi9cblx0ICAgICAgICBwYXJzZTogZnVuY3Rpb24gKHV0ZjE2U3RyKSB7XG5cdCAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgIHZhciB1dGYxNlN0ckxlbmd0aCA9IHV0ZjE2U3RyLmxlbmd0aDtcblxuXHQgICAgICAgICAgICAvLyBDb252ZXJ0XG5cdCAgICAgICAgICAgIHZhciB3b3JkcyA9IFtdO1xuXHQgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHV0ZjE2U3RyTGVuZ3RoOyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIHdvcmRzW2kgPj4+IDFdIHw9IHN3YXBFbmRpYW4odXRmMTZTdHIuY2hhckNvZGVBdChpKSA8PCAoMTYgLSAoaSAlIDIpICogMTYpKTtcblx0ICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgIHJldHVybiBXb3JkQXJyYXkuY3JlYXRlKHdvcmRzLCB1dGYxNlN0ckxlbmd0aCAqIDIpO1xuXHQgICAgICAgIH1cblx0ICAgIH07XG5cblx0ICAgIGZ1bmN0aW9uIHN3YXBFbmRpYW4od29yZCkge1xuXHQgICAgICAgIHJldHVybiAoKHdvcmQgPDwgOCkgJiAweGZmMDBmZjAwKSB8ICgod29yZCA+Pj4gOCkgJiAweDAwZmYwMGZmKTtcblx0ICAgIH1cblx0fSgpKTtcblxuXG5cdHJldHVybiBDcnlwdG9KUy5lbmMuVXRmMTY7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiA1OSAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNiksIF9fd2VicGFja19yZXF1aXJlX18oMjgpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAodW5kZWZpbmVkKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBDaXBoZXJQYXJhbXMgPSBDX2xpYi5DaXBoZXJQYXJhbXM7XG5cdCAgICB2YXIgQ19lbmMgPSBDLmVuYztcblx0ICAgIHZhciBIZXggPSBDX2VuYy5IZXg7XG5cdCAgICB2YXIgQ19mb3JtYXQgPSBDLmZvcm1hdDtcblxuXHQgICAgdmFyIEhleEZvcm1hdHRlciA9IENfZm9ybWF0LkhleCA9IHtcblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyB0aGUgY2lwaGVydGV4dCBvZiBhIGNpcGhlciBwYXJhbXMgb2JqZWN0IHRvIGEgaGV4YWRlY2ltYWxseSBlbmNvZGVkIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBwYXJhbSB7Q2lwaGVyUGFyYW1zfSBjaXBoZXJQYXJhbXMgVGhlIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7c3RyaW5nfSBUaGUgaGV4YWRlY2ltYWxseSBlbmNvZGVkIHN0cmluZy5cblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBzdGF0aWNcblx0ICAgICAgICAgKlxuXHQgICAgICAgICAqIEBleGFtcGxlXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiAgICAgdmFyIGhleFN0cmluZyA9IENyeXB0b0pTLmZvcm1hdC5IZXguc3RyaW5naWZ5KGNpcGhlclBhcmFtcyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgc3RyaW5naWZ5OiBmdW5jdGlvbiAoY2lwaGVyUGFyYW1zKSB7XG5cdCAgICAgICAgICAgIHJldHVybiBjaXBoZXJQYXJhbXMuY2lwaGVydGV4dC50b1N0cmluZyhIZXgpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICAvKipcblx0ICAgICAgICAgKiBDb252ZXJ0cyBhIGhleGFkZWNpbWFsbHkgZW5jb2RlZCBjaXBoZXJ0ZXh0IHN0cmluZyB0byBhIGNpcGhlciBwYXJhbXMgb2JqZWN0LlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHBhcmFtIHtzdHJpbmd9IGlucHV0IFRoZSBoZXhhZGVjaW1hbGx5IGVuY29kZWQgc3RyaW5nLlxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogQHJldHVybiB7Q2lwaGVyUGFyYW1zfSBUaGUgY2lwaGVyIHBhcmFtcyBvYmplY3QuXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAc3RhdGljXG5cdCAgICAgICAgICpcblx0ICAgICAgICAgKiBAZXhhbXBsZVxuXHQgICAgICAgICAqXG5cdCAgICAgICAgICogICAgIHZhciBjaXBoZXJQYXJhbXMgPSBDcnlwdG9KUy5mb3JtYXQuSGV4LnBhcnNlKGhleFN0cmluZyk7XG5cdCAgICAgICAgICovXG5cdCAgICAgICAgcGFyc2U6IGZ1bmN0aW9uIChpbnB1dCkge1xuXHQgICAgICAgICAgICB2YXIgY2lwaGVydGV4dCA9IEhleC5wYXJzZShpbnB1dCk7XG5cdCAgICAgICAgICAgIHJldHVybiBDaXBoZXJQYXJhbXMuY3JlYXRlKHsgY2lwaGVydGV4dDogY2lwaGVydGV4dCB9KTtcblx0ICAgICAgICB9XG5cdCAgICB9O1xuXHR9KCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLmZvcm1hdC5IZXg7XG5cbn0pKTtcblxuLyoqKi8gfSksXG4vKiA2MCAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG47KGZ1bmN0aW9uIChyb290LCBmYWN0b3J5KSB7XG5cdGlmICh0cnVlKSB7XG5cdFx0Ly8gQ29tbW9uSlNcblx0XHRtb2R1bGUuZXhwb3J0cyA9IGV4cG9ydHMgPSBmYWN0b3J5KF9fd2VicGFja19yZXF1aXJlX18oNiksIF9fd2VicGFja19yZXF1aXJlX18oMTEpLCBfX3dlYnBhY2tfcmVxdWlyZV9fKDYxKSwgX193ZWJwYWNrX3JlcXVpcmVfXygyNyksIF9fd2VicGFja19yZXF1aXJlX18oMjgpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoKSB7XG5cdCAgICAvLyBTaG9ydGN1dHNcblx0ICAgIHZhciBDID0gQ3J5cHRvSlM7XG5cdCAgICB2YXIgQ19saWIgPSBDLmxpYjtcblx0ICAgIHZhciBCbG9ja0NpcGhlciA9IENfbGliLkJsb2NrQ2lwaGVyO1xuXHQgICAgdmFyIENfYWxnbyA9IEMuYWxnbztcblxuXHQgICAgLy8gTG9va3VwIHRhYmxlc1xuXHQgICAgdmFyIFNCT1ggPSBbXTtcblx0ICAgIHZhciBJTlZfU0JPWCA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMCA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMSA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMiA9IFtdO1xuXHQgICAgdmFyIFNVQl9NSVhfMyA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzAgPSBbXTtcblx0ICAgIHZhciBJTlZfU1VCX01JWF8xID0gW107XG5cdCAgICB2YXIgSU5WX1NVQl9NSVhfMiA9IFtdO1xuXHQgICAgdmFyIElOVl9TVUJfTUlYXzMgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBsb29rdXAgdGFibGVzXG5cdCAgICAoZnVuY3Rpb24gKCkge1xuXHQgICAgICAgIC8vIENvbXB1dGUgZG91YmxlIHRhYmxlXG5cdCAgICAgICAgdmFyIGQgPSBbXTtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdCAgICAgICAgICAgIGlmIChpIDwgMTI4KSB7XG5cdCAgICAgICAgICAgICAgICBkW2ldID0gaSA8PCAxO1xuXHQgICAgICAgICAgICB9IGVsc2Uge1xuXHQgICAgICAgICAgICAgICAgZFtpXSA9IChpIDw8IDEpIF4gMHgxMWI7XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9XG5cblx0ICAgICAgICAvLyBXYWxrIEdGKDJeOClcblx0ICAgICAgICB2YXIgeCA9IDA7XG5cdCAgICAgICAgdmFyIHhpID0gMDtcblx0ICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IDI1NjsgaSsrKSB7XG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgc2JveFxuXHQgICAgICAgICAgICB2YXIgc3ggPSB4aSBeICh4aSA8PCAxKSBeICh4aSA8PCAyKSBeICh4aSA8PCAzKSBeICh4aSA8PCA0KTtcblx0ICAgICAgICAgICAgc3ggPSAoc3ggPj4+IDgpIF4gKHN4ICYgMHhmZikgXiAweDYzO1xuXHQgICAgICAgICAgICBTQk9YW3hdID0gc3g7XG5cdCAgICAgICAgICAgIElOVl9TQk9YW3N4XSA9IHg7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBtdWx0aXBsaWNhdGlvblxuXHQgICAgICAgICAgICB2YXIgeDIgPSBkW3hdO1xuXHQgICAgICAgICAgICB2YXIgeDQgPSBkW3gyXTtcblx0ICAgICAgICAgICAgdmFyIHg4ID0gZFt4NF07XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBzdWIgYnl0ZXMsIG1peCBjb2x1bW5zIHRhYmxlc1xuXHQgICAgICAgICAgICB2YXIgdCA9IChkW3N4XSAqIDB4MTAxKSBeIChzeCAqIDB4MTAxMDEwMCk7XG5cdCAgICAgICAgICAgIFNVQl9NSVhfMFt4XSA9ICh0IDw8IDI0KSB8ICh0ID4+PiA4KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8xW3hdID0gKHQgPDwgMTYpIHwgKHQgPj4+IDE2KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8yW3hdID0gKHQgPDwgOCkgIHwgKHQgPj4+IDI0KTtcblx0ICAgICAgICAgICAgU1VCX01JWF8zW3hdID0gdDtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGludiBzdWIgYnl0ZXMsIGludiBtaXggY29sdW1ucyB0YWJsZXNcblx0ICAgICAgICAgICAgdmFyIHQgPSAoeDggKiAweDEwMTAxMDEpIF4gKHg0ICogMHgxMDAwMSkgXiAoeDIgKiAweDEwMSkgXiAoeCAqIDB4MTAxMDEwMCk7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzBbc3hdID0gKHQgPDwgMjQpIHwgKHQgPj4+IDgpO1xuXHQgICAgICAgICAgICBJTlZfU1VCX01JWF8xW3N4XSA9ICh0IDw8IDE2KSB8ICh0ID4+PiAxNik7XG5cdCAgICAgICAgICAgIElOVl9TVUJfTUlYXzJbc3hdID0gKHQgPDwgOCkgIHwgKHQgPj4+IDI0KTtcblx0ICAgICAgICAgICAgSU5WX1NVQl9NSVhfM1tzeF0gPSB0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbmV4dCBjb3VudGVyXG5cdCAgICAgICAgICAgIGlmICgheCkge1xuXHQgICAgICAgICAgICAgICAgeCA9IHhpID0gMTtcblx0ICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgIHggPSB4MiBeIGRbZFtkW3g4IF4geDJdXV07XG5cdCAgICAgICAgICAgICAgICB4aSBePSBkW2RbeGldXTtcblx0ICAgICAgICAgICAgfVxuXHQgICAgICAgIH1cblx0ICAgIH0oKSk7XG5cblx0ICAgIC8vIFByZWNvbXB1dGVkIFJjb24gbG9va3VwXG5cdCAgICB2YXIgUkNPTiA9IFsweDAwLCAweDAxLCAweDAyLCAweDA0LCAweDA4LCAweDEwLCAweDIwLCAweDQwLCAweDgwLCAweDFiLCAweDM2XTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBBRVMgYmxvY2sgY2lwaGVyIGFsZ29yaXRobS5cblx0ICAgICAqL1xuXHQgICAgdmFyIEFFUyA9IENfYWxnby5BRVMgPSBCbG9ja0NpcGhlci5leHRlbmQoe1xuXHQgICAgICAgIF9kb1Jlc2V0OiBmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgICAgIHZhciB0O1xuXG5cdCAgICAgICAgICAgIC8vIFNraXAgcmVzZXQgb2YgblJvdW5kcyBoYXMgYmVlbiBzZXQgYmVmb3JlIGFuZCBrZXkgZGlkIG5vdCBjaGFuZ2Vcblx0ICAgICAgICAgICAgaWYgKHRoaXMuX25Sb3VuZHMgJiYgdGhpcy5fa2V5UHJpb3JSZXNldCA9PT0gdGhpcy5fa2V5KSB7XG5cdCAgICAgICAgICAgICAgICByZXR1cm47XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGtleSA9IHRoaXMuX2tleVByaW9yUmVzZXQgPSB0aGlzLl9rZXk7XG5cdCAgICAgICAgICAgIHZhciBrZXlXb3JkcyA9IGtleS53b3Jkcztcblx0ICAgICAgICAgICAgdmFyIGtleVNpemUgPSBrZXkuc2lnQnl0ZXMgLyA0O1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGUgbnVtYmVyIG9mIHJvdW5kc1xuXHQgICAgICAgICAgICB2YXIgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHMgPSBrZXlTaXplICsgNjtcblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIG51bWJlciBvZiBrZXkgc2NoZWR1bGUgcm93c1xuXHQgICAgICAgICAgICB2YXIga3NSb3dzID0gKG5Sb3VuZHMgKyAxKSAqIDQ7XG5cblx0ICAgICAgICAgICAgLy8gQ29tcHV0ZSBrZXkgc2NoZWR1bGVcblx0ICAgICAgICAgICAgdmFyIGtleVNjaGVkdWxlID0gdGhpcy5fa2V5U2NoZWR1bGUgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIga3NSb3cgPSAwOyBrc1JvdyA8IGtzUm93czsga3NSb3crKykge1xuXHQgICAgICAgICAgICAgICAgaWYgKGtzUm93IDwga2V5U2l6ZSkge1xuXHQgICAgICAgICAgICAgICAgICAgIGtleVNjaGVkdWxlW2tzUm93XSA9IGtleVdvcmRzW2tzUm93XTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdCA9IGtleVNjaGVkdWxlW2tzUm93IC0gMV07XG5cblx0ICAgICAgICAgICAgICAgICAgICBpZiAoIShrc1JvdyAlIGtleVNpemUpKSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFJvdCB3b3JkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAodCA8PCA4KSB8ICh0ID4+PiAyNCk7XG5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgLy8gU3ViIHdvcmRcblx0ICAgICAgICAgICAgICAgICAgICAgICAgdCA9IChTQk9YW3QgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsodCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHQgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3QgJiAweGZmXTtcblxuXHQgICAgICAgICAgICAgICAgICAgICAgICAvLyBNaXggUmNvblxuXHQgICAgICAgICAgICAgICAgICAgICAgICB0IF49IFJDT05bKGtzUm93IC8ga2V5U2l6ZSkgfCAwXSA8PCAyNDtcblx0ICAgICAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKGtleVNpemUgPiA2ICYmIGtzUm93ICUga2V5U2l6ZSA9PSA0KSB7XG5cdCAgICAgICAgICAgICAgICAgICAgICAgIC8vIFN1YiB3b3JkXG5cdCAgICAgICAgICAgICAgICAgICAgICAgIHQgPSAoU0JPWFt0ID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHQgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyh0ID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFt0ICYgMHhmZl07XG5cdCAgICAgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICAgICAga2V5U2NoZWR1bGVba3NSb3ddID0ga2V5U2NoZWR1bGVba3NSb3cgLSBrZXlTaXplXSBeIHQ7XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBDb21wdXRlIGludiBrZXkgc2NoZWR1bGVcblx0ICAgICAgICAgICAgdmFyIGludktleVNjaGVkdWxlID0gdGhpcy5faW52S2V5U2NoZWR1bGUgPSBbXTtcblx0ICAgICAgICAgICAgZm9yICh2YXIgaW52S3NSb3cgPSAwOyBpbnZLc1JvdyA8IGtzUm93czsgaW52S3NSb3crKykge1xuXHQgICAgICAgICAgICAgICAgdmFyIGtzUm93ID0ga3NSb3dzIC0gaW52S3NSb3c7XG5cblx0ICAgICAgICAgICAgICAgIGlmIChpbnZLc1JvdyAlIDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICB2YXIgdCA9IGtleVNjaGVkdWxlW2tzUm93XTtcblx0ICAgICAgICAgICAgICAgIH0gZWxzZSB7XG5cdCAgICAgICAgICAgICAgICAgICAgdmFyIHQgPSBrZXlTY2hlZHVsZVtrc1JvdyAtIDRdO1xuXHQgICAgICAgICAgICAgICAgfVxuXG5cdCAgICAgICAgICAgICAgICBpZiAoaW52S3NSb3cgPCA0IHx8IGtzUm93IDw9IDQpIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSB0O1xuXHQgICAgICAgICAgICAgICAgfSBlbHNlIHtcblx0ICAgICAgICAgICAgICAgICAgICBpbnZLZXlTY2hlZHVsZVtpbnZLc1Jvd10gPSBJTlZfU1VCX01JWF8wW1NCT1hbdCA+Pj4gMjRdXSBeIElOVl9TVUJfTUlYXzFbU0JPWFsodCA+Pj4gMTYpICYgMHhmZl1dIF5cblx0ICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBJTlZfU1VCX01JWF8yW1NCT1hbKHQgPj4+IDgpICYgMHhmZl1dIF4gSU5WX1NVQl9NSVhfM1tTQk9YW3QgJiAweGZmXV07XG5cdCAgICAgICAgICAgICAgICB9XG5cdCAgICAgICAgICAgIH1cblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgZW5jcnlwdEJsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2tleVNjaGVkdWxlLCBTVUJfTUlYXzAsIFNVQl9NSVhfMSwgU1VCX01JWF8yLCBTVUJfTUlYXzMsIFNCT1gpO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBkZWNyeXB0QmxvY2s6IGZ1bmN0aW9uIChNLCBvZmZzZXQpIHtcblx0ICAgICAgICAgICAgLy8gU3dhcCAybmQgYW5kIDR0aCByb3dzXG5cdCAgICAgICAgICAgIHZhciB0ID0gTVtvZmZzZXQgKyAxXTtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAxXSA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgM10gPSB0O1xuXG5cdCAgICAgICAgICAgIHRoaXMuX2RvQ3J5cHRCbG9jayhNLCBvZmZzZXQsIHRoaXMuX2ludktleVNjaGVkdWxlLCBJTlZfU1VCX01JWF8wLCBJTlZfU1VCX01JWF8xLCBJTlZfU1VCX01JWF8yLCBJTlZfU1VCX01JWF8zLCBJTlZfU0JPWCk7XG5cblx0ICAgICAgICAgICAgLy8gSW52IHN3YXAgMm5kIGFuZCA0dGggcm93c1xuXHQgICAgICAgICAgICB2YXIgdCA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMV0gPSBNW29mZnNldCArIDNdO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDNdID0gdDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvQ3J5cHRCbG9jazogZnVuY3Rpb24gKE0sIG9mZnNldCwga2V5U2NoZWR1bGUsIFNVQl9NSVhfMCwgU1VCX01JWF8xLCBTVUJfTUlYXzIsIFNVQl9NSVhfMywgU0JPWCkge1xuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dFxuXHQgICAgICAgICAgICB2YXIgblJvdW5kcyA9IHRoaXMuX25Sb3VuZHM7XG5cblx0ICAgICAgICAgICAgLy8gR2V0IGlucHV0LCBhZGQgcm91bmQga2V5XG5cdCAgICAgICAgICAgIHZhciBzMCA9IE1bb2Zmc2V0XSAgICAgXiBrZXlTY2hlZHVsZVswXTtcblx0ICAgICAgICAgICAgdmFyIHMxID0gTVtvZmZzZXQgKyAxXSBeIGtleVNjaGVkdWxlWzFdO1xuXHQgICAgICAgICAgICB2YXIgczIgPSBNW29mZnNldCArIDJdIF4ga2V5U2NoZWR1bGVbMl07XG5cdCAgICAgICAgICAgIHZhciBzMyA9IE1bb2Zmc2V0ICsgM10gXiBrZXlTY2hlZHVsZVszXTtcblxuXHQgICAgICAgICAgICAvLyBLZXkgc2NoZWR1bGUgcm93IGNvdW50ZXJcblx0ICAgICAgICAgICAgdmFyIGtzUm93ID0gNDtcblxuXHQgICAgICAgICAgICAvLyBSb3VuZHNcblx0ICAgICAgICAgICAgZm9yICh2YXIgcm91bmQgPSAxOyByb3VuZCA8IG5Sb3VuZHM7IHJvdW5kKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNoaWZ0IHJvd3MsIHN1YiBieXRlcywgbWl4IGNvbHVtbnMsIGFkZCByb3VuZCBrZXlcblx0ICAgICAgICAgICAgICAgIHZhciB0MCA9IFNVQl9NSVhfMFtzMCA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMSA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMyID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MzICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MSA9IFNVQl9NSVhfMFtzMSA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMiA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMzID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MwICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MiA9IFNVQl9NSVhfMFtzMiA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMyA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMwID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MxICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgICAgIHZhciB0MyA9IFNVQl9NSVhfMFtzMyA+Pj4gMjRdIF4gU1VCX01JWF8xWyhzMCA+Pj4gMTYpICYgMHhmZl0gXiBTVUJfTUlYXzJbKHMxID4+PiA4KSAmIDB4ZmZdIF4gU1VCX01JWF8zW3MyICYgMHhmZl0gXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblxuXHQgICAgICAgICAgICAgICAgLy8gVXBkYXRlIHN0YXRlXG5cdCAgICAgICAgICAgICAgICBzMCA9IHQwO1xuXHQgICAgICAgICAgICAgICAgczEgPSB0MTtcblx0ICAgICAgICAgICAgICAgIHMyID0gdDI7XG5cdCAgICAgICAgICAgICAgICBzMyA9IHQzO1xuXHQgICAgICAgICAgICB9XG5cblx0ICAgICAgICAgICAgLy8gU2hpZnQgcm93cywgc3ViIGJ5dGVzLCBhZGQgcm91bmQga2V5XG5cdCAgICAgICAgICAgIHZhciB0MCA9ICgoU0JPWFtzMCA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMSA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMyID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMyAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXHQgICAgICAgICAgICB2YXIgdDEgPSAoKFNCT1hbczEgPj4+IDI0XSA8PCAyNCkgfCAoU0JPWFsoczIgPj4+IDE2KSAmIDB4ZmZdIDw8IDE2KSB8IChTQk9YWyhzMyA+Pj4gOCkgJiAweGZmXSA8PCA4KSB8IFNCT1hbczAgJiAweGZmXSkgXiBrZXlTY2hlZHVsZVtrc1JvdysrXTtcblx0ICAgICAgICAgICAgdmFyIHQyID0gKChTQk9YW3MyID4+PiAyNF0gPDwgMjQpIHwgKFNCT1hbKHMzID4+PiAxNikgJiAweGZmXSA8PCAxNikgfCAoU0JPWFsoczAgPj4+IDgpICYgMHhmZl0gPDwgOCkgfCBTQk9YW3MxICYgMHhmZl0pIF4ga2V5U2NoZWR1bGVba3NSb3crK107XG5cdCAgICAgICAgICAgIHZhciB0MyA9ICgoU0JPWFtzMyA+Pj4gMjRdIDw8IDI0KSB8IChTQk9YWyhzMCA+Pj4gMTYpICYgMHhmZl0gPDwgMTYpIHwgKFNCT1hbKHMxID4+PiA4KSAmIDB4ZmZdIDw8IDgpIHwgU0JPWFtzMiAmIDB4ZmZdKSBeIGtleVNjaGVkdWxlW2tzUm93KytdO1xuXG5cdCAgICAgICAgICAgIC8vIFNldCBvdXRwdXRcblx0ICAgICAgICAgICAgTVtvZmZzZXRdICAgICA9IHQwO1xuXHQgICAgICAgICAgICBNW29mZnNldCArIDFdID0gdDE7XG5cdCAgICAgICAgICAgIE1bb2Zmc2V0ICsgMl0gPSB0Mjtcblx0ICAgICAgICAgICAgTVtvZmZzZXQgKyAzXSA9IHQzO1xuXHQgICAgICAgIH0sXG5cblx0ICAgICAgICBrZXlTaXplOiAyNTYvMzJcblx0ICAgIH0pO1xuXG5cdCAgICAvKipcblx0ICAgICAqIFNob3J0Y3V0IGZ1bmN0aW9ucyB0byB0aGUgY2lwaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgY2lwaGVydGV4dCA9IENyeXB0b0pTLkFFUy5lbmNyeXB0KG1lc3NhZ2UsIGtleSwgY2ZnKTtcblx0ICAgICAqICAgICB2YXIgcGxhaW50ZXh0ICA9IENyeXB0b0pTLkFFUy5kZWNyeXB0KGNpcGhlcnRleHQsIGtleSwgY2ZnKTtcblx0ICAgICAqL1xuXHQgICAgQy5BRVMgPSBCbG9ja0NpcGhlci5fY3JlYXRlSGVscGVyKEFFUyk7XG5cdH0oKSk7XG5cblxuXHRyZXR1cm4gQ3J5cHRvSlMuQUVTO1xuXG59KSk7XG5cbi8qKiovIH0pLFxuLyogNjEgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuOyhmdW5jdGlvbiAocm9vdCwgZmFjdG9yeSkge1xuXHRpZiAodHJ1ZSkge1xuXHRcdC8vIENvbW1vbkpTXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBleHBvcnRzID0gZmFjdG9yeShfX3dlYnBhY2tfcmVxdWlyZV9fKDYpKTtcblx0fVxuXHRlbHNlIHt9XG59KHRoaXMsIGZ1bmN0aW9uIChDcnlwdG9KUykge1xuXG5cdChmdW5jdGlvbiAoTWF0aCkge1xuXHQgICAgLy8gU2hvcnRjdXRzXG5cdCAgICB2YXIgQyA9IENyeXB0b0pTO1xuXHQgICAgdmFyIENfbGliID0gQy5saWI7XG5cdCAgICB2YXIgV29yZEFycmF5ID0gQ19saWIuV29yZEFycmF5O1xuXHQgICAgdmFyIEhhc2hlciA9IENfbGliLkhhc2hlcjtcblx0ICAgIHZhciBDX2FsZ28gPSBDLmFsZ287XG5cblx0ICAgIC8vIENvbnN0YW50cyB0YWJsZVxuXHQgICAgdmFyIFQgPSBbXTtcblxuXHQgICAgLy8gQ29tcHV0ZSBjb25zdGFudHNcblx0ICAgIChmdW5jdGlvbiAoKSB7XG5cdCAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA2NDsgaSsrKSB7XG5cdCAgICAgICAgICAgIFRbaV0gPSAoTWF0aC5hYnMoTWF0aC5zaW4oaSArIDEpKSAqIDB4MTAwMDAwMDAwKSB8IDA7XG5cdCAgICAgICAgfVxuXHQgICAgfSgpKTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBNRDUgaGFzaCBhbGdvcml0aG0uXG5cdCAgICAgKi9cblx0ICAgIHZhciBNRDUgPSBDX2FsZ28uTUQ1ID0gSGFzaGVyLmV4dGVuZCh7XG5cdCAgICAgICAgX2RvUmVzZXQ6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdGhpcy5faGFzaCA9IG5ldyBXb3JkQXJyYXkuaW5pdChbXG5cdCAgICAgICAgICAgICAgICAweDY3NDUyMzAxLCAweGVmY2RhYjg5LFxuXHQgICAgICAgICAgICAgICAgMHg5OGJhZGNmZSwgMHgxMDMyNTQ3NlxuXHQgICAgICAgICAgICBdKTtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvUHJvY2Vzc0Jsb2NrOiBmdW5jdGlvbiAoTSwgb2Zmc2V0KSB7XG5cdCAgICAgICAgICAgIC8vIFN3YXAgZW5kaWFuXG5cdCAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMTY7IGkrKykge1xuXHQgICAgICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgICAgICB2YXIgb2Zmc2V0X2kgPSBvZmZzZXQgKyBpO1xuXHQgICAgICAgICAgICAgICAgdmFyIE1fb2Zmc2V0X2kgPSBNW29mZnNldF9pXTtcblxuXHQgICAgICAgICAgICAgICAgTVtvZmZzZXRfaV0gPSAoXG5cdCAgICAgICAgICAgICAgICAgICAgKCgoTV9vZmZzZXRfaSA8PCA4KSAgfCAoTV9vZmZzZXRfaSA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICAgICAoKChNX29mZnNldF9pIDw8IDI0KSB8IChNX29mZnNldF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMClcblx0ICAgICAgICAgICAgICAgICk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIEggPSB0aGlzLl9oYXNoLndvcmRzO1xuXG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8wICA9IE1bb2Zmc2V0ICsgMF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xICA9IE1bb2Zmc2V0ICsgMV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8yICA9IE1bb2Zmc2V0ICsgMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8zICA9IE1bb2Zmc2V0ICsgM107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF80ICA9IE1bb2Zmc2V0ICsgNF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF81ICA9IE1bb2Zmc2V0ICsgNV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF82ICA9IE1bb2Zmc2V0ICsgNl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF83ICA9IE1bb2Zmc2V0ICsgN107XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF84ICA9IE1bb2Zmc2V0ICsgOF07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF85ICA9IE1bb2Zmc2V0ICsgOV07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMCA9IE1bb2Zmc2V0ICsgMTBdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTEgPSBNW29mZnNldCArIDExXTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzEyID0gTVtvZmZzZXQgKyAxMl07XG5cdCAgICAgICAgICAgIHZhciBNX29mZnNldF8xMyA9IE1bb2Zmc2V0ICsgMTNdO1xuXHQgICAgICAgICAgICB2YXIgTV9vZmZzZXRfMTQgPSBNW29mZnNldCArIDE0XTtcblx0ICAgICAgICAgICAgdmFyIE1fb2Zmc2V0XzE1ID0gTVtvZmZzZXQgKyAxNV07XG5cblx0ICAgICAgICAgICAgLy8gV29ya2luZyB2YXJpYWxiZXNcblx0ICAgICAgICAgICAgdmFyIGEgPSBIWzBdO1xuXHQgICAgICAgICAgICB2YXIgYiA9IEhbMV07XG5cdCAgICAgICAgICAgIHZhciBjID0gSFsyXTtcblx0ICAgICAgICAgICAgdmFyIGQgPSBIWzNdO1xuXG5cdCAgICAgICAgICAgIC8vIENvbXB1dGF0aW9uXG5cdCAgICAgICAgICAgIGEgPSBGRihhLCBiLCBjLCBkLCBNX29mZnNldF8wLCAgNywgIFRbMF0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMSwgIDEyLCBUWzFdKTtcblx0ICAgICAgICAgICAgYyA9IEZGKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzIsICAxNywgVFsyXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8zLCAgMjIsIFRbM10pO1xuXHQgICAgICAgICAgICBhID0gRkYoYSwgYiwgYywgZCwgTV9vZmZzZXRfNCwgIDcsICBUWzRdKTtcblx0ICAgICAgICAgICAgZCA9IEZGKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzUsICAxMiwgVFs1XSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF82LCAgMTcsIFRbNl0pO1xuXHQgICAgICAgICAgICBiID0gRkYoYiwgYywgZCwgYSwgTV9vZmZzZXRfNywgIDIyLCBUWzddKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzgsICA3LCAgVFs4XSk7XG5cdCAgICAgICAgICAgIGQgPSBGRihkLCBhLCBiLCBjLCBNX29mZnNldF85LCAgMTIsIFRbOV0pO1xuXHQgICAgICAgICAgICBjID0gRkYoYywgZCwgYSwgYiwgTV9vZmZzZXRfMTAsIDE3LCBUWzEwXSk7XG5cdCAgICAgICAgICAgIGIgPSBGRihiLCBjLCBkLCBhLCBNX29mZnNldF8xMSwgMjIsIFRbMTFdKTtcblx0ICAgICAgICAgICAgYSA9IEZGKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEyLCA3LCAgVFsxMl0pO1xuXHQgICAgICAgICAgICBkID0gRkYoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTMsIDEyLCBUWzEzXSk7XG5cdCAgICAgICAgICAgIGMgPSBGRihjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTcsIFRbMTRdKTtcblx0ICAgICAgICAgICAgYiA9IEZGKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzE1LCAyMiwgVFsxNV0pO1xuXG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNSwgIFRbMTZdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzYsICA5LCAgVFsxN10pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfMTEsIDE0LCBUWzE4XSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8wLCAgMjAsIFRbMTldKTtcblx0ICAgICAgICAgICAgYSA9IEdHKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzUsICA1LCAgVFsyMF0pO1xuXHQgICAgICAgICAgICBkID0gR0coZCwgYSwgYiwgYywgTV9vZmZzZXRfMTAsIDksICBUWzIxXSk7XG5cdCAgICAgICAgICAgIGMgPSBHRyhjLCBkLCBhLCBiLCBNX29mZnNldF8xNSwgMTQsIFRbMjJdKTtcblx0ICAgICAgICAgICAgYiA9IEdHKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzQsICAyMCwgVFsyM10pO1xuXHQgICAgICAgICAgICBhID0gR0coYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDUsICBUWzI0XSk7XG5cdCAgICAgICAgICAgIGQgPSBHRyhkLCBhLCBiLCBjLCBNX29mZnNldF8xNCwgOSwgIFRbMjVdKTtcblx0ICAgICAgICAgICAgYyA9IEdHKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzMsICAxNCwgVFsyNl0pO1xuXHQgICAgICAgICAgICBiID0gR0coYiwgYywgZCwgYSwgTV9vZmZzZXRfOCwgIDIwLCBUWzI3XSk7XG5cdCAgICAgICAgICAgIGEgPSBHRyhhLCBiLCBjLCBkLCBNX29mZnNldF8xMywgNSwgIFRbMjhdKTtcblx0ICAgICAgICAgICAgZCA9IEdHKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzIsICA5LCAgVFsyOV0pO1xuXHQgICAgICAgICAgICBjID0gR0coYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE0LCBUWzMwXSk7XG5cdCAgICAgICAgICAgIGIgPSBHRyhiLCBjLCBkLCBhLCBNX29mZnNldF8xMiwgMjAsIFRbMzFdKTtcblxuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfNSwgIDQsICBUWzMyXSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF84LCAgMTEsIFRbMzNdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzExLCAxNiwgVFszNF0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMTQsIDIzLCBUWzM1XSk7XG5cdCAgICAgICAgICAgIGEgPSBISChhLCBiLCBjLCBkLCBNX29mZnNldF8xLCAgNCwgIFRbMzZdKTtcblx0ICAgICAgICAgICAgZCA9IEhIKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzQsICAxMSwgVFszN10pO1xuXHQgICAgICAgICAgICBjID0gSEgoYywgZCwgYSwgYiwgTV9vZmZzZXRfNywgIDE2LCBUWzM4XSk7XG5cdCAgICAgICAgICAgIGIgPSBISChiLCBjLCBkLCBhLCBNX29mZnNldF8xMCwgMjMsIFRbMzldKTtcblx0ICAgICAgICAgICAgYSA9IEhIKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzEzLCA0LCAgVFs0MF0pO1xuXHQgICAgICAgICAgICBkID0gSEgoZCwgYSwgYiwgYywgTV9vZmZzZXRfMCwgIDExLCBUWzQxXSk7XG5cdCAgICAgICAgICAgIGMgPSBISChjLCBkLCBhLCBiLCBNX29mZnNldF8zLCAgMTYsIFRbNDJdKTtcblx0ICAgICAgICAgICAgYiA9IEhIKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzYsICAyMywgVFs0M10pO1xuXHQgICAgICAgICAgICBhID0gSEgoYSwgYiwgYywgZCwgTV9vZmZzZXRfOSwgIDQsICBUWzQ0XSk7XG5cdCAgICAgICAgICAgIGQgPSBISChkLCBhLCBiLCBjLCBNX29mZnNldF8xMiwgMTEsIFRbNDVdKTtcblx0ICAgICAgICAgICAgYyA9IEhIKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzE1LCAxNiwgVFs0Nl0pO1xuXHQgICAgICAgICAgICBiID0gSEgoYiwgYywgZCwgYSwgTV9vZmZzZXRfMiwgIDIzLCBUWzQ3XSk7XG5cblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzAsICA2LCAgVFs0OF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfNywgIDEwLCBUWzQ5XSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8xNCwgMTUsIFRbNTBdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzUsICAyMSwgVFs1MV0pO1xuXHQgICAgICAgICAgICBhID0gSUkoYSwgYiwgYywgZCwgTV9vZmZzZXRfMTIsIDYsICBUWzUyXSk7XG5cdCAgICAgICAgICAgIGQgPSBJSShkLCBhLCBiLCBjLCBNX29mZnNldF8zLCAgMTAsIFRbNTNdKTtcblx0ICAgICAgICAgICAgYyA9IElJKGMsIGQsIGEsIGIsIE1fb2Zmc2V0XzEwLCAxNSwgVFs1NF0pO1xuXHQgICAgICAgICAgICBiID0gSUkoYiwgYywgZCwgYSwgTV9vZmZzZXRfMSwgIDIxLCBUWzU1XSk7XG5cdCAgICAgICAgICAgIGEgPSBJSShhLCBiLCBjLCBkLCBNX29mZnNldF84LCAgNiwgIFRbNTZdKTtcblx0ICAgICAgICAgICAgZCA9IElJKGQsIGEsIGIsIGMsIE1fb2Zmc2V0XzE1LCAxMCwgVFs1N10pO1xuXHQgICAgICAgICAgICBjID0gSUkoYywgZCwgYSwgYiwgTV9vZmZzZXRfNiwgIDE1LCBUWzU4XSk7XG5cdCAgICAgICAgICAgIGIgPSBJSShiLCBjLCBkLCBhLCBNX29mZnNldF8xMywgMjEsIFRbNTldKTtcblx0ICAgICAgICAgICAgYSA9IElJKGEsIGIsIGMsIGQsIE1fb2Zmc2V0XzQsICA2LCAgVFs2MF0pO1xuXHQgICAgICAgICAgICBkID0gSUkoZCwgYSwgYiwgYywgTV9vZmZzZXRfMTEsIDEwLCBUWzYxXSk7XG5cdCAgICAgICAgICAgIGMgPSBJSShjLCBkLCBhLCBiLCBNX29mZnNldF8yLCAgMTUsIFRbNjJdKTtcblx0ICAgICAgICAgICAgYiA9IElJKGIsIGMsIGQsIGEsIE1fb2Zmc2V0XzksICAyMSwgVFs2M10pO1xuXG5cdCAgICAgICAgICAgIC8vIEludGVybWVkaWF0ZSBoYXNoIHZhbHVlXG5cdCAgICAgICAgICAgIEhbMF0gPSAoSFswXSArIGEpIHwgMDtcblx0ICAgICAgICAgICAgSFsxXSA9IChIWzFdICsgYikgfCAwO1xuXHQgICAgICAgICAgICBIWzJdID0gKEhbMl0gKyBjKSB8IDA7XG5cdCAgICAgICAgICAgIEhbM10gPSAoSFszXSArIGQpIHwgMDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgX2RvRmluYWxpemU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgLy8gU2hvcnRjdXRzXG5cdCAgICAgICAgICAgIHZhciBkYXRhID0gdGhpcy5fZGF0YTtcblx0ICAgICAgICAgICAgdmFyIGRhdGFXb3JkcyA9IGRhdGEud29yZHM7XG5cblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWwgPSB0aGlzLl9uRGF0YUJ5dGVzICogODtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzTGVmdCA9IGRhdGEuc2lnQnl0ZXMgKiA4O1xuXG5cdCAgICAgICAgICAgIC8vIEFkZCBwYWRkaW5nXG5cdCAgICAgICAgICAgIGRhdGFXb3Jkc1tuQml0c0xlZnQgPj4+IDVdIHw9IDB4ODAgPDwgKDI0IC0gbkJpdHNMZWZ0ICUgMzIpO1xuXG5cdCAgICAgICAgICAgIHZhciBuQml0c1RvdGFsSCA9IE1hdGguZmxvb3IobkJpdHNUb3RhbCAvIDB4MTAwMDAwMDAwKTtcblx0ICAgICAgICAgICAgdmFyIG5CaXRzVG90YWxMID0gbkJpdHNUb3RhbDtcblx0ICAgICAgICAgICAgZGF0YVdvcmRzWygoKG5CaXRzTGVmdCArIDY0KSA+Pj4gOSkgPDwgNCkgKyAxNV0gPSAoXG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCA4KSAgfCAobkJpdHNUb3RhbEggPj4+IDI0KSkgJiAweDAwZmYwMGZmKSB8XG5cdCAgICAgICAgICAgICAgICAoKChuQml0c1RvdGFsSCA8PCAyNCkgfCAobkJpdHNUb3RhbEggPj4+IDgpKSAgJiAweGZmMDBmZjAwKVxuXHQgICAgICAgICAgICApO1xuXHQgICAgICAgICAgICBkYXRhV29yZHNbKCgobkJpdHNMZWZ0ICsgNjQpID4+PiA5KSA8PCA0KSArIDE0XSA9IChcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDgpICB8IChuQml0c1RvdGFsTCA+Pj4gMjQpKSAmIDB4MDBmZjAwZmYpIHxcblx0ICAgICAgICAgICAgICAgICgoKG5CaXRzVG90YWxMIDw8IDI0KSB8IChuQml0c1RvdGFsTCA+Pj4gOCkpICAmIDB4ZmYwMGZmMDApXG5cdCAgICAgICAgICAgICk7XG5cblx0ICAgICAgICAgICAgZGF0YS5zaWdCeXRlcyA9IChkYXRhV29yZHMubGVuZ3RoICsgMSkgKiA0O1xuXG5cdCAgICAgICAgICAgIC8vIEhhc2ggZmluYWwgYmxvY2tzXG5cdCAgICAgICAgICAgIHRoaXMuX3Byb2Nlc3MoKTtcblxuXHQgICAgICAgICAgICAvLyBTaG9ydGN1dHNcblx0ICAgICAgICAgICAgdmFyIGhhc2ggPSB0aGlzLl9oYXNoO1xuXHQgICAgICAgICAgICB2YXIgSCA9IGhhc2gud29yZHM7XG5cblx0ICAgICAgICAgICAgLy8gU3dhcCBlbmRpYW5cblx0ICAgICAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCA0OyBpKyspIHtcblx0ICAgICAgICAgICAgICAgIC8vIFNob3J0Y3V0XG5cdCAgICAgICAgICAgICAgICB2YXIgSF9pID0gSFtpXTtcblxuXHQgICAgICAgICAgICAgICAgSFtpXSA9ICgoKEhfaSA8PCA4KSAgfCAoSF9pID4+PiAyNCkpICYgMHgwMGZmMDBmZikgfFxuXHQgICAgICAgICAgICAgICAgICAgICAgICgoKEhfaSA8PCAyNCkgfCAoSF9pID4+PiA4KSkgICYgMHhmZjAwZmYwMCk7XG5cdCAgICAgICAgICAgIH1cblxuXHQgICAgICAgICAgICAvLyBSZXR1cm4gZmluYWwgY29tcHV0ZWQgaGFzaFxuXHQgICAgICAgICAgICByZXR1cm4gaGFzaDtcblx0ICAgICAgICB9LFxuXG5cdCAgICAgICAgY2xvbmU6IGZ1bmN0aW9uICgpIHtcblx0ICAgICAgICAgICAgdmFyIGNsb25lID0gSGFzaGVyLmNsb25lLmNhbGwodGhpcyk7XG5cdCAgICAgICAgICAgIGNsb25lLl9oYXNoID0gdGhpcy5faGFzaC5jbG9uZSgpO1xuXG5cdCAgICAgICAgICAgIHJldHVybiBjbG9uZTtcblx0ICAgICAgICB9XG5cdCAgICB9KTtcblxuXHQgICAgZnVuY3Rpb24gRkYoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGMpIHwgKH5iICYgZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gR0coYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArICgoYiAmIGQpIHwgKGMgJiB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSEgoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChiIF4gYyBeIGQpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgZnVuY3Rpb24gSUkoYSwgYiwgYywgZCwgeCwgcywgdCkge1xuXHQgICAgICAgIHZhciBuID0gYSArIChjIF4gKGIgfCB+ZCkpICsgeCArIHQ7XG5cdCAgICAgICAgcmV0dXJuICgobiA8PCBzKSB8IChuID4+PiAoMzIgLSBzKSkpICsgYjtcblx0ICAgIH1cblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgaGFzaGVyJ3Mgb2JqZWN0IGludGVyZmFjZS5cblx0ICAgICAqXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IG1lc3NhZ2UgVGhlIG1lc3NhZ2UgdG8gaGFzaC5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBoYXNoLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaGFzaCA9IENyeXB0b0pTLk1ENSgnbWVzc2FnZScpO1xuXHQgICAgICogICAgIHZhciBoYXNoID0gQ3J5cHRvSlMuTUQ1KHdvcmRBcnJheSk7XG5cdCAgICAgKi9cblx0ICAgIEMuTUQ1ID0gSGFzaGVyLl9jcmVhdGVIZWxwZXIoTUQ1KTtcblxuXHQgICAgLyoqXG5cdCAgICAgKiBTaG9ydGN1dCBmdW5jdGlvbiB0byB0aGUgSE1BQydzIG9iamVjdCBpbnRlcmZhY2UuXG5cdCAgICAgKlxuXHQgICAgICogQHBhcmFtIHtXb3JkQXJyYXl8c3RyaW5nfSBtZXNzYWdlIFRoZSBtZXNzYWdlIHRvIGhhc2guXG5cdCAgICAgKiBAcGFyYW0ge1dvcmRBcnJheXxzdHJpbmd9IGtleSBUaGUgc2VjcmV0IGtleS5cblx0ICAgICAqXG5cdCAgICAgKiBAcmV0dXJuIHtXb3JkQXJyYXl9IFRoZSBITUFDLlxuXHQgICAgICpcblx0ICAgICAqIEBzdGF0aWNcblx0ICAgICAqXG5cdCAgICAgKiBAZXhhbXBsZVxuXHQgICAgICpcblx0ICAgICAqICAgICB2YXIgaG1hYyA9IENyeXB0b0pTLkhtYWNNRDUobWVzc2FnZSwga2V5KTtcblx0ICAgICAqL1xuXHQgICAgQy5IbWFjTUQ1ID0gSGFzaGVyLl9jcmVhdGVIbWFjSGVscGVyKE1ENSk7XG5cdH0oTWF0aCkpO1xuXG5cblx0cmV0dXJuIENyeXB0b0pTLk1ENTtcblxufSkpO1xuXG4vKioqLyB9KSxcbi8qIDYyICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG52YXIgX2E7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG52YXIgZGVmYXVsdHNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oOCkpO1xudmFyIGVycm9yaW5mb18xID0gX193ZWJwYWNrX3JlcXVpcmVfXyg0KTtcbnZhciBIdHRwTWV0aG9kc18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXygxOCkpO1xudmFyIHhocnJlcXVlc3RfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMTYpKTtcbnZhciBYSFJTdGF0ZXNfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMjEpKTtcbnZhciBsb2dnZXJfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMikpO1xudmFyIGpzb25wdHJhbnNwb3J0XzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDI5KTtcbnZhciBmZXRjaHJlcXVlc3RfMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oNjMpKTtcbnZhciBIdHRwU3RhdHVzQ29kZXNfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMjUpO1xuZnVuY3Rpb24gc2hvdWxkRmFsbGJhY2soZXJyb3JJbmZvKSB7XG4gICAgdmFyIHN0YXR1c0NvZGUgPSBlcnJvckluZm8uc3RhdHVzQ29kZTtcbiAgICAvKiA0MDAgKyBubyBjb2RlID0gYSBnZW5lcmljIHhociBvbmVycm9yLiBCcm93c2VyIGRvZXNuJ3QgZ2l2ZSB1cyBlbm91Z2hcbiAgICAgKiBkZXRhaWwgdG8ga25vdyB3aGV0aGVyIGl0J3MgZmFsbGJhY2stZml4YWJsZSwgYnV0IGl0IG1heSBiZSAoZWcgaWYgYVxuICAgICAqIG5ldHdvcmsgaXNzdWUpLCBzbyB0cnkganVzdCBpbiBjYXNlICovXG4gICAgcmV0dXJuICgoc3RhdHVzQ29kZSA9PT0gNDA4ICYmICFlcnJvckluZm8uY29kZSkgfHxcbiAgICAgICAgKHN0YXR1c0NvZGUgPT09IDQwMCAmJiAhZXJyb3JJbmZvLmNvZGUpIHx8XG4gICAgICAgIChzdGF0dXNDb2RlID49IDUwMCAmJiBzdGF0dXNDb2RlIDw9IDUwNCkpO1xufVxuZnVuY3Rpb24gZ2V0SG9zdHMoY2xpZW50KSB7XG4gICAgLyogSWYgd2UncmUgYSBjb25uZWN0ZWQgcmVhbHRpbWUgY2xpZW50LCB0cnkgdGhlIGVuZHBvaW50IHdlJ3JlIGNvbm5lY3RlZFxuICAgICAqIHRvIGZpcnN0IC0tIGJ1dCBzdGlsbCBoYXZlIGZhbGxiYWNrcywgYmVpbmcgY29ubmVjdGVkIGlzIG5vdCBhbiBhYnNvbHV0ZVxuICAgICAqIGd1YXJhbnRlZSB0aGF0IGEgZGF0YWNlbnRlciBoYXMgZnJlZSBjYXBhY2l0eSB0byBzZXJ2aWNlIFJFU1QgcmVxdWVzdHMuICovXG4gICAgdmFyIGNvbm5lY3Rpb24gPSBjbGllbnQuY29ubmVjdGlvbiwgY29ubmVjdGlvbkhvc3QgPSBjb25uZWN0aW9uICYmIGNvbm5lY3Rpb24uY29ubmVjdGlvbk1hbmFnZXIuaG9zdDtcbiAgICBpZiAoY29ubmVjdGlvbkhvc3QpIHtcbiAgICAgICAgcmV0dXJuIFtjb25uZWN0aW9uSG9zdF0uY29uY2F0KGRlZmF1bHRzXzEuZGVmYXVsdC5nZXRGYWxsYmFja0hvc3RzKGNsaWVudC5vcHRpb25zKSk7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0c18xLmRlZmF1bHQuZ2V0SG9zdHMoY2xpZW50Lm9wdGlvbnMpO1xufVxudmFyIEh0dHAgPSAoX2EgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGZ1bmN0aW9uIGNsYXNzXzEob3B0aW9ucykge1xuICAgICAgICAgICAgdGhpcy5jaGVja3NJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aXZpdHkgPSB1bmRlZmluZWQ7XG4gICAgICAgICAgICB0aGlzLnN1cHBvcnRzQXV0aEhlYWRlcnMgPSBmYWxzZTtcbiAgICAgICAgICAgIHRoaXMuc3VwcG9ydHNMaW5rSGVhZGVycyA9IGZhbHNlO1xuICAgICAgICAgICAgdGhpcy5fZ2V0SG9zdHMgPSBnZXRIb3N0cztcbiAgICAgICAgICAgIHRoaXMub3B0aW9ucyA9IG9wdGlvbnMgfHwge307XG4gICAgICAgICAgICB2YXIgY29ubmVjdGl2aXR5Q2hlY2tVcmwgPSB0aGlzLm9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmwgfHwgZGVmYXVsdHNfMS5kZWZhdWx0LmNvbm5lY3Rpdml0eUNoZWNrVXJsO1xuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zID0gdGhpcy5vcHRpb25zLmNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zO1xuICAgICAgICAgICAgdmFyIGNvbm5lY3Rpdml0eVVybElzRGVmYXVsdCA9ICF0aGlzLm9wdGlvbnMuY29ubmVjdGl2aXR5Q2hlY2tVcmw7XG4gICAgICAgICAgICBpZiAocGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy54aHJTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1cHBvcnRzQXV0aEhlYWRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuUmVxdWVzdCA9IGZ1bmN0aW9uIChtZXRob2QsIHJlc3QsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICB2YXIgcmVxID0geGhycmVxdWVzdF8xLmRlZmF1bHQuY3JlYXRlUmVxdWVzdCh1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgWEhSU3RhdGVzXzEuZGVmYXVsdC5SRVFfU0VORCwgcmVzdCAmJiByZXN0Lm9wdGlvbnMudGltZW91dHMsIG1ldGhvZCk7XG4gICAgICAgICAgICAgICAgICAgIHJlcS5vbmNlKCdjb21wbGV0ZScsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLmV4ZWMoKTtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHJlcTtcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICh0aGlzLm9wdGlvbnMuZGlzYWJsZUNvbm5lY3Rpdml0eUNoZWNrKSB7XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuY2hlY2tDb25uZWN0aXZpdHkgPSBmdW5jdGlvbiAoY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpdml0eSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgbG9nZ2VyXzEuZGVmYXVsdC5sb2dBY3Rpb24obG9nZ2VyXzEuZGVmYXVsdC5MT0dfTUlDUk8sICcoWEhSUmVxdWVzdClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCknLCAnU2VuZGluZzsgJyArIGNvbm5lY3Rpdml0eUNoZWNrVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuZG9VcmkoSHR0cE1ldGhvZHNfMS5kZWZhdWx0LkdldCwgbnVsbCwgY29ubmVjdGl2aXR5Q2hlY2tVcmwsIG51bGwsIG51bGwsIGNvbm5lY3Rpdml0eUNoZWNrUGFyYW1zLCBmdW5jdGlvbiAoZXJyLCByZXNwb25zZVRleHQsIGhlYWRlcnMsIHVucGFja2VkLCBzdGF0dXNDb2RlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghY29ubmVjdGl2aXR5VXJsSXNEZWZhdWx0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdCA9ICFlcnIgJiYgKDAsIEh0dHBTdGF0dXNDb2Rlc18xLmlzU3VjY2Vzc0NvZGUpKHN0YXR1c0NvZGUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0ID0gIWVyciAmJiAocmVzcG9uc2VUZXh0ID09PSBudWxsIHx8IHJlc3BvbnNlVGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2VUZXh0LnJlcGxhY2UoL1xcbi8sICcnKSkgPT0gJ3llcyc7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnKFhIUlJlcXVlc3QpSHR0cC5jaGVja0Nvbm5lY3Rpdml0eSgpJywgJ1Jlc3VsdDogJyArIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuanNvbnBTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLlJlcXVlc3QgPSBmdW5jdGlvbiAobWV0aG9kLCByZXN0LCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9ICgwLCBqc29ucHRyYW5zcG9ydF8xLmNyZWF0ZVJlcXVlc3QpKHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBYSFJTdGF0ZXNfMS5kZWZhdWx0LlJFUV9TRU5ELCByZXN0ICYmIHJlc3Qub3B0aW9ucy50aW1lb3V0cywgbWV0aG9kKTtcbiAgICAgICAgICAgICAgICAgICAgcmVxLm9uY2UoJ2NvbXBsZXRlJywgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgICAgICBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLm5leHRUaWNrKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcS5leGVjKCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm4gcmVxO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKHRoaXMub3B0aW9ucy5kaXNhYmxlQ29ubmVjdGl2aXR5Q2hlY2spIHtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpdml0eSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrQ29ubmVjdGl2aXR5ID0gZnVuY3Rpb24gKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHVwVXJsID0gZGVmYXVsdHNfMS5kZWZhdWx0Lmpzb25wSW50ZXJuZXRVcFVybDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICh0aGlzLmNoZWNrc0luUHJvZ3Jlc3MpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aGlzLmNoZWNrc0luUHJvZ3Jlc3MucHVzaChjYWxsYmFjayk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5jaGVja3NJblByb2dyZXNzID0gW2NhbGxiYWNrXTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGxvZ2dlcl8xLmRlZmF1bHQubG9nQWN0aW9uKGxvZ2dlcl8xLmRlZmF1bHQuTE9HX01JQ1JPLCAnKEpTT05QKUh0dHAuY2hlY2tDb25uZWN0aXZpdHkoKScsICdTZW5kaW5nOyAnICsgdXBVcmwpO1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIHJlcSA9IG5ldyBqc29ucHRyYW5zcG9ydF8xLlJlcXVlc3QoJ2lzVGhlSW50ZXJuZXRVcCcsIHVwVXJsLCBudWxsLCBudWxsLCBudWxsLCBYSFJTdGF0ZXNfMS5kZWZhdWx0LlJFUV9TRU5ELCBkZWZhdWx0c18xLmRlZmF1bHQuVElNRU9VVFMpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVxLm9uY2UoJ2NvbXBsZXRlJywgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2UpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gIWVyciAmJiByZXNwb25zZTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJyhKU09OUClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCknLCAnUmVzdWx0OiAnICsgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IF90aGlzLmNoZWNrc0luUHJvZ3Jlc3MubGVuZ3RoOyBpKyspXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF90aGlzLmNoZWNrc0luUHJvZ3Jlc3NbaV0obnVsbCwgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfdGhpcy5jaGVja3NJblByb2dyZXNzID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICAgICAgcGxhdGZvcm1fMS5kZWZhdWx0LkNvbmZpZy5uZXh0VGljayhmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVxLmV4ZWMoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHBsYXRmb3JtXzEuZGVmYXVsdC5Db25maWcuZmV0Y2hTdXBwb3J0ZWQpIHtcbiAgICAgICAgICAgICAgICB0aGlzLnN1cHBvcnRzQXV0aEhlYWRlcnMgPSB0cnVlO1xuICAgICAgICAgICAgICAgIHRoaXMuUmVxdWVzdCA9IGZldGNocmVxdWVzdF8xLmRlZmF1bHQ7XG4gICAgICAgICAgICAgICAgdGhpcy5jaGVja0Nvbm5lY3Rpdml0eSA9IGZ1bmN0aW9uIChjYWxsYmFjaykge1xuICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJyhGZXRjaClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCknLCAnU2VuZGluZzsgJyArIGNvbm5lY3Rpdml0eUNoZWNrVXJsKTtcbiAgICAgICAgICAgICAgICAgICAgdGhpcy5kb1VyaShIdHRwTWV0aG9kc18xLmRlZmF1bHQuR2V0LCBudWxsLCBjb25uZWN0aXZpdHlDaGVja1VybCwgbnVsbCwgbnVsbCwgbnVsbCwgZnVuY3Rpb24gKGVyciwgcmVzcG9uc2VUZXh0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgcmVzdWx0ID0gIWVyciAmJiAocmVzcG9uc2VUZXh0ID09PSBudWxsIHx8IHJlc3BvbnNlVGV4dCA9PT0gdm9pZCAwID8gdm9pZCAwIDogcmVzcG9uc2VUZXh0LnJlcGxhY2UoL1xcbi8sICcnKSkgPT0gJ3llcyc7XG4gICAgICAgICAgICAgICAgICAgICAgICBsb2dnZXJfMS5kZWZhdWx0LmxvZ0FjdGlvbihsb2dnZXJfMS5kZWZhdWx0LkxPR19NSUNSTywgJyhGZXRjaClIdHRwLmNoZWNrQ29ubmVjdGl2aXR5KCknLCAnUmVzdWx0OiAnICsgcmVzdWx0KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIHJlc3VsdCk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICB0aGlzLlJlcXVlc3QgPSBmdW5jdGlvbiAobWV0aG9kLCByZXN0LCB1cmksIGhlYWRlcnMsIHBhcmFtcywgYm9keSwgY2FsbGJhY2spIHtcbiAgICAgICAgICAgICAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ25vIHN1cHBvcnRlZCBIVFRQIHRyYW5zcG9ydHMgYXZhaWxhYmxlJywgbnVsbCwgNDAwKSwgbnVsbCk7XG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAvKiBVbmxpa2UgZm9yIGRvVXJpLCB0aGUgJ3Jlc3QnIHBhcmFtIGhlcmUgaXMgbWFuZGF0b3J5LCBhcyBpdCdzIHVzZWQgdG8gZ2VuZXJhdGUgdGhlIGhvc3RzICovXG4gICAgICAgIGNsYXNzXzEucHJvdG90eXBlLmRvID0gZnVuY3Rpb24gKG1ldGhvZCwgcmVzdCwgcGF0aCwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgdmFyIF90aGlzID0gdGhpcztcbiAgICAgICAgICAgIHZhciB1cmlGcm9tSG9zdCA9IHR5cGVvZiBwYXRoID09ICdmdW5jdGlvbidcbiAgICAgICAgICAgICAgICA/IHBhdGhcbiAgICAgICAgICAgICAgICA6IGZ1bmN0aW9uIChob3N0KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiByZXN0LmJhc2VVcmkoaG9zdCkgKyBwYXRoO1xuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB2YXIgY3VycmVudEZhbGxiYWNrID0gcmVzdC5fY3VycmVudEZhbGxiYWNrO1xuICAgICAgICAgICAgaWYgKGN1cnJlbnRGYWxsYmFjaykge1xuICAgICAgICAgICAgICAgIGlmIChjdXJyZW50RmFsbGJhY2sudmFsaWRVbnRpbCA+IFV0aWxzLm5vdygpKSB7XG4gICAgICAgICAgICAgICAgICAgIC8qIFVzZSBzdG9yZWQgZmFsbGJhY2sgKi9cbiAgICAgICAgICAgICAgICAgICAgaWYgKCF0aGlzLlJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhbGxiYWNrID09PSBudWxsIHx8IGNhbGxiYWNrID09PSB2b2lkIDAgPyB2b2lkIDAgOiBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygnUmVxdWVzdCBpbnZva2VkIGJlZm9yZSBhc3NpZ25lZCB0bycsIG51bGwsIDUwMCkpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHRoaXMuUmVxdWVzdChtZXRob2QsIHJlc3QsIHVyaUZyb21Ib3N0KGN1cnJlbnRGYWxsYmFjay5ob3N0KSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICB2YXIgYXJncyA9IFtdO1xuICAgICAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhcmdzW19pIC0gMV0gPSBhcmd1bWVudHNbX2ldO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB0eXBlY2FzdCBpcyBzYWZlIGJlY2F1c2UgRXJybm9FeGNlcHRpb25zIGFyZSBvbmx5IHRocm93biBpbiBOb2RlSlNcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlcnIgJiYgc2hvdWxkRmFsbGJhY2soZXJyKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8qIHVuc3RvcmUgdGhlIGZhbGxiYWNrIGFuZCBzdGFydCBmcm9tIHRoZSB0b3Agd2l0aCB0aGUgZGVmYXVsdCBzZXF1ZW5jZSAqL1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3QuX2N1cnJlbnRGYWxsYmFjayA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3RoaXMuZG8obWV0aG9kLCByZXN0LCBwYXRoLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGNhbGxiYWNrKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2suYXBwbHkodm9pZCAwLCB0c2xpYl8xLl9fc3ByZWFkQXJyYXkoW2Vycl0sIGFyZ3MsIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAvKiBGYWxsYmFjayBleHBpcmVkOyByZW1vdmUgaXQgYW5kIGZhbGx0aHJvdWdoIHRvIG5vcm1hbCBzZXF1ZW5jZSAqL1xuICAgICAgICAgICAgICAgICAgICByZXN0Ll9jdXJyZW50RmFsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHZhciBob3N0cyA9IGdldEhvc3RzKHJlc3QpO1xuICAgICAgICAgICAgLyogaWYgdGhlcmUgaXMgb25seSBvbmUgaG9zdCBkbyBpdCAqL1xuICAgICAgICAgICAgaWYgKGhvc3RzLmxlbmd0aCA9PT0gMSkge1xuICAgICAgICAgICAgICAgIHRoaXMuZG9VcmkobWV0aG9kLCByZXN0LCB1cmlGcm9tSG9zdChob3N0c1swXSksIGhlYWRlcnMsIGJvZHksIHBhcmFtcywgY2FsbGJhY2spO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIC8qIGhvc3RzIGlzIGFuIGFycmF5IHdpdGggcHJlZmVycmVkIGhvc3QgcGx1cyBhdCBsZWFzdCBvbmUgZmFsbGJhY2sgKi9cbiAgICAgICAgICAgIHZhciB0cnlBSG9zdCA9IGZ1bmN0aW9uIChjYW5kaWRhdGVIb3N0cywgcGVyc2lzdE9uU3VjY2Vzcykge1xuICAgICAgICAgICAgICAgIHZhciBob3N0ID0gY2FuZGlkYXRlSG9zdHMuc2hpZnQoKTtcbiAgICAgICAgICAgICAgICBfdGhpcy5kb1VyaShtZXRob2QsIHJlc3QsIHVyaUZyb21Ib3N0KGhvc3QpLCBoZWFkZXJzLCBib2R5LCBwYXJhbXMsIGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGFyZ3MgPSBbXTtcbiAgICAgICAgICAgICAgICAgICAgZm9yICh2YXIgX2kgPSAxOyBfaSA8IGFyZ3VtZW50cy5sZW5ndGg7IF9pKyspIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGFyZ3NbX2kgLSAxXSA9IGFyZ3VtZW50c1tfaV07XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhpcyB0eXBlY2FzdCBpcyBzYWZlIGJlY2F1c2UgRXJybm9FeGNlcHRpb25zIGFyZSBvbmx5IHRocm93biBpbiBOb2RlSlNcbiAgICAgICAgICAgICAgICAgICAgaWYgKGVyciAmJiBzaG91bGRGYWxsYmFjayhlcnIpICYmIGNhbmRpZGF0ZUhvc3RzLmxlbmd0aCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgdHJ5QUhvc3QoY2FuZGlkYXRlSG9zdHMsIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChwZXJzaXN0T25TdWNjZXNzKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAvKiBSU0MxNWYgKi9cbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3QuX2N1cnJlbnRGYWxsYmFjayA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBob3N0OiBob3N0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbGlkVW50aWw6IFV0aWxzLm5vdygpICsgcmVzdC5vcHRpb25zLnRpbWVvdXRzLmZhbGxiYWNrUmV0cnlUaW1lb3V0LFxuICAgICAgICAgICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBjYWxsYmFjayA9PT0gbnVsbCB8fCBjYWxsYmFjayA9PT0gdm9pZCAwID8gdm9pZCAwIDogY2FsbGJhY2suYXBwbHkodm9pZCAwLCB0c2xpYl8xLl9fc3ByZWFkQXJyYXkoW2Vycl0sIGFyZ3MsIGZhbHNlKSk7XG4gICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgdHJ5QUhvc3QoaG9zdHMpO1xuICAgICAgICB9O1xuICAgICAgICBjbGFzc18xLnByb3RvdHlwZS5kb1VyaSA9IGZ1bmN0aW9uIChtZXRob2QsIHJlc3QsIHVyaSwgaGVhZGVycywgYm9keSwgcGFyYW1zLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgaWYgKCF0aGlzLlJlcXVlc3QpIHtcbiAgICAgICAgICAgICAgICBjYWxsYmFjayhuZXcgZXJyb3JpbmZvXzEuUGFydGlhbEVycm9ySW5mbygnUmVxdWVzdCBpbnZva2VkIGJlZm9yZSBhc3NpZ25lZCB0bycsIG51bGwsIDUwMCkpO1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIHRoaXMuUmVxdWVzdChtZXRob2QsIHJlc3QsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBjYWxsYmFjayk7XG4gICAgICAgIH07XG4gICAgICAgIHJldHVybiBjbGFzc18xO1xuICAgIH0oKSksXG4gICAgX2EubWV0aG9kcyA9IFtIdHRwTWV0aG9kc18xLmRlZmF1bHQuR2V0LCBIdHRwTWV0aG9kc18xLmRlZmF1bHQuRGVsZXRlLCBIdHRwTWV0aG9kc18xLmRlZmF1bHQuUG9zdCwgSHR0cE1ldGhvZHNfMS5kZWZhdWx0LlB1dCwgSHR0cE1ldGhvZHNfMS5kZWZhdWx0LlBhdGNoXSxcbiAgICBfYS5tZXRob2RzV2l0aG91dEJvZHkgPSBbSHR0cE1ldGhvZHNfMS5kZWZhdWx0LkdldCwgSHR0cE1ldGhvZHNfMS5kZWZhdWx0LkRlbGV0ZV0sXG4gICAgX2EubWV0aG9kc1dpdGhCb2R5ID0gW0h0dHBNZXRob2RzXzEuZGVmYXVsdC5Qb3N0LCBIdHRwTWV0aG9kc18xLmRlZmF1bHQuUHV0LCBIdHRwTWV0aG9kc18xLmRlZmF1bHQuUGF0Y2hdLFxuICAgIF9hKTtcbmV4cG9ydHMuZGVmYXVsdCA9IEh0dHA7XG5cblxuLyoqKi8gfSksXG4vKiA2MyAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIGVycm9yaW5mb18xID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXyg0KSk7XG52YXIgcGxhdGZvcm1fMSA9IHRzbGliXzEuX19pbXBvcnREZWZhdWx0KF9fd2VicGFja19yZXF1aXJlX18oMykpO1xudmFyIGRlZmF1bHRzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDgpKTtcbnZhciBVdGlscyA9IHRzbGliXzEuX19pbXBvcnRTdGFyKF9fd2VicGFja19yZXF1aXJlX18oMSkpO1xudmFyIHV0aWxzXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDEpO1xuZnVuY3Rpb24gaXNBYmx5RXJyb3IocmVzcG9uc2VCb2R5LCBoZWFkZXJzKSB7XG4gICAgcmV0dXJuICEhaGVhZGVycy5nZXQoJ3gtYWJseS1lcnJvcmNvZGUnKTtcbn1cbmZ1bmN0aW9uIGdldEFibHlFcnJvcihyZXNwb25zZUJvZHksIGhlYWRlcnMpIHtcbiAgICBpZiAoaXNBYmx5RXJyb3IocmVzcG9uc2VCb2R5LCBoZWFkZXJzKSkge1xuICAgICAgICByZXR1cm4gcmVzcG9uc2VCb2R5LmVycm9yICYmIGVycm9yaW5mb18xLmRlZmF1bHQuZnJvbVZhbHVlcyhyZXNwb25zZUJvZHkuZXJyb3IpO1xuICAgIH1cbn1cbmZ1bmN0aW9uIGZldGNoUmVxdWVzdChtZXRob2QsIHJlc3QsIHVyaSwgaGVhZGVycywgcGFyYW1zLCBib2R5LCBjYWxsYmFjaykge1xuICAgIHZhciBmZXRjaEhlYWRlcnMgPSBuZXcgSGVhZGVycyhoZWFkZXJzIHx8IHt9KTtcbiAgICB2YXIgX21ldGhvZCA9IG1ldGhvZCA/IG1ldGhvZC50b1VwcGVyQ2FzZSgpIDogVXRpbHMuaXNFbXB0eUFyZyhib2R5KSA/ICdHRVQnIDogJ1BPU1QnO1xuICAgIHZhciBjb250cm9sbGVyID0gbmV3IEFib3J0Q29udHJvbGxlcigpO1xuICAgIHZhciB0aW1lb3V0ID0gc2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRyb2xsZXIuYWJvcnQoKTtcbiAgICAgICAgY2FsbGJhY2sobmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ1JlcXVlc3QgdGltZWQgb3V0JywgbnVsbCwgNDA4KSk7XG4gICAgfSwgcmVzdCA/IHJlc3Qub3B0aW9ucy50aW1lb3V0cy5odHRwUmVxdWVzdFRpbWVvdXQgOiBkZWZhdWx0c18xLmRlZmF1bHQuVElNRU9VVFMuaHR0cFJlcXVlc3RUaW1lb3V0KTtcbiAgICB2YXIgcmVxdWVzdEluaXQgPSB7XG4gICAgICAgIG1ldGhvZDogX21ldGhvZCxcbiAgICAgICAgaGVhZGVyczogZmV0Y2hIZWFkZXJzLFxuICAgICAgICBib2R5OiBib2R5LFxuICAgIH07XG4gICAgaWYgKCFwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmlzV2Vid29ya2VyKSB7XG4gICAgICAgIHJlcXVlc3RJbml0LmNyZWRlbnRpYWxzID0gZmV0Y2hIZWFkZXJzLmhhcygnYXV0aG9yaXphdGlvbicpID8gJ2luY2x1ZGUnIDogJ3NhbWUtb3JpZ2luJztcbiAgICB9XG4gICAgKDAsIHV0aWxzXzEuZ2V0R2xvYmFsT2JqZWN0KSgpXG4gICAgICAgIC5mZXRjaCh1cmkgKyAnPycgKyBuZXcgVVJMU2VhcmNoUGFyYW1zKHBhcmFtcyB8fCB7fSksIHJlcXVlc3RJbml0KVxuICAgICAgICAudGhlbihmdW5jdGlvbiAocmVzKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgdmFyIGNvbnRlbnRUeXBlID0gcmVzLmhlYWRlcnMuZ2V0KCdDb250ZW50LVR5cGUnKTtcbiAgICAgICAgdmFyIHByb207XG4gICAgICAgIGlmIChjb250ZW50VHlwZSAmJiBjb250ZW50VHlwZS5pbmRleE9mKCdhcHBsaWNhdGlvbi94LW1zZ3BhY2snKSA+IC0xKSB7XG4gICAgICAgICAgICBwcm9tID0gcmVzLmFycmF5QnVmZmVyKCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoY29udGVudFR5cGUgJiYgY29udGVudFR5cGUuaW5kZXhPZignYXBwbGljYXRpb24vanNvbicpID4gLTEpIHtcbiAgICAgICAgICAgIHByb20gPSByZXMuanNvbigpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgcHJvbSA9IHJlcy50ZXh0KCk7XG4gICAgICAgIH1cbiAgICAgICAgcHJvbS50aGVuKGZ1bmN0aW9uIChib2R5KSB7XG4gICAgICAgICAgICB2YXIgdW5wYWNrZWQgPSAhIWNvbnRlbnRUeXBlICYmIGNvbnRlbnRUeXBlLmluZGV4T2YoJ2FwcGxpY2F0aW9uL3gtbXNncGFjaycpID09PSAtMTtcbiAgICAgICAgICAgIGlmICghcmVzLm9rKSB7XG4gICAgICAgICAgICAgICAgdmFyIGVyciA9IGdldEFibHlFcnJvcihib2R5LCByZXMuaGVhZGVycykgfHxcbiAgICAgICAgICAgICAgICAgICAgbmV3IGVycm9yaW5mb18xLlBhcnRpYWxFcnJvckluZm8oJ0Vycm9yIHJlc3BvbnNlIHJlY2VpdmVkIGZyb20gc2VydmVyOiAnICsgcmVzLnN0YXR1cyArICcgYm9keSB3YXM6ICcgKyBwbGF0Zm9ybV8xLmRlZmF1bHQuQ29uZmlnLmluc3BlY3QoYm9keSksIG51bGwsIHJlcy5zdGF0dXMpO1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKGVyciwgYm9keSwgcmVzLmhlYWRlcnMsIHVucGFja2VkLCByZXMuc3RhdHVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIGNhbGxiYWNrKG51bGwsIGJvZHksIHJlcy5oZWFkZXJzLCB1bnBhY2tlZCwgcmVzLnN0YXR1cyk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgIH0pXG4gICAgICAgIC5jYXRjaChmdW5jdGlvbiAoZXJyKSB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lb3V0KTtcbiAgICAgICAgY2FsbGJhY2soZXJyKTtcbiAgICB9KTtcbn1cbmV4cG9ydHMuZGVmYXVsdCA9IGZldGNoUmVxdWVzdDtcblxuXG4vKioqLyB9KSxcbi8qIDY0ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBleHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuXG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgbXNncGFja18xID0gdHNsaWJfMS5fX2ltcG9ydERlZmF1bHQoX193ZWJwYWNrX3JlcXVpcmVfXyg0MSkpO1xudmFyIFV0aWxzID0gdHNsaWJfMS5fX2ltcG9ydFN0YXIoX193ZWJwYWNrX3JlcXVpcmVfXygxKSk7XG4vLyBXb3JrYXJvdW5kIGZvciBzYWxlc2ZvcmNlIGxpZ2h0bmluZyBsb2NrZXIgY29tcGF0XG52YXIgZ2xvYmFsT2JqZWN0ID0gVXRpbHMuZ2V0R2xvYmFsT2JqZWN0KCk7XG5pZiAodHlwZW9mIFdpbmRvdyA9PT0gJ3VuZGVmaW5lZCcgJiYgdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlID09PSAndW5kZWZpbmVkJykge1xuICAgIGNvbnNvbGUubG9nKFwiV2FybmluZzogdGhpcyBkaXN0cmlidXRpb24gb2YgQWJseSBpcyBpbnRlbmRlZCBmb3IgYnJvd3NlcnMuIE9uIG5vZGVqcywgcGxlYXNlIHVzZSB0aGUgJ2FibHknIHBhY2thZ2Ugb24gbnBtXCIpO1xufVxuZnVuY3Rpb24gYWxsb3dDb21ldCgpIHtcbiAgICAvKiB4aHIgcmVxdWVzdHMgZnJvbSBsb2NhbCBmaWxlcyBhcmUgdW5yZWxpYWJsZSBpbiBzb21lIGJyb3dzZXJzLCBzdWNoIGFzIENocm9tZSA2NSBhbmQgaGlnaGVyIC0tIHNlZSBlZ1xuICAgICAqIGh0dHBzOi8vc3RhY2tvdmVyZmxvdy5jb20vcXVlc3Rpb25zLzQ5MjU2NDI5L2Nocm9tZS02NS11bmFibGUtdG8tbWFrZS1wb3N0LXJlcXVlc3RzLWZyb20tbG9jYWwtZmlsZXMtdG8tZmxhc2tcbiAgICAgKiBTbyBpZiB3ZWJzb2NrZXRzIGFyZSBzdXBwb3J0ZWQsIHRoZW4ganVzdCBmb3JnZXQgYWJvdXQgY29tZXQgdHJhbnNwb3J0cyBhbmQgdXNlIHRoYXQgKi9cbiAgICB2YXIgbG9jID0gZ2xvYmFsT2JqZWN0LmxvY2F0aW9uO1xuICAgIHJldHVybiAhZ2xvYmFsT2JqZWN0LldlYlNvY2tldCB8fCAhbG9jIHx8ICFsb2Mub3JpZ2luIHx8IGxvYy5vcmlnaW4uaW5kZXhPZignaHR0cCcpID4gLTE7XG59XG52YXIgdXNlckFnZW50ID0gZ2xvYmFsT2JqZWN0Lm5hdmlnYXRvciAmJiBnbG9iYWxPYmplY3QubmF2aWdhdG9yLnVzZXJBZ2VudC50b1N0cmluZygpO1xudmFyIGN1cnJlbnRVcmwgPSBnbG9iYWxPYmplY3QubG9jYXRpb24gJiYgZ2xvYmFsT2JqZWN0LmxvY2F0aW9uLmhyZWY7XG52YXIgQ29uZmlnID0ge1xuICAgIGFnZW50OiAnYnJvd3NlcicsXG4gICAgbG9nVGltZXN0YW1wczogdHJ1ZSxcbiAgICB1c2VyQWdlbnQ6IHVzZXJBZ2VudCxcbiAgICBjdXJyZW50VXJsOiBjdXJyZW50VXJsLFxuICAgIG5vVXBncmFkZTogdXNlckFnZW50ICYmICEhdXNlckFnZW50Lm1hdGNoKC9NU0lFXFxzOFxcLjAvKSxcbiAgICBiaW5hcnlUeXBlOiAnYXJyYXlidWZmZXInLFxuICAgIFdlYlNvY2tldDogZ2xvYmFsT2JqZWN0LldlYlNvY2tldCxcbiAgICBmZXRjaFN1cHBvcnRlZDogISFnbG9iYWxPYmplY3QuZmV0Y2gsXG4gICAgeGhyU3VwcG9ydGVkOiBnbG9iYWxPYmplY3QuWE1MSHR0cFJlcXVlc3QgJiYgJ3dpdGhDcmVkZW50aWFscycgaW4gbmV3IFhNTEh0dHBSZXF1ZXN0KCksXG4gICAganNvbnBTdXBwb3J0ZWQ6IHR5cGVvZiBkb2N1bWVudCAhPT0gJ3VuZGVmaW5lZCcsXG4gICAgYWxsb3dDb21ldDogYWxsb3dDb21ldCgpLFxuICAgIHN0cmVhbWluZ1N1cHBvcnRlZDogdHJ1ZSxcbiAgICB1c2VQcm90b2NvbEhlYXJ0YmVhdHM6IHRydWUsXG4gICAgY3JlYXRlSG1hYzogbnVsbCxcbiAgICBtc2dwYWNrOiBtc2dwYWNrXzEuZGVmYXVsdCxcbiAgICBzdXBwb3J0c0JpbmFyeTogISFnbG9iYWxPYmplY3QuVGV4dERlY29kZXIsXG4gICAgLyogUGVyIFBhZGR5IChodHRwczovL2FibHktcmVhbC10aW1lLnNsYWNrLmNvbS9hcmNoaXZlcy9DVVJMNFUyRlAvcDE3MDU2NzQ1Mzc3NjM0NzkpIHdlYiBpbnRlbnRpb25hbGx5IHByZWZlcnMgSlNPTiB0byBNZXNzYWdlUGFjazpcbiAgICAgKlxuICAgICAqID4gYnJvd3NlcnMnIHN1cHBvcnQgZm9yIGJpbmFyeSB0eXBlcyBpbiBnZW5lcmFsIHdhcyBoaXN0b3JpY2FsbHkgcG9vciwgYW5kIEpTT04gdHJhbnNwb3J0IHBlcmZvcm1hbmNlIGlzIHNpZ25pZmljYW50bHkgYmV0dGVyIGluIGEgYnJvd3NlciB0aGFuIG1zZ3BhY2suIEluIG1vZGVybiBicm93c2VycyB0aGVuIGJpbmFyeSBpcyBzdXBwb3J0ZWQgY29uc2lzdGVudGx5LCBidXQgSSdkIHN0aWxsIGV4cGVjdCB0aGF0IEpTT04gZW5jb2RlL2RlY29kZSBwZXJmb3JtYW5jZSBpcyBkcmFtYXRpY2FsbHkgYmV0dGVyIHRoYW4gbXNncGFjayBpbiBhIGJyb3dzZXIuXG4gICAgICovXG4gICAgcHJlZmVyQmluYXJ5OiBmYWxzZSxcbiAgICBBcnJheUJ1ZmZlcjogZ2xvYmFsT2JqZWN0LkFycmF5QnVmZmVyLFxuICAgIGF0b2I6IGdsb2JhbE9iamVjdC5hdG9iLFxuICAgIG5leHRUaWNrOiB0eXBlb2YgZ2xvYmFsT2JqZWN0LnNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCdcbiAgICAgICAgPyBnbG9iYWxPYmplY3Quc2V0SW1tZWRpYXRlLmJpbmQoZ2xvYmFsT2JqZWN0KVxuICAgICAgICA6IGZ1bmN0aW9uIChmKSB7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KGYsIDApO1xuICAgICAgICB9LFxuICAgIGFkZEV2ZW50TGlzdGVuZXI6IGdsb2JhbE9iamVjdC5hZGRFdmVudExpc3RlbmVyLFxuICAgIGluc3BlY3Q6IEpTT04uc3RyaW5naWZ5LFxuICAgIHN0cmluZ0J5dGVTaXplOiBmdW5jdGlvbiAoc3RyKSB7XG4gICAgICAgIC8qIHN0ci5sZW5ndGggd2lsbCBiZSBhbiB1bmRlcmVzdGltYXRlIGZvciBub24tYXNjaWkgc3RyaW5ncy4gQnV0IGlmIHdlJ3JlXG4gICAgICAgICAqIGluIGEgYnJvd3NlciB0b28gb2xkIHRvIHN1cHBvcnQgVGV4dERlY29kZXIsIG5vdCBtdWNoIHdlIGNhbiBkby4gQmV0dGVyXG4gICAgICAgICAqIHRvIHVuZGVyZXN0aW1hdGUsIHNvIGlmIHdlIGRvIGdvIG92ZXItc2l6ZSwgdGhlIHNlcnZlciB3aWxsIHJlamVjdCB0aGVcbiAgICAgICAgICogbWVzc2FnZSAqL1xuICAgICAgICByZXR1cm4gKGdsb2JhbE9iamVjdC5UZXh0RGVjb2RlciAmJiBuZXcgZ2xvYmFsT2JqZWN0LlRleHRFbmNvZGVyKCkuZW5jb2RlKHN0cikubGVuZ3RoKSB8fCBzdHIubGVuZ3RoO1xuICAgIH0sXG4gICAgVGV4dEVuY29kZXI6IGdsb2JhbE9iamVjdC5UZXh0RW5jb2RlcixcbiAgICBUZXh0RGVjb2RlcjogZ2xvYmFsT2JqZWN0LlRleHREZWNvZGVyLFxuICAgIFByb21pc2U6IGdsb2JhbE9iamVjdC5Qcm9taXNlLFxuICAgIGdldFJhbmRvbVZhbHVlczogKGZ1bmN0aW9uIChjcnlwdG8pIHtcbiAgICAgICAgaWYgKGNyeXB0byA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoYXJyLCBjYWxsYmFjaykge1xuICAgICAgICAgICAgY3J5cHRvLmdldFJhbmRvbVZhbHVlcyhhcnIpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSB7XG4gICAgICAgICAgICAgICAgY2FsbGJhY2sobnVsbCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfSkoZ2xvYmFsT2JqZWN0LmNyeXB0byB8fCBtc0NyeXB0byksXG59O1xuZXhwb3J0cy5kZWZhdWx0ID0gQ29uZmlnO1xuXG5cbi8qKiovIH0pLFxuLyogNjUgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG4vKiBXRUJQQUNLIFZBUiBJTkpFQ1RJT04gKi8oZnVuY3Rpb24oZ2xvYmFsKSB7XG5PYmplY3QuZGVmaW5lUHJvcGVydHkoZXhwb3J0cywgXCJfX2VzTW9kdWxlXCIsIHsgdmFsdWU6IHRydWUgfSk7XG52YXIgdHNsaWJfMSA9IF9fd2VicGFja19yZXF1aXJlX18oMCk7XG52YXIgVXRpbHMgPSB0c2xpYl8xLl9faW1wb3J0U3RhcihfX3dlYnBhY2tfcmVxdWlyZV9fKDEpKTtcbnZhciB0ZXN0ID0gJ2FibHlqcy1zdG9yYWdlLXRlc3QnO1xudmFyIFdlYnN0b3JhZ2UgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoKSB7XG4gICAgZnVuY3Rpb24gV2Vic3RvcmFnZSgpIHtcbiAgICAgICAgLyogRXZlbiBqdXN0IGFjY2Vzc2luZyB0aGUgc2Vzc2lvbi9sb2NhbFN0b3JhZ2Ugb2JqZWN0IGNhbiB0aHJvdyBhXG4gICAgICAgICAqIHNlY3VyaXR5IGV4Y2VwdGlvbiBpbiBzb21lIGNpcmN1bXN0YW5jZXMgd2l0aCBzb21lIGJyb3dzZXJzLiBJblxuICAgICAgICAgKiBvdGhlcnMsIGNhbGxpbmcgc2V0SXRlbSB3aWxsIHRocm93LiBTbyBoYXZlIHRvIGNoZWNrIGluIHRoaXNcbiAgICAgICAgICogc29tZXdoYXQgcm91bmRhYm91dCB3YXkuIChJZiB1bnN1cHBvcnRlZCBvciBubyBnbG9iYWwgb2JqZWN0LFxuICAgICAgICAgKiB3aWxsIHRocm93IG9uIGFjY2Vzc2luZyBhIHByb3BlcnR5IG9mIHVuZGVmaW5lZCkgKi9cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIGdsb2JhbC5zZXNzaW9uU3RvcmFnZS5zZXRJdGVtKHRlc3QsIHRlc3QpO1xuICAgICAgICAgICAgZ2xvYmFsLnNlc3Npb25TdG9yYWdlLnJlbW92ZUl0ZW0odGVzdCk7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb25TdXBwb3J0ZWQgPSB0cnVlO1xuICAgICAgICB9XG4gICAgICAgIGNhdGNoIChlKSB7XG4gICAgICAgICAgICB0aGlzLnNlc3Npb25TdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgICAgICB0cnkge1xuICAgICAgICAgICAgZ2xvYmFsLmxvY2FsU3RvcmFnZS5zZXRJdGVtKHRlc3QsIHRlc3QpO1xuICAgICAgICAgICAgZ2xvYmFsLmxvY2FsU3RvcmFnZS5yZW1vdmVJdGVtKHRlc3QpO1xuICAgICAgICAgICAgdGhpcy5sb2NhbFN1cHBvcnRlZCA9IHRydWU7XG4gICAgICAgIH1cbiAgICAgICAgY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIHRoaXMubG9jYWxTdXBwb3J0ZWQgPSBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBXZWJzdG9yYWdlLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KG5hbWUsIGZhbHNlKTtcbiAgICB9O1xuICAgIFdlYnN0b3JhZ2UucHJvdG90eXBlLmdldFNlc3Npb24gPSBmdW5jdGlvbiAobmFtZSkge1xuICAgICAgICByZXR1cm4gdGhpcy5fZ2V0KG5hbWUsIHRydWUpO1xuICAgIH07XG4gICAgV2Vic3RvcmFnZS5wcm90b3R5cGUucmVtb3ZlID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZShuYW1lLCBmYWxzZSk7XG4gICAgfTtcbiAgICBXZWJzdG9yYWdlLnByb3RvdHlwZS5yZW1vdmVTZXNzaW9uID0gZnVuY3Rpb24gKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuIHRoaXMuX3JlbW92ZShuYW1lLCB0cnVlKTtcbiAgICB9O1xuICAgIFdlYnN0b3JhZ2UucHJvdG90eXBlLnNldCA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgdHRsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXQobmFtZSwgdmFsdWUsIHR0bCwgZmFsc2UpO1xuICAgIH07XG4gICAgV2Vic3RvcmFnZS5wcm90b3R5cGUuc2V0U2Vzc2lvbiA9IGZ1bmN0aW9uIChuYW1lLCB2YWx1ZSwgdHRsKSB7XG4gICAgICAgIHJldHVybiB0aGlzLl9zZXQobmFtZSwgdmFsdWUsIHR0bCwgdHJ1ZSk7XG4gICAgfTtcbiAgICBXZWJzdG9yYWdlLnByb3RvdHlwZS5fc2V0ID0gZnVuY3Rpb24gKG5hbWUsIHZhbHVlLCB0dGwsIHNlc3Npb24pIHtcbiAgICAgICAgdmFyIHdyYXBwZWRWYWx1ZSA9IHsgdmFsdWU6IHZhbHVlIH07XG4gICAgICAgIGlmICh0dGwpIHtcbiAgICAgICAgICAgIHdyYXBwZWRWYWx1ZS5leHBpcmVzID0gVXRpbHMubm93KCkgKyB0dGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHRoaXMuc3RvcmFnZUludGVyZmFjZShzZXNzaW9uKS5zZXRJdGVtKG5hbWUsIEpTT04uc3RyaW5naWZ5KHdyYXBwZWRWYWx1ZSkpO1xuICAgIH07XG4gICAgV2Vic3RvcmFnZS5wcm90b3R5cGUuX2dldCA9IGZ1bmN0aW9uIChuYW1lLCBzZXNzaW9uKSB7XG4gICAgICAgIGlmIChzZXNzaW9uICYmICF0aGlzLnNlc3Npb25TdXBwb3J0ZWQpXG4gICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1Nlc3Npb24gU3RvcmFnZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIGlmICghc2Vzc2lvbiAmJiAhdGhpcy5sb2NhbFN1cHBvcnRlZClcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignTG9jYWwgU3RvcmFnZSBub3Qgc3VwcG9ydGVkJyk7XG4gICAgICAgIHZhciByYXdJdGVtID0gdGhpcy5zdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pLmdldEl0ZW0obmFtZSk7XG4gICAgICAgIGlmICghcmF3SXRlbSlcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICB2YXIgd3JhcHBlZFZhbHVlID0gSlNPTi5wYXJzZShyYXdJdGVtKTtcbiAgICAgICAgaWYgKHdyYXBwZWRWYWx1ZS5leHBpcmVzICYmIHdyYXBwZWRWYWx1ZS5leHBpcmVzIDwgVXRpbHMubm93KCkpIHtcbiAgICAgICAgICAgIHRoaXMuc3RvcmFnZUludGVyZmFjZShzZXNzaW9uKS5yZW1vdmVJdGVtKG5hbWUpO1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHdyYXBwZWRWYWx1ZS52YWx1ZTtcbiAgICB9O1xuICAgIFdlYnN0b3JhZ2UucHJvdG90eXBlLl9yZW1vdmUgPSBmdW5jdGlvbiAobmFtZSwgc2Vzc2lvbikge1xuICAgICAgICByZXR1cm4gdGhpcy5zdG9yYWdlSW50ZXJmYWNlKHNlc3Npb24pLnJlbW92ZUl0ZW0obmFtZSk7XG4gICAgfTtcbiAgICBXZWJzdG9yYWdlLnByb3RvdHlwZS5zdG9yYWdlSW50ZXJmYWNlID0gZnVuY3Rpb24gKHNlc3Npb24pIHtcbiAgICAgICAgcmV0dXJuIHNlc3Npb24gPyBnbG9iYWwuc2Vzc2lvblN0b3JhZ2UgOiBnbG9iYWwubG9jYWxTdG9yYWdlO1xuICAgIH07XG4gICAgcmV0dXJuIFdlYnN0b3JhZ2U7XG59KCkpO1xuZXhwb3J0cy5kZWZhdWx0ID0gbmV3IFdlYnN0b3JhZ2UoKTtcblxuLyogV0VCUEFDSyBWQVIgSU5KRUNUSU9OICovfS5jYWxsKHRoaXMsIF9fd2VicGFja19yZXF1aXJlX18oMTMpKSlcblxuLyoqKi8gfSksXG4vKiA2NiAqL1xuLyoqKi8gKGZ1bmN0aW9uKG1vZHVsZSwgZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5cInVzZSBzdHJpY3RcIjtcblxuT2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIFwiX19lc01vZHVsZVwiLCB7IHZhbHVlOiB0cnVlIH0pO1xudmFyIHRzbGliXzEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDApO1xudmFyIFRyYW5zcG9ydE5hbWVzXzEgPSB0c2xpYl8xLl9faW1wb3J0RGVmYXVsdChfX3dlYnBhY2tfcmVxdWlyZV9fKDY3KSk7XG52YXIgRGVmYXVsdHMgPSB7XG4gICAgY29ubmVjdGl2aXR5Q2hlY2tVcmw6ICdodHRwczovL2ludGVybmV0LXVwLmFibHktcmVhbHRpbWUuY29tL2lzLXRoZS1pbnRlcm5ldC11cC50eHQnLFxuICAgIGpzb25wSW50ZXJuZXRVcFVybDogJ2h0dHBzOi8vaW50ZXJuZXQtdXAuYWJseS1yZWFsdGltZS5jb20vaXMtdGhlLWludGVybmV0LXVwLTAtOS5qcycsXG4gICAgLyogT3JkZXIgbWF0dGVycyBoZXJlOiB0aGUgYmFzZSB0cmFuc3BvcnQgaXMgdGhlIGxlZnRtb3N0IG9uZSBpbiB0aGVcbiAgICAgKiBpbnRlcnNlY3Rpb24gb2YgYmFzZVRyYW5zcG9ydE9yZGVyIGFuZCB0aGUgdHJhbnNwb3J0cyBjbGllbnRPcHRpb24gdGhhdCdzXG4gICAgICogc3VwcG9ydGVkLiAgVGhpcyBpcyBub3QgcXVpdGUgdGhlIHNhbWUgYXMgdGhlIHByZWZlcmVuY2Ugb3JkZXIgLS0gZS5nLlxuICAgICAqIHhocl9wb2xsaW5nIGlzIHByZWZlcnJlZCB0byBqc29ucCwgYnV0IGZvciBicm93c2VycyB0aGF0IHN1cHBvcnQgaXQgd2Ugd2FudFxuICAgICAqIHRoZSBiYXNlIHRyYW5zcG9ydCB0byBiZSB4aHJfcG9sbGluZywgbm90IGpzb25wICovXG4gICAgZGVmYXVsdFRyYW5zcG9ydHM6IFtcbiAgICAgICAgVHJhbnNwb3J0TmFtZXNfMS5kZWZhdWx0LlhoclBvbGxpbmcsXG4gICAgICAgIFRyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5YaHJTdHJlYW1pbmcsXG4gICAgICAgIFRyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5Kc29uUCxcbiAgICAgICAgVHJhbnNwb3J0TmFtZXNfMS5kZWZhdWx0LldlYlNvY2tldCxcbiAgICBdLFxuICAgIGJhc2VUcmFuc3BvcnRPcmRlcjogW1xuICAgICAgICBUcmFuc3BvcnROYW1lc18xLmRlZmF1bHQuWGhyUG9sbGluZyxcbiAgICAgICAgVHJhbnNwb3J0TmFtZXNfMS5kZWZhdWx0LlhoclN0cmVhbWluZyxcbiAgICAgICAgVHJhbnNwb3J0TmFtZXNfMS5kZWZhdWx0Lkpzb25QLFxuICAgICAgICBUcmFuc3BvcnROYW1lc18xLmRlZmF1bHQuV2ViU29ja2V0LFxuICAgIF0sXG4gICAgdHJhbnNwb3J0UHJlZmVyZW5jZU9yZGVyOiBbXG4gICAgICAgIFRyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5Kc29uUCxcbiAgICAgICAgVHJhbnNwb3J0TmFtZXNfMS5kZWZhdWx0LlhoclBvbGxpbmcsXG4gICAgICAgIFRyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5YaHJTdHJlYW1pbmcsXG4gICAgICAgIFRyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5XZWJTb2NrZXQsXG4gICAgXSxcbiAgICB1cGdyYWRlVHJhbnNwb3J0czogW1RyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5YaHJTdHJlYW1pbmcsIFRyYW5zcG9ydE5hbWVzXzEuZGVmYXVsdC5XZWJTb2NrZXRdLFxufTtcbmV4cG9ydHMuZGVmYXVsdCA9IERlZmF1bHRzO1xuXG5cbi8qKiovIH0pLFxuLyogNjcgKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIGV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pIHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5cbk9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBcIl9fZXNNb2R1bGVcIiwgeyB2YWx1ZTogdHJ1ZSB9KTtcbnZhciBUcmFuc3BvcnROYW1lcztcbihmdW5jdGlvbiAoVHJhbnNwb3J0TmFtZXMpIHtcbiAgICBUcmFuc3BvcnROYW1lc1tcIldlYlNvY2tldFwiXSA9IFwid2ViX3NvY2tldFwiO1xuICAgIFRyYW5zcG9ydE5hbWVzW1wiQ29tZXRcIl0gPSBcImNvbWV0XCI7XG4gICAgVHJhbnNwb3J0TmFtZXNbXCJYaHJTdHJlYW1pbmdcIl0gPSBcInhocl9zdHJlYW1pbmdcIjtcbiAgICBUcmFuc3BvcnROYW1lc1tcIlhoclBvbGxpbmdcIl0gPSBcInhocl9wb2xsaW5nXCI7XG4gICAgVHJhbnNwb3J0TmFtZXNbXCJKc29uUFwiXSA9IFwianNvbnBcIjtcbn0pKFRyYW5zcG9ydE5hbWVzIHx8IChUcmFuc3BvcnROYW1lcyA9IHt9KSk7XG5leHBvcnRzLmRlZmF1bHQgPSBUcmFuc3BvcnROYW1lcztcblxuXG4vKioqLyB9KSxcbi8qIDY4ICovXG4vKioqLyAoZnVuY3Rpb24obW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSB7XG5cblwidXNlIHN0cmljdFwiO1xuLy8gRVNNIENPTVBBVCBGTEFHXG5fX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvcGxhdGZvcm0vd2ViL2xpYi90cmFuc3BvcnQvanNvbnB0cmFuc3BvcnQudHNcbnZhciBqc29ucHRyYW5zcG9ydCA9IF9fd2VicGFja19yZXF1aXJlX18oMjkpO1xudmFyIGpzb25wdHJhbnNwb3J0X2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKGpzb25wdHJhbnNwb3J0KTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21tb24vbGliL3V0aWwvdXRpbHMudHNcbnZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oMSk7XG5cbi8vIEVYVEVSTkFMIE1PRFVMRTogLi9zcmMvY29tbW9uL3BsYXRmb3JtLnRzXG52YXIgcGxhdGZvcm0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKDMpO1xudmFyIHBsYXRmb3JtX2RlZmF1bHQgPSAvKiNfX1BVUkVfXyovX193ZWJwYWNrX3JlcXVpcmVfXy5uKHBsYXRmb3JtKTtcblxuLy8gRVhURVJOQUwgTU9EVUxFOiAuL3NyYy9jb21tb24vbGliL3RyYW5zcG9ydC9jb21ldHRyYW5zcG9ydC50c1xudmFyIGNvbWV0dHJhbnNwb3J0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxMik7XG52YXIgY29tZXR0cmFuc3BvcnRfZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oY29tZXR0cmFuc3BvcnQpO1xuXG4vLyBFWFRFUk5BTCBNT0RVTEU6IC4vc3JjL3BsYXRmb3JtL3dlYi9saWIvdHJhbnNwb3J0L3hocnJlcXVlc3QudHNcbnZhciB4aHJyZXF1ZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygxNik7XG52YXIgeGhycmVxdWVzdF9kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubih4aHJyZXF1ZXN0KTtcblxuLy8gQ09OQ0FURU5BVEVEIE1PRFVMRTogLi9zcmMvcGxhdGZvcm0vd2ViL2xpYi90cmFuc3BvcnQveGhycG9sbGluZ3RyYW5zcG9ydC5qc1xuXG5cblxuXG5cbnZhciB4aHJwb2xsaW5ndHJhbnNwb3J0X1hIUlBvbGxpbmdUcmFuc3BvcnQgPSBmdW5jdGlvbiAoY29ubmVjdGlvbk1hbmFnZXIpIHtcbiAgdmFyIHNob3J0TmFtZSA9ICd4aHJfcG9sbGluZyc7XG5cbiAgZnVuY3Rpb24gWEhSUG9sbGluZ1RyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG4gICAgcGFyYW1zLnN0cmVhbSA9IGZhbHNlO1xuICAgIGNvbWV0dHJhbnNwb3J0X2RlZmF1bHQuYS5jYWxsKHRoaXMsIGNvbm5lY3Rpb25NYW5hZ2VyLCBhdXRoLCBwYXJhbXMpO1xuICAgIHRoaXMuc2hvcnROYW1lID0gc2hvcnROYW1lO1xuICB9XG4gIHV0aWxzW1wiaW5oZXJpdHNcIl0oWEhSUG9sbGluZ1RyYW5zcG9ydCwgY29tZXR0cmFuc3BvcnRfZGVmYXVsdC5hKTtcblxuICBYSFJQb2xsaW5nVHJhbnNwb3J0LmlzQXZhaWxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwbGF0Zm9ybV9kZWZhdWx0LmEuQ29uZmlnLnhoclN1cHBvcnRlZCAmJiBwbGF0Zm9ybV9kZWZhdWx0LmEuQ29uZmlnLmFsbG93Q29tZXQ7XG4gIH07XG5cbiAgWEhSUG9sbGluZ1RyYW5zcG9ydC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiAoKSB7XG4gICAgcmV0dXJuICdYSFJQb2xsaW5nVHJhbnNwb3J0OyB1cmk9JyArIHRoaXMuYmFzZVVyaSArICc7IGlzQ29ubmVjdGVkPScgKyB0aGlzLmlzQ29ubmVjdGVkO1xuICB9O1xuXG4gIFhIUlBvbGxpbmdUcmFuc3BvcnQucHJvdG90eXBlLmNyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbiAodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlKSB7XG4gICAgcmV0dXJuIHhocnJlcXVlc3RfZGVmYXVsdC5hLmNyZWF0ZVJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aGlzLnRpbWVvdXRzKTtcbiAgfTtcblxuICBpZiAodHlwZW9mIGNvbm5lY3Rpb25NYW5hZ2VyICE9PSAndW5kZWZpbmVkJyAmJiBYSFJQb2xsaW5nVHJhbnNwb3J0LmlzQXZhaWxhYmxlKCkpIHtcbiAgICBjb25uZWN0aW9uTWFuYWdlci5zdXBwb3J0ZWRUcmFuc3BvcnRzW3Nob3J0TmFtZV0gPSBYSFJQb2xsaW5nVHJhbnNwb3J0O1xuICB9XG5cbiAgcmV0dXJuIFhIUlBvbGxpbmdUcmFuc3BvcnQ7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB4aHJwb2xsaW5ndHJhbnNwb3J0ID0gKHhocnBvbGxpbmd0cmFuc3BvcnRfWEhSUG9sbGluZ1RyYW5zcG9ydCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3BsYXRmb3JtL3dlYi9saWIvdHJhbnNwb3J0L3hocnN0cmVhbWluZ3RyYW5zcG9ydC5qc1xuXG5cblxuXG5cbnZhciB4aHJzdHJlYW1pbmd0cmFuc3BvcnRfWEhSU3RyZWFtaW5nVHJhbnNwb3J0ID0gZnVuY3Rpb24gKGNvbm5lY3Rpb25NYW5hZ2VyKSB7XG4gIHZhciBzaG9ydE5hbWUgPSAneGhyX3N0cmVhbWluZyc7XG5cbiAgLyogcHVibGljIGNvbnN0cnVjdG9yICovXG4gIGZ1bmN0aW9uIFhIUlN0cmVhbWluZ1RyYW5zcG9ydChjb25uZWN0aW9uTWFuYWdlciwgYXV0aCwgcGFyYW1zKSB7XG4gICAgY29tZXR0cmFuc3BvcnRfZGVmYXVsdC5hLmNhbGwodGhpcywgY29ubmVjdGlvbk1hbmFnZXIsIGF1dGgsIHBhcmFtcyk7XG4gICAgdGhpcy5zaG9ydE5hbWUgPSBzaG9ydE5hbWU7XG4gIH1cbiAgdXRpbHNbXCJpbmhlcml0c1wiXShYSFJTdHJlYW1pbmdUcmFuc3BvcnQsIGNvbWV0dHJhbnNwb3J0X2RlZmF1bHQuYSk7XG5cbiAgWEhSU3RyZWFtaW5nVHJhbnNwb3J0LmlzQXZhaWxhYmxlID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBwbGF0Zm9ybV9kZWZhdWx0LmEuQ29uZmlnLnhoclN1cHBvcnRlZCAmJiBwbGF0Zm9ybV9kZWZhdWx0LmEuQ29uZmlnLnN0cmVhbWluZ1N1cHBvcnRlZCAmJiBwbGF0Zm9ybV9kZWZhdWx0LmEuQ29uZmlnLmFsbG93Q29tZXQ7XG4gIH07XG5cbiAgWEhSU3RyZWFtaW5nVHJhbnNwb3J0LnByb3RvdHlwZS50b1N0cmluZyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gJ1hIUlN0cmVhbWluZ1RyYW5zcG9ydDsgdXJpPScgKyB0aGlzLmJhc2VVcmkgKyAnOyBpc0Nvbm5lY3RlZD0nICsgdGhpcy5pc0Nvbm5lY3RlZDtcbiAgfTtcblxuICBYSFJTdHJlYW1pbmdUcmFuc3BvcnQucHJvdG90eXBlLmNyZWF0ZVJlcXVlc3QgPSBmdW5jdGlvbiAodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlKSB7XG4gICAgcmV0dXJuIHhocnJlcXVlc3RfZGVmYXVsdC5hLmNyZWF0ZVJlcXVlc3QodXJpLCBoZWFkZXJzLCBwYXJhbXMsIGJvZHksIHJlcXVlc3RNb2RlLCB0aGlzLnRpbWVvdXRzKTtcbiAgfTtcblxuICBpZiAodHlwZW9mIGNvbm5lY3Rpb25NYW5hZ2VyICE9PSAndW5kZWZpbmVkJyAmJiBYSFJTdHJlYW1pbmdUcmFuc3BvcnQuaXNBdmFpbGFibGUoKSkge1xuICAgIGNvbm5lY3Rpb25NYW5hZ2VyLnN1cHBvcnRlZFRyYW5zcG9ydHNbc2hvcnROYW1lXSA9IFhIUlN0cmVhbWluZ1RyYW5zcG9ydDtcbiAgfVxuXG4gIHJldHVybiBYSFJTdHJlYW1pbmdUcmFuc3BvcnQ7XG59O1xuXG4vKiBoYXJtb255IGRlZmF1bHQgZXhwb3J0ICovIHZhciB4aHJzdHJlYW1pbmd0cmFuc3BvcnQgPSAoeGhyc3RyZWFtaW5ndHJhbnNwb3J0X1hIUlN0cmVhbWluZ1RyYW5zcG9ydCk7XG5cbi8vIENPTkNBVEVOQVRFRCBNT0RVTEU6IC4vc3JjL3BsYXRmb3JtL3dlYi9saWIvdHJhbnNwb3J0L2luZGV4LmpzXG5cblxuXG5cbi8qIGhhcm1vbnkgZGVmYXVsdCBleHBvcnQgKi8gdmFyIHRyYW5zcG9ydCA9IF9fd2VicGFja19leHBvcnRzX19bXCJkZWZhdWx0XCJdID0gKFtqc29ucHRyYW5zcG9ydF9kZWZhdWx0LmEsIHhocnBvbGxpbmd0cmFuc3BvcnQsIHhocnN0cmVhbWluZ3RyYW5zcG9ydF0pO1xuXG5cbi8qKiovIH0pXG4vKioqKioqLyBdKVtcImRlZmF1bHRcIl07XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/ably/build/ably-commonjs.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Frdzcn%2Fprojects%2Fpet%2Fonline-memory-game%2Fapp%2Fauthentication%2Fpage.tsx&server=false!":
/*!********************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Frdzcn%2Fprojects%2Fpet%2Fonline-memory-game%2Fapp%2Fauthentication%2Fpage.tsx&server=false! ***!
  \********************************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/authentication/page.tsx */ \"(app-client)/./app/authentication/page.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvbmV4dC1mbGlnaHQtY2xpZW50LWVudHJ5LWxvYWRlci5qcz9tb2R1bGVzPSUyRlVzZXJzJTJGcmR6Y24lMkZwcm9qZWN0cyUyRnBldCUyRm9ubGluZS1tZW1vcnktZ2FtZSUyRmFwcCUyRmF1dGhlbnRpY2F0aW9uJTJGcGFnZS50c3gmc2VydmVyPWZhbHNlIS5qcyIsIm1hcHBpbmdzIjoiQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzQ3MTYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0KC8qIHdlYnBhY2tNb2RlOiBcImVhZ2VyXCIgKi8gXCIvVXNlcnMvcmR6Y24vcHJvamVjdHMvcGV0L29ubGluZS1tZW1vcnktZ2FtZS9hcHAvYXV0aGVudGljYXRpb24vcGFnZS50c3hcIikiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Frdzcn%2Fprojects%2Fpet%2Fonline-memory-game%2Fapp%2Fauthentication%2Fpage.tsx&server=false!\n"));

/***/ }),

/***/ "(app-client)/./app/authentication/page.tsx":
/*!*************************************!*\
  !*** ./app/authentication/page.tsx ***!
  \*************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ Authentication; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _components_Logger__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../components/Logger */ \"(app-client)/./components/Logger.tsx\");\n/* harmony import */ var _ably_labs_react_hooks__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @ably-labs/react-hooks */ \"(app-client)/./node_modules/@ably-labs/react-hooks/dist/mjs/index.js\");\n\nvar _s = $RefreshSig$();\n\n\n\nfunction Authentication() {\n    _s();\n    const [logs, setLogs] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)([]);\n    const [connectionState, setConnectionState] = (0,react__WEBPACK_IMPORTED_MODULE_1__.useState)(\"unknown\");\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        const handleConnectionStateChange = (stateChange)=>{\n            setLogs((prev)=>[\n                    ...prev,\n                    new _components_Logger__WEBPACK_IMPORTED_MODULE_2__.LogEntry(\"Connection state change: \".concat(stateChange.previous, \" -> \").concat(stateChange.current))\n                ]);\n            setConnectionState(stateChange.current);\n        };\n        const ably = (0,_ably_labs_react_hooks__WEBPACK_IMPORTED_MODULE_3__.configureAbly)({\n            authUrl: \"/api/authentication/token-auth\"\n        });\n        ably.connection.on(handleConnectionStateChange);\n        return ()=>{\n            ably.connection.off();\n        };\n    }, []); // Only run the client\n    const connectionToggle = (_event)=>{\n        const ably = (0,_ably_labs_react_hooks__WEBPACK_IMPORTED_MODULE_3__.assertConfiguration)();\n        if (connectionState === \"connected\") {\n            ably.connection.close();\n        } else if (connectionState === \"closed\") {\n            ably.connection.connect();\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                children: \"Authenticate and establish a persistent bi-direction connection to the Ably platform.\"\n            }, void 0, false, {\n                fileName: \"/Users/rdzcn/projects/pet/online-memory-game/app/authentication/page.tsx\",\n                lineNumber: 52,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"section\", {\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h3\", {\n                        className: \"text-3x mt-4 font-bold underline\",\n                        children: [\n                            \"Connection status: \",\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                children: connectionState\n                            }, void 0, false, {\n                                fileName: \"/Users/rdzcn/projects/pet/online-memory-game/app/authentication/page.tsx\",\n                                lineNumber: 59,\n                                columnNumber: 30\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"/Users/rdzcn/projects/pet/online-memory-game/app/authentication/page.tsx\",\n                        lineNumber: 58,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                            onClick: connectionToggle,\n                            className: \"mt-4 px-3 py-3 text-indigo-600 bg-indigo-50 rounded-lg duration-150 hover:bg-indigo-100 active:bg-indigo-200\",\n                            children: connectionState === \"connected\" ? \"Disconnect\" : \"Connect\"\n                        }, void 0, false, {\n                            fileName: \"/Users/rdzcn/projects/pet/online-memory-game/app/authentication/page.tsx\",\n                            lineNumber: 63,\n                            columnNumber: 11\n                        }, this)\n                    }, void 0, false, {\n                        fileName: \"/Users/rdzcn/projects/pet/online-memory-game/app/authentication/page.tsx\",\n                        lineNumber: 62,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_Logger__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {\n                        logEntries: logs\n                    }, void 0, false, {\n                        fileName: \"/Users/rdzcn/projects/pet/online-memory-game/app/authentication/page.tsx\",\n                        lineNumber: 71,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"/Users/rdzcn/projects/pet/online-memory-game/app/authentication/page.tsx\",\n                lineNumber: 57,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true);\n}\n_s(Authentication, \"FbdoHj5N+f4FGUMEH1B9vigIPuc=\");\n_c = Authentication;\nvar _c;\n$RefreshReg$(_c, \"Authentication\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vYXBwL2F1dGhlbnRpY2F0aW9uL3BhZ2UudHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBRTJFO0FBRWhCO0FBR2lCO0FBRTdELFNBQVNNLGlCQUFpQjs7SUFDdkMsTUFBTSxDQUFDQyxNQUFNQyxRQUFRLEdBQUdSLCtDQUFRQSxDQUFrQixFQUFFO0lBQ3BELE1BQU0sQ0FBQ1MsaUJBQWlCQyxtQkFBbUIsR0FBR1YsK0NBQVFBLENBQUM7SUFFdkRDLGdEQUFTQSxDQUFDLElBQU07UUFDZCxNQUFNVSw4QkFBOEIsQ0FDbENDLGNBQ0c7WUFDSEosUUFBUSxDQUFDSyxPQUFTO3VCQUNiQTtvQkFDSCxJQUFJVix3REFBUUEsQ0FDViw0QkFBdURTLE9BQTNCQSxZQUFZRSxRQUFRLEVBQUMsUUFBMEIsT0FBcEJGLFlBQVlHLE9BQU87aUJBRTdFO1lBRURMLG1CQUFtQkUsWUFBWUcsT0FBTztRQUN4QztRQUVBLE1BQU1DLE9BQW1DWCxxRUFBYUEsQ0FBQztZQUNyRFksU0FBUztRQUNYO1FBQ0FELEtBQUtFLFVBQVUsQ0FBQ0MsRUFBRSxDQUFDUjtRQUVuQixPQUFPLElBQU07WUFDWEssS0FBS0UsVUFBVSxDQUFDRSxHQUFHO1FBQ3JCO0lBQ0YsR0FBRyxFQUFFLEdBQUcsc0JBQXNCO0lBRTlCLE1BQU1DLG1CQUFzQyxDQUMxQ0MsU0FDRztRQUNILE1BQU1OLE9BQU9aLDJFQUFtQkE7UUFFaEMsSUFBSUssb0JBQW9CLGFBQWE7WUFDbkNPLEtBQUtFLFVBQVUsQ0FBQ0ssS0FBSztRQUN2QixPQUFPLElBQUlkLG9CQUFvQixVQUFVO1lBQ3ZDTyxLQUFLRSxVQUFVLENBQUNNLE9BQU87UUFDekIsQ0FBQztJQUNIO0lBRUEscUJBQ0U7OzBCQUNFLDhEQUFDQzswQkFBRTs7Ozs7OzBCQUtILDhEQUFDQzs7a0NBQ0MsOERBQUNDO3dCQUFHQyxXQUFVOzs0QkFBbUM7MENBQzVCLDhEQUFDQzswQ0FBTXBCOzs7Ozs7Ozs7Ozs7a0NBRzVCLDhEQUFDcUI7a0NBQ0MsNEVBQUNDOzRCQUNDQyxTQUFTWDs0QkFDVE8sV0FBVTtzQ0FFVG5CLG9CQUFvQixjQUFjLGVBQWUsU0FBUzs7Ozs7Ozs7Ozs7a0NBSS9ELDhEQUFDUCwwREFBTUE7d0JBQUMrQixZQUFZMUI7Ozs7Ozs7Ozs7Ozs7O0FBSTVCLENBQUM7R0FqRXVCRDtLQUFBQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9hcHAvYXV0aGVudGljYXRpb24vcGFnZS50c3g/NDE5YSJdLCJzb3VyY2VzQ29udGVudCI6WyJcInVzZSBjbGllbnRcIjtcblxuaW1wb3J0IHsgTW91c2VFdmVudEhhbmRsZXIsIE1vdXNlRXZlbnQsIHVzZVN0YXRlLCB1c2VFZmZlY3QgfSBmcm9tIFwicmVhY3RcIjtcblxuaW1wb3J0IExvZ2dlciwgeyBMb2dFbnRyeSB9IGZyb20gXCIuLi8uLi9jb21wb25lbnRzL0xvZ2dlclwiO1xuXG5pbXBvcnQgKiBhcyBBYmx5IGZyb20gXCJhYmx5L3Byb21pc2VzXCI7XG5pbXBvcnQgeyBhc3NlcnRDb25maWd1cmF0aW9uLCBjb25maWd1cmVBYmx5IH0gZnJvbSBcIkBhYmx5LWxhYnMvcmVhY3QtaG9va3NcIjtcblxuZXhwb3J0IGRlZmF1bHQgZnVuY3Rpb24gQXV0aGVudGljYXRpb24oKSB7XG4gIGNvbnN0IFtsb2dzLCBzZXRMb2dzXSA9IHVzZVN0YXRlPEFycmF5PExvZ0VudHJ5Pj4oW10pO1xuICBjb25zdCBbY29ubmVjdGlvblN0YXRlLCBzZXRDb25uZWN0aW9uU3RhdGVdID0gdXNlU3RhdGUoXCJ1bmtub3duXCIpO1xuXG4gIHVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgaGFuZGxlQ29ubmVjdGlvblN0YXRlQ2hhbmdlID0gKFxuICAgICAgc3RhdGVDaGFuZ2U6IEFibHkuVHlwZXMuQ29ubmVjdGlvblN0YXRlQ2hhbmdlLFxuICAgICkgPT4ge1xuICAgICAgc2V0TG9ncygocHJldikgPT4gW1xuICAgICAgICAuLi5wcmV2LFxuICAgICAgICBuZXcgTG9nRW50cnkoXG4gICAgICAgICAgYENvbm5lY3Rpb24gc3RhdGUgY2hhbmdlOiAke3N0YXRlQ2hhbmdlLnByZXZpb3VzfSAtPiAke3N0YXRlQ2hhbmdlLmN1cnJlbnR9YCxcbiAgICAgICAgKSxcbiAgICAgIF0pO1xuXG4gICAgICBzZXRDb25uZWN0aW9uU3RhdGUoc3RhdGVDaGFuZ2UuY3VycmVudCk7XG4gICAgfTtcblxuICAgIGNvbnN0IGFibHk6IEFibHkuVHlwZXMuUmVhbHRpbWVQcm9taXNlID0gY29uZmlndXJlQWJseSh7XG4gICAgICBhdXRoVXJsOiBcIi9hcGkvYXV0aGVudGljYXRpb24vdG9rZW4tYXV0aFwiLFxuICAgIH0pO1xuICAgIGFibHkuY29ubmVjdGlvbi5vbihoYW5kbGVDb25uZWN0aW9uU3RhdGVDaGFuZ2UpO1xuXG4gICAgcmV0dXJuICgpID0+IHtcbiAgICAgIGFibHkuY29ubmVjdGlvbi5vZmYoKTtcbiAgICB9O1xuICB9LCBbXSk7IC8vIE9ubHkgcnVuIHRoZSBjbGllbnRcblxuICBjb25zdCBjb25uZWN0aW9uVG9nZ2xlOiBNb3VzZUV2ZW50SGFuZGxlciA9IChcbiAgICBfZXZlbnQ6IE1vdXNlRXZlbnQ8SFRNTEJ1dHRvbkVsZW1lbnQ+LFxuICApID0+IHtcbiAgICBjb25zdCBhYmx5ID0gYXNzZXJ0Q29uZmlndXJhdGlvbigpO1xuXG4gICAgaWYgKGNvbm5lY3Rpb25TdGF0ZSA9PT0gXCJjb25uZWN0ZWRcIikge1xuICAgICAgYWJseS5jb25uZWN0aW9uLmNsb3NlKCk7XG4gICAgfSBlbHNlIGlmIChjb25uZWN0aW9uU3RhdGUgPT09IFwiY2xvc2VkXCIpIHtcbiAgICAgIGFibHkuY29ubmVjdGlvbi5jb25uZWN0KCk7XG4gICAgfVxuICB9O1xuXG4gIHJldHVybiAoXG4gICAgPD5cbiAgICAgIDxwPlxuICAgICAgICBBdXRoZW50aWNhdGUgYW5kIGVzdGFibGlzaCBhIHBlcnNpc3RlbnQgYmktZGlyZWN0aW9uIGNvbm5lY3Rpb24gdG8gdGhlXG4gICAgICAgIEFibHkgcGxhdGZvcm0uXG4gICAgICA8L3A+XG5cbiAgICAgIDxzZWN0aW9uPlxuICAgICAgICA8aDMgY2xhc3NOYW1lPVwidGV4dC0zeCBtdC00IGZvbnQtYm9sZCB1bmRlcmxpbmVcIj5cbiAgICAgICAgICBDb25uZWN0aW9uIHN0YXR1czogPHNwYW4+e2Nvbm5lY3Rpb25TdGF0ZX08L3NwYW4+XG4gICAgICAgIDwvaDM+XG5cbiAgICAgICAgPGRpdj5cbiAgICAgICAgICA8YnV0dG9uXG4gICAgICAgICAgICBvbkNsaWNrPXtjb25uZWN0aW9uVG9nZ2xlfVxuICAgICAgICAgICAgY2xhc3NOYW1lPVwibXQtNCBweC0zIHB5LTMgdGV4dC1pbmRpZ28tNjAwIGJnLWluZGlnby01MCByb3VuZGVkLWxnIGR1cmF0aW9uLTE1MCBob3ZlcjpiZy1pbmRpZ28tMTAwIGFjdGl2ZTpiZy1pbmRpZ28tMjAwXCJcbiAgICAgICAgICA+XG4gICAgICAgICAgICB7Y29ubmVjdGlvblN0YXRlID09PSBcImNvbm5lY3RlZFwiID8gXCJEaXNjb25uZWN0XCIgOiBcIkNvbm5lY3RcIn1cbiAgICAgICAgICA8L2J1dHRvbj5cbiAgICAgICAgPC9kaXY+XG5cbiAgICAgICAgPExvZ2dlciBsb2dFbnRyaWVzPXtsb2dzfSAvPlxuICAgICAgPC9zZWN0aW9uPlxuICAgIDwvPlxuICApO1xufVxuIl0sIm5hbWVzIjpbInVzZVN0YXRlIiwidXNlRWZmZWN0IiwiTG9nZ2VyIiwiTG9nRW50cnkiLCJhc3NlcnRDb25maWd1cmF0aW9uIiwiY29uZmlndXJlQWJseSIsIkF1dGhlbnRpY2F0aW9uIiwibG9ncyIsInNldExvZ3MiLCJjb25uZWN0aW9uU3RhdGUiLCJzZXRDb25uZWN0aW9uU3RhdGUiLCJoYW5kbGVDb25uZWN0aW9uU3RhdGVDaGFuZ2UiLCJzdGF0ZUNoYW5nZSIsInByZXYiLCJwcmV2aW91cyIsImN1cnJlbnQiLCJhYmx5IiwiYXV0aFVybCIsImNvbm5lY3Rpb24iLCJvbiIsIm9mZiIsImNvbm5lY3Rpb25Ub2dnbGUiLCJfZXZlbnQiLCJjbG9zZSIsImNvbm5lY3QiLCJwIiwic2VjdGlvbiIsImgzIiwiY2xhc3NOYW1lIiwic3BhbiIsImRpdiIsImJ1dHRvbiIsIm9uQ2xpY2siLCJsb2dFbnRyaWVzIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./app/authentication/page.tsx\n"));

/***/ }),

/***/ "(app-client)/./components/Logger.tsx":
/*!*******************************!*\
  !*** ./components/Logger.tsx ***!
  \*******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"LogEntry\": function() { return /* binding */ LogEntry; },\n/* harmony export */   \"default\": function() { return /* binding */ Logger; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n\nclass LogEntry {\n    constructor(message){\n        this.timestamp = new Date();\n        this.message = message;\n    }\n}\nfunction Logger(param) {\n    let { logEntries  } = param;\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"ul\", {\n        className: \"mt-4 divide-y\",\n        children: // Show the newest log entry at the top\n        logEntries.sort((a, b)=>{\n            return b.timestamp.getTime() - a.timestamp.getTime();\n        }).map((logEntry, index)=>{\n            return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"li\", {\n                className: \"py-5 flex items-start justify-between\",\n                children: [\n                    logEntry.timestamp.toISOString(),\n                    \": \",\n                    logEntry.message\n                ]\n            }, index, true, {\n                fileName: \"/Users/rdzcn/projects/pet/online-memory-game/components/Logger.tsx\",\n                lineNumber: 26,\n                columnNumber: 15\n            }, this);\n        })\n    }, void 0, false, {\n        fileName: \"/Users/rdzcn/projects/pet/online-memory-game/components/Logger.tsx\",\n        lineNumber: 17,\n        columnNumber: 5\n    }, this);\n}\n_c = Logger;\nvar _c;\n$RefreshReg$(_c, \"Logger\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vY29tcG9uZW50cy9Mb2dnZXIudHN4LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBTyxNQUFNQTtJQUlYQyxZQUFZQyxPQUFlLENBQUU7UUFDM0IsSUFBSSxDQUFDQyxTQUFTLEdBQUcsSUFBSUM7UUFDckIsSUFBSSxDQUFDRixPQUFPLEdBQUdBO0lBQ2pCO0FBQ0YsQ0FBQztBQU1jLFNBQVNHLE9BQU8sS0FBNEIsRUFBRTtRQUE5QixFQUFFQyxXQUFVLEVBQWdCLEdBQTVCO0lBQzdCLHFCQUNFLDhEQUFDQztRQUFHQyxXQUFVO2tCQUdWRix1Q0FEdUM7UUFDdkNBLFdBQ0dHLElBQUksQ0FBQyxDQUFDQyxHQUFhQyxJQUFnQjtZQUNsQyxPQUFPQSxFQUFFUixTQUFTLENBQUNTLE9BQU8sS0FBS0YsRUFBRVAsU0FBUyxDQUFDUyxPQUFPO1FBQ3BELEdBQ0NDLEdBQUcsQ0FBQyxDQUFDQyxVQUFvQkMsUUFBa0I7WUFDMUMscUJBQ0UsOERBQUNDO2dCQUFlUixXQUFVOztvQkFDdkJNLFNBQVNYLFNBQVMsQ0FBQ2MsV0FBVztvQkFBRztvQkFBR0gsU0FBU1osT0FBTzs7ZUFEOUNhOzs7OztRQUliOzs7Ozs7QUFJVixDQUFDO0tBbkJ1QlYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vY29tcG9uZW50cy9Mb2dnZXIudHN4PzFhYTMiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIExvZ0VudHJ5IHtcbiAgcHVibGljIHRpbWVzdGFtcDogRGF0ZTtcbiAgcHVibGljIG1lc3NhZ2U6IHN0cmluZztcblxuICBjb25zdHJ1Y3RvcihtZXNzYWdlOiBzdHJpbmcpIHtcbiAgICB0aGlzLnRpbWVzdGFtcCA9IG5ldyBEYXRlKCk7XG4gICAgdGhpcy5tZXNzYWdlID0gbWVzc2FnZTtcbiAgfVxufVxuXG5leHBvcnQgdHlwZSBMb2dnaW5nUHJvcHMgPSB7XG4gIGxvZ0VudHJpZXM6IEFycmF5PExvZ0VudHJ5Pjtcbn07XG5cbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIExvZ2dlcih7IGxvZ0VudHJpZXMgfTogTG9nZ2luZ1Byb3BzKSB7XG4gIHJldHVybiAoXG4gICAgPHVsIGNsYXNzTmFtZT1cIm10LTQgZGl2aWRlLXlcIj5cbiAgICAgIHtcbiAgICAgICAgLy8gU2hvdyB0aGUgbmV3ZXN0IGxvZyBlbnRyeSBhdCB0aGUgdG9wXG4gICAgICAgIGxvZ0VudHJpZXNcbiAgICAgICAgICAuc29ydCgoYTogTG9nRW50cnksIGI6IExvZ0VudHJ5KSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gYi50aW1lc3RhbXAuZ2V0VGltZSgpIC0gYS50aW1lc3RhbXAuZ2V0VGltZSgpO1xuICAgICAgICAgIH0pXG4gICAgICAgICAgLm1hcCgobG9nRW50cnk6IExvZ0VudHJ5LCBpbmRleDogbnVtYmVyKSA9PiB7XG4gICAgICAgICAgICByZXR1cm4gKFxuICAgICAgICAgICAgICA8bGkga2V5PXtpbmRleH0gY2xhc3NOYW1lPVwicHktNSBmbGV4IGl0ZW1zLXN0YXJ0IGp1c3RpZnktYmV0d2VlblwiPlxuICAgICAgICAgICAgICAgIHtsb2dFbnRyeS50aW1lc3RhbXAudG9JU09TdHJpbmcoKX06IHtsb2dFbnRyeS5tZXNzYWdlfVxuICAgICAgICAgICAgICA8L2xpPlxuICAgICAgICAgICAgKTtcbiAgICAgICAgICB9KVxuICAgICAgfVxuICAgIDwvdWw+XG4gICk7XG59XG4iXSwibmFtZXMiOlsiTG9nRW50cnkiLCJjb25zdHJ1Y3RvciIsIm1lc3NhZ2UiLCJ0aW1lc3RhbXAiLCJEYXRlIiwiTG9nZ2VyIiwibG9nRW50cmllcyIsInVsIiwiY2xhc3NOYW1lIiwic29ydCIsImEiLCJiIiwiZ2V0VGltZSIsIm1hcCIsImxvZ0VudHJ5IiwiaW5kZXgiLCJsaSIsInRvSVNPU3RyaW5nIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./components/Logger.tsx\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/compiled/buffer/index.js":
/*!*********************************************************!*\
  !*** ./node_modules/next/dist/compiled/buffer/index.js ***!
  \*********************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var __dirname = \"/\";\n(function(){var e={675:function(e,r){\"use strict\";r.byteLength=byteLength;r.toByteArray=toByteArray;r.fromByteArray=fromByteArray;var t=[];var f=[];var n=typeof Uint8Array!==\"undefined\"?Uint8Array:Array;var i=\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";for(var o=0,u=i.length;o<u;++o){t[o]=i[o];f[i.charCodeAt(o)]=o}f[\"-\".charCodeAt(0)]=62;f[\"_\".charCodeAt(0)]=63;function getLens(e){var r=e.length;if(r%4>0){throw new Error(\"Invalid string. Length must be a multiple of 4\")}var t=e.indexOf(\"=\");if(t===-1)t=r;var f=t===r?0:4-t%4;return[t,f]}function byteLength(e){var r=getLens(e);var t=r[0];var f=r[1];return(t+f)*3/4-f}function _byteLength(e,r,t){return(r+t)*3/4-t}function toByteArray(e){var r;var t=getLens(e);var i=t[0];var o=t[1];var u=new n(_byteLength(e,i,o));var a=0;var s=o>0?i-4:i;var h;for(h=0;h<s;h+=4){r=f[e.charCodeAt(h)]<<18|f[e.charCodeAt(h+1)]<<12|f[e.charCodeAt(h+2)]<<6|f[e.charCodeAt(h+3)];u[a++]=r>>16&255;u[a++]=r>>8&255;u[a++]=r&255}if(o===2){r=f[e.charCodeAt(h)]<<2|f[e.charCodeAt(h+1)]>>4;u[a++]=r&255}if(o===1){r=f[e.charCodeAt(h)]<<10|f[e.charCodeAt(h+1)]<<4|f[e.charCodeAt(h+2)]>>2;u[a++]=r>>8&255;u[a++]=r&255}return u}function tripletToBase64(e){return t[e>>18&63]+t[e>>12&63]+t[e>>6&63]+t[e&63]}function encodeChunk(e,r,t){var f;var n=[];for(var i=r;i<t;i+=3){f=(e[i]<<16&16711680)+(e[i+1]<<8&65280)+(e[i+2]&255);n.push(tripletToBase64(f))}return n.join(\"\")}function fromByteArray(e){var r;var f=e.length;var n=f%3;var i=[];var o=16383;for(var u=0,a=f-n;u<a;u+=o){i.push(encodeChunk(e,u,u+o>a?a:u+o))}if(n===1){r=e[f-1];i.push(t[r>>2]+t[r<<4&63]+\"==\")}else if(n===2){r=(e[f-2]<<8)+e[f-1];i.push(t[r>>10]+t[r>>4&63]+t[r<<2&63]+\"=\")}return i.join(\"\")}},72:function(e,r,t){\"use strict\";\n/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <https://feross.org>\n * @license  MIT\n */var f=t(675);var n=t(783);var i=typeof Symbol===\"function\"&&typeof Symbol.for===\"function\"?Symbol.for(\"nodejs.util.inspect.custom\"):null;r.Buffer=Buffer;r.SlowBuffer=SlowBuffer;r.INSPECT_MAX_BYTES=50;var o=2147483647;r.kMaxLength=o;Buffer.TYPED_ARRAY_SUPPORT=typedArraySupport();if(!Buffer.TYPED_ARRAY_SUPPORT&&typeof console!==\"undefined\"&&typeof console.error===\"function\"){console.error(\"This browser lacks typed array (Uint8Array) support which is required by \"+\"`buffer` v5.x. Use `buffer` v4.x if you require old browser support.\")}function typedArraySupport(){try{var e=new Uint8Array(1);var r={foo:function(){return 42}};Object.setPrototypeOf(r,Uint8Array.prototype);Object.setPrototypeOf(e,r);return e.foo()===42}catch(e){return false}}Object.defineProperty(Buffer.prototype,\"parent\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.buffer}});Object.defineProperty(Buffer.prototype,\"offset\",{enumerable:true,get:function(){if(!Buffer.isBuffer(this))return undefined;return this.byteOffset}});function createBuffer(e){if(e>o){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}var r=new Uint8Array(e);Object.setPrototypeOf(r,Buffer.prototype);return r}function Buffer(e,r,t){if(typeof e===\"number\"){if(typeof r===\"string\"){throw new TypeError('The \"string\" argument must be of type string. Received type number')}return allocUnsafe(e)}return from(e,r,t)}Buffer.poolSize=8192;function from(e,r,t){if(typeof e===\"string\"){return fromString(e,r)}if(ArrayBuffer.isView(e)){return fromArrayLike(e)}if(e==null){throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}if(isInstance(e,ArrayBuffer)||e&&isInstance(e.buffer,ArrayBuffer)){return fromArrayBuffer(e,r,t)}if(typeof SharedArrayBuffer!==\"undefined\"&&(isInstance(e,SharedArrayBuffer)||e&&isInstance(e.buffer,SharedArrayBuffer))){return fromArrayBuffer(e,r,t)}if(typeof e===\"number\"){throw new TypeError('The \"value\" argument must not be of type number. Received type number')}var f=e.valueOf&&e.valueOf();if(f!=null&&f!==e){return Buffer.from(f,r,t)}var n=fromObject(e);if(n)return n;if(typeof Symbol!==\"undefined\"&&Symbol.toPrimitive!=null&&typeof e[Symbol.toPrimitive]===\"function\"){return Buffer.from(e[Symbol.toPrimitive](\"string\"),r,t)}throw new TypeError(\"The first argument must be one of type string, Buffer, ArrayBuffer, Array, \"+\"or Array-like Object. Received type \"+typeof e)}Buffer.from=function(e,r,t){return from(e,r,t)};Object.setPrototypeOf(Buffer.prototype,Uint8Array.prototype);Object.setPrototypeOf(Buffer,Uint8Array);function assertSize(e){if(typeof e!==\"number\"){throw new TypeError('\"size\" argument must be of type number')}else if(e<0){throw new RangeError('The value \"'+e+'\" is invalid for option \"size\"')}}function alloc(e,r,t){assertSize(e);if(e<=0){return createBuffer(e)}if(r!==undefined){return typeof t===\"string\"?createBuffer(e).fill(r,t):createBuffer(e).fill(r)}return createBuffer(e)}Buffer.alloc=function(e,r,t){return alloc(e,r,t)};function allocUnsafe(e){assertSize(e);return createBuffer(e<0?0:checked(e)|0)}Buffer.allocUnsafe=function(e){return allocUnsafe(e)};Buffer.allocUnsafeSlow=function(e){return allocUnsafe(e)};function fromString(e,r){if(typeof r!==\"string\"||r===\"\"){r=\"utf8\"}if(!Buffer.isEncoding(r)){throw new TypeError(\"Unknown encoding: \"+r)}var t=byteLength(e,r)|0;var f=createBuffer(t);var n=f.write(e,r);if(n!==t){f=f.slice(0,n)}return f}function fromArrayLike(e){var r=e.length<0?0:checked(e.length)|0;var t=createBuffer(r);for(var f=0;f<r;f+=1){t[f]=e[f]&255}return t}function fromArrayBuffer(e,r,t){if(r<0||e.byteLength<r){throw new RangeError('\"offset\" is outside of buffer bounds')}if(e.byteLength<r+(t||0)){throw new RangeError('\"length\" is outside of buffer bounds')}var f;if(r===undefined&&t===undefined){f=new Uint8Array(e)}else if(t===undefined){f=new Uint8Array(e,r)}else{f=new Uint8Array(e,r,t)}Object.setPrototypeOf(f,Buffer.prototype);return f}function fromObject(e){if(Buffer.isBuffer(e)){var r=checked(e.length)|0;var t=createBuffer(r);if(t.length===0){return t}e.copy(t,0,0,r);return t}if(e.length!==undefined){if(typeof e.length!==\"number\"||numberIsNaN(e.length)){return createBuffer(0)}return fromArrayLike(e)}if(e.type===\"Buffer\"&&Array.isArray(e.data)){return fromArrayLike(e.data)}}function checked(e){if(e>=o){throw new RangeError(\"Attempt to allocate Buffer larger than maximum \"+\"size: 0x\"+o.toString(16)+\" bytes\")}return e|0}function SlowBuffer(e){if(+e!=e){e=0}return Buffer.alloc(+e)}Buffer.isBuffer=function isBuffer(e){return e!=null&&e._isBuffer===true&&e!==Buffer.prototype};Buffer.compare=function compare(e,r){if(isInstance(e,Uint8Array))e=Buffer.from(e,e.offset,e.byteLength);if(isInstance(r,Uint8Array))r=Buffer.from(r,r.offset,r.byteLength);if(!Buffer.isBuffer(e)||!Buffer.isBuffer(r)){throw new TypeError('The \"buf1\", \"buf2\" arguments must be one of type Buffer or Uint8Array')}if(e===r)return 0;var t=e.length;var f=r.length;for(var n=0,i=Math.min(t,f);n<i;++n){if(e[n]!==r[n]){t=e[n];f=r[n];break}}if(t<f)return-1;if(f<t)return 1;return 0};Buffer.isEncoding=function isEncoding(e){switch(String(e).toLowerCase()){case\"hex\":case\"utf8\":case\"utf-8\":case\"ascii\":case\"latin1\":case\"binary\":case\"base64\":case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return true;default:return false}};Buffer.concat=function concat(e,r){if(!Array.isArray(e)){throw new TypeError('\"list\" argument must be an Array of Buffers')}if(e.length===0){return Buffer.alloc(0)}var t;if(r===undefined){r=0;for(t=0;t<e.length;++t){r+=e[t].length}}var f=Buffer.allocUnsafe(r);var n=0;for(t=0;t<e.length;++t){var i=e[t];if(isInstance(i,Uint8Array)){i=Buffer.from(i)}if(!Buffer.isBuffer(i)){throw new TypeError('\"list\" argument must be an Array of Buffers')}i.copy(f,n);n+=i.length}return f};function byteLength(e,r){if(Buffer.isBuffer(e)){return e.length}if(ArrayBuffer.isView(e)||isInstance(e,ArrayBuffer)){return e.byteLength}if(typeof e!==\"string\"){throw new TypeError('The \"string\" argument must be one of type string, Buffer, or ArrayBuffer. '+\"Received type \"+typeof e)}var t=e.length;var f=arguments.length>2&&arguments[2]===true;if(!f&&t===0)return 0;var n=false;for(;;){switch(r){case\"ascii\":case\"latin1\":case\"binary\":return t;case\"utf8\":case\"utf-8\":return utf8ToBytes(e).length;case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return t*2;case\"hex\":return t>>>1;case\"base64\":return base64ToBytes(e).length;default:if(n){return f?-1:utf8ToBytes(e).length}r=(\"\"+r).toLowerCase();n=true}}}Buffer.byteLength=byteLength;function slowToString(e,r,t){var f=false;if(r===undefined||r<0){r=0}if(r>this.length){return\"\"}if(t===undefined||t>this.length){t=this.length}if(t<=0){return\"\"}t>>>=0;r>>>=0;if(t<=r){return\"\"}if(!e)e=\"utf8\";while(true){switch(e){case\"hex\":return hexSlice(this,r,t);case\"utf8\":case\"utf-8\":return utf8Slice(this,r,t);case\"ascii\":return asciiSlice(this,r,t);case\"latin1\":case\"binary\":return latin1Slice(this,r,t);case\"base64\":return base64Slice(this,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return utf16leSlice(this,r,t);default:if(f)throw new TypeError(\"Unknown encoding: \"+e);e=(e+\"\").toLowerCase();f=true}}}Buffer.prototype._isBuffer=true;function swap(e,r,t){var f=e[r];e[r]=e[t];e[t]=f}Buffer.prototype.swap16=function swap16(){var e=this.length;if(e%2!==0){throw new RangeError(\"Buffer size must be a multiple of 16-bits\")}for(var r=0;r<e;r+=2){swap(this,r,r+1)}return this};Buffer.prototype.swap32=function swap32(){var e=this.length;if(e%4!==0){throw new RangeError(\"Buffer size must be a multiple of 32-bits\")}for(var r=0;r<e;r+=4){swap(this,r,r+3);swap(this,r+1,r+2)}return this};Buffer.prototype.swap64=function swap64(){var e=this.length;if(e%8!==0){throw new RangeError(\"Buffer size must be a multiple of 64-bits\")}for(var r=0;r<e;r+=8){swap(this,r,r+7);swap(this,r+1,r+6);swap(this,r+2,r+5);swap(this,r+3,r+4)}return this};Buffer.prototype.toString=function toString(){var e=this.length;if(e===0)return\"\";if(arguments.length===0)return utf8Slice(this,0,e);return slowToString.apply(this,arguments)};Buffer.prototype.toLocaleString=Buffer.prototype.toString;Buffer.prototype.equals=function equals(e){if(!Buffer.isBuffer(e))throw new TypeError(\"Argument must be a Buffer\");if(this===e)return true;return Buffer.compare(this,e)===0};Buffer.prototype.inspect=function inspect(){var e=\"\";var t=r.INSPECT_MAX_BYTES;e=this.toString(\"hex\",0,t).replace(/(.{2})/g,\"$1 \").trim();if(this.length>t)e+=\" ... \";return\"<Buffer \"+e+\">\"};if(i){Buffer.prototype[i]=Buffer.prototype.inspect}Buffer.prototype.compare=function compare(e,r,t,f,n){if(isInstance(e,Uint8Array)){e=Buffer.from(e,e.offset,e.byteLength)}if(!Buffer.isBuffer(e)){throw new TypeError('The \"target\" argument must be one of type Buffer or Uint8Array. '+\"Received type \"+typeof e)}if(r===undefined){r=0}if(t===undefined){t=e?e.length:0}if(f===undefined){f=0}if(n===undefined){n=this.length}if(r<0||t>e.length||f<0||n>this.length){throw new RangeError(\"out of range index\")}if(f>=n&&r>=t){return 0}if(f>=n){return-1}if(r>=t){return 1}r>>>=0;t>>>=0;f>>>=0;n>>>=0;if(this===e)return 0;var i=n-f;var o=t-r;var u=Math.min(i,o);var a=this.slice(f,n);var s=e.slice(r,t);for(var h=0;h<u;++h){if(a[h]!==s[h]){i=a[h];o=s[h];break}}if(i<o)return-1;if(o<i)return 1;return 0};function bidirectionalIndexOf(e,r,t,f,n){if(e.length===0)return-1;if(typeof t===\"string\"){f=t;t=0}else if(t>2147483647){t=2147483647}else if(t<-2147483648){t=-2147483648}t=+t;if(numberIsNaN(t)){t=n?0:e.length-1}if(t<0)t=e.length+t;if(t>=e.length){if(n)return-1;else t=e.length-1}else if(t<0){if(n)t=0;else return-1}if(typeof r===\"string\"){r=Buffer.from(r,f)}if(Buffer.isBuffer(r)){if(r.length===0){return-1}return arrayIndexOf(e,r,t,f,n)}else if(typeof r===\"number\"){r=r&255;if(typeof Uint8Array.prototype.indexOf===\"function\"){if(n){return Uint8Array.prototype.indexOf.call(e,r,t)}else{return Uint8Array.prototype.lastIndexOf.call(e,r,t)}}return arrayIndexOf(e,[r],t,f,n)}throw new TypeError(\"val must be string, number or Buffer\")}function arrayIndexOf(e,r,t,f,n){var i=1;var o=e.length;var u=r.length;if(f!==undefined){f=String(f).toLowerCase();if(f===\"ucs2\"||f===\"ucs-2\"||f===\"utf16le\"||f===\"utf-16le\"){if(e.length<2||r.length<2){return-1}i=2;o/=2;u/=2;t/=2}}function read(e,r){if(i===1){return e[r]}else{return e.readUInt16BE(r*i)}}var a;if(n){var s=-1;for(a=t;a<o;a++){if(read(e,a)===read(r,s===-1?0:a-s)){if(s===-1)s=a;if(a-s+1===u)return s*i}else{if(s!==-1)a-=a-s;s=-1}}}else{if(t+u>o)t=o-u;for(a=t;a>=0;a--){var h=true;for(var c=0;c<u;c++){if(read(e,a+c)!==read(r,c)){h=false;break}}if(h)return a}}return-1}Buffer.prototype.includes=function includes(e,r,t){return this.indexOf(e,r,t)!==-1};Buffer.prototype.indexOf=function indexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,true)};Buffer.prototype.lastIndexOf=function lastIndexOf(e,r,t){return bidirectionalIndexOf(this,e,r,t,false)};function hexWrite(e,r,t,f){t=Number(t)||0;var n=e.length-t;if(!f){f=n}else{f=Number(f);if(f>n){f=n}}var i=r.length;if(f>i/2){f=i/2}for(var o=0;o<f;++o){var u=parseInt(r.substr(o*2,2),16);if(numberIsNaN(u))return o;e[t+o]=u}return o}function utf8Write(e,r,t,f){return blitBuffer(utf8ToBytes(r,e.length-t),e,t,f)}function asciiWrite(e,r,t,f){return blitBuffer(asciiToBytes(r),e,t,f)}function latin1Write(e,r,t,f){return asciiWrite(e,r,t,f)}function base64Write(e,r,t,f){return blitBuffer(base64ToBytes(r),e,t,f)}function ucs2Write(e,r,t,f){return blitBuffer(utf16leToBytes(r,e.length-t),e,t,f)}Buffer.prototype.write=function write(e,r,t,f){if(r===undefined){f=\"utf8\";t=this.length;r=0}else if(t===undefined&&typeof r===\"string\"){f=r;t=this.length;r=0}else if(isFinite(r)){r=r>>>0;if(isFinite(t)){t=t>>>0;if(f===undefined)f=\"utf8\"}else{f=t;t=undefined}}else{throw new Error(\"Buffer.write(string, encoding, offset[, length]) is no longer supported\")}var n=this.length-r;if(t===undefined||t>n)t=n;if(e.length>0&&(t<0||r<0)||r>this.length){throw new RangeError(\"Attempt to write outside buffer bounds\")}if(!f)f=\"utf8\";var i=false;for(;;){switch(f){case\"hex\":return hexWrite(this,e,r,t);case\"utf8\":case\"utf-8\":return utf8Write(this,e,r,t);case\"ascii\":return asciiWrite(this,e,r,t);case\"latin1\":case\"binary\":return latin1Write(this,e,r,t);case\"base64\":return base64Write(this,e,r,t);case\"ucs2\":case\"ucs-2\":case\"utf16le\":case\"utf-16le\":return ucs2Write(this,e,r,t);default:if(i)throw new TypeError(\"Unknown encoding: \"+f);f=(\"\"+f).toLowerCase();i=true}}};Buffer.prototype.toJSON=function toJSON(){return{type:\"Buffer\",data:Array.prototype.slice.call(this._arr||this,0)}};function base64Slice(e,r,t){if(r===0&&t===e.length){return f.fromByteArray(e)}else{return f.fromByteArray(e.slice(r,t))}}function utf8Slice(e,r,t){t=Math.min(e.length,t);var f=[];var n=r;while(n<t){var i=e[n];var o=null;var u=i>239?4:i>223?3:i>191?2:1;if(n+u<=t){var a,s,h,c;switch(u){case 1:if(i<128){o=i}break;case 2:a=e[n+1];if((a&192)===128){c=(i&31)<<6|a&63;if(c>127){o=c}}break;case 3:a=e[n+1];s=e[n+2];if((a&192)===128&&(s&192)===128){c=(i&15)<<12|(a&63)<<6|s&63;if(c>2047&&(c<55296||c>57343)){o=c}}break;case 4:a=e[n+1];s=e[n+2];h=e[n+3];if((a&192)===128&&(s&192)===128&&(h&192)===128){c=(i&15)<<18|(a&63)<<12|(s&63)<<6|h&63;if(c>65535&&c<1114112){o=c}}}}if(o===null){o=65533;u=1}else if(o>65535){o-=65536;f.push(o>>>10&1023|55296);o=56320|o&1023}f.push(o);n+=u}return decodeCodePointsArray(f)}var u=4096;function decodeCodePointsArray(e){var r=e.length;if(r<=u){return String.fromCharCode.apply(String,e)}var t=\"\";var f=0;while(f<r){t+=String.fromCharCode.apply(String,e.slice(f,f+=u))}return t}function asciiSlice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n]&127)}return f}function latin1Slice(e,r,t){var f=\"\";t=Math.min(e.length,t);for(var n=r;n<t;++n){f+=String.fromCharCode(e[n])}return f}function hexSlice(e,r,t){var f=e.length;if(!r||r<0)r=0;if(!t||t<0||t>f)t=f;var n=\"\";for(var i=r;i<t;++i){n+=s[e[i]]}return n}function utf16leSlice(e,r,t){var f=e.slice(r,t);var n=\"\";for(var i=0;i<f.length;i+=2){n+=String.fromCharCode(f[i]+f[i+1]*256)}return n}Buffer.prototype.slice=function slice(e,r){var t=this.length;e=~~e;r=r===undefined?t:~~r;if(e<0){e+=t;if(e<0)e=0}else if(e>t){e=t}if(r<0){r+=t;if(r<0)r=0}else if(r>t){r=t}if(r<e)r=e;var f=this.subarray(e,r);Object.setPrototypeOf(f,Buffer.prototype);return f};function checkOffset(e,r,t){if(e%1!==0||e<0)throw new RangeError(\"offset is not uint\");if(e+r>t)throw new RangeError(\"Trying to access beyond buffer length\")}Buffer.prototype.readUIntLE=function readUIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}return f};Buffer.prototype.readUIntBE=function readUIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t){checkOffset(e,r,this.length)}var f=this[e+--r];var n=1;while(r>0&&(n*=256)){f+=this[e+--r]*n}return f};Buffer.prototype.readUInt8=function readUInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);return this[e]};Buffer.prototype.readUInt16LE=function readUInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]|this[e+1]<<8};Buffer.prototype.readUInt16BE=function readUInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);return this[e]<<8|this[e+1]};Buffer.prototype.readUInt32LE=function readUInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return(this[e]|this[e+1]<<8|this[e+2]<<16)+this[e+3]*16777216};Buffer.prototype.readUInt32BE=function readUInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]*16777216+(this[e+1]<<16|this[e+2]<<8|this[e+3])};Buffer.prototype.readIntLE=function readIntLE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=this[e];var n=1;var i=0;while(++i<r&&(n*=256)){f+=this[e+i]*n}n*=128;if(f>=n)f-=Math.pow(2,8*r);return f};Buffer.prototype.readIntBE=function readIntBE(e,r,t){e=e>>>0;r=r>>>0;if(!t)checkOffset(e,r,this.length);var f=r;var n=1;var i=this[e+--f];while(f>0&&(n*=256)){i+=this[e+--f]*n}n*=128;if(i>=n)i-=Math.pow(2,8*r);return i};Buffer.prototype.readInt8=function readInt8(e,r){e=e>>>0;if(!r)checkOffset(e,1,this.length);if(!(this[e]&128))return this[e];return(255-this[e]+1)*-1};Buffer.prototype.readInt16LE=function readInt16LE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e]|this[e+1]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt16BE=function readInt16BE(e,r){e=e>>>0;if(!r)checkOffset(e,2,this.length);var t=this[e+1]|this[e]<<8;return t&32768?t|4294901760:t};Buffer.prototype.readInt32LE=function readInt32LE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]|this[e+1]<<8|this[e+2]<<16|this[e+3]<<24};Buffer.prototype.readInt32BE=function readInt32BE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return this[e]<<24|this[e+1]<<16|this[e+2]<<8|this[e+3]};Buffer.prototype.readFloatLE=function readFloatLE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,true,23,4)};Buffer.prototype.readFloatBE=function readFloatBE(e,r){e=e>>>0;if(!r)checkOffset(e,4,this.length);return n.read(this,e,false,23,4)};Buffer.prototype.readDoubleLE=function readDoubleLE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,true,52,8)};Buffer.prototype.readDoubleBE=function readDoubleBE(e,r){e=e>>>0;if(!r)checkOffset(e,8,this.length);return n.read(this,e,false,52,8)};function checkInt(e,r,t,f,n,i){if(!Buffer.isBuffer(e))throw new TypeError('\"buffer\" argument must be a Buffer instance');if(r>n||r<i)throw new RangeError('\"value\" argument is out of bounds');if(t+f>e.length)throw new RangeError(\"Index out of range\")}Buffer.prototype.writeUIntLE=function writeUIntLE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=1;var o=0;this[r]=e&255;while(++o<t&&(i*=256)){this[r+o]=e/i&255}return r+t};Buffer.prototype.writeUIntBE=function writeUIntBE(e,r,t,f){e=+e;r=r>>>0;t=t>>>0;if(!f){var n=Math.pow(2,8*t)-1;checkInt(this,e,r,t,n,0)}var i=t-1;var o=1;this[r+i]=e&255;while(--i>=0&&(o*=256)){this[r+i]=e/o&255}return r+t};Buffer.prototype.writeUInt8=function writeUInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,255,0);this[r]=e&255;return r+1};Buffer.prototype.writeUInt16LE=function writeUInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeUInt16BE=function writeUInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,65535,0);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeUInt32LE=function writeUInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r+3]=e>>>24;this[r+2]=e>>>16;this[r+1]=e>>>8;this[r]=e&255;return r+4};Buffer.prototype.writeUInt32BE=function writeUInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,4294967295,0);this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};Buffer.prototype.writeIntLE=function writeIntLE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=0;var o=1;var u=0;this[r]=e&255;while(++i<t&&(o*=256)){if(e<0&&u===0&&this[r+i-1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeIntBE=function writeIntBE(e,r,t,f){e=+e;r=r>>>0;if(!f){var n=Math.pow(2,8*t-1);checkInt(this,e,r,t,n-1,-n)}var i=t-1;var o=1;var u=0;this[r+i]=e&255;while(--i>=0&&(o*=256)){if(e<0&&u===0&&this[r+i+1]!==0){u=1}this[r+i]=(e/o>>0)-u&255}return r+t};Buffer.prototype.writeInt8=function writeInt8(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,1,127,-128);if(e<0)e=255+e+1;this[r]=e&255;return r+1};Buffer.prototype.writeInt16LE=function writeInt16LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e&255;this[r+1]=e>>>8;return r+2};Buffer.prototype.writeInt16BE=function writeInt16BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,2,32767,-32768);this[r]=e>>>8;this[r+1]=e&255;return r+2};Buffer.prototype.writeInt32LE=function writeInt32LE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);this[r]=e&255;this[r+1]=e>>>8;this[r+2]=e>>>16;this[r+3]=e>>>24;return r+4};Buffer.prototype.writeInt32BE=function writeInt32BE(e,r,t){e=+e;r=r>>>0;if(!t)checkInt(this,e,r,4,2147483647,-2147483648);if(e<0)e=4294967295+e+1;this[r]=e>>>24;this[r+1]=e>>>16;this[r+2]=e>>>8;this[r+3]=e&255;return r+4};function checkIEEE754(e,r,t,f,n,i){if(t+f>e.length)throw new RangeError(\"Index out of range\");if(t<0)throw new RangeError(\"Index out of range\")}function writeFloat(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,4,34028234663852886e22,-34028234663852886e22)}n.write(e,r,t,f,23,4);return t+4}Buffer.prototype.writeFloatLE=function writeFloatLE(e,r,t){return writeFloat(this,e,r,true,t)};Buffer.prototype.writeFloatBE=function writeFloatBE(e,r,t){return writeFloat(this,e,r,false,t)};function writeDouble(e,r,t,f,i){r=+r;t=t>>>0;if(!i){checkIEEE754(e,r,t,8,17976931348623157e292,-17976931348623157e292)}n.write(e,r,t,f,52,8);return t+8}Buffer.prototype.writeDoubleLE=function writeDoubleLE(e,r,t){return writeDouble(this,e,r,true,t)};Buffer.prototype.writeDoubleBE=function writeDoubleBE(e,r,t){return writeDouble(this,e,r,false,t)};Buffer.prototype.copy=function copy(e,r,t,f){if(!Buffer.isBuffer(e))throw new TypeError(\"argument should be a Buffer\");if(!t)t=0;if(!f&&f!==0)f=this.length;if(r>=e.length)r=e.length;if(!r)r=0;if(f>0&&f<t)f=t;if(f===t)return 0;if(e.length===0||this.length===0)return 0;if(r<0){throw new RangeError(\"targetStart out of bounds\")}if(t<0||t>=this.length)throw new RangeError(\"Index out of range\");if(f<0)throw new RangeError(\"sourceEnd out of bounds\");if(f>this.length)f=this.length;if(e.length-r<f-t){f=e.length-r+t}var n=f-t;if(this===e&&typeof Uint8Array.prototype.copyWithin===\"function\"){this.copyWithin(r,t,f)}else if(this===e&&t<r&&r<f){for(var i=n-1;i>=0;--i){e[i+r]=this[i+t]}}else{Uint8Array.prototype.set.call(e,this.subarray(t,f),r)}return n};Buffer.prototype.fill=function fill(e,r,t,f){if(typeof e===\"string\"){if(typeof r===\"string\"){f=r;r=0;t=this.length}else if(typeof t===\"string\"){f=t;t=this.length}if(f!==undefined&&typeof f!==\"string\"){throw new TypeError(\"encoding must be a string\")}if(typeof f===\"string\"&&!Buffer.isEncoding(f)){throw new TypeError(\"Unknown encoding: \"+f)}if(e.length===1){var n=e.charCodeAt(0);if(f===\"utf8\"&&n<128||f===\"latin1\"){e=n}}}else if(typeof e===\"number\"){e=e&255}else if(typeof e===\"boolean\"){e=Number(e)}if(r<0||this.length<r||this.length<t){throw new RangeError(\"Out of range index\")}if(t<=r){return this}r=r>>>0;t=t===undefined?this.length:t>>>0;if(!e)e=0;var i;if(typeof e===\"number\"){for(i=r;i<t;++i){this[i]=e}}else{var o=Buffer.isBuffer(e)?e:Buffer.from(e,f);var u=o.length;if(u===0){throw new TypeError('The value \"'+e+'\" is invalid for argument \"value\"')}for(i=0;i<t-r;++i){this[i+r]=o[i%u]}}return this};var a=/[^+/0-9A-Za-z-_]/g;function base64clean(e){e=e.split(\"=\")[0];e=e.trim().replace(a,\"\");if(e.length<2)return\"\";while(e.length%4!==0){e=e+\"=\"}return e}function utf8ToBytes(e,r){r=r||Infinity;var t;var f=e.length;var n=null;var i=[];for(var o=0;o<f;++o){t=e.charCodeAt(o);if(t>55295&&t<57344){if(!n){if(t>56319){if((r-=3)>-1)i.push(239,191,189);continue}else if(o+1===f){if((r-=3)>-1)i.push(239,191,189);continue}n=t;continue}if(t<56320){if((r-=3)>-1)i.push(239,191,189);n=t;continue}t=(n-55296<<10|t-56320)+65536}else if(n){if((r-=3)>-1)i.push(239,191,189)}n=null;if(t<128){if((r-=1)<0)break;i.push(t)}else if(t<2048){if((r-=2)<0)break;i.push(t>>6|192,t&63|128)}else if(t<65536){if((r-=3)<0)break;i.push(t>>12|224,t>>6&63|128,t&63|128)}else if(t<1114112){if((r-=4)<0)break;i.push(t>>18|240,t>>12&63|128,t>>6&63|128,t&63|128)}else{throw new Error(\"Invalid code point\")}}return i}function asciiToBytes(e){var r=[];for(var t=0;t<e.length;++t){r.push(e.charCodeAt(t)&255)}return r}function utf16leToBytes(e,r){var t,f,n;var i=[];for(var o=0;o<e.length;++o){if((r-=2)<0)break;t=e.charCodeAt(o);f=t>>8;n=t%256;i.push(n);i.push(f)}return i}function base64ToBytes(e){return f.toByteArray(base64clean(e))}function blitBuffer(e,r,t,f){for(var n=0;n<f;++n){if(n+t>=r.length||n>=e.length)break;r[n+t]=e[n]}return n}function isInstance(e,r){return e instanceof r||e!=null&&e.constructor!=null&&e.constructor.name!=null&&e.constructor.name===r.name}function numberIsNaN(e){return e!==e}var s=function(){var e=\"0123456789abcdef\";var r=new Array(256);for(var t=0;t<16;++t){var f=t*16;for(var n=0;n<16;++n){r[f+n]=e[t]+e[n]}}return r}()},783:function(e,r){\n/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nr.read=function(e,r,t,f,n){var i,o;var u=n*8-f-1;var a=(1<<u)-1;var s=a>>1;var h=-7;var c=t?n-1:0;var l=t?-1:1;var p=e[r+c];c+=l;i=p&(1<<-h)-1;p>>=-h;h+=u;for(;h>0;i=i*256+e[r+c],c+=l,h-=8){}o=i&(1<<-h)-1;i>>=-h;h+=f;for(;h>0;o=o*256+e[r+c],c+=l,h-=8){}if(i===0){i=1-s}else if(i===a){return o?NaN:(p?-1:1)*Infinity}else{o=o+Math.pow(2,f);i=i-s}return(p?-1:1)*o*Math.pow(2,i-f)};r.write=function(e,r,t,f,n,i){var o,u,a;var s=i*8-n-1;var h=(1<<s)-1;var c=h>>1;var l=n===23?Math.pow(2,-24)-Math.pow(2,-77):0;var p=f?0:i-1;var y=f?1:-1;var g=r<0||r===0&&1/r<0?1:0;r=Math.abs(r);if(isNaN(r)||r===Infinity){u=isNaN(r)?1:0;o=h}else{o=Math.floor(Math.log(r)/Math.LN2);if(r*(a=Math.pow(2,-o))<1){o--;a*=2}if(o+c>=1){r+=l/a}else{r+=l*Math.pow(2,1-c)}if(r*a>=2){o++;a/=2}if(o+c>=h){u=0;o=h}else if(o+c>=1){u=(r*a-1)*Math.pow(2,n);o=o+c}else{u=r*Math.pow(2,c-1)*Math.pow(2,n);o=0}}for(;n>=8;e[t+p]=u&255,p+=y,u/=256,n-=8){}o=o<<n|u;s+=n;for(;s>0;e[t+p]=o&255,p+=y,o/=256,s-=8){}e[t+p-y]|=g*128}}};var r={};function __nccwpck_require__(t){var f=r[t];if(f!==undefined){return f.exports}var n=r[t]={exports:{}};var i=true;try{e[t](n,n.exports,__nccwpck_require__);i=false}finally{if(i)delete r[t]}return n.exports}if(typeof __nccwpck_require__!==\"undefined\")__nccwpck_require__.ab=__dirname+\"/\";var t=__nccwpck_require__(72);module.exports=t})();//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9idWZmZXIvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6IjtBQUFBLFlBQVksT0FBTyxrQkFBa0IsYUFBYSx3QkFBd0IsMEJBQTBCLDhCQUE4QixTQUFTLFNBQVMsdURBQXVELHlFQUF5RSx1QkFBdUIsSUFBSSxLQUFLLFVBQVUscUJBQXFCLHdCQUF3Qix3QkFBd0Isb0JBQW9CLGVBQWUsVUFBVSxrRUFBa0UscUJBQXFCLGNBQWMsb0JBQW9CLFlBQVksdUJBQXVCLGlCQUFpQixXQUFXLFdBQVcsa0JBQWtCLDRCQUE0QixrQkFBa0Isd0JBQXdCLE1BQU0saUJBQWlCLFdBQVcsV0FBVyxnQ0FBZ0MsUUFBUSxnQkFBZ0IsTUFBTSxRQUFRLElBQUksTUFBTSwrRkFBK0YsaUJBQWlCLGdCQUFnQixhQUFhLFVBQVUsZ0RBQWdELGFBQWEsVUFBVSx5RUFBeUUsZ0JBQWdCLGFBQWEsU0FBUyw0QkFBNEIsa0RBQWtELDRCQUE0QixNQUFNLFNBQVMsWUFBWSxJQUFJLE1BQU0scURBQXFELDJCQUEyQixrQkFBa0IsMEJBQTBCLE1BQU0sZUFBZSxVQUFVLFNBQVMsWUFBWSxrQkFBa0IsSUFBSSxNQUFNLHFDQUFxQyxVQUFVLFNBQVMsZ0NBQWdDLGVBQWUscUJBQXFCLDJDQUEyQyxtQkFBbUIsb0JBQW9CO0FBQzlyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCLGFBQWEsK0dBQStHLGdCQUFnQix3QkFBd0IsdUJBQXVCLGlCQUFpQixlQUFlLCtDQUErQyxpR0FBaUcsa0tBQWtLLDZCQUE2QixJQUFJLHdCQUF3QixPQUFPLGVBQWUsWUFBWSw4Q0FBOEMsMkJBQTJCLG9CQUFvQixTQUFTLGNBQWMsaURBQWlELCtCQUErQiwyQ0FBMkMsb0JBQW9CLEVBQUUsaURBQWlELCtCQUErQiwyQ0FBMkMsd0JBQXdCLEVBQUUseUJBQXlCLFFBQVEsdUVBQXVFLHdCQUF3QiwwQ0FBMEMsU0FBUyx1QkFB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QyxjQUFjLGFBQWEsNEJBQTRCLGNBQWMsMkJBQTJCLGVBQWUsSUFBSSxLQUFLLG1DQUFtQywyQkFBMkIsSUFBSSxLQUFLLFdBQVcsT0FBTyxLQUFLLHFCQUFxQixXQUFXLElBQUksS0FBSyxXQUFXLElBQUksSUFBSSxnQkFBZ0Isd0JBQXdCLE1BQU0sS0FBSyxrQ0FBa0MsS0FBSyxLQUFLLEtBQUssZ0NBQWdDLFNBQVMsS0FBSyxLQUFLLElBQUksZ0NBQWdDLG1CQUFtQixTQUFTLGdDQUFnQyxXQUFXLGtCQUFrQixpQkFBaUIsWUFBWSxZQUFZLFdBQVcsSUFBSSxzQ0FBc0MsUUFBUSxRQUFRLGlCQUFpQixpQkFBaUIsbUVBQW1FLFNBQVMsS0FBSyw4QkFBOEIsaUJBQWlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvYnVmZmVyL2luZGV4LmpzPzQ5ZmMiXSwic291cmNlc0NvbnRlbnQiOlsiKGZ1bmN0aW9uKCl7dmFyIGU9ezY3NTpmdW5jdGlvbihlLHIpe1widXNlIHN0cmljdFwiO3IuYnl0ZUxlbmd0aD1ieXRlTGVuZ3RoO3IudG9CeXRlQXJyYXk9dG9CeXRlQXJyYXk7ci5mcm9tQnl0ZUFycmF5PWZyb21CeXRlQXJyYXk7dmFyIHQ9W107dmFyIGY9W107dmFyIG49dHlwZW9mIFVpbnQ4QXJyYXkhPT1cInVuZGVmaW5lZFwiP1VpbnQ4QXJyYXk6QXJyYXk7dmFyIGk9XCJBQkNERUZHSElKS0xNTk9QUVJTVFVWV1hZWmFiY2RlZmdoaWprbG1ub3BxcnN0dXZ3eHl6MDEyMzQ1Njc4OSsvXCI7Zm9yKHZhciBvPTAsdT1pLmxlbmd0aDtvPHU7KytvKXt0W29dPWlbb107ZltpLmNoYXJDb2RlQXQobyldPW99ZltcIi1cIi5jaGFyQ29kZUF0KDApXT02MjtmW1wiX1wiLmNoYXJDb2RlQXQoMCldPTYzO2Z1bmN0aW9uIGdldExlbnMoZSl7dmFyIHI9ZS5sZW5ndGg7aWYociU0PjApe3Rocm93IG5ldyBFcnJvcihcIkludmFsaWQgc3RyaW5nLiBMZW5ndGggbXVzdCBiZSBhIG11bHRpcGxlIG9mIDRcIil9dmFyIHQ9ZS5pbmRleE9mKFwiPVwiKTtpZih0PT09LTEpdD1yO3ZhciBmPXQ9PT1yPzA6NC10JTQ7cmV0dXJuW3QsZl19ZnVuY3Rpb24gYnl0ZUxlbmd0aChlKXt2YXIgcj1nZXRMZW5zKGUpO3ZhciB0PXJbMF07dmFyIGY9clsxXTtyZXR1cm4odCtmKSozLzQtZn1mdW5jdGlvbiBfYnl0ZUxlbmd0aChlLHIsdCl7cmV0dXJuKHIrdCkqMy80LXR9ZnVuY3Rpb24gdG9CeXRlQXJyYXkoZSl7dmFyIHI7dmFyIHQ9Z2V0TGVucyhlKTt2YXIgaT10WzBdO3ZhciBvPXRbMV07dmFyIHU9bmV3IG4oX2J5dGVMZW5ndGgoZSxpLG8pKTt2YXIgYT0wO3ZhciBzPW8+MD9pLTQ6aTt2YXIgaDtmb3IoaD0wO2g8cztoKz00KXtyPWZbZS5jaGFyQ29kZUF0KGgpXTw8MTh8ZltlLmNoYXJDb2RlQXQoaCsxKV08PDEyfGZbZS5jaGFyQ29kZUF0KGgrMildPDw2fGZbZS5jaGFyQ29kZUF0KGgrMyldO3VbYSsrXT1yPj4xNiYyNTU7dVthKytdPXI+PjgmMjU1O3VbYSsrXT1yJjI1NX1pZihvPT09Mil7cj1mW2UuY2hhckNvZGVBdChoKV08PDJ8ZltlLmNoYXJDb2RlQXQoaCsxKV0+PjQ7dVthKytdPXImMjU1fWlmKG89PT0xKXtyPWZbZS5jaGFyQ29kZUF0KGgpXTw8MTB8ZltlLmNoYXJDb2RlQXQoaCsxKV08PDR8ZltlLmNoYXJDb2RlQXQoaCsyKV0+PjI7dVthKytdPXI+PjgmMjU1O3VbYSsrXT1yJjI1NX1yZXR1cm4gdX1mdW5jdGlvbiB0cmlwbGV0VG9CYXNlNjQoZSl7cmV0dXJuIHRbZT4+MTgmNjNdK3RbZT4+MTImNjNdK3RbZT4+NiY2M10rdFtlJjYzXX1mdW5jdGlvbiBlbmNvZGVDaHVuayhlLHIsdCl7dmFyIGY7dmFyIG49W107Zm9yKHZhciBpPXI7aTx0O2krPTMpe2Y9KGVbaV08PDE2JjE2NzExNjgwKSsoZVtpKzFdPDw4JjY1MjgwKSsoZVtpKzJdJjI1NSk7bi5wdXNoKHRyaXBsZXRUb0Jhc2U2NChmKSl9cmV0dXJuIG4uam9pbihcIlwiKX1mdW5jdGlvbiBmcm9tQnl0ZUFycmF5KGUpe3ZhciByO3ZhciBmPWUubGVuZ3RoO3ZhciBuPWYlMzt2YXIgaT1bXTt2YXIgbz0xNjM4Mztmb3IodmFyIHU9MCxhPWYtbjt1PGE7dSs9byl7aS5wdXNoKGVuY29kZUNodW5rKGUsdSx1K28+YT9hOnUrbykpfWlmKG49PT0xKXtyPWVbZi0xXTtpLnB1c2godFtyPj4yXSt0W3I8PDQmNjNdK1wiPT1cIil9ZWxzZSBpZihuPT09Mil7cj0oZVtmLTJdPDw4KStlW2YtMV07aS5wdXNoKHRbcj4+MTBdK3Rbcj4+NCY2M10rdFtyPDwyJjYzXStcIj1cIil9cmV0dXJuIGkuam9pbihcIlwiKX19LDcyOmZ1bmN0aW9uKGUscix0KXtcInVzZSBzdHJpY3RcIjtcbi8qIVxuICogVGhlIGJ1ZmZlciBtb2R1bGUgZnJvbSBub2RlLmpzLCBmb3IgdGhlIGJyb3dzZXIuXG4gKlxuICogQGF1dGhvciAgIEZlcm9zcyBBYm91a2hhZGlqZWggPGh0dHBzOi8vZmVyb3NzLm9yZz5cbiAqIEBsaWNlbnNlICBNSVRcbiAqL3ZhciBmPXQoNjc1KTt2YXIgbj10KDc4Myk7dmFyIGk9dHlwZW9mIFN5bWJvbD09PVwiZnVuY3Rpb25cIiYmdHlwZW9mIFN5bWJvbC5mb3I9PT1cImZ1bmN0aW9uXCI/U3ltYm9sLmZvcihcIm5vZGVqcy51dGlsLmluc3BlY3QuY3VzdG9tXCIpOm51bGw7ci5CdWZmZXI9QnVmZmVyO3IuU2xvd0J1ZmZlcj1TbG93QnVmZmVyO3IuSU5TUEVDVF9NQVhfQllURVM9NTA7dmFyIG89MjE0NzQ4MzY0NztyLmtNYXhMZW5ndGg9bztCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVD10eXBlZEFycmF5U3VwcG9ydCgpO2lmKCFCdWZmZXIuVFlQRURfQVJSQVlfU1VQUE9SVCYmdHlwZW9mIGNvbnNvbGUhPT1cInVuZGVmaW5lZFwiJiZ0eXBlb2YgY29uc29sZS5lcnJvcj09PVwiZnVuY3Rpb25cIil7Y29uc29sZS5lcnJvcihcIlRoaXMgYnJvd3NlciBsYWNrcyB0eXBlZCBhcnJheSAoVWludDhBcnJheSkgc3VwcG9ydCB3aGljaCBpcyByZXF1aXJlZCBieSBcIitcImBidWZmZXJgIHY1LnguIFVzZSBgYnVmZmVyYCB2NC54IGlmIHlvdSByZXF1aXJlIG9sZCBicm93c2VyIHN1cHBvcnQuXCIpfWZ1bmN0aW9uIHR5cGVkQXJyYXlTdXBwb3J0KCl7dHJ5e3ZhciBlPW5ldyBVaW50OEFycmF5KDEpO3ZhciByPXtmb286ZnVuY3Rpb24oKXtyZXR1cm4gNDJ9fTtPYmplY3Quc2V0UHJvdG90eXBlT2YocixVaW50OEFycmF5LnByb3RvdHlwZSk7T2JqZWN0LnNldFByb3RvdHlwZU9mKGUscik7cmV0dXJuIGUuZm9vKCk9PT00Mn1jYXRjaChlKXtyZXR1cm4gZmFsc2V9fU9iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLFwicGFyZW50XCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtpZighQnVmZmVyLmlzQnVmZmVyKHRoaXMpKXJldHVybiB1bmRlZmluZWQ7cmV0dXJuIHRoaXMuYnVmZmVyfX0pO09iamVjdC5kZWZpbmVQcm9wZXJ0eShCdWZmZXIucHJvdG90eXBlLFwib2Zmc2V0XCIse2VudW1lcmFibGU6dHJ1ZSxnZXQ6ZnVuY3Rpb24oKXtpZighQnVmZmVyLmlzQnVmZmVyKHRoaXMpKXJldHVybiB1bmRlZmluZWQ7cmV0dXJuIHRoaXMuYnl0ZU9mZnNldH19KTtmdW5jdGlvbiBjcmVhdGVCdWZmZXIoZSl7aWYoZT5vKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJytlKydcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKX12YXIgcj1uZXcgVWludDhBcnJheShlKTtPYmplY3Quc2V0UHJvdG90eXBlT2YocixCdWZmZXIucHJvdG90eXBlKTtyZXR1cm4gcn1mdW5jdGlvbiBCdWZmZXIoZSxyLHQpe2lmKHR5cGVvZiBlPT09XCJudW1iZXJcIil7aWYodHlwZW9mIHI9PT1cInN0cmluZ1wiKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJzdHJpbmdcIiBhcmd1bWVudCBtdXN0IGJlIG9mIHR5cGUgc3RyaW5nLiBSZWNlaXZlZCB0eXBlIG51bWJlcicpfXJldHVybiBhbGxvY1Vuc2FmZShlKX1yZXR1cm4gZnJvbShlLHIsdCl9QnVmZmVyLnBvb2xTaXplPTgxOTI7ZnVuY3Rpb24gZnJvbShlLHIsdCl7aWYodHlwZW9mIGU9PT1cInN0cmluZ1wiKXtyZXR1cm4gZnJvbVN0cmluZyhlLHIpfWlmKEFycmF5QnVmZmVyLmlzVmlldyhlKSl7cmV0dXJuIGZyb21BcnJheUxpa2UoZSl9aWYoZT09bnVsbCl7dGhyb3cgbmV3IFR5cGVFcnJvcihcIlRoZSBmaXJzdCBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIHN0cmluZywgQnVmZmVyLCBBcnJheUJ1ZmZlciwgQXJyYXksIFwiK1wib3IgQXJyYXktbGlrZSBPYmplY3QuIFJlY2VpdmVkIHR5cGUgXCIrdHlwZW9mIGUpfWlmKGlzSW5zdGFuY2UoZSxBcnJheUJ1ZmZlcil8fGUmJmlzSW5zdGFuY2UoZS5idWZmZXIsQXJyYXlCdWZmZXIpKXtyZXR1cm4gZnJvbUFycmF5QnVmZmVyKGUscix0KX1pZih0eXBlb2YgU2hhcmVkQXJyYXlCdWZmZXIhPT1cInVuZGVmaW5lZFwiJiYoaXNJbnN0YW5jZShlLFNoYXJlZEFycmF5QnVmZmVyKXx8ZSYmaXNJbnN0YW5jZShlLmJ1ZmZlcixTaGFyZWRBcnJheUJ1ZmZlcikpKXtyZXR1cm4gZnJvbUFycmF5QnVmZmVyKGUscix0KX1pZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInZhbHVlXCIgYXJndW1lbnQgbXVzdCBub3QgYmUgb2YgdHlwZSBudW1iZXIuIFJlY2VpdmVkIHR5cGUgbnVtYmVyJyl9dmFyIGY9ZS52YWx1ZU9mJiZlLnZhbHVlT2YoKTtpZihmIT1udWxsJiZmIT09ZSl7cmV0dXJuIEJ1ZmZlci5mcm9tKGYscix0KX12YXIgbj1mcm9tT2JqZWN0KGUpO2lmKG4pcmV0dXJuIG47aWYodHlwZW9mIFN5bWJvbCE9PVwidW5kZWZpbmVkXCImJlN5bWJvbC50b1ByaW1pdGl2ZSE9bnVsbCYmdHlwZW9mIGVbU3ltYm9sLnRvUHJpbWl0aXZlXT09PVwiZnVuY3Rpb25cIil7cmV0dXJuIEJ1ZmZlci5mcm9tKGVbU3ltYm9sLnRvUHJpbWl0aXZlXShcInN0cmluZ1wiKSxyLHQpfXRocm93IG5ldyBUeXBlRXJyb3IoXCJUaGUgZmlyc3QgYXJndW1lbnQgbXVzdCBiZSBvbmUgb2YgdHlwZSBzdHJpbmcsIEJ1ZmZlciwgQXJyYXlCdWZmZXIsIEFycmF5LCBcIitcIm9yIEFycmF5LWxpa2UgT2JqZWN0LiBSZWNlaXZlZCB0eXBlIFwiK3R5cGVvZiBlKX1CdWZmZXIuZnJvbT1mdW5jdGlvbihlLHIsdCl7cmV0dXJuIGZyb20oZSxyLHQpfTtPYmplY3Quc2V0UHJvdG90eXBlT2YoQnVmZmVyLnByb3RvdHlwZSxVaW50OEFycmF5LnByb3RvdHlwZSk7T2JqZWN0LnNldFByb3RvdHlwZU9mKEJ1ZmZlcixVaW50OEFycmF5KTtmdW5jdGlvbiBhc3NlcnRTaXplKGUpe2lmKHR5cGVvZiBlIT09XCJudW1iZXJcIil7dGhyb3cgbmV3IFR5cGVFcnJvcignXCJzaXplXCIgYXJndW1lbnQgbXVzdCBiZSBvZiB0eXBlIG51bWJlcicpfWVsc2UgaWYoZTwwKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcignVGhlIHZhbHVlIFwiJytlKydcIiBpcyBpbnZhbGlkIGZvciBvcHRpb24gXCJzaXplXCInKX19ZnVuY3Rpb24gYWxsb2MoZSxyLHQpe2Fzc2VydFNpemUoZSk7aWYoZTw9MCl7cmV0dXJuIGNyZWF0ZUJ1ZmZlcihlKX1pZihyIT09dW5kZWZpbmVkKXtyZXR1cm4gdHlwZW9mIHQ9PT1cInN0cmluZ1wiP2NyZWF0ZUJ1ZmZlcihlKS5maWxsKHIsdCk6Y3JlYXRlQnVmZmVyKGUpLmZpbGwocil9cmV0dXJuIGNyZWF0ZUJ1ZmZlcihlKX1CdWZmZXIuYWxsb2M9ZnVuY3Rpb24oZSxyLHQpe3JldHVybiBhbGxvYyhlLHIsdCl9O2Z1bmN0aW9uIGFsbG9jVW5zYWZlKGUpe2Fzc2VydFNpemUoZSk7cmV0dXJuIGNyZWF0ZUJ1ZmZlcihlPDA/MDpjaGVja2VkKGUpfDApfUJ1ZmZlci5hbGxvY1Vuc2FmZT1mdW5jdGlvbihlKXtyZXR1cm4gYWxsb2NVbnNhZmUoZSl9O0J1ZmZlci5hbGxvY1Vuc2FmZVNsb3c9ZnVuY3Rpb24oZSl7cmV0dXJuIGFsbG9jVW5zYWZlKGUpfTtmdW5jdGlvbiBmcm9tU3RyaW5nKGUscil7aWYodHlwZW9mIHIhPT1cInN0cmluZ1wifHxyPT09XCJcIil7cj1cInV0ZjhcIn1pZighQnVmZmVyLmlzRW5jb2Rpbmcocikpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIityKX12YXIgdD1ieXRlTGVuZ3RoKGUscil8MDt2YXIgZj1jcmVhdGVCdWZmZXIodCk7dmFyIG49Zi53cml0ZShlLHIpO2lmKG4hPT10KXtmPWYuc2xpY2UoMCxuKX1yZXR1cm4gZn1mdW5jdGlvbiBmcm9tQXJyYXlMaWtlKGUpe3ZhciByPWUubGVuZ3RoPDA/MDpjaGVja2VkKGUubGVuZ3RoKXwwO3ZhciB0PWNyZWF0ZUJ1ZmZlcihyKTtmb3IodmFyIGY9MDtmPHI7Zis9MSl7dFtmXT1lW2ZdJjI1NX1yZXR1cm4gdH1mdW5jdGlvbiBmcm9tQXJyYXlCdWZmZXIoZSxyLHQpe2lmKHI8MHx8ZS5ieXRlTGVuZ3RoPHIpe3Rocm93IG5ldyBSYW5nZUVycm9yKCdcIm9mZnNldFwiIGlzIG91dHNpZGUgb2YgYnVmZmVyIGJvdW5kcycpfWlmKGUuYnl0ZUxlbmd0aDxyKyh0fHwwKSl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoJ1wibGVuZ3RoXCIgaXMgb3V0c2lkZSBvZiBidWZmZXIgYm91bmRzJyl9dmFyIGY7aWYocj09PXVuZGVmaW5lZCYmdD09PXVuZGVmaW5lZCl7Zj1uZXcgVWludDhBcnJheShlKX1lbHNlIGlmKHQ9PT11bmRlZmluZWQpe2Y9bmV3IFVpbnQ4QXJyYXkoZSxyKX1lbHNle2Y9bmV3IFVpbnQ4QXJyYXkoZSxyLHQpfU9iamVjdC5zZXRQcm90b3R5cGVPZihmLEJ1ZmZlci5wcm90b3R5cGUpO3JldHVybiBmfWZ1bmN0aW9uIGZyb21PYmplY3QoZSl7aWYoQnVmZmVyLmlzQnVmZmVyKGUpKXt2YXIgcj1jaGVja2VkKGUubGVuZ3RoKXwwO3ZhciB0PWNyZWF0ZUJ1ZmZlcihyKTtpZih0Lmxlbmd0aD09PTApe3JldHVybiB0fWUuY29weSh0LDAsMCxyKTtyZXR1cm4gdH1pZihlLmxlbmd0aCE9PXVuZGVmaW5lZCl7aWYodHlwZW9mIGUubGVuZ3RoIT09XCJudW1iZXJcInx8bnVtYmVySXNOYU4oZS5sZW5ndGgpKXtyZXR1cm4gY3JlYXRlQnVmZmVyKDApfXJldHVybiBmcm9tQXJyYXlMaWtlKGUpfWlmKGUudHlwZT09PVwiQnVmZmVyXCImJkFycmF5LmlzQXJyYXkoZS5kYXRhKSl7cmV0dXJuIGZyb21BcnJheUxpa2UoZS5kYXRhKX19ZnVuY3Rpb24gY2hlY2tlZChlKXtpZihlPj1vKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkF0dGVtcHQgdG8gYWxsb2NhdGUgQnVmZmVyIGxhcmdlciB0aGFuIG1heGltdW0gXCIrXCJzaXplOiAweFwiK28udG9TdHJpbmcoMTYpK1wiIGJ5dGVzXCIpfXJldHVybiBlfDB9ZnVuY3Rpb24gU2xvd0J1ZmZlcihlKXtpZigrZSE9ZSl7ZT0wfXJldHVybiBCdWZmZXIuYWxsb2MoK2UpfUJ1ZmZlci5pc0J1ZmZlcj1mdW5jdGlvbiBpc0J1ZmZlcihlKXtyZXR1cm4gZSE9bnVsbCYmZS5faXNCdWZmZXI9PT10cnVlJiZlIT09QnVmZmVyLnByb3RvdHlwZX07QnVmZmVyLmNvbXBhcmU9ZnVuY3Rpb24gY29tcGFyZShlLHIpe2lmKGlzSW5zdGFuY2UoZSxVaW50OEFycmF5KSllPUJ1ZmZlci5mcm9tKGUsZS5vZmZzZXQsZS5ieXRlTGVuZ3RoKTtpZihpc0luc3RhbmNlKHIsVWludDhBcnJheSkpcj1CdWZmZXIuZnJvbShyLHIub2Zmc2V0LHIuYnl0ZUxlbmd0aCk7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKXx8IUJ1ZmZlci5pc0J1ZmZlcihyKSl7dGhyb3cgbmV3IFR5cGVFcnJvcignVGhlIFwiYnVmMVwiLCBcImJ1ZjJcIiBhcmd1bWVudHMgbXVzdCBiZSBvbmUgb2YgdHlwZSBCdWZmZXIgb3IgVWludDhBcnJheScpfWlmKGU9PT1yKXJldHVybiAwO3ZhciB0PWUubGVuZ3RoO3ZhciBmPXIubGVuZ3RoO2Zvcih2YXIgbj0wLGk9TWF0aC5taW4odCxmKTtuPGk7KytuKXtpZihlW25dIT09cltuXSl7dD1lW25dO2Y9cltuXTticmVha319aWYodDxmKXJldHVybi0xO2lmKGY8dClyZXR1cm4gMTtyZXR1cm4gMH07QnVmZmVyLmlzRW5jb2Rpbmc9ZnVuY3Rpb24gaXNFbmNvZGluZyhlKXtzd2l0Y2goU3RyaW5nKGUpLnRvTG93ZXJDYXNlKCkpe2Nhc2VcImhleFwiOmNhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOmNhc2VcImFzY2lpXCI6Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6Y2FzZVwiYmFzZTY0XCI6Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHRydWU7ZGVmYXVsdDpyZXR1cm4gZmFsc2V9fTtCdWZmZXIuY29uY2F0PWZ1bmN0aW9uIGNvbmNhdChlLHIpe2lmKCFBcnJheS5pc0FycmF5KGUpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKX1pZihlLmxlbmd0aD09PTApe3JldHVybiBCdWZmZXIuYWxsb2MoMCl9dmFyIHQ7aWYocj09PXVuZGVmaW5lZCl7cj0wO2Zvcih0PTA7dDxlLmxlbmd0aDsrK3Qpe3IrPWVbdF0ubGVuZ3RofX12YXIgZj1CdWZmZXIuYWxsb2NVbnNhZmUocik7dmFyIG49MDtmb3IodD0wO3Q8ZS5sZW5ndGg7Kyt0KXt2YXIgaT1lW3RdO2lmKGlzSW5zdGFuY2UoaSxVaW50OEFycmF5KSl7aT1CdWZmZXIuZnJvbShpKX1pZighQnVmZmVyLmlzQnVmZmVyKGkpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdcImxpc3RcIiBhcmd1bWVudCBtdXN0IGJlIGFuIEFycmF5IG9mIEJ1ZmZlcnMnKX1pLmNvcHkoZixuKTtuKz1pLmxlbmd0aH1yZXR1cm4gZn07ZnVuY3Rpb24gYnl0ZUxlbmd0aChlLHIpe2lmKEJ1ZmZlci5pc0J1ZmZlcihlKSl7cmV0dXJuIGUubGVuZ3RofWlmKEFycmF5QnVmZmVyLmlzVmlldyhlKXx8aXNJbnN0YW5jZShlLEFycmF5QnVmZmVyKSl7cmV0dXJuIGUuYnl0ZUxlbmd0aH1pZih0eXBlb2YgZSE9PVwic3RyaW5nXCIpe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBcInN0cmluZ1wiIGFyZ3VtZW50IG11c3QgYmUgb25lIG9mIHR5cGUgc3RyaW5nLCBCdWZmZXIsIG9yIEFycmF5QnVmZmVyLiAnK1wiUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9dmFyIHQ9ZS5sZW5ndGg7dmFyIGY9YXJndW1lbnRzLmxlbmd0aD4yJiZhcmd1bWVudHNbMl09PT10cnVlO2lmKCFmJiZ0PT09MClyZXR1cm4gMDt2YXIgbj1mYWxzZTtmb3IoOzspe3N3aXRjaChyKXtjYXNlXCJhc2NpaVwiOmNhc2VcImxhdGluMVwiOmNhc2VcImJpbmFyeVwiOnJldHVybiB0O2Nhc2VcInV0ZjhcIjpjYXNlXCJ1dGYtOFwiOnJldHVybiB1dGY4VG9CeXRlcyhlKS5sZW5ndGg7Y2FzZVwidWNzMlwiOmNhc2VcInVjcy0yXCI6Y2FzZVwidXRmMTZsZVwiOmNhc2VcInV0Zi0xNmxlXCI6cmV0dXJuIHQqMjtjYXNlXCJoZXhcIjpyZXR1cm4gdD4+PjE7Y2FzZVwiYmFzZTY0XCI6cmV0dXJuIGJhc2U2NFRvQnl0ZXMoZSkubGVuZ3RoO2RlZmF1bHQ6aWYobil7cmV0dXJuIGY/LTE6dXRmOFRvQnl0ZXMoZSkubGVuZ3RofXI9KFwiXCIrcikudG9Mb3dlckNhc2UoKTtuPXRydWV9fX1CdWZmZXIuYnl0ZUxlbmd0aD1ieXRlTGVuZ3RoO2Z1bmN0aW9uIHNsb3dUb1N0cmluZyhlLHIsdCl7dmFyIGY9ZmFsc2U7aWYocj09PXVuZGVmaW5lZHx8cjwwKXtyPTB9aWYocj50aGlzLmxlbmd0aCl7cmV0dXJuXCJcIn1pZih0PT09dW5kZWZpbmVkfHx0PnRoaXMubGVuZ3RoKXt0PXRoaXMubGVuZ3RofWlmKHQ8PTApe3JldHVyblwiXCJ9dD4+Pj0wO3I+Pj49MDtpZih0PD1yKXtyZXR1cm5cIlwifWlmKCFlKWU9XCJ1dGY4XCI7d2hpbGUodHJ1ZSl7c3dpdGNoKGUpe2Nhc2VcImhleFwiOnJldHVybiBoZXhTbGljZSh0aGlzLHIsdCk7Y2FzZVwidXRmOFwiOmNhc2VcInV0Zi04XCI6cmV0dXJuIHV0ZjhTbGljZSh0aGlzLHIsdCk7Y2FzZVwiYXNjaWlcIjpyZXR1cm4gYXNjaWlTbGljZSh0aGlzLHIsdCk7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIGxhdGluMVNsaWNlKHRoaXMscix0KTtjYXNlXCJiYXNlNjRcIjpyZXR1cm4gYmFzZTY0U2xpY2UodGhpcyxyLHQpO2Nhc2VcInVjczJcIjpjYXNlXCJ1Y3MtMlwiOmNhc2VcInV0ZjE2bGVcIjpjYXNlXCJ1dGYtMTZsZVwiOnJldHVybiB1dGYxNmxlU2xpY2UodGhpcyxyLHQpO2RlZmF1bHQ6aWYoZil0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZSk7ZT0oZStcIlwiKS50b0xvd2VyQ2FzZSgpO2Y9dHJ1ZX19fUJ1ZmZlci5wcm90b3R5cGUuX2lzQnVmZmVyPXRydWU7ZnVuY3Rpb24gc3dhcChlLHIsdCl7dmFyIGY9ZVtyXTtlW3JdPWVbdF07ZVt0XT1mfUJ1ZmZlci5wcm90b3R5cGUuc3dhcDE2PWZ1bmN0aW9uIHN3YXAxNigpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGUlMiE9PTApe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDE2LWJpdHNcIil9Zm9yKHZhciByPTA7cjxlO3IrPTIpe3N3YXAodGhpcyxyLHIrMSl9cmV0dXJuIHRoaXN9O0J1ZmZlci5wcm90b3R5cGUuc3dhcDMyPWZ1bmN0aW9uIHN3YXAzMigpe3ZhciBlPXRoaXMubGVuZ3RoO2lmKGUlNCE9PTApe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiQnVmZmVyIHNpemUgbXVzdCBiZSBhIG11bHRpcGxlIG9mIDMyLWJpdHNcIil9Zm9yKHZhciByPTA7cjxlO3IrPTQpe3N3YXAodGhpcyxyLHIrMyk7c3dhcCh0aGlzLHIrMSxyKzIpfXJldHVybiB0aGlzfTtCdWZmZXIucHJvdG90eXBlLnN3YXA2ND1mdW5jdGlvbiBzd2FwNjQoKXt2YXIgZT10aGlzLmxlbmd0aDtpZihlJTghPT0wKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkJ1ZmZlciBzaXplIG11c3QgYmUgYSBtdWx0aXBsZSBvZiA2NC1iaXRzXCIpfWZvcih2YXIgcj0wO3I8ZTtyKz04KXtzd2FwKHRoaXMscixyKzcpO3N3YXAodGhpcyxyKzEscis2KTtzd2FwKHRoaXMscisyLHIrNSk7c3dhcCh0aGlzLHIrMyxyKzQpfXJldHVybiB0aGlzfTtCdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nPWZ1bmN0aW9uIHRvU3RyaW5nKCl7dmFyIGU9dGhpcy5sZW5ndGg7aWYoZT09PTApcmV0dXJuXCJcIjtpZihhcmd1bWVudHMubGVuZ3RoPT09MClyZXR1cm4gdXRmOFNsaWNlKHRoaXMsMCxlKTtyZXR1cm4gc2xvd1RvU3RyaW5nLmFwcGx5KHRoaXMsYXJndW1lbnRzKX07QnVmZmVyLnByb3RvdHlwZS50b0xvY2FsZVN0cmluZz1CdWZmZXIucHJvdG90eXBlLnRvU3RyaW5nO0J1ZmZlci5wcm90b3R5cGUuZXF1YWxzPWZ1bmN0aW9uIGVxdWFscyhlKXtpZighQnVmZmVyLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoXCJBcmd1bWVudCBtdXN0IGJlIGEgQnVmZmVyXCIpO2lmKHRoaXM9PT1lKXJldHVybiB0cnVlO3JldHVybiBCdWZmZXIuY29tcGFyZSh0aGlzLGUpPT09MH07QnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0PWZ1bmN0aW9uIGluc3BlY3QoKXt2YXIgZT1cIlwiO3ZhciB0PXIuSU5TUEVDVF9NQVhfQllURVM7ZT10aGlzLnRvU3RyaW5nKFwiaGV4XCIsMCx0KS5yZXBsYWNlKC8oLnsyfSkvZyxcIiQxIFwiKS50cmltKCk7aWYodGhpcy5sZW5ndGg+dCllKz1cIiAuLi4gXCI7cmV0dXJuXCI8QnVmZmVyIFwiK2UrXCI+XCJ9O2lmKGkpe0J1ZmZlci5wcm90b3R5cGVbaV09QnVmZmVyLnByb3RvdHlwZS5pbnNwZWN0fUJ1ZmZlci5wcm90b3R5cGUuY29tcGFyZT1mdW5jdGlvbiBjb21wYXJlKGUscix0LGYsbil7aWYoaXNJbnN0YW5jZShlLFVpbnQ4QXJyYXkpKXtlPUJ1ZmZlci5mcm9tKGUsZS5vZmZzZXQsZS5ieXRlTGVuZ3RoKX1pZighQnVmZmVyLmlzQnVmZmVyKGUpKXt0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgXCJ0YXJnZXRcIiBhcmd1bWVudCBtdXN0IGJlIG9uZSBvZiB0eXBlIEJ1ZmZlciBvciBVaW50OEFycmF5LiAnK1wiUmVjZWl2ZWQgdHlwZSBcIit0eXBlb2YgZSl9aWYocj09PXVuZGVmaW5lZCl7cj0wfWlmKHQ9PT11bmRlZmluZWQpe3Q9ZT9lLmxlbmd0aDowfWlmKGY9PT11bmRlZmluZWQpe2Y9MH1pZihuPT09dW5kZWZpbmVkKXtuPXRoaXMubGVuZ3RofWlmKHI8MHx8dD5lLmxlbmd0aHx8ZjwwfHxuPnRoaXMubGVuZ3RoKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIm91dCBvZiByYW5nZSBpbmRleFwiKX1pZihmPj1uJiZyPj10KXtyZXR1cm4gMH1pZihmPj1uKXtyZXR1cm4tMX1pZihyPj10KXtyZXR1cm4gMX1yPj4+PTA7dD4+Pj0wO2Y+Pj49MDtuPj4+PTA7aWYodGhpcz09PWUpcmV0dXJuIDA7dmFyIGk9bi1mO3ZhciBvPXQtcjt2YXIgdT1NYXRoLm1pbihpLG8pO3ZhciBhPXRoaXMuc2xpY2UoZixuKTt2YXIgcz1lLnNsaWNlKHIsdCk7Zm9yKHZhciBoPTA7aDx1OysraCl7aWYoYVtoXSE9PXNbaF0pe2k9YVtoXTtvPXNbaF07YnJlYWt9fWlmKGk8bylyZXR1cm4tMTtpZihvPGkpcmV0dXJuIDE7cmV0dXJuIDB9O2Z1bmN0aW9uIGJpZGlyZWN0aW9uYWxJbmRleE9mKGUscix0LGYsbil7aWYoZS5sZW5ndGg9PT0wKXJldHVybi0xO2lmKHR5cGVvZiB0PT09XCJzdHJpbmdcIil7Zj10O3Q9MH1lbHNlIGlmKHQ+MjE0NzQ4MzY0Nyl7dD0yMTQ3NDgzNjQ3fWVsc2UgaWYodDwtMjE0NzQ4MzY0OCl7dD0tMjE0NzQ4MzY0OH10PSt0O2lmKG51bWJlcklzTmFOKHQpKXt0PW4/MDplLmxlbmd0aC0xfWlmKHQ8MCl0PWUubGVuZ3RoK3Q7aWYodD49ZS5sZW5ndGgpe2lmKG4pcmV0dXJuLTE7ZWxzZSB0PWUubGVuZ3RoLTF9ZWxzZSBpZih0PDApe2lmKG4pdD0wO2Vsc2UgcmV0dXJuLTF9aWYodHlwZW9mIHI9PT1cInN0cmluZ1wiKXtyPUJ1ZmZlci5mcm9tKHIsZil9aWYoQnVmZmVyLmlzQnVmZmVyKHIpKXtpZihyLmxlbmd0aD09PTApe3JldHVybi0xfXJldHVybiBhcnJheUluZGV4T2YoZSxyLHQsZixuKX1lbHNlIGlmKHR5cGVvZiByPT09XCJudW1iZXJcIil7cj1yJjI1NTtpZih0eXBlb2YgVWludDhBcnJheS5wcm90b3R5cGUuaW5kZXhPZj09PVwiZnVuY3Rpb25cIil7aWYobil7cmV0dXJuIFVpbnQ4QXJyYXkucHJvdG90eXBlLmluZGV4T2YuY2FsbChlLHIsdCl9ZWxzZXtyZXR1cm4gVWludDhBcnJheS5wcm90b3R5cGUubGFzdEluZGV4T2YuY2FsbChlLHIsdCl9fXJldHVybiBhcnJheUluZGV4T2YoZSxbcl0sdCxmLG4pfXRocm93IG5ldyBUeXBlRXJyb3IoXCJ2YWwgbXVzdCBiZSBzdHJpbmcsIG51bWJlciBvciBCdWZmZXJcIil9ZnVuY3Rpb24gYXJyYXlJbmRleE9mKGUscix0LGYsbil7dmFyIGk9MTt2YXIgbz1lLmxlbmd0aDt2YXIgdT1yLmxlbmd0aDtpZihmIT09dW5kZWZpbmVkKXtmPVN0cmluZyhmKS50b0xvd2VyQ2FzZSgpO2lmKGY9PT1cInVjczJcInx8Zj09PVwidWNzLTJcInx8Zj09PVwidXRmMTZsZVwifHxmPT09XCJ1dGYtMTZsZVwiKXtpZihlLmxlbmd0aDwyfHxyLmxlbmd0aDwyKXtyZXR1cm4tMX1pPTI7by89Mjt1Lz0yO3QvPTJ9fWZ1bmN0aW9uIHJlYWQoZSxyKXtpZihpPT09MSl7cmV0dXJuIGVbcl19ZWxzZXtyZXR1cm4gZS5yZWFkVUludDE2QkUocippKX19dmFyIGE7aWYobil7dmFyIHM9LTE7Zm9yKGE9dDthPG87YSsrKXtpZihyZWFkKGUsYSk9PT1yZWFkKHIscz09PS0xPzA6YS1zKSl7aWYocz09PS0xKXM9YTtpZihhLXMrMT09PXUpcmV0dXJuIHMqaX1lbHNle2lmKHMhPT0tMSlhLT1hLXM7cz0tMX19fWVsc2V7aWYodCt1Pm8pdD1vLXU7Zm9yKGE9dDthPj0wO2EtLSl7dmFyIGg9dHJ1ZTtmb3IodmFyIGM9MDtjPHU7YysrKXtpZihyZWFkKGUsYStjKSE9PXJlYWQocixjKSl7aD1mYWxzZTticmVha319aWYoaClyZXR1cm4gYX19cmV0dXJuLTF9QnVmZmVyLnByb3RvdHlwZS5pbmNsdWRlcz1mdW5jdGlvbiBpbmNsdWRlcyhlLHIsdCl7cmV0dXJuIHRoaXMuaW5kZXhPZihlLHIsdCkhPT0tMX07QnVmZmVyLnByb3RvdHlwZS5pbmRleE9mPWZ1bmN0aW9uIGluZGV4T2YoZSxyLHQpe3JldHVybiBiaWRpcmVjdGlvbmFsSW5kZXhPZih0aGlzLGUscix0LHRydWUpfTtCdWZmZXIucHJvdG90eXBlLmxhc3RJbmRleE9mPWZ1bmN0aW9uIGxhc3RJbmRleE9mKGUscix0KXtyZXR1cm4gYmlkaXJlY3Rpb25hbEluZGV4T2YodGhpcyxlLHIsdCxmYWxzZSl9O2Z1bmN0aW9uIGhleFdyaXRlKGUscix0LGYpe3Q9TnVtYmVyKHQpfHwwO3ZhciBuPWUubGVuZ3RoLXQ7aWYoIWYpe2Y9bn1lbHNle2Y9TnVtYmVyKGYpO2lmKGY+bil7Zj1ufX12YXIgaT1yLmxlbmd0aDtpZihmPmkvMil7Zj1pLzJ9Zm9yKHZhciBvPTA7bzxmOysrbyl7dmFyIHU9cGFyc2VJbnQoci5zdWJzdHIobyoyLDIpLDE2KTtpZihudW1iZXJJc05hTih1KSlyZXR1cm4gbztlW3Qrb109dX1yZXR1cm4gb31mdW5jdGlvbiB1dGY4V3JpdGUoZSxyLHQsZil7cmV0dXJuIGJsaXRCdWZmZXIodXRmOFRvQnl0ZXMocixlLmxlbmd0aC10KSxlLHQsZil9ZnVuY3Rpb24gYXNjaWlXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcihhc2NpaVRvQnl0ZXMociksZSx0LGYpfWZ1bmN0aW9uIGxhdGluMVdyaXRlKGUscix0LGYpe3JldHVybiBhc2NpaVdyaXRlKGUscix0LGYpfWZ1bmN0aW9uIGJhc2U2NFdyaXRlKGUscix0LGYpe3JldHVybiBibGl0QnVmZmVyKGJhc2U2NFRvQnl0ZXMociksZSx0LGYpfWZ1bmN0aW9uIHVjczJXcml0ZShlLHIsdCxmKXtyZXR1cm4gYmxpdEJ1ZmZlcih1dGYxNmxlVG9CeXRlcyhyLGUubGVuZ3RoLXQpLGUsdCxmKX1CdWZmZXIucHJvdG90eXBlLndyaXRlPWZ1bmN0aW9uIHdyaXRlKGUscix0LGYpe2lmKHI9PT11bmRlZmluZWQpe2Y9XCJ1dGY4XCI7dD10aGlzLmxlbmd0aDtyPTB9ZWxzZSBpZih0PT09dW5kZWZpbmVkJiZ0eXBlb2Ygcj09PVwic3RyaW5nXCIpe2Y9cjt0PXRoaXMubGVuZ3RoO3I9MH1lbHNlIGlmKGlzRmluaXRlKHIpKXtyPXI+Pj4wO2lmKGlzRmluaXRlKHQpKXt0PXQ+Pj4wO2lmKGY9PT11bmRlZmluZWQpZj1cInV0ZjhcIn1lbHNle2Y9dDt0PXVuZGVmaW5lZH19ZWxzZXt0aHJvdyBuZXcgRXJyb3IoXCJCdWZmZXIud3JpdGUoc3RyaW5nLCBlbmNvZGluZywgb2Zmc2V0WywgbGVuZ3RoXSkgaXMgbm8gbG9uZ2VyIHN1cHBvcnRlZFwiKX12YXIgbj10aGlzLmxlbmd0aC1yO2lmKHQ9PT11bmRlZmluZWR8fHQ+bil0PW47aWYoZS5sZW5ndGg+MCYmKHQ8MHx8cjwwKXx8cj50aGlzLmxlbmd0aCl7dGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJBdHRlbXB0IHRvIHdyaXRlIG91dHNpZGUgYnVmZmVyIGJvdW5kc1wiKX1pZighZilmPVwidXRmOFwiO3ZhciBpPWZhbHNlO2Zvcig7Oyl7c3dpdGNoKGYpe2Nhc2VcImhleFwiOnJldHVybiBoZXhXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJ1dGY4XCI6Y2FzZVwidXRmLThcIjpyZXR1cm4gdXRmOFdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcImFzY2lpXCI6cmV0dXJuIGFzY2lpV3JpdGUodGhpcyxlLHIsdCk7Y2FzZVwibGF0aW4xXCI6Y2FzZVwiYmluYXJ5XCI6cmV0dXJuIGxhdGluMVdyaXRlKHRoaXMsZSxyLHQpO2Nhc2VcImJhc2U2NFwiOnJldHVybiBiYXNlNjRXcml0ZSh0aGlzLGUscix0KTtjYXNlXCJ1Y3MyXCI6Y2FzZVwidWNzLTJcIjpjYXNlXCJ1dGYxNmxlXCI6Y2FzZVwidXRmLTE2bGVcIjpyZXR1cm4gdWNzMldyaXRlKHRoaXMsZSxyLHQpO2RlZmF1bHQ6aWYoaSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiVW5rbm93biBlbmNvZGluZzogXCIrZik7Zj0oXCJcIitmKS50b0xvd2VyQ2FzZSgpO2k9dHJ1ZX19fTtCdWZmZXIucHJvdG90eXBlLnRvSlNPTj1mdW5jdGlvbiB0b0pTT04oKXtyZXR1cm57dHlwZTpcIkJ1ZmZlclwiLGRhdGE6QXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwodGhpcy5fYXJyfHx0aGlzLDApfX07ZnVuY3Rpb24gYmFzZTY0U2xpY2UoZSxyLHQpe2lmKHI9PT0wJiZ0PT09ZS5sZW5ndGgpe3JldHVybiBmLmZyb21CeXRlQXJyYXkoZSl9ZWxzZXtyZXR1cm4gZi5mcm9tQnl0ZUFycmF5KGUuc2xpY2Uocix0KSl9fWZ1bmN0aW9uIHV0ZjhTbGljZShlLHIsdCl7dD1NYXRoLm1pbihlLmxlbmd0aCx0KTt2YXIgZj1bXTt2YXIgbj1yO3doaWxlKG48dCl7dmFyIGk9ZVtuXTt2YXIgbz1udWxsO3ZhciB1PWk+MjM5PzQ6aT4yMjM/MzppPjE5MT8yOjE7aWYobit1PD10KXt2YXIgYSxzLGgsYztzd2l0Y2godSl7Y2FzZSAxOmlmKGk8MTI4KXtvPWl9YnJlYWs7Y2FzZSAyOmE9ZVtuKzFdO2lmKChhJjE5Mik9PT0xMjgpe2M9KGkmMzEpPDw2fGEmNjM7aWYoYz4xMjcpe289Y319YnJlYWs7Y2FzZSAzOmE9ZVtuKzFdO3M9ZVtuKzJdO2lmKChhJjE5Mik9PT0xMjgmJihzJjE5Mik9PT0xMjgpe2M9KGkmMTUpPDwxMnwoYSY2Myk8PDZ8cyY2MztpZihjPjIwNDcmJihjPDU1Mjk2fHxjPjU3MzQzKSl7bz1jfX1icmVhaztjYXNlIDQ6YT1lW24rMV07cz1lW24rMl07aD1lW24rM107aWYoKGEmMTkyKT09PTEyOCYmKHMmMTkyKT09PTEyOCYmKGgmMTkyKT09PTEyOCl7Yz0oaSYxNSk8PDE4fChhJjYzKTw8MTJ8KHMmNjMpPDw2fGgmNjM7aWYoYz42NTUzNSYmYzwxMTE0MTEyKXtvPWN9fX19aWYobz09PW51bGwpe289NjU1MzM7dT0xfWVsc2UgaWYobz42NTUzNSl7by09NjU1MzY7Zi5wdXNoKG8+Pj4xMCYxMDIzfDU1Mjk2KTtvPTU2MzIwfG8mMTAyM31mLnB1c2gobyk7bis9dX1yZXR1cm4gZGVjb2RlQ29kZVBvaW50c0FycmF5KGYpfXZhciB1PTQwOTY7ZnVuY3Rpb24gZGVjb2RlQ29kZVBvaW50c0FycmF5KGUpe3ZhciByPWUubGVuZ3RoO2lmKHI8PXUpe3JldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxlKX12YXIgdD1cIlwiO3ZhciBmPTA7d2hpbGUoZjxyKXt0Kz1TdHJpbmcuZnJvbUNoYXJDb2RlLmFwcGx5KFN0cmluZyxlLnNsaWNlKGYsZis9dSkpfXJldHVybiB0fWZ1bmN0aW9uIGFzY2lpU2xpY2UoZSxyLHQpe3ZhciBmPVwiXCI7dD1NYXRoLm1pbihlLmxlbmd0aCx0KTtmb3IodmFyIG49cjtuPHQ7KytuKXtmKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGVbbl0mMTI3KX1yZXR1cm4gZn1mdW5jdGlvbiBsYXRpbjFTbGljZShlLHIsdCl7dmFyIGY9XCJcIjt0PU1hdGgubWluKGUubGVuZ3RoLHQpO2Zvcih2YXIgbj1yO248dDsrK24pe2YrPVN0cmluZy5mcm9tQ2hhckNvZGUoZVtuXSl9cmV0dXJuIGZ9ZnVuY3Rpb24gaGV4U2xpY2UoZSxyLHQpe3ZhciBmPWUubGVuZ3RoO2lmKCFyfHxyPDApcj0wO2lmKCF0fHx0PDB8fHQ+Zil0PWY7dmFyIG49XCJcIjtmb3IodmFyIGk9cjtpPHQ7KytpKXtuKz1zW2VbaV1dfXJldHVybiBufWZ1bmN0aW9uIHV0ZjE2bGVTbGljZShlLHIsdCl7dmFyIGY9ZS5zbGljZShyLHQpO3ZhciBuPVwiXCI7Zm9yKHZhciBpPTA7aTxmLmxlbmd0aDtpKz0yKXtuKz1TdHJpbmcuZnJvbUNoYXJDb2RlKGZbaV0rZltpKzFdKjI1Nil9cmV0dXJuIG59QnVmZmVyLnByb3RvdHlwZS5zbGljZT1mdW5jdGlvbiBzbGljZShlLHIpe3ZhciB0PXRoaXMubGVuZ3RoO2U9fn5lO3I9cj09PXVuZGVmaW5lZD90On5+cjtpZihlPDApe2UrPXQ7aWYoZTwwKWU9MH1lbHNlIGlmKGU+dCl7ZT10fWlmKHI8MCl7cis9dDtpZihyPDApcj0wfWVsc2UgaWYocj50KXtyPXR9aWYocjxlKXI9ZTt2YXIgZj10aGlzLnN1YmFycmF5KGUscik7T2JqZWN0LnNldFByb3RvdHlwZU9mKGYsQnVmZmVyLnByb3RvdHlwZSk7cmV0dXJuIGZ9O2Z1bmN0aW9uIGNoZWNrT2Zmc2V0KGUscix0KXtpZihlJTEhPT0wfHxlPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJvZmZzZXQgaXMgbm90IHVpbnRcIik7aWYoZStyPnQpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJUcnlpbmcgdG8gYWNjZXNzIGJleW9uZCBidWZmZXIgbGVuZ3RoXCIpfUJ1ZmZlci5wcm90b3R5cGUucmVhZFVJbnRMRT1mdW5jdGlvbiByZWFkVUludExFKGUscix0KXtlPWU+Pj4wO3I9cj4+PjA7aWYoIXQpY2hlY2tPZmZzZXQoZSxyLHRoaXMubGVuZ3RoKTt2YXIgZj10aGlzW2VdO3ZhciBuPTE7dmFyIGk9MDt3aGlsZSgrK2k8ciYmKG4qPTI1Nikpe2YrPXRoaXNbZStpXSpufXJldHVybiBmfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50QkU9ZnVuY3Rpb24gcmVhZFVJbnRCRShlLHIsdCl7ZT1lPj4+MDtyPXI+Pj4wO2lmKCF0KXtjaGVja09mZnNldChlLHIsdGhpcy5sZW5ndGgpfXZhciBmPXRoaXNbZSstLXJdO3ZhciBuPTE7d2hpbGUocj4wJiYobio9MjU2KSl7Zis9dGhpc1tlKy0tcl0qbn1yZXR1cm4gZn07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDg9ZnVuY3Rpb24gcmVhZFVJbnQ4KGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDEsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZMRT1mdW5jdGlvbiByZWFkVUludDE2TEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMix0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV18dGhpc1tlKzFdPDw4fTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MTZCRT1mdW5jdGlvbiByZWFkVUludDE2QkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMix0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV08PDh8dGhpc1tlKzFdfTtCdWZmZXIucHJvdG90eXBlLnJlYWRVSW50MzJMRT1mdW5jdGlvbiByZWFkVUludDMyTEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuKHRoaXNbZV18dGhpc1tlKzFdPDw4fHRoaXNbZSsyXTw8MTYpK3RoaXNbZSszXSoxNjc3NzIxNn07QnVmZmVyLnByb3RvdHlwZS5yZWFkVUludDMyQkU9ZnVuY3Rpb24gcmVhZFVJbnQzMkJFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiB0aGlzW2VdKjE2Nzc3MjE2Kyh0aGlzW2UrMV08PDE2fHRoaXNbZSsyXTw8OHx0aGlzW2UrM10pfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnRMRT1mdW5jdGlvbiByZWFkSW50TEUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCljaGVja09mZnNldChlLHIsdGhpcy5sZW5ndGgpO3ZhciBmPXRoaXNbZV07dmFyIG49MTt2YXIgaT0wO3doaWxlKCsraTxyJiYobio9MjU2KSl7Zis9dGhpc1tlK2ldKm59bio9MTI4O2lmKGY+PW4pZi09TWF0aC5wb3coMiw4KnIpO3JldHVybiBmfTtCdWZmZXIucHJvdG90eXBlLnJlYWRJbnRCRT1mdW5jdGlvbiByZWFkSW50QkUoZSxyLHQpe2U9ZT4+PjA7cj1yPj4+MDtpZighdCljaGVja09mZnNldChlLHIsdGhpcy5sZW5ndGgpO3ZhciBmPXI7dmFyIG49MTt2YXIgaT10aGlzW2UrLS1mXTt3aGlsZShmPjAmJihuKj0yNTYpKXtpKz10aGlzW2UrLS1mXSpufW4qPTEyODtpZihpPj1uKWktPU1hdGgucG93KDIsOCpyKTtyZXR1cm4gaX07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50OD1mdW5jdGlvbiByZWFkSW50OChlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSwxLHRoaXMubGVuZ3RoKTtpZighKHRoaXNbZV0mMTI4KSlyZXR1cm4gdGhpc1tlXTtyZXR1cm4oMjU1LXRoaXNbZV0rMSkqLTF9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2TEU9ZnVuY3Rpb24gcmVhZEludDE2TEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMix0aGlzLmxlbmd0aCk7dmFyIHQ9dGhpc1tlXXx0aGlzW2UrMV08PDg7cmV0dXJuIHQmMzI3Njg/dHw0Mjk0OTAxNzYwOnR9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDE2QkU9ZnVuY3Rpb24gcmVhZEludDE2QkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsMix0aGlzLmxlbmd0aCk7dmFyIHQ9dGhpc1tlKzFdfHRoaXNbZV08PDg7cmV0dXJuIHQmMzI3Njg/dHw0Mjk0OTAxNzYwOnR9O0J1ZmZlci5wcm90b3R5cGUucmVhZEludDMyTEU9ZnVuY3Rpb24gcmVhZEludDMyTEUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIHRoaXNbZV18dGhpc1tlKzFdPDw4fHRoaXNbZSsyXTw8MTZ8dGhpc1tlKzNdPDwyNH07QnVmZmVyLnByb3RvdHlwZS5yZWFkSW50MzJCRT1mdW5jdGlvbiByZWFkSW50MzJCRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw0LHRoaXMubGVuZ3RoKTtyZXR1cm4gdGhpc1tlXTw8MjR8dGhpc1tlKzFdPDwxNnx0aGlzW2UrMl08PDh8dGhpc1tlKzNdfTtCdWZmZXIucHJvdG90eXBlLnJlYWRGbG9hdExFPWZ1bmN0aW9uIHJlYWRGbG9hdExFKGUscil7ZT1lPj4+MDtpZighciljaGVja09mZnNldChlLDQsdGhpcy5sZW5ndGgpO3JldHVybiBuLnJlYWQodGhpcyxlLHRydWUsMjMsNCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZEZsb2F0QkU9ZnVuY3Rpb24gcmVhZEZsb2F0QkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsNCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsZmFsc2UsMjMsNCl9O0J1ZmZlci5wcm90b3R5cGUucmVhZERvdWJsZUxFPWZ1bmN0aW9uIHJlYWREb3VibGVMRShlLHIpe2U9ZT4+PjA7aWYoIXIpY2hlY2tPZmZzZXQoZSw4LHRoaXMubGVuZ3RoKTtyZXR1cm4gbi5yZWFkKHRoaXMsZSx0cnVlLDUyLDgpfTtCdWZmZXIucHJvdG90eXBlLnJlYWREb3VibGVCRT1mdW5jdGlvbiByZWFkRG91YmxlQkUoZSxyKXtlPWU+Pj4wO2lmKCFyKWNoZWNrT2Zmc2V0KGUsOCx0aGlzLmxlbmd0aCk7cmV0dXJuIG4ucmVhZCh0aGlzLGUsZmFsc2UsNTIsOCl9O2Z1bmN0aW9uIGNoZWNrSW50KGUscix0LGYsbixpKXtpZighQnVmZmVyLmlzQnVmZmVyKGUpKXRocm93IG5ldyBUeXBlRXJyb3IoJ1wiYnVmZmVyXCIgYXJndW1lbnQgbXVzdCBiZSBhIEJ1ZmZlciBpbnN0YW5jZScpO2lmKHI+bnx8cjxpKXRocm93IG5ldyBSYW5nZUVycm9yKCdcInZhbHVlXCIgYXJndW1lbnQgaXMgb3V0IG9mIGJvdW5kcycpO2lmKHQrZj5lLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKX1CdWZmZXIucHJvdG90eXBlLndyaXRlVUludExFPWZ1bmN0aW9uIHdyaXRlVUludExFKGUscix0LGYpe2U9K2U7cj1yPj4+MDt0PXQ+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdCktMTtjaGVja0ludCh0aGlzLGUscix0LG4sMCl9dmFyIGk9MTt2YXIgbz0wO3RoaXNbcl09ZSYyNTU7d2hpbGUoKytvPHQmJihpKj0yNTYpKXt0aGlzW3Irb109ZS9pJjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludEJFPWZ1bmN0aW9uIHdyaXRlVUludEJFKGUscix0LGYpe2U9K2U7cj1yPj4+MDt0PXQ+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdCktMTtjaGVja0ludCh0aGlzLGUscix0LG4sMCl9dmFyIGk9dC0xO3ZhciBvPTE7dGhpc1tyK2ldPWUmMjU1O3doaWxlKC0taT49MCYmKG8qPTI1Nikpe3RoaXNbcitpXT1lL28mMjU1fXJldHVybiByK3R9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50OD1mdW5jdGlvbiB3cml0ZVVJbnQ4KGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMSwyNTUsMCk7dGhpc1tyXT1lJjI1NTtyZXR1cm4gcisxfTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDE2TEU9ZnVuY3Rpb24gd3JpdGVVSW50MTZMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDIsNjU1MzUsMCk7dGhpc1tyXT1lJjI1NTt0aGlzW3IrMV09ZT4+Pjg7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZVVJbnQxNkJFPWZ1bmN0aW9uIHdyaXRlVUludDE2QkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDY1NTM1LDApO3RoaXNbcl09ZT4+Pjg7dGhpc1tyKzFdPWUmMjU1O3JldHVybiByKzJ9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVVSW50MzJMRT1mdW5jdGlvbiB3cml0ZVVJbnQzMkxFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsNCw0Mjk0OTY3Mjk1LDApO3RoaXNbciszXT1lPj4+MjQ7dGhpc1tyKzJdPWU+Pj4xNjt0aGlzW3IrMV09ZT4+Pjg7dGhpc1tyXT1lJjI1NTtyZXR1cm4gcis0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlVUludDMyQkU9ZnVuY3Rpb24gd3JpdGVVSW50MzJCRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDQsNDI5NDk2NzI5NSwwKTt0aGlzW3JdPWU+Pj4yNDt0aGlzW3IrMV09ZT4+PjE2O3RoaXNbcisyXT1lPj4+ODt0aGlzW3IrM109ZSYyNTU7cmV0dXJuIHIrNH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludExFPWZ1bmN0aW9uIHdyaXRlSW50TEUoZSxyLHQsZil7ZT0rZTtyPXI+Pj4wO2lmKCFmKXt2YXIgbj1NYXRoLnBvdygyLDgqdC0xKTtjaGVja0ludCh0aGlzLGUscix0LG4tMSwtbil9dmFyIGk9MDt2YXIgbz0xO3ZhciB1PTA7dGhpc1tyXT1lJjI1NTt3aGlsZSgrK2k8dCYmKG8qPTI1Nikpe2lmKGU8MCYmdT09PTAmJnRoaXNbcitpLTFdIT09MCl7dT0xfXRoaXNbcitpXT0oZS9vPj4wKS11JjI1NX1yZXR1cm4gcit0fTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50QkU9ZnVuY3Rpb24gd3JpdGVJbnRCRShlLHIsdCxmKXtlPStlO3I9cj4+PjA7aWYoIWYpe3ZhciBuPU1hdGgucG93KDIsOCp0LTEpO2NoZWNrSW50KHRoaXMsZSxyLHQsbi0xLC1uKX12YXIgaT10LTE7dmFyIG89MTt2YXIgdT0wO3RoaXNbcitpXT1lJjI1NTt3aGlsZSgtLWk+PTAmJihvKj0yNTYpKXtpZihlPDAmJnU9PT0wJiZ0aGlzW3IraSsxXSE9PTApe3U9MX10aGlzW3IraV09KGUvbz4+MCktdSYyNTV9cmV0dXJuIHIrdH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDg9ZnVuY3Rpb24gd3JpdGVJbnQ4KGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsMSwxMjcsLTEyOCk7aWYoZTwwKWU9MjU1K2UrMTt0aGlzW3JdPWUmMjU1O3JldHVybiByKzF9O0J1ZmZlci5wcm90b3R5cGUud3JpdGVJbnQxNkxFPWZ1bmN0aW9uIHdyaXRlSW50MTZMRShlLHIsdCl7ZT0rZTtyPXI+Pj4wO2lmKCF0KWNoZWNrSW50KHRoaXMsZSxyLDIsMzI3NjcsLTMyNzY4KTt0aGlzW3JdPWUmMjU1O3RoaXNbcisxXT1lPj4+ODtyZXR1cm4gcisyfTtCdWZmZXIucHJvdG90eXBlLndyaXRlSW50MTZCRT1mdW5jdGlvbiB3cml0ZUludDE2QkUoZSxyLHQpe2U9K2U7cj1yPj4+MDtpZighdCljaGVja0ludCh0aGlzLGUsciwyLDMyNzY3LC0zMjc2OCk7dGhpc1tyXT1lPj4+ODt0aGlzW3IrMV09ZSYyNTU7cmV0dXJuIHIrMn07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyTEU9ZnVuY3Rpb24gd3JpdGVJbnQzMkxFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KTt0aGlzW3JdPWUmMjU1O3RoaXNbcisxXT1lPj4+ODt0aGlzW3IrMl09ZT4+PjE2O3RoaXNbciszXT1lPj4+MjQ7cmV0dXJuIHIrNH07QnVmZmVyLnByb3RvdHlwZS53cml0ZUludDMyQkU9ZnVuY3Rpb24gd3JpdGVJbnQzMkJFKGUscix0KXtlPStlO3I9cj4+PjA7aWYoIXQpY2hlY2tJbnQodGhpcyxlLHIsNCwyMTQ3NDgzNjQ3LC0yMTQ3NDgzNjQ4KTtpZihlPDApZT00Mjk0OTY3Mjk1K2UrMTt0aGlzW3JdPWU+Pj4yNDt0aGlzW3IrMV09ZT4+PjE2O3RoaXNbcisyXT1lPj4+ODt0aGlzW3IrM109ZSYyNTU7cmV0dXJuIHIrNH07ZnVuY3Rpb24gY2hlY2tJRUVFNzU0KGUscix0LGYsbixpKXtpZih0K2Y+ZS5sZW5ndGgpdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJJbmRleCBvdXQgb2YgcmFuZ2VcIik7aWYodDwwKXRocm93IG5ldyBSYW5nZUVycm9yKFwiSW5kZXggb3V0IG9mIHJhbmdlXCIpfWZ1bmN0aW9uIHdyaXRlRmxvYXQoZSxyLHQsZixpKXtyPStyO3Q9dD4+PjA7aWYoIWkpe2NoZWNrSUVFRTc1NChlLHIsdCw0LDM0MDI4MjM0NjYzODUyODg2ZTIyLC0zNDAyODIzNDY2Mzg1Mjg4NmUyMil9bi53cml0ZShlLHIsdCxmLDIzLDQpO3JldHVybiB0KzR9QnVmZmVyLnByb3RvdHlwZS53cml0ZUZsb2F0TEU9ZnVuY3Rpb24gd3JpdGVGbG9hdExFKGUscix0KXtyZXR1cm4gd3JpdGVGbG9hdCh0aGlzLGUscix0cnVlLHQpfTtCdWZmZXIucHJvdG90eXBlLndyaXRlRmxvYXRCRT1mdW5jdGlvbiB3cml0ZUZsb2F0QkUoZSxyLHQpe3JldHVybiB3cml0ZUZsb2F0KHRoaXMsZSxyLGZhbHNlLHQpfTtmdW5jdGlvbiB3cml0ZURvdWJsZShlLHIsdCxmLGkpe3I9K3I7dD10Pj4+MDtpZighaSl7Y2hlY2tJRUVFNzU0KGUscix0LDgsMTc5NzY5MzEzNDg2MjMxNTdlMjkyLC0xNzk3NjkzMTM0ODYyMzE1N2UyOTIpfW4ud3JpdGUoZSxyLHQsZiw1Miw4KTtyZXR1cm4gdCs4fUJ1ZmZlci5wcm90b3R5cGUud3JpdGVEb3VibGVMRT1mdW5jdGlvbiB3cml0ZURvdWJsZUxFKGUscix0KXtyZXR1cm4gd3JpdGVEb3VibGUodGhpcyxlLHIsdHJ1ZSx0KX07QnVmZmVyLnByb3RvdHlwZS53cml0ZURvdWJsZUJFPWZ1bmN0aW9uIHdyaXRlRG91YmxlQkUoZSxyLHQpe3JldHVybiB3cml0ZURvdWJsZSh0aGlzLGUscixmYWxzZSx0KX07QnVmZmVyLnByb3RvdHlwZS5jb3B5PWZ1bmN0aW9uIGNvcHkoZSxyLHQsZil7aWYoIUJ1ZmZlci5pc0J1ZmZlcihlKSl0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgc2hvdWxkIGJlIGEgQnVmZmVyXCIpO2lmKCF0KXQ9MDtpZighZiYmZiE9PTApZj10aGlzLmxlbmd0aDtpZihyPj1lLmxlbmd0aClyPWUubGVuZ3RoO2lmKCFyKXI9MDtpZihmPjAmJmY8dClmPXQ7aWYoZj09PXQpcmV0dXJuIDA7aWYoZS5sZW5ndGg9PT0wfHx0aGlzLmxlbmd0aD09PTApcmV0dXJuIDA7aWYocjwwKXt0aHJvdyBuZXcgUmFuZ2VFcnJvcihcInRhcmdldFN0YXJ0IG91dCBvZiBib3VuZHNcIil9aWYodDwwfHx0Pj10aGlzLmxlbmd0aCl0aHJvdyBuZXcgUmFuZ2VFcnJvcihcIkluZGV4IG91dCBvZiByYW5nZVwiKTtpZihmPDApdGhyb3cgbmV3IFJhbmdlRXJyb3IoXCJzb3VyY2VFbmQgb3V0IG9mIGJvdW5kc1wiKTtpZihmPnRoaXMubGVuZ3RoKWY9dGhpcy5sZW5ndGg7aWYoZS5sZW5ndGgtcjxmLXQpe2Y9ZS5sZW5ndGgtcit0fXZhciBuPWYtdDtpZih0aGlzPT09ZSYmdHlwZW9mIFVpbnQ4QXJyYXkucHJvdG90eXBlLmNvcHlXaXRoaW49PT1cImZ1bmN0aW9uXCIpe3RoaXMuY29weVdpdGhpbihyLHQsZil9ZWxzZSBpZih0aGlzPT09ZSYmdDxyJiZyPGYpe2Zvcih2YXIgaT1uLTE7aT49MDstLWkpe2VbaStyXT10aGlzW2krdF19fWVsc2V7VWludDhBcnJheS5wcm90b3R5cGUuc2V0LmNhbGwoZSx0aGlzLnN1YmFycmF5KHQsZikscil9cmV0dXJuIG59O0J1ZmZlci5wcm90b3R5cGUuZmlsbD1mdW5jdGlvbiBmaWxsKGUscix0LGYpe2lmKHR5cGVvZiBlPT09XCJzdHJpbmdcIil7aWYodHlwZW9mIHI9PT1cInN0cmluZ1wiKXtmPXI7cj0wO3Q9dGhpcy5sZW5ndGh9ZWxzZSBpZih0eXBlb2YgdD09PVwic3RyaW5nXCIpe2Y9dDt0PXRoaXMubGVuZ3RofWlmKGYhPT11bmRlZmluZWQmJnR5cGVvZiBmIT09XCJzdHJpbmdcIil7dGhyb3cgbmV3IFR5cGVFcnJvcihcImVuY29kaW5nIG11c3QgYmUgYSBzdHJpbmdcIil9aWYodHlwZW9mIGY9PT1cInN0cmluZ1wiJiYhQnVmZmVyLmlzRW5jb2RpbmcoZikpe3Rocm93IG5ldyBUeXBlRXJyb3IoXCJVbmtub3duIGVuY29kaW5nOiBcIitmKX1pZihlLmxlbmd0aD09PTEpe3ZhciBuPWUuY2hhckNvZGVBdCgwKTtpZihmPT09XCJ1dGY4XCImJm48MTI4fHxmPT09XCJsYXRpbjFcIil7ZT1ufX19ZWxzZSBpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe2U9ZSYyNTV9ZWxzZSBpZih0eXBlb2YgZT09PVwiYm9vbGVhblwiKXtlPU51bWJlcihlKX1pZihyPDB8fHRoaXMubGVuZ3RoPHJ8fHRoaXMubGVuZ3RoPHQpe3Rocm93IG5ldyBSYW5nZUVycm9yKFwiT3V0IG9mIHJhbmdlIGluZGV4XCIpfWlmKHQ8PXIpe3JldHVybiB0aGlzfXI9cj4+PjA7dD10PT09dW5kZWZpbmVkP3RoaXMubGVuZ3RoOnQ+Pj4wO2lmKCFlKWU9MDt2YXIgaTtpZih0eXBlb2YgZT09PVwibnVtYmVyXCIpe2ZvcihpPXI7aTx0OysraSl7dGhpc1tpXT1lfX1lbHNle3ZhciBvPUJ1ZmZlci5pc0J1ZmZlcihlKT9lOkJ1ZmZlci5mcm9tKGUsZik7dmFyIHU9by5sZW5ndGg7aWYodT09PTApe3Rocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSB2YWx1ZSBcIicrZSsnXCIgaXMgaW52YWxpZCBmb3IgYXJndW1lbnQgXCJ2YWx1ZVwiJyl9Zm9yKGk9MDtpPHQtcjsrK2kpe3RoaXNbaStyXT1vW2kldV19fXJldHVybiB0aGlzfTt2YXIgYT0vW14rLzAtOUEtWmEtei1fXS9nO2Z1bmN0aW9uIGJhc2U2NGNsZWFuKGUpe2U9ZS5zcGxpdChcIj1cIilbMF07ZT1lLnRyaW0oKS5yZXBsYWNlKGEsXCJcIik7aWYoZS5sZW5ndGg8MilyZXR1cm5cIlwiO3doaWxlKGUubGVuZ3RoJTQhPT0wKXtlPWUrXCI9XCJ9cmV0dXJuIGV9ZnVuY3Rpb24gdXRmOFRvQnl0ZXMoZSxyKXtyPXJ8fEluZmluaXR5O3ZhciB0O3ZhciBmPWUubGVuZ3RoO3ZhciBuPW51bGw7dmFyIGk9W107Zm9yKHZhciBvPTA7bzxmOysrbyl7dD1lLmNoYXJDb2RlQXQobyk7aWYodD41NTI5NSYmdDw1NzM0NCl7aWYoIW4pe2lmKHQ+NTYzMTkpe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpO2NvbnRpbnVlfWVsc2UgaWYobysxPT09Zil7aWYoKHItPTMpPi0xKWkucHVzaCgyMzksMTkxLDE4OSk7Y29udGludWV9bj10O2NvbnRpbnVlfWlmKHQ8NTYzMjApe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpO249dDtjb250aW51ZX10PShuLTU1Mjk2PDwxMHx0LTU2MzIwKSs2NTUzNn1lbHNlIGlmKG4pe2lmKChyLT0zKT4tMSlpLnB1c2goMjM5LDE5MSwxODkpfW49bnVsbDtpZih0PDEyOCl7aWYoKHItPTEpPDApYnJlYWs7aS5wdXNoKHQpfWVsc2UgaWYodDwyMDQ4KXtpZigoci09Mik8MClicmVhaztpLnB1c2godD4+NnwxOTIsdCY2M3wxMjgpfWVsc2UgaWYodDw2NTUzNil7aWYoKHItPTMpPDApYnJlYWs7aS5wdXNoKHQ+PjEyfDIyNCx0Pj42JjYzfDEyOCx0JjYzfDEyOCl9ZWxzZSBpZih0PDExMTQxMTIpe2lmKChyLT00KTwwKWJyZWFrO2kucHVzaCh0Pj4xOHwyNDAsdD4+MTImNjN8MTI4LHQ+PjYmNjN8MTI4LHQmNjN8MTI4KX1lbHNle3Rocm93IG5ldyBFcnJvcihcIkludmFsaWQgY29kZSBwb2ludFwiKX19cmV0dXJuIGl9ZnVuY3Rpb24gYXNjaWlUb0J5dGVzKGUpe3ZhciByPVtdO2Zvcih2YXIgdD0wO3Q8ZS5sZW5ndGg7Kyt0KXtyLnB1c2goZS5jaGFyQ29kZUF0KHQpJjI1NSl9cmV0dXJuIHJ9ZnVuY3Rpb24gdXRmMTZsZVRvQnl0ZXMoZSxyKXt2YXIgdCxmLG47dmFyIGk9W107Zm9yKHZhciBvPTA7bzxlLmxlbmd0aDsrK28pe2lmKChyLT0yKTwwKWJyZWFrO3Q9ZS5jaGFyQ29kZUF0KG8pO2Y9dD4+ODtuPXQlMjU2O2kucHVzaChuKTtpLnB1c2goZil9cmV0dXJuIGl9ZnVuY3Rpb24gYmFzZTY0VG9CeXRlcyhlKXtyZXR1cm4gZi50b0J5dGVBcnJheShiYXNlNjRjbGVhbihlKSl9ZnVuY3Rpb24gYmxpdEJ1ZmZlcihlLHIsdCxmKXtmb3IodmFyIG49MDtuPGY7KytuKXtpZihuK3Q+PXIubGVuZ3RofHxuPj1lLmxlbmd0aClicmVhaztyW24rdF09ZVtuXX1yZXR1cm4gbn1mdW5jdGlvbiBpc0luc3RhbmNlKGUscil7cmV0dXJuIGUgaW5zdGFuY2VvZiByfHxlIT1udWxsJiZlLmNvbnN0cnVjdG9yIT1udWxsJiZlLmNvbnN0cnVjdG9yLm5hbWUhPW51bGwmJmUuY29uc3RydWN0b3IubmFtZT09PXIubmFtZX1mdW5jdGlvbiBudW1iZXJJc05hTihlKXtyZXR1cm4gZSE9PWV9dmFyIHM9ZnVuY3Rpb24oKXt2YXIgZT1cIjAxMjM0NTY3ODlhYmNkZWZcIjt2YXIgcj1uZXcgQXJyYXkoMjU2KTtmb3IodmFyIHQ9MDt0PDE2OysrdCl7dmFyIGY9dCoxNjtmb3IodmFyIG49MDtuPDE2Oysrbil7cltmK25dPWVbdF0rZVtuXX19cmV0dXJuIHJ9KCl9LDc4MzpmdW5jdGlvbihlLHIpe1xuLyohIGllZWU3NTQuIEJTRC0zLUNsYXVzZSBMaWNlbnNlLiBGZXJvc3MgQWJvdWtoYWRpamVoIDxodHRwczovL2Zlcm9zcy5vcmcvb3BlbnNvdXJjZT4gKi9cbnIucmVhZD1mdW5jdGlvbihlLHIsdCxmLG4pe3ZhciBpLG87dmFyIHU9bio4LWYtMTt2YXIgYT0oMTw8dSktMTt2YXIgcz1hPj4xO3ZhciBoPS03O3ZhciBjPXQ/bi0xOjA7dmFyIGw9dD8tMToxO3ZhciBwPWVbcitjXTtjKz1sO2k9cCYoMTw8LWgpLTE7cD4+PS1oO2grPXU7Zm9yKDtoPjA7aT1pKjI1NitlW3IrY10sYys9bCxoLT04KXt9bz1pJigxPDwtaCktMTtpPj49LWg7aCs9Zjtmb3IoO2g+MDtvPW8qMjU2K2VbcitjXSxjKz1sLGgtPTgpe31pZihpPT09MCl7aT0xLXN9ZWxzZSBpZihpPT09YSl7cmV0dXJuIG8/TmFOOihwPy0xOjEpKkluZmluaXR5fWVsc2V7bz1vK01hdGgucG93KDIsZik7aT1pLXN9cmV0dXJuKHA/LTE6MSkqbypNYXRoLnBvdygyLGktZil9O3Iud3JpdGU9ZnVuY3Rpb24oZSxyLHQsZixuLGkpe3ZhciBvLHUsYTt2YXIgcz1pKjgtbi0xO3ZhciBoPSgxPDxzKS0xO3ZhciBjPWg+PjE7dmFyIGw9bj09PTIzP01hdGgucG93KDIsLTI0KS1NYXRoLnBvdygyLC03Nyk6MDt2YXIgcD1mPzA6aS0xO3ZhciB5PWY/MTotMTt2YXIgZz1yPDB8fHI9PT0wJiYxL3I8MD8xOjA7cj1NYXRoLmFicyhyKTtpZihpc05hTihyKXx8cj09PUluZmluaXR5KXt1PWlzTmFOKHIpPzE6MDtvPWh9ZWxzZXtvPU1hdGguZmxvb3IoTWF0aC5sb2cocikvTWF0aC5MTjIpO2lmKHIqKGE9TWF0aC5wb3coMiwtbykpPDEpe28tLTthKj0yfWlmKG8rYz49MSl7cis9bC9hfWVsc2V7cis9bCpNYXRoLnBvdygyLDEtYyl9aWYociphPj0yKXtvKys7YS89Mn1pZihvK2M+PWgpe3U9MDtvPWh9ZWxzZSBpZihvK2M+PTEpe3U9KHIqYS0xKSpNYXRoLnBvdygyLG4pO289bytjfWVsc2V7dT1yKk1hdGgucG93KDIsYy0xKSpNYXRoLnBvdygyLG4pO289MH19Zm9yKDtuPj04O2VbdCtwXT11JjI1NSxwKz15LHUvPTI1NixuLT04KXt9bz1vPDxufHU7cys9bjtmb3IoO3M+MDtlW3QrcF09byYyNTUscCs9eSxvLz0yNTYscy09OCl7fWVbdCtwLXldfD1nKjEyOH19fTt2YXIgcj17fTtmdW5jdGlvbiBfX25jY3dwY2tfcmVxdWlyZV9fKHQpe3ZhciBmPXJbdF07aWYoZiE9PXVuZGVmaW5lZCl7cmV0dXJuIGYuZXhwb3J0c312YXIgbj1yW3RdPXtleHBvcnRzOnt9fTt2YXIgaT10cnVlO3RyeXtlW3RdKG4sbi5leHBvcnRzLF9fbmNjd3Bja19yZXF1aXJlX18pO2k9ZmFsc2V9ZmluYWxseXtpZihpKWRlbGV0ZSByW3RdfXJldHVybiBuLmV4cG9ydHN9aWYodHlwZW9mIF9fbmNjd3Bja19yZXF1aXJlX18hPT1cInVuZGVmaW5lZFwiKV9fbmNjd3Bja19yZXF1aXJlX18uYWI9X19kaXJuYW1lK1wiL1wiO3ZhciB0PV9fbmNjd3Bja19yZXF1aXJlX18oNzIpO21vZHVsZS5leHBvcnRzPXR9KSgpOyJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/compiled/buffer/index.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */\n\n\n\nif (true) {\n  (function() {\n'use strict';\n\nvar React = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n\n// ATTENTION\n// When adding new symbols to this file,\n// Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n// The Symbol used to tag the ReactElement-like types.\nvar REACT_ELEMENT_TYPE = Symbol.for('react.element');\nvar REACT_PORTAL_TYPE = Symbol.for('react.portal');\nvar REACT_FRAGMENT_TYPE = Symbol.for('react.fragment');\nvar REACT_STRICT_MODE_TYPE = Symbol.for('react.strict_mode');\nvar REACT_PROFILER_TYPE = Symbol.for('react.profiler');\nvar REACT_PROVIDER_TYPE = Symbol.for('react.provider');\nvar REACT_CONTEXT_TYPE = Symbol.for('react.context');\nvar REACT_SERVER_CONTEXT_TYPE = Symbol.for('react.server_context');\nvar REACT_FORWARD_REF_TYPE = Symbol.for('react.forward_ref');\nvar REACT_SUSPENSE_TYPE = Symbol.for('react.suspense');\nvar REACT_SUSPENSE_LIST_TYPE = Symbol.for('react.suspense_list');\nvar REACT_MEMO_TYPE = Symbol.for('react.memo');\nvar REACT_LAZY_TYPE = Symbol.for('react.lazy');\nvar REACT_OFFSCREEN_TYPE = Symbol.for('react.offscreen');\nvar REACT_CACHE_TYPE = Symbol.for('react.cache');\nvar MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\nvar FAUX_ITERATOR_SYMBOL = '@@iterator';\nfunction getIteratorFn(maybeIterable) {\n  if (maybeIterable === null || typeof maybeIterable !== 'object') {\n    return null;\n  }\n\n  var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n\n  if (typeof maybeIterator === 'function') {\n    return maybeIterator;\n  }\n\n  return null;\n}\n\nvar ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n\nfunction error(format) {\n  {\n    {\n      for (var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++) {\n        args[_key2 - 1] = arguments[_key2];\n      }\n\n      printWarning('error', format, args);\n    }\n  }\n}\n\nfunction printWarning(level, format, args) {\n  // When changing this logic, you might want to also\n  // update consoleWithStackDev.www.js as well.\n  {\n    var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n    var stack = ReactDebugCurrentFrame.getStackAddendum();\n\n    if (stack !== '') {\n      format += '%s';\n      args = args.concat([stack]);\n    } // eslint-disable-next-line react-internal/safe-string-coercion\n\n\n    var argsWithFormat = args.map(function (item) {\n      return String(item);\n    }); // Careful: RN currently depends on this prefix\n\n    argsWithFormat.unshift('Warning: ' + format); // We intentionally don't use spread (or .apply) directly because it\n    // breaks IE9: https://github.com/facebook/react/issues/13610\n    // eslint-disable-next-line react-internal/no-production-logging\n\n    Function.prototype.apply.call(console[level], console, argsWithFormat);\n  }\n}\n\n// -----------------------------------------------------------------------------\n\nvar enableScopeAPI = false; // Experimental Create Event Handle API.\nvar enableCacheElement = false;\nvar enableTransitionTracing = false; // No known bugs, but needs performance testing\n\nvar enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n// stuff. Intended to enable React core members to more easily debug scheduling\n// issues in DEV builds.\n\nvar enableDebugTracing = false; // Track which Fiber(s) schedule render work.\n\nvar REACT_MODULE_REFERENCE = Symbol.for('react.module.reference');\nfunction isValidElementType(type) {\n  if (typeof type === 'string' || typeof type === 'function') {\n    return true;\n  } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n\n\n  if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing  || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden  || type === REACT_OFFSCREEN_TYPE || enableScopeAPI  || enableCacheElement  || enableTransitionTracing ) {\n    return true;\n  }\n\n  if (typeof type === 'object' && type !== null) {\n    if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n    // types supported by any Flight configuration anywhere since\n    // we don't know which Flight build this will end up being used\n    // with.\n    type.$$typeof === REACT_MODULE_REFERENCE || type.getModuleId !== undefined) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\nfunction getWrappedName(outerType, innerType, wrapperName) {\n  var displayName = outerType.displayName;\n\n  if (displayName) {\n    return displayName;\n  }\n\n  var functionName = innerType.displayName || innerType.name || '';\n  return functionName !== '' ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n} // Keep in sync with react-reconciler/getComponentNameFromFiber\n\n\nfunction getContextName(type) {\n  return type.displayName || 'Context';\n} // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n\n\nfunction getComponentNameFromType(type) {\n  if (type == null) {\n    // Host root, text node or just invalid type.\n    return null;\n  }\n\n  {\n    if (typeof type.tag === 'number') {\n      error('Received an unexpected object in getComponentNameFromType(). ' + 'This is likely a bug in React. Please file an issue.');\n    }\n  }\n\n  if (typeof type === 'function') {\n    return type.displayName || type.name || null;\n  }\n\n  if (typeof type === 'string') {\n    return type;\n  }\n\n  switch (type) {\n    case REACT_FRAGMENT_TYPE:\n      return 'Fragment';\n\n    case REACT_PORTAL_TYPE:\n      return 'Portal';\n\n    case REACT_PROFILER_TYPE:\n      return 'Profiler';\n\n    case REACT_STRICT_MODE_TYPE:\n      return 'StrictMode';\n\n    case REACT_SUSPENSE_TYPE:\n      return 'Suspense';\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return 'SuspenseList';\n\n    case REACT_CACHE_TYPE:\n      {\n        return 'Cache';\n      }\n\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_CONTEXT_TYPE:\n        var context = type;\n        return getContextName(context) + '.Consumer';\n\n      case REACT_PROVIDER_TYPE:\n        var provider = type;\n        return getContextName(provider._context) + '.Provider';\n\n      case REACT_FORWARD_REF_TYPE:\n        return getWrappedName(type, type.render, 'ForwardRef');\n\n      case REACT_MEMO_TYPE:\n        var outerName = type.displayName || null;\n\n        if (outerName !== null) {\n          return outerName;\n        }\n\n        return getComponentNameFromType(type.type) || 'Memo';\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            return getComponentNameFromType(init(payload));\n          } catch (x) {\n            return null;\n          }\n        }\n\n      case REACT_SERVER_CONTEXT_TYPE:\n        {\n          var context2 = type;\n          return (context2.displayName || context2._globalName) + '.Provider';\n        }\n\n      // eslint-disable-next-line no-fallthrough\n    }\n  }\n\n  return null;\n}\n\nvar assign = Object.assign;\n\n// Helpers to patch console.logs to avoid logging during side-effect free\n// replaying on render function. This currently only patches the object\n// lazily which won't cover if the log function was extracted eagerly.\n// We could also eagerly patch the method.\nvar disabledDepth = 0;\nvar prevLog;\nvar prevInfo;\nvar prevWarn;\nvar prevError;\nvar prevGroup;\nvar prevGroupCollapsed;\nvar prevGroupEnd;\n\nfunction disabledLog() {}\n\ndisabledLog.__reactDisabledLog = true;\nfunction disableLogs() {\n  {\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      prevLog = console.log;\n      prevInfo = console.info;\n      prevWarn = console.warn;\n      prevError = console.error;\n      prevGroup = console.group;\n      prevGroupCollapsed = console.groupCollapsed;\n      prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n\n      var props = {\n        configurable: true,\n        enumerable: true,\n        value: disabledLog,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        info: props,\n        log: props,\n        warn: props,\n        error: props,\n        group: props,\n        groupCollapsed: props,\n        groupEnd: props\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    disabledDepth++;\n  }\n}\nfunction reenableLogs() {\n  {\n    disabledDepth--;\n\n    if (disabledDepth === 0) {\n      /* eslint-disable react-internal/no-production-logging */\n      var props = {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      }; // $FlowFixMe Flow thinks console is immutable.\n\n      Object.defineProperties(console, {\n        log: assign({}, props, {\n          value: prevLog\n        }),\n        info: assign({}, props, {\n          value: prevInfo\n        }),\n        warn: assign({}, props, {\n          value: prevWarn\n        }),\n        error: assign({}, props, {\n          value: prevError\n        }),\n        group: assign({}, props, {\n          value: prevGroup\n        }),\n        groupCollapsed: assign({}, props, {\n          value: prevGroupCollapsed\n        }),\n        groupEnd: assign({}, props, {\n          value: prevGroupEnd\n        })\n      });\n      /* eslint-enable react-internal/no-production-logging */\n    }\n\n    if (disabledDepth < 0) {\n      error('disabledDepth fell below zero. ' + 'This is a bug in React. Please file an issue.');\n    }\n  }\n}\n\nvar ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\nvar prefix;\nfunction describeBuiltInComponentFrame(name, source, ownerFn) {\n  {\n    if (prefix === undefined) {\n      // Extract the VM specific prefix used by each line.\n      try {\n        throw Error();\n      } catch (x) {\n        var match = x.stack.trim().match(/\\n( *(at )?)/);\n        prefix = match && match[1] || '';\n      }\n    } // We use the prefix to ensure our stacks line up with native stack frames.\n\n\n    return '\\n' + prefix + name;\n  }\n}\nvar reentry = false;\nvar componentFrameCache;\n\n{\n  var PossiblyWeakMap = typeof WeakMap === 'function' ? WeakMap : Map;\n  componentFrameCache = new PossiblyWeakMap();\n}\n\nfunction describeNativeComponentFrame(fn, construct) {\n  // If something asked for a stack inside a fake render, it should get ignored.\n  if ( !fn || reentry) {\n    return '';\n  }\n\n  {\n    var frame = componentFrameCache.get(fn);\n\n    if (frame !== undefined) {\n      return frame;\n    }\n  }\n\n  var control;\n  reentry = true;\n  var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe It does accept undefined.\n\n  Error.prepareStackTrace = undefined;\n  var previousDispatcher;\n\n  {\n    previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n    // for warnings.\n\n    ReactCurrentDispatcher.current = null;\n    disableLogs();\n  }\n\n  try {\n    // This should throw.\n    if (construct) {\n      // Something should be setting the props in the constructor.\n      var Fake = function () {\n        throw Error();\n      }; // $FlowFixMe\n\n\n      Object.defineProperty(Fake.prototype, 'props', {\n        set: function () {\n          // We use a throwing setter instead of frozen or non-writable props\n          // because that won't throw in a non-strict mode function.\n          throw Error();\n        }\n      });\n\n      if (typeof Reflect === 'object' && Reflect.construct) {\n        // We construct a different control for this case to include any extra\n        // frames added by the construct call.\n        try {\n          Reflect.construct(Fake, []);\n        } catch (x) {\n          control = x;\n        }\n\n        Reflect.construct(fn, [], Fake);\n      } else {\n        try {\n          Fake.call();\n        } catch (x) {\n          control = x;\n        } // $FlowFixMe[prop-missing] found when upgrading Flow\n\n\n        fn.call(Fake.prototype);\n      }\n    } else {\n      try {\n        throw Error();\n      } catch (x) {\n        control = x;\n      } // TODO(luna): This will currently only throw if the function component\n      // tries to access React/ReactDOM/props. We should probably make this throw\n      // in simple components too\n\n\n      fn();\n    }\n  } catch (sample) {\n    // This is inlined manually because closure doesn't do it for us.\n    if (sample && control && typeof sample.stack === 'string') {\n      // This extracts the first frame from the sample that isn't also in the control.\n      // Skipping one frame that we assume is the frame that calls the two.\n      var sampleLines = sample.stack.split('\\n');\n      var controlLines = control.stack.split('\\n');\n      var s = sampleLines.length - 1;\n      var c = controlLines.length - 1;\n\n      while (s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]) {\n        // We expect at least one stack frame to be shared.\n        // Typically this will be the root most one. However, stack frames may be\n        // cut off due to maximum stack limits. In this case, one maybe cut off\n        // earlier than the other. We assume that the sample is longer or the same\n        // and there for cut off earlier. So we should find the root most frame in\n        // the sample somewhere in the control.\n        c--;\n      }\n\n      for (; s >= 1 && c >= 0; s--, c--) {\n        // Next we find the first one that isn't the same which should be the\n        // frame that called our sample function and the control.\n        if (sampleLines[s] !== controlLines[c]) {\n          // In V8, the first line is describing the message but other VMs don't.\n          // If we're about to return the first line, and the control is also on the same\n          // line, that's a pretty good indicator that our sample threw at same line as\n          // the control. I.e. before we entered the sample frame. So we ignore this result.\n          // This can happen if you passed a class to function component, or non-function.\n          if (s !== 1 || c !== 1) {\n            do {\n              s--;\n              c--; // We may still have similar intermediate frames from the construct call.\n              // The next one that isn't the same should be our match though.\n\n              if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                var _frame = '\\n' + sampleLines[s].replace(' at new ', ' at '); // If our component frame is labeled \"<anonymous>\"\n                // but we have a user-provided \"displayName\"\n                // splice it in to make the stack more readable.\n\n\n                if (fn.displayName && _frame.includes('<anonymous>')) {\n                  _frame = _frame.replace('<anonymous>', fn.displayName);\n                }\n\n                {\n                  if (typeof fn === 'function') {\n                    componentFrameCache.set(fn, _frame);\n                  }\n                } // Return the line we found.\n\n\n                return _frame;\n              }\n            } while (s >= 1 && c >= 0);\n          }\n\n          break;\n        }\n      }\n    }\n  } finally {\n    reentry = false;\n\n    {\n      ReactCurrentDispatcher.current = previousDispatcher;\n      reenableLogs();\n    }\n\n    Error.prepareStackTrace = previousPrepareStackTrace;\n  } // Fallback to just using the name if we couldn't make it throw.\n\n\n  var name = fn ? fn.displayName || fn.name : '';\n  var syntheticFrame = name ? describeBuiltInComponentFrame(name) : '';\n\n  {\n    if (typeof fn === 'function') {\n      componentFrameCache.set(fn, syntheticFrame);\n    }\n  }\n\n  return syntheticFrame;\n}\nfunction describeFunctionComponentFrame(fn, source, ownerFn) {\n  {\n    return describeNativeComponentFrame(fn, false);\n  }\n}\n\nfunction shouldConstruct(Component) {\n  var prototype = Component.prototype;\n  return !!(prototype && prototype.isReactComponent);\n}\n\nfunction describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n\n  if (type == null) {\n    return '';\n  }\n\n  if (typeof type === 'function') {\n    {\n      return describeNativeComponentFrame(type, shouldConstruct(type));\n    }\n  }\n\n  if (typeof type === 'string') {\n    return describeBuiltInComponentFrame(type);\n  }\n\n  switch (type) {\n    case REACT_SUSPENSE_TYPE:\n      return describeBuiltInComponentFrame('Suspense');\n\n    case REACT_SUSPENSE_LIST_TYPE:\n      return describeBuiltInComponentFrame('SuspenseList');\n  }\n\n  if (typeof type === 'object') {\n    switch (type.$$typeof) {\n      case REACT_FORWARD_REF_TYPE:\n        return describeFunctionComponentFrame(type.render);\n\n      case REACT_MEMO_TYPE:\n        // Memo may contain any component type so we recursively resolve it.\n        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n\n      case REACT_LAZY_TYPE:\n        {\n          var lazyComponent = type;\n          var payload = lazyComponent._payload;\n          var init = lazyComponent._init;\n\n          try {\n            // Lazy may contain any component type so we recursively resolve it.\n            return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n          } catch (x) {}\n        }\n    }\n  }\n\n  return '';\n}\n\n// $FlowFixMe[method-unbinding]\nvar hasOwnProperty = Object.prototype.hasOwnProperty;\n\nvar loggedTypeFailures = {};\nvar ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame.setExtraStackFrame(null);\n    }\n  }\n}\n\nfunction checkPropTypes(typeSpecs, values, location, componentName, element) {\n  {\n    // $FlowFixMe This is okay but Flow doesn't know it.\n    var has = Function.call.bind(hasOwnProperty);\n\n    for (var typeSpecName in typeSpecs) {\n      if (has(typeSpecs, typeSpecName)) {\n        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n        // fail the render phase where it didn't fail before. So we log it.\n        // After these have been cleaned up, we'll let them throw.\n\n        try {\n          // This is intentionally an invariant that gets caught. It's the same\n          // behavior as without this statement except with a better message.\n          if (typeof typeSpecs[typeSpecName] !== 'function') {\n            // eslint-disable-next-line react-internal/prod-error-codes\n            var err = Error((componentName || 'React class') + ': ' + location + ' type `' + typeSpecName + '` is invalid; ' + 'it must be a function, usually from the `prop-types` package, but received `' + typeof typeSpecs[typeSpecName] + '`.' + 'This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.');\n            err.name = 'Invariant Violation';\n            throw err;\n          }\n\n          error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, 'SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED');\n        } catch (ex) {\n          error$1 = ex;\n        }\n\n        if (error$1 && !(error$1 instanceof Error)) {\n          setCurrentlyValidatingElement(element);\n\n          error('%s: type specification of %s' + ' `%s` is invalid; the type checker ' + 'function must return `null` or an `Error` but returned a %s. ' + 'You may have forgotten to pass an argument to the type checker ' + 'creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and ' + 'shape all require an argument).', componentName || 'React class', location, typeSpecName, typeof error$1);\n\n          setCurrentlyValidatingElement(null);\n        }\n\n        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n          // Only monitor this failure once because there tends to be a lot of the\n          // same error.\n          loggedTypeFailures[error$1.message] = true;\n          setCurrentlyValidatingElement(element);\n\n          error('Failed %s type: %s', location, error$1.message);\n\n          setCurrentlyValidatingElement(null);\n        }\n      }\n    }\n  }\n}\n\nvar isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n\nfunction isArray(a) {\n  return isArrayImpl(a);\n}\n\n/*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */\n// $FlowFixMe only called in DEV, so void return is not possible.\nfunction typeName(value) {\n  {\n    // toStringTag is needed for namespaced types like Temporal.Instant\n    var hasToStringTag = typeof Symbol === 'function' && Symbol.toStringTag;\n    var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || 'Object'; // $FlowFixMe\n\n    return type;\n  }\n} // $FlowFixMe only called in DEV, so void return is not possible.\n\n\nfunction willCoercionThrow(value) {\n  {\n    try {\n      testStringCoercion(value);\n      return false;\n    } catch (e) {\n      return true;\n    }\n  }\n}\n\nfunction testStringCoercion(value) {\n  // If you ended up here by following an exception call stack, here's what's\n  // happened: you supplied an object or symbol value to React (as a prop, key,\n  // DOM attribute, CSS property, string ref, etc.) and when React tried to\n  // coerce it to a string using `'' + value`, an exception was thrown.\n  //\n  // The most common types that will cause this exception are `Symbol` instances\n  // and Temporal objects like `Temporal.Instant`. But any object that has a\n  // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n  // exception. (Library authors do this to prevent users from using built-in\n  // numeric operators like `+` or comparison operators like `>=` because custom\n  // methods are needed to perform accurate arithmetic or comparison.)\n  //\n  // To fix the problem, coerce this object or symbol value to a string before\n  // passing it to React. The most reliable way is usually `String(value)`.\n  //\n  // To find which value is throwing, check the browser or debugger console.\n  // Before this exception was thrown, there should be `console.error` output\n  // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n  // problem and how that type was used: key, atrribute, input value prop, etc.\n  // In most cases, this console output also shows the component and its\n  // ancestor components where the exception happened.\n  //\n  // eslint-disable-next-line react-internal/safe-string-coercion\n  return '' + value;\n}\nfunction checkKeyStringCoercion(value) {\n  {\n    if (willCoercionThrow(value)) {\n      error('The provided key is an unsupported type %s.' + ' This value must be coerced to a string before before using it here.', typeName(value));\n\n      return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n    }\n  }\n}\n\nvar ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\nvar RESERVED_PROPS = {\n  key: true,\n  ref: true,\n  __self: true,\n  __source: true\n};\nvar specialPropKeyWarningShown;\nvar specialPropRefWarningShown;\nvar didWarnAboutStringRefs;\n\n{\n  didWarnAboutStringRefs = {};\n}\n\nfunction hasValidRef(config) {\n  {\n    if (hasOwnProperty.call(config, 'ref')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'ref').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.ref !== undefined;\n}\n\nfunction hasValidKey(config) {\n  {\n    if (hasOwnProperty.call(config, 'key')) {\n      var getter = Object.getOwnPropertyDescriptor(config, 'key').get;\n\n      if (getter && getter.isReactWarning) {\n        return false;\n      }\n    }\n  }\n\n  return config.key !== undefined;\n}\n\nfunction warnIfStringRefCannotBeAutoConverted(config, self) {\n  {\n    if (typeof config.ref === 'string' && ReactCurrentOwner.current && self && ReactCurrentOwner.current.stateNode !== self) {\n      var componentName = getComponentNameFromType(ReactCurrentOwner.current.type);\n\n      if (!didWarnAboutStringRefs[componentName]) {\n        error('Component \"%s\" contains the string ref \"%s\". ' + 'Support for string refs will be removed in a future major release. ' + 'This case cannot be automatically converted to an arrow function. ' + 'We ask you to manually fix this case by using useRef() or createRef() instead. ' + 'Learn more about using refs safely here: ' + 'https://reactjs.org/link/strict-mode-string-ref', getComponentNameFromType(ReactCurrentOwner.current.type), config.ref);\n\n        didWarnAboutStringRefs[componentName] = true;\n      }\n    }\n  }\n}\n\nfunction defineKeyPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingKey = function () {\n      if (!specialPropKeyWarningShown) {\n        specialPropKeyWarningShown = true;\n\n        error('%s: `key` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingKey.isReactWarning = true;\n    Object.defineProperty(props, 'key', {\n      get: warnAboutAccessingKey,\n      configurable: true\n    });\n  }\n}\n\nfunction defineRefPropWarningGetter(props, displayName) {\n  {\n    var warnAboutAccessingRef = function () {\n      if (!specialPropRefWarningShown) {\n        specialPropRefWarningShown = true;\n\n        error('%s: `ref` is not a prop. Trying to access it will result ' + 'in `undefined` being returned. If you need to access the same ' + 'value within the child component, you should pass it as a different ' + 'prop. (https://reactjs.org/link/special-props)', displayName);\n      }\n    };\n\n    warnAboutAccessingRef.isReactWarning = true;\n    Object.defineProperty(props, 'ref', {\n      get: warnAboutAccessingRef,\n      configurable: true\n    });\n  }\n}\n/**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */\n\n\nvar ReactElement = function (type, key, ref, self, source, owner, props) {\n  var element = {\n    // This tag allows us to uniquely identify this as a React Element\n    $$typeof: REACT_ELEMENT_TYPE,\n    // Built-in properties that belong on the element\n    type: type,\n    key: key,\n    ref: ref,\n    props: props,\n    // Record the component responsible for creating this element.\n    _owner: owner\n  };\n\n  {\n    // The validation flag is currently mutative. We put it on\n    // an external backing store so that we can freeze the whole object.\n    // This can be replaced with a WeakMap once they are implemented in\n    // commonly used development environments.\n    element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n    // the validation flag non-enumerable (where possible, which should\n    // include every environment we run tests in), so the test framework\n    // ignores it.\n\n    Object.defineProperty(element._store, 'validated', {\n      configurable: false,\n      enumerable: false,\n      writable: true,\n      value: false\n    }); // self and source are DEV only properties.\n\n    Object.defineProperty(element, '_self', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: self\n    }); // Two elements created in two different places should be considered\n    // equal for testing purposes and therefore we hide it from enumeration.\n\n    Object.defineProperty(element, '_source', {\n      configurable: false,\n      enumerable: false,\n      writable: false,\n      value: source\n    });\n\n    if (Object.freeze) {\n      Object.freeze(element.props);\n      Object.freeze(element);\n    }\n  }\n\n  return element;\n};\n/**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */\n\nfunction jsxDEV(type, config, maybeKey, source, self) {\n  {\n    var propName; // Reserved names are extracted\n\n    var props = {};\n    var key = null;\n    var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n    // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n    // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n    // but as an intermediary step, we will use jsxDEV for everything except\n    // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n    // key is explicitly declared to be undefined or not.\n\n    if (maybeKey !== undefined) {\n      {\n        checkKeyStringCoercion(maybeKey);\n      }\n\n      key = '' + maybeKey;\n    }\n\n    if (hasValidKey(config)) {\n      {\n        checkKeyStringCoercion(config.key);\n      }\n\n      key = '' + config.key;\n    }\n\n    if (hasValidRef(config)) {\n      ref = config.ref;\n      warnIfStringRefCannotBeAutoConverted(config, self);\n    } // Remaining properties are added to a new props object\n\n\n    for (propName in config) {\n      if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n        props[propName] = config[propName];\n      }\n    } // Resolve default props\n\n\n    if (type && type.defaultProps) {\n      var defaultProps = type.defaultProps;\n\n      for (propName in defaultProps) {\n        if (props[propName] === undefined) {\n          props[propName] = defaultProps[propName];\n        }\n      }\n    }\n\n    if (key || ref) {\n      var displayName = typeof type === 'function' ? type.displayName || type.name || 'Unknown' : type;\n\n      if (key) {\n        defineKeyPropWarningGetter(props, displayName);\n      }\n\n      if (ref) {\n        defineRefPropWarningGetter(props, displayName);\n      }\n    }\n\n    return ReactElement(type, key, ref, self, source, ReactCurrentOwner.current, props);\n  }\n}\n\nvar ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\nvar ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n\nfunction setCurrentlyValidatingElement$1(element) {\n  {\n    if (element) {\n      var owner = element._owner;\n      var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n      ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n    } else {\n      ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n    }\n  }\n}\n\nvar propTypesMisspellWarningShown;\n\n{\n  propTypesMisspellWarningShown = false;\n}\n/**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */\n\n\nfunction isValidElement(object) {\n  {\n    return typeof object === 'object' && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n  }\n}\n\nfunction getDeclarationErrorAddendum() {\n  {\n    if (ReactCurrentOwner$1.current) {\n      var name = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n\n      if (name) {\n        return '\\n\\nCheck the render method of `' + name + '`.';\n      }\n    }\n\n    return '';\n  }\n}\n\nfunction getSourceInfoErrorAddendum(source) {\n  {\n    if (source !== undefined) {\n      var fileName = source.fileName.replace(/^.*[\\\\\\/]/, '');\n      var lineNumber = source.lineNumber;\n      return '\\n\\nCheck your code at ' + fileName + ':' + lineNumber + '.';\n    }\n\n    return '';\n  }\n}\n/**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */\n\n\nvar ownerHasKeyUseWarning = {};\n\nfunction getCurrentComponentErrorInfo(parentType) {\n  {\n    var info = getDeclarationErrorAddendum();\n\n    if (!info) {\n      var parentName = typeof parentType === 'string' ? parentType : parentType.displayName || parentType.name;\n\n      if (parentName) {\n        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n      }\n    }\n\n    return info;\n  }\n}\n/**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */\n\n\nfunction validateExplicitKey(element, parentType) {\n  {\n    if (!element._store || element._store.validated || element.key != null) {\n      return;\n    }\n\n    element._store.validated = true;\n    var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n\n    if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n      return;\n    }\n\n    ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n    // property, it may be the creator of the child that's responsible for\n    // assigning it a key.\n\n    var childOwner = '';\n\n    if (element && element._owner && element._owner !== ReactCurrentOwner$1.current) {\n      // Give the component that originally created this child.\n      childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n    }\n\n    setCurrentlyValidatingElement$1(element);\n\n    error('Each child in a list should have a unique \"key\" prop.' + '%s%s See https://reactjs.org/link/warning-keys for more information.', currentComponentErrorInfo, childOwner);\n\n    setCurrentlyValidatingElement$1(null);\n  }\n}\n/**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */\n\n\nfunction validateChildKeys(node, parentType) {\n  {\n    if (typeof node !== 'object') {\n      return;\n    }\n\n    if (isArray(node)) {\n      for (var i = 0; i < node.length; i++) {\n        var child = node[i];\n\n        if (isValidElement(child)) {\n          validateExplicitKey(child, parentType);\n        }\n      }\n    } else if (isValidElement(node)) {\n      // This element was passed in a valid location.\n      if (node._store) {\n        node._store.validated = true;\n      }\n    } else if (node) {\n      var iteratorFn = getIteratorFn(node);\n\n      if (typeof iteratorFn === 'function') {\n        // Entry iterators used to provide implicit keys,\n        // but now we print a separate warning for them later.\n        if (iteratorFn !== node.entries) {\n          var iterator = iteratorFn.call(node);\n          var step;\n\n          while (!(step = iterator.next()).done) {\n            if (isValidElement(step.value)) {\n              validateExplicitKey(step.value, parentType);\n            }\n          }\n        }\n      }\n    }\n  }\n}\n/**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */\n\n\nfunction validatePropTypes(element) {\n  {\n    var type = element.type;\n\n    if (type === null || type === undefined || typeof type === 'string') {\n      return;\n    }\n\n    var propTypes;\n\n    if (typeof type === 'function') {\n      propTypes = type.propTypes;\n    } else if (typeof type === 'object' && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n    // Inner props are checked in the reconciler.\n    type.$$typeof === REACT_MEMO_TYPE)) {\n      propTypes = type.propTypes;\n    } else {\n      return;\n    }\n\n    if (propTypes) {\n      // Intentionally inside to avoid triggering lazy initializers:\n      var name = getComponentNameFromType(type);\n      checkPropTypes(propTypes, element.props, 'prop', name, element);\n    } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n      propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n\n      var _name = getComponentNameFromType(type);\n\n      error('Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?', _name || 'Unknown');\n    }\n\n    if (typeof type.getDefaultProps === 'function' && !type.getDefaultProps.isReactClassApproved) {\n      error('getDefaultProps is only used on classic React.createClass ' + 'definitions. Use a static property named `defaultProps` instead.');\n    }\n  }\n}\n/**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */\n\n\nfunction validateFragmentProps(fragment) {\n  {\n    var keys = Object.keys(fragment.props);\n\n    for (var i = 0; i < keys.length; i++) {\n      var key = keys[i];\n\n      if (key !== 'children' && key !== 'key') {\n        setCurrentlyValidatingElement$1(fragment);\n\n        error('Invalid prop `%s` supplied to `React.Fragment`. ' + 'React.Fragment can only have `key` and `children` props.', key);\n\n        setCurrentlyValidatingElement$1(null);\n        break;\n      }\n    }\n\n    if (fragment.ref !== null) {\n      setCurrentlyValidatingElement$1(fragment);\n\n      error('Invalid attribute `ref` supplied to `React.Fragment`.');\n\n      setCurrentlyValidatingElement$1(null);\n    }\n  }\n}\n\nvar didWarnAboutKeySpread = {};\nfunction jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n  {\n    var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n    // succeed and there will likely be errors in render.\n\n    if (!validType) {\n      var info = '';\n\n      if (type === undefined || typeof type === 'object' && type !== null && Object.keys(type).length === 0) {\n        info += ' You likely forgot to export your component from the file ' + \"it's defined in, or you might have mixed up default and named imports.\";\n      }\n\n      var sourceInfo = getSourceInfoErrorAddendum(source);\n\n      if (sourceInfo) {\n        info += sourceInfo;\n      } else {\n        info += getDeclarationErrorAddendum();\n      }\n\n      var typeString;\n\n      if (type === null) {\n        typeString = 'null';\n      } else if (isArray(type)) {\n        typeString = 'array';\n      } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n        typeString = \"<\" + (getComponentNameFromType(type.type) || 'Unknown') + \" />\";\n        info = ' Did you accidentally export a JSX literal instead of a component?';\n      } else {\n        typeString = typeof type;\n      }\n\n      error('React.jsx: type is invalid -- expected a string (for ' + 'built-in components) or a class/function (for composite ' + 'components) but got: %s.%s', typeString, info);\n    }\n\n    var element = jsxDEV(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n    // TODO: Drop this when these are no longer allowed as the type argument.\n\n    if (element == null) {\n      return element;\n    } // Skip key warning if the type isn't valid since our key validation logic\n    // doesn't expect a non-string/function type and can throw confusing errors.\n    // We don't want exception behavior to differ between dev and prod.\n    // (Rendering will throw with a helpful message and as soon as the type is\n    // fixed, the key warnings will appear.)\n\n\n    if (validType) {\n      var children = props.children;\n\n      if (children !== undefined) {\n        if (isStaticChildren) {\n          if (isArray(children)) {\n            for (var i = 0; i < children.length; i++) {\n              validateChildKeys(children[i], type);\n            }\n\n            if (Object.freeze) {\n              Object.freeze(children);\n            }\n          } else {\n            error('React.jsx: Static children should always be an array. ' + 'You are likely explicitly calling React.jsxs or React.jsxDEV. ' + 'Use the Babel transform instead.');\n          }\n        } else {\n          validateChildKeys(children, type);\n        }\n      }\n    }\n\n    {\n      if (hasOwnProperty.call(props, 'key')) {\n        var componentName = getComponentNameFromType(type);\n        var keys = Object.keys(props).filter(function (k) {\n          return k !== 'key';\n        });\n        var beforeExample = keys.length > 0 ? '{key: someKey, ' + keys.join(': ..., ') + ': ...}' : '{key: someKey}';\n\n        if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n          var afterExample = keys.length > 0 ? '{' + keys.join(': ..., ') + ': ...}' : '{}';\n\n          error('A props object containing a \"key\" prop is being spread into JSX:\\n' + '  let props = %s;\\n' + '  <%s {...props} />\\n' + 'React keys must be passed directly to JSX without using spread:\\n' + '  let props = %s;\\n' + '  <%s key={someKey} {...props} />', beforeExample, componentName, afterExample, componentName);\n\n          didWarnAboutKeySpread[componentName + beforeExample] = true;\n        }\n      }\n    }\n\n    if (type === REACT_FRAGMENT_TYPE) {\n      validateFragmentProps(element);\n    } else {\n      validatePropTypes(element);\n    }\n\n    return element;\n  }\n} // These two functions exist to still get child warnings in dev\n\nvar jsxDEV$1 =  jsxWithValidation ;\n\nexports.Fragment = REACT_FRAGMENT_TYPE;\nexports.jsxDEV = jsxDEV$1;\n  })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYixJQUFJLElBQXFDO0FBQ3pDO0FBQ0E7O0FBRUEsWUFBWSxtQkFBTyxDQUFDLDRFQUFPOztBQUUzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpR0FBaUcsZUFBZTtBQUNoSDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxNQUFNOzs7QUFHTjtBQUNBO0FBQ0EsS0FBSyxHQUFHOztBQUVSLGtEQUFrRDtBQUNsRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSw0QkFBNEI7QUFDNUI7QUFDQSxxQ0FBcUM7O0FBRXJDLGdDQUFnQztBQUNoQztBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJOzs7QUFHSjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7OztBQUdGO0FBQ0E7QUFDQSxFQUFFOzs7QUFHRjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FB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QTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0NBQXdDO0FBQ3hDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxHQUFHO0FBQ2QsV0FBVyxlQUFlO0FBQzFCLFdBQVcsR0FBRztBQUNkLFdBQVcsR0FBRztBQUNkO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVyxHQUFHO0FBQ2Q7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssR0FBRzs7QUFFUjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSyxHQUFHO0FBQ1I7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7O0FBRUw7QUFDQTtB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QUFRO0FBQ1I7QUFDQTtBQUNBLFFBQVE7QUFDUjtBQUNBOztBQUVBO0FBQ0E7O0FBRUEsMERBQTBEO0FBQzFEOztBQUVBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLHFCQUFxQjtBQUNqRDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsZ0RBQWdELGdEQUFnRCxNQUFNLGFBQWE7O0FBRW5IO0FBQ0EsaURBQWlELGtDQUFrQyxPQUFPOztBQUUxRix5R0FBeUcsY0FBYyxVQUFVLGdHQUFnRyxrQkFBa0IsVUFBVSxVQUFVOztBQUV2UTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsTUFBTTtBQUNOO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLEVBQUU7O0FBRUY7O0FBRUEsZ0JBQWdCO0FBQ2hCLGNBQWM7QUFDZCxHQUFHO0FBQ0giLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzP2MzZjMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBAbGljZW5zZSBSZWFjdFxuICogcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzXG4gKlxuICogQ29weXJpZ2h0IChjKSBNZXRhIFBsYXRmb3JtcywgSW5jLiBhbmQgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuJ3VzZSBzdHJpY3QnO1xuXG52YXIgUmVhY3QgPSByZXF1aXJlKCdyZWFjdCcpO1xuXG4vLyBBVFRFTlRJT05cbi8vIFdoZW4gYWRkaW5nIG5ldyBzeW1ib2xzIHRvIHRoaXMgZmlsZSxcbi8vIFBsZWFzZSBjb25zaWRlciBhbHNvIGFkZGluZyB0byAncmVhY3QtZGV2dG9vbHMtc2hhcmVkL3NyYy9iYWNrZW5kL1JlYWN0U3ltYm9scydcbi8vIFRoZSBTeW1ib2wgdXNlZCB0byB0YWcgdGhlIFJlYWN0RWxlbWVudC1saWtlIHR5cGVzLlxudmFyIFJFQUNUX0VMRU1FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmVsZW1lbnQnKTtcbnZhciBSRUFDVF9QT1JUQUxfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnBvcnRhbCcpO1xudmFyIFJFQUNUX0ZSQUdNRU5UX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mcmFnbWVudCcpO1xudmFyIFJFQUNUX1NUUklDVF9NT0RFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdHJpY3RfbW9kZScpO1xudmFyIFJFQUNUX1BST0ZJTEVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm9maWxlcicpO1xudmFyIFJFQUNUX1BST1ZJREVSX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5wcm92aWRlcicpO1xudmFyIFJFQUNUX0NPTlRFWFRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNvbnRleHQnKTtcbnZhciBSRUFDVF9TRVJWRVJfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc2VydmVyX2NvbnRleHQnKTtcbnZhciBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZm9yd2FyZF9yZWYnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Quc3VzcGVuc2UnKTtcbnZhciBSRUFDVF9TVVNQRU5TRV9MSVNUX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZV9saXN0Jyk7XG52YXIgUkVBQ1RfTUVNT19UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubWVtbycpO1xudmFyIFJFQUNUX0xBWllfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmxhenknKTtcbnZhciBSRUFDVF9PRkZTQ1JFRU5fVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0Lm9mZnNjcmVlbicpO1xudmFyIFJFQUNUX0NBQ0hFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5jYWNoZScpO1xudmFyIE1BWUJFX0lURVJBVE9SX1NZTUJPTCA9IFN5bWJvbC5pdGVyYXRvcjtcbnZhciBGQVVYX0lURVJBVE9SX1NZTUJPTCA9ICdAQGl0ZXJhdG9yJztcbmZ1bmN0aW9uIGdldEl0ZXJhdG9yRm4obWF5YmVJdGVyYWJsZSkge1xuICBpZiAobWF5YmVJdGVyYWJsZSA9PT0gbnVsbCB8fCB0eXBlb2YgbWF5YmVJdGVyYWJsZSAhPT0gJ29iamVjdCcpIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBtYXliZUl0ZXJhdG9yID0gTUFZQkVfSVRFUkFUT1JfU1lNQk9MICYmIG1heWJlSXRlcmFibGVbTUFZQkVfSVRFUkFUT1JfU1lNQk9MXSB8fCBtYXliZUl0ZXJhYmxlW0ZBVVhfSVRFUkFUT1JfU1lNQk9MXTtcblxuICBpZiAodHlwZW9mIG1heWJlSXRlcmF0b3IgPT09ICdmdW5jdGlvbicpIHtcbiAgICByZXR1cm4gbWF5YmVJdGVyYXRvcjtcbiAgfVxuXG4gIHJldHVybiBudWxsO1xufVxuXG52YXIgUmVhY3RTaGFyZWRJbnRlcm5hbHMgPSBSZWFjdC5fX1NFQ1JFVF9JTlRFUk5BTFNfRE9fTk9UX1VTRV9PUl9ZT1VfV0lMTF9CRV9GSVJFRDtcblxuZnVuY3Rpb24gZXJyb3IoZm9ybWF0KSB7XG4gIHtcbiAgICB7XG4gICAgICBmb3IgKHZhciBfbGVuMiA9IGFyZ3VtZW50cy5sZW5ndGgsIGFyZ3MgPSBuZXcgQXJyYXkoX2xlbjIgPiAxID8gX2xlbjIgLSAxIDogMCksIF9rZXkyID0gMTsgX2tleTIgPCBfbGVuMjsgX2tleTIrKykge1xuICAgICAgICBhcmdzW19rZXkyIC0gMV0gPSBhcmd1bWVudHNbX2tleTJdO1xuICAgICAgfVxuXG4gICAgICBwcmludFdhcm5pbmcoJ2Vycm9yJywgZm9ybWF0LCBhcmdzKTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gcHJpbnRXYXJuaW5nKGxldmVsLCBmb3JtYXQsIGFyZ3MpIHtcbiAgLy8gV2hlbiBjaGFuZ2luZyB0aGlzIGxvZ2ljLCB5b3UgbWlnaHQgd2FudCB0byBhbHNvXG4gIC8vIHVwZGF0ZSBjb25zb2xlV2l0aFN0YWNrRGV2Lnd3dy5qcyBhcyB3ZWxsLlxuICB7XG4gICAgdmFyIFJlYWN0RGVidWdDdXJyZW50RnJhbWUgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuICAgIHZhciBzdGFjayA9IFJlYWN0RGVidWdDdXJyZW50RnJhbWUuZ2V0U3RhY2tBZGRlbmR1bSgpO1xuXG4gICAgaWYgKHN0YWNrICE9PSAnJykge1xuICAgICAgZm9ybWF0ICs9ICclcyc7XG4gICAgICBhcmdzID0gYXJncy5jb25jYXQoW3N0YWNrXSk7XG4gICAgfSAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cblxuXG4gICAgdmFyIGFyZ3NXaXRoRm9ybWF0ID0gYXJncy5tYXAoZnVuY3Rpb24gKGl0ZW0pIHtcbiAgICAgIHJldHVybiBTdHJpbmcoaXRlbSk7XG4gICAgfSk7IC8vIENhcmVmdWw6IFJOIGN1cnJlbnRseSBkZXBlbmRzIG9uIHRoaXMgcHJlZml4XG5cbiAgICBhcmdzV2l0aEZvcm1hdC51bnNoaWZ0KCdXYXJuaW5nOiAnICsgZm9ybWF0KTsgLy8gV2UgaW50ZW50aW9uYWxseSBkb24ndCB1c2Ugc3ByZWFkIChvciAuYXBwbHkpIGRpcmVjdGx5IGJlY2F1c2UgaXRcbiAgICAvLyBicmVha3MgSUU5OiBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzEzNjEwXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZ1xuXG4gICAgRnVuY3Rpb24ucHJvdG90eXBlLmFwcGx5LmNhbGwoY29uc29sZVtsZXZlbF0sIGNvbnNvbGUsIGFyZ3NXaXRoRm9ybWF0KTtcbiAgfVxufVxuXG4vLyAtLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLVxuXG52YXIgZW5hYmxlU2NvcGVBUEkgPSBmYWxzZTsgLy8gRXhwZXJpbWVudGFsIENyZWF0ZSBFdmVudCBIYW5kbGUgQVBJLlxudmFyIGVuYWJsZUNhY2hlRWxlbWVudCA9IGZhbHNlO1xudmFyIGVuYWJsZVRyYW5zaXRpb25UcmFjaW5nID0gZmFsc2U7IC8vIE5vIGtub3duIGJ1Z3MsIGJ1dCBuZWVkcyBwZXJmb3JtYW5jZSB0ZXN0aW5nXG5cbnZhciBlbmFibGVMZWdhY3lIaWRkZW4gPSBmYWxzZTsgLy8gRW5hYmxlcyB1bnN0YWJsZV9hdm9pZFRoaXNGYWxsYmFjayBmZWF0dXJlIGluIEZpYmVyXG4vLyBzdHVmZi4gSW50ZW5kZWQgdG8gZW5hYmxlIFJlYWN0IGNvcmUgbWVtYmVycyB0byBtb3JlIGVhc2lseSBkZWJ1ZyBzY2hlZHVsaW5nXG4vLyBpc3N1ZXMgaW4gREVWIGJ1aWxkcy5cblxudmFyIGVuYWJsZURlYnVnVHJhY2luZyA9IGZhbHNlOyAvLyBUcmFjayB3aGljaCBGaWJlcihzKSBzY2hlZHVsZSByZW5kZXIgd29yay5cblxudmFyIFJFQUNUX01PRFVMRV9SRUZFUkVOQ0UgPSBTeW1ib2wuZm9yKCdyZWFjdC5tb2R1bGUucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9NT0RVTEVfUkVGRVJFTkNFIHx8IHR5cGUuZ2V0TW9kdWxlSWQgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIGZhbHNlO1xufVxuXG5mdW5jdGlvbiBnZXRXcmFwcGVkTmFtZShvdXRlclR5cGUsIGlubmVyVHlwZSwgd3JhcHBlck5hbWUpIHtcbiAgdmFyIGRpc3BsYXlOYW1lID0gb3V0ZXJUeXBlLmRpc3BsYXlOYW1lO1xuXG4gIGlmIChkaXNwbGF5TmFtZSkge1xuICAgIHJldHVybiBkaXNwbGF5TmFtZTtcbiAgfVxuXG4gIHZhciBmdW5jdGlvbk5hbWUgPSBpbm5lclR5cGUuZGlzcGxheU5hbWUgfHwgaW5uZXJUeXBlLm5hbWUgfHwgJyc7XG4gIHJldHVybiBmdW5jdGlvbk5hbWUgIT09ICcnID8gd3JhcHBlck5hbWUgKyBcIihcIiArIGZ1bmN0aW9uTmFtZSArIFwiKVwiIDogd3JhcHBlck5hbWU7XG59IC8vIEtlZXAgaW4gc3luYyB3aXRoIHJlYWN0LXJlY29uY2lsZXIvZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlclxuXG5cbmZ1bmN0aW9uIGdldENvbnRleHROYW1lKHR5cGUpIHtcbiAgcmV0dXJuIHR5cGUuZGlzcGxheU5hbWUgfHwgJ0NvbnRleHQnO1xufSAvLyBOb3RlIHRoYXQgdGhlIHJlY29uY2lsZXIgcGFja2FnZSBzaG91bGQgZ2VuZXJhbGx5IHByZWZlciB0byB1c2UgZ2V0Q29tcG9uZW50TmFtZUZyb21GaWJlcigpIGluc3RlYWQuXG5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAge1xuICAgIGlmICh0eXBlb2YgdHlwZS50YWcgPT09ICdudW1iZXInKSB7XG4gICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICBzd2l0Y2ggKHR5cGUuJCR0eXBlb2YpIHtcbiAgICAgIGNhc2UgUkVBQ1RfQ09OVEVYVF9UWVBFOlxuICAgICAgICB2YXIgY29udGV4dCA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShjb250ZXh0KSArICcuQ29uc3VtZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX1BST1ZJREVSX1RZUEU6XG4gICAgICAgIHZhciBwcm92aWRlciA9IHR5cGU7XG4gICAgICAgIHJldHVybiBnZXRDb250ZXh0TmFtZShwcm92aWRlci5fY29udGV4dCkgKyAnLlByb3ZpZGVyJztcblxuICAgICAgY2FzZSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFOlxuICAgICAgICByZXR1cm4gZ2V0V3JhcHBlZE5hbWUodHlwZSwgdHlwZS5yZW5kZXIsICdGb3J3YXJkUmVmJyk7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTUVNT19UWVBFOlxuICAgICAgICB2YXIgb3V0ZXJOYW1lID0gdHlwZS5kaXNwbGF5TmFtZSB8fCBudWxsO1xuXG4gICAgICAgIGlmIChvdXRlck5hbWUgIT09IG51bGwpIHtcbiAgICAgICAgICByZXR1cm4gb3V0ZXJOYW1lO1xuICAgICAgICB9XG5cbiAgICAgICAgcmV0dXJuIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdNZW1vJztcblxuICAgICAgY2FzZSBSRUFDVF9MQVpZX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgbGF6eUNvbXBvbmVudCA9IHR5cGU7XG4gICAgICAgICAgdmFyIHBheWxvYWQgPSBsYXp5Q29tcG9uZW50Ll9wYXlsb2FkO1xuICAgICAgICAgIHZhciBpbml0ID0gbGF6eUNvbXBvbmVudC5faW5pdDtcblxuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKGluaXQocGF5bG9hZCkpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIHJldHVybiBudWxsO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuXG4gICAgICBjYXNlIFJFQUNUX1NFUlZFUl9DT05URVhUX1RZUEU6XG4gICAgICAgIHtcbiAgICAgICAgICB2YXIgY29udGV4dDIgPSB0eXBlO1xuICAgICAgICAgIHJldHVybiAoY29udGV4dDIuZGlzcGxheU5hbWUgfHwgY29udGV4dDIuX2dsb2JhbE5hbWUpICsgJy5Qcm92aWRlcic7XG4gICAgICAgIH1cblxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLWZhbGx0aHJvdWdoXG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBhc3NpZ24gPSBPYmplY3QuYXNzaWduO1xuXG4vLyBIZWxwZXJzIHRvIHBhdGNoIGNvbnNvbGUubG9ncyB0byBhdm9pZCBsb2dnaW5nIGR1cmluZyBzaWRlLWVmZmVjdCBmcmVlXG4vLyByZXBsYXlpbmcgb24gcmVuZGVyIGZ1bmN0aW9uLiBUaGlzIGN1cnJlbnRseSBvbmx5IHBhdGNoZXMgdGhlIG9iamVjdFxuLy8gbGF6aWx5IHdoaWNoIHdvbid0IGNvdmVyIGlmIHRoZSBsb2cgZnVuY3Rpb24gd2FzIGV4dHJhY3RlZCBlYWdlcmx5LlxuLy8gV2UgY291bGQgYWxzbyBlYWdlcmx5IHBhdGNoIHRoZSBtZXRob2QuXG52YXIgZGlzYWJsZWREZXB0aCA9IDA7XG52YXIgcHJldkxvZztcbnZhciBwcmV2SW5mbztcbnZhciBwcmV2V2FybjtcbnZhciBwcmV2RXJyb3I7XG52YXIgcHJldkdyb3VwO1xudmFyIHByZXZHcm91cENvbGxhcHNlZDtcbnZhciBwcmV2R3JvdXBFbmQ7XG5cbmZ1bmN0aW9uIGRpc2FibGVkTG9nKCkge31cblxuZGlzYWJsZWRMb2cuX19yZWFjdERpc2FibGVkTG9nID0gdHJ1ZTtcbmZ1bmN0aW9uIGRpc2FibGVMb2dzKCkge1xuICB7XG4gICAgaWYgKGRpc2FibGVkRGVwdGggPT09IDApIHtcbiAgICAgIC8qIGVzbGludC1kaXNhYmxlIHJlYWN0LWludGVybmFsL25vLXByb2R1Y3Rpb24tbG9nZ2luZyAqL1xuICAgICAgcHJldkxvZyA9IGNvbnNvbGUubG9nO1xuICAgICAgcHJldkluZm8gPSBjb25zb2xlLmluZm87XG4gICAgICBwcmV2V2FybiA9IGNvbnNvbGUud2FybjtcbiAgICAgIHByZXZFcnJvciA9IGNvbnNvbGUuZXJyb3I7XG4gICAgICBwcmV2R3JvdXAgPSBjb25zb2xlLmdyb3VwO1xuICAgICAgcHJldkdyb3VwQ29sbGFwc2VkID0gY29uc29sZS5ncm91cENvbGxhcHNlZDtcbiAgICAgIHByZXZHcm91cEVuZCA9IGNvbnNvbGUuZ3JvdXBFbmQ7IC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTkwOTlcblxuICAgICAgdmFyIHByb3BzID0ge1xuICAgICAgICBjb25maWd1cmFibGU6IHRydWUsXG4gICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgIHZhbHVlOiBkaXNhYmxlZExvZyxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWUgRmxvdyB0aGlua3MgY29uc29sZSBpcyBpbW11dGFibGUuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKGNvbnNvbGUsIHtcbiAgICAgICAgaW5mbzogcHJvcHMsXG4gICAgICAgIGxvZzogcHJvcHMsXG4gICAgICAgIHdhcm46IHByb3BzLFxuICAgICAgICBlcnJvcjogcHJvcHMsXG4gICAgICAgIGdyb3VwOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBDb2xsYXBzZWQ6IHByb3BzLFxuICAgICAgICBncm91cEVuZDogcHJvcHNcbiAgICAgIH0pO1xuICAgICAgLyogZXNsaW50LWVuYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICB9XG5cbiAgICBkaXNhYmxlZERlcHRoKys7XG4gIH1cbn1cbmZ1bmN0aW9uIHJlZW5hYmxlTG9ncygpIHtcbiAge1xuICAgIGRpc2FibGVkRGVwdGgtLTtcblxuICAgIGlmIChkaXNhYmxlZERlcHRoID09PSAwKSB7XG4gICAgICAvKiBlc2xpbnQtZGlzYWJsZSByZWFjdC1pbnRlcm5hbC9uby1wcm9kdWN0aW9uLWxvZ2dpbmcgKi9cbiAgICAgIHZhciBwcm9wcyA9IHtcbiAgICAgICAgY29uZmlndXJhYmxlOiB0cnVlLFxuICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG5cbmZ1bmN0aW9uIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGNvbnN0cnVjdCkge1xuICAvLyBJZiBzb21ldGhpbmcgYXNrZWQgZm9yIGEgc3RhY2sgaW5zaWRlIGEgZmFrZSByZW5kZXIsIGl0IHNob3VsZCBnZXQgaWdub3JlZC5cbiAgaWYgKCAhZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHZhciBjb250cm9sO1xuICByZWVudHJ5ID0gdHJ1ZTtcbiAgdmFyIHByZXZpb3VzUHJlcGFyZVN0YWNrVHJhY2UgPSBFcnJvci5wcmVwYXJlU3RhY2tUcmFjZTsgLy8gJEZsb3dGaXhNZSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG5cbiAgdHJ5IHtcbiAgICAvLyBUaGlzIHNob3VsZCB0aHJvdy5cbiAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAvLyBTb21ldGhpbmcgc2hvdWxkIGJlIHNldHRpbmcgdGhlIHByb3BzIGluIHRoZSBjb25zdHJ1Y3Rvci5cbiAgICAgIHZhciBGYWtlID0gZnVuY3Rpb24gKCkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfTsgLy8gJEZsb3dGaXhNZVxuXG5cbiAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShGYWtlLnByb3RvdHlwZSwgJ3Byb3BzJywge1xuICAgICAgICBzZXQ6IGZ1bmN0aW9uICgpIHtcbiAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgLy8gYmVjYXVzZSB0aGF0IHdvbid0IHRocm93IGluIGEgbm9uLXN0cmljdCBtb2RlIGZ1bmN0aW9uLlxuICAgICAgICAgIHRocm93IEVycm9yKCk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuXG4gICAgICBpZiAodHlwZW9mIFJlZmxlY3QgPT09ICdvYmplY3QnICYmIFJlZmxlY3QuY29uc3RydWN0KSB7XG4gICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgLy8gZnJhbWVzIGFkZGVkIGJ5IHRoZSBjb25zdHJ1Y3QgY2FsbC5cbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICBjb250cm9sID0geDtcbiAgICAgICAgfVxuXG4gICAgICAgIFJlZmxlY3QuY29uc3RydWN0KGZuLCBbXSwgRmFrZSk7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0cnkge1xuICAgICAgICAgIEZha2UuY2FsbCgpO1xuICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgIH0gLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddIGZvdW5kIHdoZW4gdXBncmFkaW5nIEZsb3dcblxuXG4gICAgICAgIGZuLmNhbGwoRmFrZS5wcm90b3R5cGUpO1xuICAgICAgfVxuICAgIH0gZWxzZSB7XG4gICAgICB0cnkge1xuICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICBjb250cm9sID0geDtcbiAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgIC8vIHRyaWVzIHRvIGFjY2VzcyBSZWFjdC9SZWFjdERPTS9wcm9wcy4gV2Ugc2hvdWxkIHByb2JhYmx5IG1ha2UgdGhpcyB0aHJvd1xuICAgICAgLy8gaW4gc2ltcGxlIGNvbXBvbmVudHMgdG9vXG5cblxuICAgICAgZm4oKTtcbiAgICB9XG4gIH0gY2F0Y2ggKHNhbXBsZSkge1xuICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgaWYgKHNhbXBsZSAmJiBjb250cm9sICYmIHR5cGVvZiBzYW1wbGUuc3RhY2sgPT09ICdzdHJpbmcnKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGUuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIGNvbnRyb2xMaW5lcyA9IGNvbnRyb2wuc3RhY2suc3BsaXQoJ1xcbicpO1xuICAgICAgdmFyIHMgPSBzYW1wbGVMaW5lcy5sZW5ndGggLSAxO1xuICAgICAgdmFyIGMgPSBjb250cm9sTGluZXMubGVuZ3RoIC0gMTtcblxuICAgICAgd2hpbGUgKHMgPj0gMSAmJiBjID49IDAgJiYgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgLy8gVHlwaWNhbGx5IHRoaXMgd2lsbCBiZSB0aGUgcm9vdCBtb3N0IG9uZS4gSG93ZXZlciwgc3RhY2sgZnJhbWVzIG1heSBiZVxuICAgICAgICAvLyBjdXQgb2ZmIGR1ZSB0byBtYXhpbXVtIHN0YWNrIGxpbWl0cy4gSW4gdGhpcyBjYXNlLCBvbmUgbWF5YmUgY3V0IG9mZlxuICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAvLyBhbmQgdGhlcmUgZm9yIGN1dCBvZmYgZWFybGllci4gU28gd2Ugc2hvdWxkIGZpbmQgdGhlIHJvb3QgbW9zdCBmcmFtZSBpblxuICAgICAgICAvLyB0aGUgc2FtcGxlIHNvbWV3aGVyZSBpbiB0aGUgY29udHJvbC5cbiAgICAgICAgYy0tO1xuICAgICAgfVxuXG4gICAgICBmb3IgKDsgcyA+PSAxICYmIGMgPj0gMDsgcy0tLCBjLS0pIHtcbiAgICAgICAgLy8gTmV4dCB3ZSBmaW5kIHRoZSBmaXJzdCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSB3aGljaCBzaG91bGQgYmUgdGhlXG4gICAgICAgIC8vIGZyYW1lIHRoYXQgY2FsbGVkIG91ciBzYW1wbGUgZnVuY3Rpb24gYW5kIHRoZSBjb250cm9sLlxuICAgICAgICBpZiAoc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgIC8vIEluIFY4LCB0aGUgZmlyc3QgbGluZSBpcyBkZXNjcmliaW5nIHRoZSBtZXNzYWdlIGJ1dCBvdGhlciBWTXMgZG9uJ3QuXG4gICAgICAgICAgLy8gSWYgd2UncmUgYWJvdXQgdG8gcmV0dXJuIHRoZSBmaXJzdCBsaW5lLCBhbmQgdGhlIGNvbnRyb2wgaXMgYWxzbyBvbiB0aGUgc2FtZVxuICAgICAgICAgIC8vIGxpbmUsIHRoYXQncyBhIHByZXR0eSBnb29kIGluZGljYXRvciB0aGF0IG91ciBzYW1wbGUgdGhyZXcgYXQgc2FtZSBsaW5lIGFzXG4gICAgICAgICAgLy8gdGhlIGNvbnRyb2wuIEkuZS4gYmVmb3JlIHdlIGVudGVyZWQgdGhlIHNhbXBsZSBmcmFtZS4gU28gd2UgaWdub3JlIHRoaXMgcmVzdWx0LlxuICAgICAgICAgIC8vIFRoaXMgY2FuIGhhcHBlbiBpZiB5b3UgcGFzc2VkIGEgY2xhc3MgdG8gZnVuY3Rpb24gY29tcG9uZW50LCBvciBub24tZnVuY3Rpb24uXG4gICAgICAgICAgaWYgKHMgIT09IDEgfHwgYyAhPT0gMSkge1xuICAgICAgICAgICAgZG8ge1xuICAgICAgICAgICAgICBzLS07XG4gICAgICAgICAgICAgIGMtLTsgLy8gV2UgbWF5IHN0aWxsIGhhdmUgc2ltaWxhciBpbnRlcm1lZGlhdGUgZnJhbWVzIGZyb20gdGhlIGNvbnN0cnVjdCBjYWxsLlxuICAgICAgICAgICAgICAvLyBUaGUgbmV4dCBvbmUgdGhhdCBpc24ndCB0aGUgc2FtZSBzaG91bGQgYmUgb3VyIG1hdGNoIHRob3VnaC5cblxuICAgICAgICAgICAgICBpZiAoYyA8IDAgfHwgc2FtcGxlTGluZXNbc10gIT09IGNvbnRyb2xMaW5lc1tjXSkge1xuICAgICAgICAgICAgICAgIC8vIFY4IGFkZHMgYSBcIm5ld1wiIHByZWZpeCBmb3IgbmF0aXZlIGNsYXNzZXMuIExldCdzIHJlbW92ZSBpdCB0byBtYWtlIGl0IHByZXR0aWVyLlxuICAgICAgICAgICAgICAgIHZhciBfZnJhbWUgPSAnXFxuJyArIHNhbXBsZUxpbmVzW3NdLnJlcGxhY2UoJyBhdCBuZXcgJywgJyBhdCAnKTsgLy8gSWYgb3VyIGNvbXBvbmVudCBmcmFtZSBpcyBsYWJlbGVkIFwiPGFub255bW91cz5cIlxuICAgICAgICAgICAgICAgIC8vIGJ1dCB3ZSBoYXZlIGEgdXNlci1wcm92aWRlZCBcImRpc3BsYXlOYW1lXCJcbiAgICAgICAgICAgICAgICAvLyBzcGxpY2UgaXQgaW4gdG8gbWFrZSB0aGUgc3RhY2sgbW9yZSByZWFkYWJsZS5cblxuXG4gICAgICAgICAgICAgICAgaWYgKGZuLmRpc3BsYXlOYW1lICYmIF9mcmFtZS5pbmNsdWRlcygnPGFub255bW91cz4nKSkge1xuICAgICAgICAgICAgICAgICAgX2ZyYW1lID0gX2ZyYW1lLnJlcGxhY2UoJzxhbm9ueW1vdXM+JywgZm4uZGlzcGxheU5hbWUpO1xuICAgICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICAgIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG5cbmZ1bmN0aW9uIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKG51bGwpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBjaGVja1Byb3BUeXBlcyh0eXBlU3BlY3MsIHZhbHVlcywgbG9jYXRpb24sIGNvbXBvbmVudE5hbWUsIGVsZW1lbnQpIHtcbiAge1xuICAgIC8vICRGbG93Rml4TWUgVGhpcyBpcyBva2F5IGJ1dCBGbG93IGRvZXNuJ3Qga25vdyBpdC5cbiAgICB2YXIgaGFzID0gRnVuY3Rpb24uY2FsbC5iaW5kKGhhc093blByb3BlcnR5KTtcblxuICAgIGZvciAodmFyIHR5cGVTcGVjTmFtZSBpbiB0eXBlU3BlY3MpIHtcbiAgICAgIGlmIChoYXModHlwZVNwZWNzLCB0eXBlU3BlY05hbWUpKSB7XG4gICAgICAgIHZhciBlcnJvciQxID0gdm9pZCAwOyAvLyBQcm9wIHR5cGUgdmFsaWRhdGlvbiBtYXkgdGhyb3cuIEluIGNhc2UgdGhleSBkbywgd2UgZG9uJ3Qgd2FudCB0b1xuICAgICAgICAvLyBmYWlsIHRoZSByZW5kZXIgcGhhc2Ugd2hlcmUgaXQgZGlkbid0IGZhaWwgYmVmb3JlLiBTbyB3ZSBsb2cgaXQuXG4gICAgICAgIC8vIEFmdGVyIHRoZXNlIGhhdmUgYmVlbiBjbGVhbmVkIHVwLCB3ZSdsbCBsZXQgdGhlbSB0aHJvdy5cblxuICAgICAgICB0cnkge1xuICAgICAgICAgIC8vIFRoaXMgaXMgaW50ZW50aW9uYWxseSBhbiBpbnZhcmlhbnQgdGhhdCBnZXRzIGNhdWdodC4gSXQncyB0aGUgc2FtZVxuICAgICAgICAgIC8vIGJlaGF2aW9yIGFzIHdpdGhvdXQgdGhpcyBzdGF0ZW1lbnQgZXhjZXB0IHdpdGggYSBiZXR0ZXIgbWVzc2FnZS5cbiAgICAgICAgICBpZiAodHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICE9PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvcHJvZC1lcnJvci1jb2Rlc1xuICAgICAgICAgICAgdmFyIGVyciA9IEVycm9yKChjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycpICsgJzogJyArIGxvY2F0aW9uICsgJyB0eXBlIGAnICsgdHlwZVNwZWNOYW1lICsgJ2AgaXMgaW52YWxpZDsgJyArICdpdCBtdXN0IGJlIGEgZnVuY3Rpb24sIHVzdWFsbHkgZnJvbSB0aGUgYHByb3AtdHlwZXNgIHBhY2thZ2UsIGJ1dCByZWNlaXZlZCBgJyArIHR5cGVvZiB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSArICdgLicgKyAnVGhpcyBvZnRlbiBoYXBwZW5zIGJlY2F1c2Ugb2YgdHlwb3Mgc3VjaCBhcyBgUHJvcFR5cGVzLmZ1bmN0aW9uYCBpbnN0ZWFkIG9mIGBQcm9wVHlwZXMuZnVuY2AuJyk7XG4gICAgICAgICAgICBlcnIubmFtZSA9ICdJbnZhcmlhbnQgVmlvbGF0aW9uJztcbiAgICAgICAgICAgIHRocm93IGVycjtcbiAgICAgICAgICB9XG5cbiAgICAgICAgICBlcnJvciQxID0gdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0odmFsdWVzLCB0eXBlU3BlY05hbWUsIGNvbXBvbmVudE5hbWUsIGxvY2F0aW9uLCBudWxsLCAnU0VDUkVUX0RPX05PVF9QQVNTX1RISVNfT1JfWU9VX1dJTExfQkVfRklSRUQnKTtcbiAgICAgICAgfSBjYXRjaCAoZXgpIHtcbiAgICAgICAgICBlcnJvciQxID0gZXg7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSAmJiAhKGVycm9yJDEgaW5zdGFuY2VvZiBFcnJvcikpIHtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCclczogdHlwZSBzcGVjaWZpY2F0aW9uIG9mICVzJyArICcgYCVzYCBpcyBpbnZhbGlkOyB0aGUgdHlwZSBjaGVja2VyICcgKyAnZnVuY3Rpb24gbXVzdCByZXR1cm4gYG51bGxgIG9yIGFuIGBFcnJvcmAgYnV0IHJldHVybmVkIGEgJXMuICcgKyAnWW91IG1heSBoYXZlIGZvcmdvdHRlbiB0byBwYXNzIGFuIGFyZ3VtZW50IHRvIHRoZSB0eXBlIGNoZWNrZXIgJyArICdjcmVhdG9yIChhcnJheU9mLCBpbnN0YW5jZU9mLCBvYmplY3RPZiwgb25lT2YsIG9uZU9mVHlwZSwgYW5kICcgKyAnc2hhcGUgYWxsIHJlcXVpcmUgYW4gYXJndW1lbnQpLicsIGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJywgbG9jYXRpb24sIHR5cGVTcGVjTmFtZSwgdHlwZW9mIGVycm9yJDEpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgICAgICAgIGVycm9yKCdGYWlsZWQgJXMgdHlwZTogJXMnLCBsb2NhdGlvbiwgZXJyb3IkMS5tZXNzYWdlKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50KG51bGwpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbnZhciBpc0FycmF5SW1wbCA9IEFycmF5LmlzQXJyYXk7IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1yZWRlY2xhcmVcblxuZnVuY3Rpb24gaXNBcnJheShhKSB7XG4gIHJldHVybiBpc0FycmF5SW1wbChhKTtcbn1cblxuLypcbiAqIFRoZSBgJycgKyB2YWx1ZWAgcGF0dGVybiAodXNlZCBpbiBwZXJmLXNlbnNpdGl2ZSBjb2RlKSB0aHJvd3MgZm9yIFN5bWJvbFxuICogYW5kIFRlbXBvcmFsLiogdHlwZXMuIFNlZSBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvcHVsbC8yMjA2NC5cbiAqXG4gKiBUaGUgZnVuY3Rpb25zIGluIHRoaXMgbW9kdWxlIHdpbGwgdGhyb3cgYW4gZWFzaWVyLXRvLXVuZGVyc3RhbmQsXG4gKiBlYXNpZXItdG8tZGVidWcgZXhjZXB0aW9uIHdpdGggYSBjbGVhciBlcnJvcnMgbWVzc2FnZSBtZXNzYWdlIGV4cGxhaW5pbmcgdGhlXG4gKiBwcm9ibGVtLiAoSW5zdGVhZCBvZiBhIGNvbmZ1c2luZyBleGNlcHRpb24gdGhyb3duIGluc2lkZSB0aGUgaW1wbGVtZW50YXRpb25cbiAqIG9mIHRoZSBgdmFsdWVgIG9iamVjdCkuXG4gKi9cbi8vICRGbG93Rml4TWUgb25seSBjYWxsZWQgaW4gREVWLCBzbyB2b2lkIHJldHVybiBpcyBub3QgcG9zc2libGUuXG5mdW5jdGlvbiB0eXBlTmFtZSh2YWx1ZSkge1xuICB7XG4gICAgLy8gdG9TdHJpbmdUYWcgaXMgbmVlZGVkIGZvciBuYW1lc3BhY2VkIHR5cGVzIGxpa2UgVGVtcG9yYWwuSW5zdGFudFxuICAgIHZhciBoYXNUb1N0cmluZ1RhZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgU3ltYm9sLnRvU3RyaW5nVGFnO1xuICAgIHZhciB0eXBlID0gaGFzVG9TdHJpbmdUYWcgJiYgdmFsdWVbU3ltYm9sLnRvU3RyaW5nVGFnXSB8fCB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lIHx8ICdPYmplY3QnOyAvLyAkRmxvd0ZpeE1lXG5cbiAgICByZXR1cm4gdHlwZTtcbiAgfVxufSAvLyAkRmxvd0ZpeE1lIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuXG5cbmZ1bmN0aW9uIHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSB7XG4gIHtcbiAgICB0cnkge1xuICAgICAgdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9IGNhdGNoIChlKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIC8vIElmIHlvdSBlbmRlZCB1cCBoZXJlIGJ5IGZvbGxvd2luZyBhbiBleGNlcHRpb24gY2FsbCBzdGFjaywgaGVyZSdzIHdoYXQnc1xuICAvLyBoYXBwZW5lZDogeW91IHN1cHBsaWVkIGFuIG9iamVjdCBvciBzeW1ib2wgdmFsdWUgdG8gUmVhY3QgKGFzIGEgcHJvcCwga2V5LFxuICAvLyBET00gYXR0cmlidXRlLCBDU1MgcHJvcGVydHksIHN0cmluZyByZWYsIGV0Yy4pIGFuZCB3aGVuIFJlYWN0IHRyaWVkIHRvXG4gIC8vIGNvZXJjZSBpdCB0byBhIHN0cmluZyB1c2luZyBgJycgKyB2YWx1ZWAsIGFuIGV4Y2VwdGlvbiB3YXMgdGhyb3duLlxuICAvL1xuICAvLyBUaGUgbW9zdCBjb21tb24gdHlwZXMgdGhhdCB3aWxsIGNhdXNlIHRoaXMgZXhjZXB0aW9uIGFyZSBgU3ltYm9sYCBpbnN0YW5jZXNcbiAgLy8gYW5kIFRlbXBvcmFsIG9iamVjdHMgbGlrZSBgVGVtcG9yYWwuSW5zdGFudGAuIEJ1dCBhbnkgb2JqZWN0IHRoYXQgaGFzIGFcbiAgLy8gYHZhbHVlT2ZgIG9yIGBbU3ltYm9sLnRvUHJpbWl0aXZlXWAgbWV0aG9kIHRoYXQgdGhyb3dzIHdpbGwgYWxzbyBjYXVzZSB0aGlzXG4gIC8vIGV4Y2VwdGlvbi4gKExpYnJhcnkgYXV0aG9ycyBkbyB0aGlzIHRvIHByZXZlbnQgdXNlcnMgZnJvbSB1c2luZyBidWlsdC1pblxuICAvLyBudW1lcmljIG9wZXJhdG9ycyBsaWtlIGArYCBvciBjb21wYXJpc29uIG9wZXJhdG9ycyBsaWtlIGA+PWAgYmVjYXVzZSBjdXN0b21cbiAgLy8gbWV0aG9kcyBhcmUgbmVlZGVkIHRvIHBlcmZvcm0gYWNjdXJhdGUgYXJpdGhtZXRpYyBvciBjb21wYXJpc29uLilcbiAgLy9cbiAgLy8gVG8gZml4IHRoZSBwcm9ibGVtLCBjb2VyY2UgdGhpcyBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIGEgc3RyaW5nIGJlZm9yZVxuICAvLyBwYXNzaW5nIGl0IHRvIFJlYWN0LiBUaGUgbW9zdCByZWxpYWJsZSB3YXkgaXMgdXN1YWxseSBgU3RyaW5nKHZhbHVlKWAuXG4gIC8vXG4gIC8vIFRvIGZpbmQgd2hpY2ggdmFsdWUgaXMgdGhyb3dpbmcsIGNoZWNrIHRoZSBicm93c2VyIG9yIGRlYnVnZ2VyIGNvbnNvbGUuXG4gIC8vIEJlZm9yZSB0aGlzIGV4Y2VwdGlvbiB3YXMgdGhyb3duLCB0aGVyZSBzaG91bGQgYmUgYGNvbnNvbGUuZXJyb3JgIG91dHB1dFxuICAvLyB0aGF0IHNob3dzIHRoZSB0eXBlIChTeW1ib2wsIFRlbXBvcmFsLlBsYWluRGF0ZSwgZXRjLikgdGhhdCBjYXVzZWQgdGhlXG4gIC8vIHByb2JsZW0gYW5kIGhvdyB0aGF0IHR5cGUgd2FzIHVzZWQ6IGtleSwgYXRycmlidXRlLCBpbnB1dCB2YWx1ZSBwcm9wLCBldGMuXG4gIC8vIEluIG1vc3QgY2FzZXMsIHRoaXMgY29uc29sZSBvdXRwdXQgYWxzbyBzaG93cyB0aGUgY29tcG9uZW50IGFuZCBpdHNcbiAgLy8gYW5jZXN0b3IgY29tcG9uZW50cyB3aGVyZSB0aGUgZXhjZXB0aW9uIGhhcHBlbmVkLlxuICAvL1xuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvc2FmZS1zdHJpbmctY29lcmNpb25cbiAgcmV0dXJuICcnICsgdmFsdWU7XG59XG5mdW5jdGlvbiBjaGVja0tleVN0cmluZ0NvZXJjaW9uKHZhbHVlKSB7XG4gIHtcbiAgICBpZiAod2lsbENvZXJjaW9uVGhyb3codmFsdWUpKSB7XG4gICAgICBlcnJvcignVGhlIHByb3ZpZGVkIGtleSBpcyBhbiB1bnN1cHBvcnRlZCB0eXBlICVzLicgKyAnIFRoaXMgdmFsdWUgbXVzdCBiZSBjb2VyY2VkIHRvIGEgc3RyaW5nIGJlZm9yZSBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUkVTRVJWRURfUFJPUFMgPSB7XG4gIGtleTogdHJ1ZSxcbiAgcmVmOiB0cnVlLFxuICBfX3NlbGY6IHRydWUsXG4gIF9fc291cmNlOiB0cnVlXG59O1xudmFyIHNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duO1xudmFyIHNwZWNpYWxQcm9wUmVmV2FybmluZ1Nob3duO1xudmFyIGRpZFdhcm5BYm91dFN0cmluZ1JlZnM7XG5cbntcbiAgZGlkV2FybkFib3V0U3RyaW5nUmVmcyA9IHt9O1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZFJlZihjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ3JlZicpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdyZWYnKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLnJlZiAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiBoYXNWYWxpZEtleShjb25maWcpIHtcbiAge1xuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgJ2tleScpKSB7XG4gICAgICB2YXIgZ2V0dGVyID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihjb25maWcsICdrZXknKS5nZXQ7XG5cbiAgICAgIGlmIChnZXR0ZXIgJiYgZ2V0dGVyLmlzUmVhY3RXYXJuaW5nKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICByZXR1cm4gY29uZmlnLmtleSAhPT0gdW5kZWZpbmVkO1xufVxuXG5mdW5jdGlvbiB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKSB7XG4gIHtcbiAgICBpZiAodHlwZW9mIGNvbmZpZy5yZWYgPT09ICdzdHJpbmcnICYmIFJlYWN0Q3VycmVudE93bmVyLmN1cnJlbnQgJiYgc2VsZiAmJiBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKCFkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdKSB7XG4gICAgICAgIGVycm9yKCdDb21wb25lbnQgXCIlc1wiIGNvbnRhaW5zIHRoZSBzdHJpbmcgcmVmIFwiJXNcIi4gJyArICdTdXBwb3J0IGZvciBzdHJpbmcgcmVmcyB3aWxsIGJlIHJlbW92ZWQgaW4gYSBmdXR1cmUgbWFqb3IgcmVsZWFzZS4gJyArICdUaGlzIGNhc2UgY2Fubm90IGJlIGF1dG9tYXRpY2FsbHkgY29udmVydGVkIHRvIGFuIGFycm93IGZ1bmN0aW9uLiAnICsgJ1dlIGFzayB5b3UgdG8gbWFudWFsbHkgZml4IHRoaXMgY2FzZSBieSB1c2luZyB1c2VSZWYoKSBvciBjcmVhdGVSZWYoKSBpbnN0ZWFkLiAnICsgJ0xlYXJuIG1vcmUgYWJvdXQgdXNpbmcgcmVmcyBzYWZlbHkgaGVyZTogJyArICdodHRwczovL3JlYWN0anMub3JnL2xpbmsvc3RyaWN0LW1vZGUtc3RyaW5nLXJlZicsIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LnR5cGUpLCBjb25maWcucmVmKTtcblxuICAgICAgICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzW2NvbXBvbmVudE5hbWVdID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nS2V5ID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcEtleVdhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBga2V5YCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdLZXkuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ2tleScsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nS2V5LFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKSB7XG4gIHtcbiAgICB2YXIgd2FybkFib3V0QWNjZXNzaW5nUmVmID0gZnVuY3Rpb24gKCkge1xuICAgICAgaWYgKCFzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93bikge1xuICAgICAgICBzcGVjaWFsUHJvcFJlZldhcm5pbmdTaG93biA9IHRydWU7XG5cbiAgICAgICAgZXJyb3IoJyVzOiBgcmVmYCBpcyBub3QgYSBwcm9wLiBUcnlpbmcgdG8gYWNjZXNzIGl0IHdpbGwgcmVzdWx0ICcgKyAnaW4gYHVuZGVmaW5lZGAgYmVpbmcgcmV0dXJuZWQuIElmIHlvdSBuZWVkIHRvIGFjY2VzcyB0aGUgc2FtZSAnICsgJ3ZhbHVlIHdpdGhpbiB0aGUgY2hpbGQgY29tcG9uZW50LCB5b3Ugc2hvdWxkIHBhc3MgaXQgYXMgYSBkaWZmZXJlbnQgJyArICdwcm9wLiAoaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3NwZWNpYWwtcHJvcHMpJywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH07XG5cbiAgICB3YXJuQWJvdXRBY2Nlc3NpbmdSZWYuaXNSZWFjdFdhcm5pbmcgPSB0cnVlO1xuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShwcm9wcywgJ3JlZicsIHtcbiAgICAgIGdldDogd2FybkFib3V0QWNjZXNzaW5nUmVmLFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXG4gICAgfSk7XG4gIH1cbn1cbi8qKlxuICogRmFjdG9yeSBtZXRob2QgdG8gY3JlYXRlIGEgbmV3IFJlYWN0IGVsZW1lbnQuIFRoaXMgbm8gbG9uZ2VyIGFkaGVyZXMgdG9cbiAqIHRoZSBjbGFzcyBwYXR0ZXJuLCBzbyBkbyBub3QgdXNlIG5ldyB0byBjYWxsIGl0LiBBbHNvLCBpbnN0YW5jZW9mIGNoZWNrXG4gKiB3aWxsIG5vdCB3b3JrLiBJbnN0ZWFkIHRlc3QgJCR0eXBlb2YgZmllbGQgYWdhaW5zdCBTeW1ib2wuZm9yKCdyZWFjdC5lbGVtZW50JykgdG8gY2hlY2tcbiAqIGlmIHNvbWV0aGluZyBpcyBhIFJlYWN0IEVsZW1lbnQuXG4gKlxuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0geyp9IHByb3BzXG4gKiBAcGFyYW0geyp9IGtleVxuICogQHBhcmFtIHtzdHJpbmd8b2JqZWN0fSByZWZcbiAqIEBwYXJhbSB7Kn0gb3duZXJcbiAqIEBwYXJhbSB7Kn0gc2VsZiBBICp0ZW1wb3JhcnkqIGhlbHBlciB0byBkZXRlY3QgcGxhY2VzIHdoZXJlIGB0aGlzYCBpc1xuICogZGlmZmVyZW50IGZyb20gdGhlIGBvd25lcmAgd2hlbiBSZWFjdC5jcmVhdGVFbGVtZW50IGlzIGNhbGxlZCwgc28gdGhhdCB3ZVxuICogY2FuIHdhcm4uIFdlIHdhbnQgdG8gZ2V0IHJpZCBvZiBvd25lciBhbmQgcmVwbGFjZSBzdHJpbmcgYHJlZmBzIHdpdGggYXJyb3dcbiAqIGZ1bmN0aW9ucywgYW5kIGFzIGxvbmcgYXMgYHRoaXNgIGFuZCBvd25lciBhcmUgdGhlIHNhbWUsIHRoZXJlIHdpbGwgYmUgbm9cbiAqIGNoYW5nZSBpbiBiZWhhdmlvci5cbiAqIEBwYXJhbSB7Kn0gc291cmNlIEFuIGFubm90YXRpb24gb2JqZWN0IChhZGRlZCBieSBhIHRyYW5zcGlsZXIgb3Igb3RoZXJ3aXNlKVxuICogaW5kaWNhdGluZyBmaWxlbmFtZSwgbGluZSBudW1iZXIsIGFuZC9vciBvdGhlciBpbmZvcm1hdGlvbi5cbiAqIEBpbnRlcm5hbFxuICovXG5cblxudmFyIFJlYWN0RWxlbWVudCA9IGZ1bmN0aW9uICh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn07XG4vKipcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9yZWFjdGpzL3JmY3MvcHVsbC8xMDdcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHtvYmplY3R9IHByb3BzXG4gKiBAcGFyYW0ge3N0cmluZ30ga2V5XG4gKi9cblxuZnVuY3Rpb24ganN4REVWKHR5cGUsIGNvbmZpZywgbWF5YmVLZXksIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHByb3BOYW1lOyAvLyBSZXNlcnZlZCBuYW1lcyBhcmUgZXh0cmFjdGVkXG5cbiAgICB2YXIgcHJvcHMgPSB7fTtcbiAgICB2YXIga2V5ID0gbnVsbDtcbiAgICB2YXIgcmVmID0gbnVsbDsgLy8gQ3VycmVudGx5LCBrZXkgY2FuIGJlIHNwcmVhZCBpbiBhcyBhIHByb3AuIFRoaXMgY2F1c2VzIGEgcG90ZW50aWFsXG4gICAgLy8gaXNzdWUgaWYga2V5IGlzIGFsc28gZXhwbGljaXRseSBkZWNsYXJlZCAoaWUuIDxkaXYgey4uLnByb3BzfSBrZXk9XCJIaVwiIC8+XG4gICAgLy8gb3IgPGRpdiBrZXk9XCJIaVwiIHsuLi5wcm9wc30gLz4gKS4gV2Ugd2FudCB0byBkZXByZWNhdGUga2V5IHNwcmVhZCxcbiAgICAvLyBidXQgYXMgYW4gaW50ZXJtZWRpYXJ5IHN0ZXAsIHdlIHdpbGwgdXNlIGpzeERFViBmb3IgZXZlcnl0aGluZyBleGNlcHRcbiAgICAvLyA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPiwgYmVjYXVzZSB3ZSBhcmVuJ3QgY3VycmVudGx5IGFibGUgdG8gdGVsbCBpZlxuICAgIC8vIGtleSBpcyBleHBsaWNpdGx5IGRlY2xhcmVkIHRvIGJlIHVuZGVmaW5lZCBvciBub3QuXG5cbiAgICBpZiAobWF5YmVLZXkgIT09IHVuZGVmaW5lZCkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKG1heWJlS2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBtYXliZUtleTtcbiAgICB9XG5cbiAgICBpZiAoaGFzVmFsaWRLZXkoY29uZmlnKSkge1xuICAgICAge1xuICAgICAgICBjaGVja0tleVN0cmluZ0NvZXJjaW9uKGNvbmZpZy5rZXkpO1xuICAgICAgfVxuXG4gICAgICBrZXkgPSAnJyArIGNvbmZpZy5rZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkUmVmKGNvbmZpZykpIHtcbiAgICAgIHJlZiA9IGNvbmZpZy5yZWY7XG4gICAgICB3YXJuSWZTdHJpbmdSZWZDYW5ub3RCZUF1dG9Db252ZXJ0ZWQoY29uZmlnLCBzZWxmKTtcbiAgICB9IC8vIFJlbWFpbmluZyBwcm9wZXJ0aWVzIGFyZSBhZGRlZCB0byBhIG5ldyBwcm9wcyBvYmplY3RcblxuXG4gICAgZm9yIChwcm9wTmFtZSBpbiBjb25maWcpIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKGNvbmZpZywgcHJvcE5hbWUpICYmICFSRVNFUlZFRF9QUk9QUy5oYXNPd25Qcm9wZXJ0eShwcm9wTmFtZSkpIHtcbiAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gY29uZmlnW3Byb3BOYW1lXTtcbiAgICAgIH1cbiAgICB9IC8vIFJlc29sdmUgZGVmYXVsdCBwcm9wc1xuXG5cbiAgICBpZiAodHlwZSAmJiB0eXBlLmRlZmF1bHRQcm9wcykge1xuICAgICAgdmFyIGRlZmF1bHRQcm9wcyA9IHR5cGUuZGVmYXVsdFByb3BzO1xuXG4gICAgICBmb3IgKHByb3BOYW1lIGluIGRlZmF1bHRQcm9wcykge1xuICAgICAgICBpZiAocHJvcHNbcHJvcE5hbWVdID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBwcm9wc1twcm9wTmFtZV0gPSBkZWZhdWx0UHJvcHNbcHJvcE5hbWVdO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGtleSB8fCByZWYpIHtcbiAgICAgIHZhciBkaXNwbGF5TmFtZSA9IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nID8gdHlwZS5kaXNwbGF5TmFtZSB8fCB0eXBlLm5hbWUgfHwgJ1Vua25vd24nIDogdHlwZTtcblxuICAgICAgaWYgKGtleSkge1xuICAgICAgICBkZWZpbmVLZXlQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuXG4gICAgICBpZiAocmVmKSB7XG4gICAgICAgIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgcmV0dXJuIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBSZWFjdEN1cnJlbnRPd25lci5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdERlYnVnQ3VycmVudEZyYW1lO1xuXG5mdW5jdGlvbiBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpIHtcbiAge1xuICAgIGlmIChlbGVtZW50KSB7XG4gICAgICB2YXIgb3duZXIgPSBlbGVtZW50Ll9vd25lcjtcbiAgICAgIHZhciBzdGFjayA9IGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVihlbGVtZW50LnR5cGUsIGVsZW1lbnQuX3NvdXJjZSwgb3duZXIgPyBvd25lci50eXBlIDogbnVsbCk7XG4gICAgICBSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duO1xuXG57XG4gIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gZmFsc2U7XG59XG4vKipcbiAqIFZlcmlmaWVzIHRoZSBvYmplY3QgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9kb2NzL3JlYWN0LWFwaS5odG1sI2lzdmFsaWRlbGVtZW50XG4gKiBAcGFyYW0gez9vYmplY3R9IG9iamVjdFxuICogQHJldHVybiB7Ym9vbGVhbn0gVHJ1ZSBpZiBgb2JqZWN0YCBpcyBhIFJlYWN0RWxlbWVudC5cbiAqIEBmaW5hbFxuICovXG5cblxuZnVuY3Rpb24gaXNWYWxpZEVsZW1lbnQob2JqZWN0KSB7XG4gIHtcbiAgICByZXR1cm4gdHlwZW9mIG9iamVjdCA9PT0gJ29iamVjdCcgJiYgb2JqZWN0ICE9PSBudWxsICYmIG9iamVjdC4kJHR5cGVvZiA9PT0gUkVBQ1RfRUxFTUVOVF9UWVBFO1xuICB9XG59XG5cbmZ1bmN0aW9uIGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpIHtcbiAge1xuICAgIGlmIChSZWFjdEN1cnJlbnRPd25lciQxLmN1cnJlbnQpIHtcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSB0eXBlb2YgcGFyZW50VHlwZSA9PT0gJ3N0cmluZycgPyBwYXJlbnRUeXBlIDogcGFyZW50VHlwZS5kaXNwbGF5TmFtZSB8fCBwYXJlbnRUeXBlLm5hbWU7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50KSB7XG4gICAgICAvLyBHaXZlIHRoZSBjb21wb25lbnQgdGhhdCBvcmlnaW5hbGx5IGNyZWF0ZWQgdGhpcyBjaGlsZC5cbiAgICAgIGNoaWxkT3duZXIgPSBcIiBJdCB3YXMgcGFzc2VkIGEgY2hpbGQgZnJvbSBcIiArIGdldENvbXBvbmVudE5hbWVGcm9tVHlwZShlbGVtZW50Ll9vd25lci50eXBlKSArIFwiLlwiO1xuICAgIH1cblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICBlcnJvcignRWFjaCBjaGlsZCBpbiBhIGxpc3Qgc2hvdWxkIGhhdmUgYSB1bmlxdWUgXCJrZXlcIiBwcm9wLicgKyAnJXMlcyBTZWUgaHR0cHM6Ly9yZWFjdGpzLm9yZy9saW5rL3dhcm5pbmcta2V5cyBmb3IgbW9yZSBpbmZvcm1hdGlvbi4nLCBjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvLCBjaGlsZE93bmVyKTtcblxuICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0Jykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChpc0FycmF5KG5vZGUpKSB7XG4gICAgICBmb3IgKHZhciBpID0gMDsgaSA8IG5vZGUubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgdmFyIGNoaWxkID0gbm9kZVtpXTtcblxuICAgICAgICBpZiAoaXNWYWxpZEVsZW1lbnQoY2hpbGQpKSB7XG4gICAgICAgICAgdmFsaWRhdGVFeHBsaWNpdEtleShjaGlsZCwgcGFyZW50VHlwZSk7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGlzVmFsaWRFbGVtZW50KG5vZGUpKSB7XG4gICAgICAvLyBUaGlzIGVsZW1lbnQgd2FzIHBhc3NlZCBpbiBhIHZhbGlkIGxvY2F0aW9uLlxuICAgICAgaWYgKG5vZGUuX3N0b3JlKSB7XG4gICAgICAgIG5vZGUuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgICB9XG4gICAgfSBlbHNlIGlmIChub2RlKSB7XG4gICAgICB2YXIgaXRlcmF0b3JGbiA9IGdldEl0ZXJhdG9yRm4obm9kZSk7XG5cbiAgICAgIGlmICh0eXBlb2YgaXRlcmF0b3JGbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgICAvLyBFbnRyeSBpdGVyYXRvcnMgdXNlZCB0byBwcm92aWRlIGltcGxpY2l0IGtleXMsXG4gICAgICAgIC8vIGJ1dCBub3cgd2UgcHJpbnQgYSBzZXBhcmF0ZSB3YXJuaW5nIGZvciB0aGVtIGxhdGVyLlxuICAgICAgICBpZiAoaXRlcmF0b3JGbiAhPT0gbm9kZS5lbnRyaWVzKSB7XG4gICAgICAgICAgdmFyIGl0ZXJhdG9yID0gaXRlcmF0b3JGbi5jYWxsKG5vZGUpO1xuICAgICAgICAgIHZhciBzdGVwO1xuXG4gICAgICAgICAgd2hpbGUgKCEoc3RlcCA9IGl0ZXJhdG9yLm5leHQoKSkuZG9uZSkge1xuICAgICAgICAgICAgaWYgKGlzVmFsaWRFbGVtZW50KHN0ZXAudmFsdWUpKSB7XG4gICAgICAgICAgICAgIHZhbGlkYXRlRXhwbGljaXRLZXkoc3RlcC52YWx1ZSwgcGFyZW50VHlwZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG59XG4vKipcbiAqIEdpdmVuIGFuIGVsZW1lbnQsIHZhbGlkYXRlIHRoYXQgaXRzIHByb3BzIGZvbGxvdyB0aGUgcHJvcFR5cGVzIGRlZmluaXRpb24sXG4gKiBwcm92aWRlZCBieSB0aGUgdHlwZS5cbiAqXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZWxlbWVudFxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCkge1xuICB7XG4gICAgdmFyIHR5cGUgPSBlbGVtZW50LnR5cGU7XG5cbiAgICBpZiAodHlwZSA9PT0gbnVsbCB8fCB0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShmcmFnbWVudCk7XG5cbiAgICAgICAgZXJyb3IoJ0ludmFsaWQgcHJvcCBgJXNgIHN1cHBsaWVkIHRvIGBSZWFjdC5GcmFnbWVudGAuICcgKyAnUmVhY3QuRnJhZ21lbnQgY2FuIG9ubHkgaGF2ZSBga2V5YCBhbmQgYGNoaWxkcmVuYCBwcm9wcy4nLCBrZXkpO1xuXG4gICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChmcmFnbWVudC5yZWYgIT09IG51bGwpIHtcbiAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICB9XG4gIH1cbn1cblxudmFyIGRpZFdhcm5BYm91dEtleVNwcmVhZCA9IHt9O1xuZnVuY3Rpb24ganN4V2l0aFZhbGlkYXRpb24odHlwZSwgcHJvcHMsIGtleSwgaXNTdGF0aWNDaGlsZHJlbiwgc291cmNlLCBzZWxmKSB7XG4gIHtcbiAgICB2YXIgdmFsaWRUeXBlID0gaXNWYWxpZEVsZW1lbnRUeXBlKHR5cGUpOyAvLyBXZSB3YXJuIGluIHRoaXMgY2FzZSBidXQgZG9uJ3QgdGhyb3cuIFdlIGV4cGVjdCB0aGUgZWxlbWVudCBjcmVhdGlvbiB0b1xuICAgIC8vIHN1Y2NlZWQgYW5kIHRoZXJlIHdpbGwgbGlrZWx5IGJlIGVycm9ycyBpbiByZW5kZXIuXG5cbiAgICBpZiAoIXZhbGlkVHlwZSkge1xuICAgICAgdmFyIGluZm8gPSAnJztcblxuICAgICAgaWYgKHR5cGUgPT09IHVuZGVmaW5lZCB8fCB0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgdHlwZSAhPT0gbnVsbCAmJiBPYmplY3Qua2V5cyh0eXBlKS5sZW5ndGggPT09IDApIHtcbiAgICAgICAgaW5mbyArPSAnIFlvdSBsaWtlbHkgZm9yZ290IHRvIGV4cG9ydCB5b3VyIGNvbXBvbmVudCBmcm9tIHRoZSBmaWxlICcgKyBcIml0J3MgZGVmaW5lZCBpbiwgb3IgeW91IG1pZ2h0IGhhdmUgbWl4ZWQgdXAgZGVmYXVsdCBhbmQgbmFtZWQgaW1wb3J0cy5cIjtcbiAgICAgIH1cblxuICAgICAgdmFyIHNvdXJjZUluZm8gPSBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpO1xuXG4gICAgICBpZiAoc291cmNlSW5mbykge1xuICAgICAgICBpbmZvICs9IHNvdXJjZUluZm87XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBpbmZvICs9IGdldERlY2xhcmF0aW9uRXJyb3JBZGRlbmR1bSgpO1xuICAgICAgfVxuXG4gICAgICB2YXIgdHlwZVN0cmluZztcblxuICAgICAgaWYgKHR5cGUgPT09IG51bGwpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdudWxsJztcbiAgICAgIH0gZWxzZSBpZiAoaXNBcnJheSh0eXBlKSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gJ2FycmF5JztcbiAgICAgIH0gZWxzZSBpZiAodHlwZSAhPT0gdW5kZWZpbmVkICYmIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRSkge1xuICAgICAgICB0eXBlU3RyaW5nID0gXCI8XCIgKyAoZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ1Vua25vd24nKSArIFwiIC8+XCI7XG4gICAgICAgIGluZm8gPSAnIERpZCB5b3UgYWNjaWRlbnRhbGx5IGV4cG9ydCBhIEpTWCBsaXRlcmFsIGluc3RlYWQgb2YgYSBjb21wb25lbnQ/JztcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSB0eXBlb2YgdHlwZTtcbiAgICAgIH1cblxuICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogdHlwZSBpcyBpbnZhbGlkIC0tIGV4cGVjdGVkIGEgc3RyaW5nIChmb3IgJyArICdidWlsdC1pbiBjb21wb25lbnRzKSBvciBhIGNsYXNzL2Z1bmN0aW9uIChmb3IgY29tcG9zaXRlICcgKyAnY29tcG9uZW50cykgYnV0IGdvdDogJXMuJXMnLCB0eXBlU3RyaW5nLCBpbmZvKTtcbiAgICB9XG5cbiAgICB2YXIgZWxlbWVudCA9IGpzeERFVih0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHtcbiAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUodHlwZSk7XG4gICAgICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXMocHJvcHMpLmZpbHRlcihmdW5jdGlvbiAoaykge1xuICAgICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgICAgfSk7XG4gICAgICAgIHZhciBiZWZvcmVFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3trZXk6IHNvbWVLZXksICcgKyBrZXlzLmpvaW4oJzogLi4uLCAnKSArICc6IC4uLn0nIDogJ3trZXk6IHNvbWVLZXl9JztcblxuICAgICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgICB2YXIgYWZ0ZXJFeGFtcGxlID0ga2V5cy5sZW5ndGggPiAwID8gJ3snICsga2V5cy5qb2luKCc6IC4uLiwgJykgKyAnOiAuLi59JyA6ICd7fSc7XG5cbiAgICAgICAgICBlcnJvcignQSBwcm9wcyBvYmplY3QgY29udGFpbmluZyBhIFwia2V5XCIgcHJvcCBpcyBiZWluZyBzcHJlYWQgaW50byBKU1g6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMgey4uLnByb3BzfSAvPlxcbicgKyAnUmVhY3Qga2V5cyBtdXN0IGJlIHBhc3NlZCBkaXJlY3RseSB0byBKU1ggd2l0aG91dCB1c2luZyBzcHJlYWQ6XFxuJyArICcgIGxldCBwcm9wcyA9ICVzO1xcbicgKyAnICA8JXMga2V5PXtzb21lS2V5fSB7Li4ucHJvcHN9IC8+JywgYmVmb3JlRXhhbXBsZSwgY29tcG9uZW50TmFtZSwgYWZ0ZXJFeGFtcGxlLCBjb21wb25lbnROYW1lKTtcblxuICAgICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKHR5cGUgPT09IFJFQUNUX0ZSQUdNRU5UX1RZUEUpIHtcbiAgICAgIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhlbGVtZW50KTtcbiAgICB9IGVsc2Uge1xuICAgICAgdmFsaWRhdGVQcm9wVHlwZXMoZWxlbWVudCk7XG4gICAgfVxuXG4gICAgcmV0dXJuIGVsZW1lbnQ7XG4gIH1cbn0gLy8gVGhlc2UgdHdvIGZ1bmN0aW9ucyBleGlzdCB0byBzdGlsbCBnZXQgY2hpbGQgd2FybmluZ3MgaW4gZGV2XG5cbnZhciBqc3hERVYkMSA9ICBqc3hXaXRoVmFsaWRhdGlvbiA7XG5cbmV4cG9ydHMuRnJhZ21lbnQgPSBSRUFDVF9GUkFHTUVOVF9UWVBFO1xuZXhwb3J0cy5qc3hERVYgPSBqc3hERVYkMTtcbiAgfSkoKTtcbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\n\nif (false) {} else {\n  module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-client)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9jb21waWxlZC9yZWFjdC9qc3gtZGV2LXJ1bnRpbWUuanMuanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsSUFBSSxLQUFxQyxFQUFFLEVBRTFDLENBQUM7QUFDRixFQUFFLHVMQUFzRTtBQUN4RSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9mNDE0Il0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/@ably-labs/react-hooks/dist/mjs/AblyReactHooks.js":
/*!************************************************************************!*\
  !*** ./node_modules/@ably-labs/react-hooks/dist/mjs/AblyReactHooks.js ***!
  \************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Realtime\": function() { return /* binding */ Realtime; },\n/* harmony export */   \"assertConfiguration\": function() { return /* binding */ assertConfiguration; },\n/* harmony export */   \"configureAbly\": function() { return /* binding */ configureAbly; },\n/* harmony export */   \"provideSdkInstance\": function() { return /* binding */ provideSdkInstance; }\n/* harmony export */ });\n/* harmony import */ var ably__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ably */ \"(app-client)/./node_modules/ably/build/ably-commonjs.js\");\n\nconst version = \"2.1.2\";\nlet sdkInstance = null;\nclass Realtime extends ably__WEBPACK_IMPORTED_MODULE_0__.Realtime.Promise {\n    constructor(options) {\n        if (typeof options === \"string\") {\n            options = {\n                key: options,\n            };\n        }\n        options.agents = { 'react-hooks': version };\n        super(options);\n    }\n}\nfunction provideSdkInstance(ablyInstance) {\n    sdkInstance = ablyInstance;\n}\nfunction configureAbly(ablyConfigurationObject) {\n    return sdkInstance || (sdkInstance = new Realtime(ablyConfigurationObject));\n}\nfunction assertConfiguration() {\n    if (!sdkInstance) {\n        throw new Error('Ably not configured - please call configureAbly({ key: \"your-api-key\", clientId: \"someid\" });');\n    }\n    return sdkInstance;\n}\n//# sourceMappingURL=AblyReactHooks.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL0BhYmx5LWxhYnMvcmVhY3QtaG9va3MvZGlzdC9tanMvQWJseVJlYWN0SG9va3MuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBd0I7QUFDeEI7QUFDQTtBQUNPLHVCQUF1QixrREFBcUI7QUFDbkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQTtBQUNPO0FBQ1A7QUFDQSwyRUFBMkUseUNBQXlDLEVBQUU7QUFDdEg7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BhYmx5LWxhYnMvcmVhY3QtaG9va3MvZGlzdC9tanMvQWJseVJlYWN0SG9va3MuanM/YmVlYiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgQWJseSBmcm9tIFwiYWJseVwiO1xuY29uc3QgdmVyc2lvbiA9IFwiMi4xLjJcIjtcbmxldCBzZGtJbnN0YW5jZSA9IG51bGw7XG5leHBvcnQgY2xhc3MgUmVhbHRpbWUgZXh0ZW5kcyBBYmx5LlJlYWx0aW1lLlByb21pc2Uge1xuICAgIGNvbnN0cnVjdG9yKG9wdGlvbnMpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBvcHRpb25zID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICBvcHRpb25zID0ge1xuICAgICAgICAgICAgICAgIGtleTogb3B0aW9ucyxcbiAgICAgICAgICAgIH07XG4gICAgICAgIH1cbiAgICAgICAgb3B0aW9ucy5hZ2VudHMgPSB7ICdyZWFjdC1ob29rcyc6IHZlcnNpb24gfTtcbiAgICAgICAgc3VwZXIob3B0aW9ucyk7XG4gICAgfVxufVxuZXhwb3J0IGZ1bmN0aW9uIHByb3ZpZGVTZGtJbnN0YW5jZShhYmx5SW5zdGFuY2UpIHtcbiAgICBzZGtJbnN0YW5jZSA9IGFibHlJbnN0YW5jZTtcbn1cbmV4cG9ydCBmdW5jdGlvbiBjb25maWd1cmVBYmx5KGFibHlDb25maWd1cmF0aW9uT2JqZWN0KSB7XG4gICAgcmV0dXJuIHNka0luc3RhbmNlIHx8IChzZGtJbnN0YW5jZSA9IG5ldyBSZWFsdGltZShhYmx5Q29uZmlndXJhdGlvbk9iamVjdCkpO1xufVxuZXhwb3J0IGZ1bmN0aW9uIGFzc2VydENvbmZpZ3VyYXRpb24oKSB7XG4gICAgaWYgKCFzZGtJbnN0YW5jZSkge1xuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0FibHkgbm90IGNvbmZpZ3VyZWQgLSBwbGVhc2UgY2FsbCBjb25maWd1cmVBYmx5KHsga2V5OiBcInlvdXItYXBpLWtleVwiLCBjbGllbnRJZDogXCJzb21laWRcIiB9KTsnKTtcbiAgICB9XG4gICAgcmV0dXJuIHNka0luc3RhbmNlO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9QWJseVJlYWN0SG9va3MuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/@ably-labs/react-hooks/dist/mjs/AblyReactHooks.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/@ably-labs/react-hooks/dist/mjs/hooks/useChannel.js":
/*!**************************************************************************!*\
  !*** ./node_modules/@ably-labs/react-hooks/dist/mjs/hooks/useChannel.js ***!
  \**************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"useChannel\": function() { return /* binding */ useChannel; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AblyReactHooks.js */ \"(app-client)/./node_modules/@ably-labs/react-hooks/dist/mjs/AblyReactHooks.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nfunction useChannel(channelNameOrNameAndOptions, ...channelSubscriptionArguments) {\n    const ably = typeof channelNameOrNameAndOptions === 'string'\n        ? (0,_AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_1__.assertConfiguration)()\n        : (channelNameOrNameAndOptions.realtime || (0,_AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_1__.assertConfiguration)());\n    const channelName = typeof channelNameOrNameAndOptions === 'string'\n        ? channelNameOrNameAndOptions\n        : channelNameOrNameAndOptions.channelName;\n    const channel = typeof channelNameOrNameAndOptions === 'string'\n        ? ably.channels.get(channelName)\n        : ably.channels.get(channelName, channelNameOrNameAndOptions.options);\n    const onMount = () => __awaiter(this, void 0, void 0, function* () {\n        yield channel.subscribe.apply(channel, channelSubscriptionArguments);\n    });\n    const onUnmount = () => __awaiter(this, void 0, void 0, function* () {\n        yield channel.unsubscribe.apply(channel, channelSubscriptionArguments);\n        setTimeout(() => __awaiter(this, void 0, void 0, function* () {\n            // React is very mount/unmount happy, so if we just detatch the channel\n            // it's quite likely it will be reattached again by a subsequent onMount calls.\n            // To solve this, we set a timer, and if all the listeners have been removed, we know that the component\n            // has been removed for good and we can detatch the channel.\n            if (channel.listeners.length === 0) {\n                yield channel.detach();\n            }\n        }), 2500);\n    });\n    const useEffectHook = () => {\n        onMount();\n        return () => { onUnmount(); };\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(useEffectHook, [channelName]);\n    return [channel, ably];\n}\n//# sourceMappingURL=useChannel.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL0BhYmx5LWxhYnMvcmVhY3QtaG9va3MvZGlzdC9tanMvaG9va3MvdXNlQ2hhbm5lbC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBQSxpQkFBaUIsU0FBSSxJQUFJLFNBQUk7QUFDN0IsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDa0M7QUFDeUI7QUFDcEQ7QUFDUDtBQUNBLFVBQVUsdUVBQW1CO0FBQzdCLG1EQUFtRCx1RUFBbUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLElBQUksZ0RBQVM7QUFDYjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL0BhYmx5LWxhYnMvcmVhY3QtaG9va3MvZGlzdC9tanMvaG9va3MvdXNlQ2hhbm5lbC5qcz83MWQzIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgdXNlRWZmZWN0IH0gZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgYXNzZXJ0Q29uZmlndXJhdGlvbiB9IGZyb20gXCIuLi9BYmx5UmVhY3RIb29rcy5qc1wiO1xuZXhwb3J0IGZ1bmN0aW9uIHVzZUNoYW5uZWwoY2hhbm5lbE5hbWVPck5hbWVBbmRPcHRpb25zLCAuLi5jaGFubmVsU3Vic2NyaXB0aW9uQXJndW1lbnRzKSB7XG4gICAgY29uc3QgYWJseSA9IHR5cGVvZiBjaGFubmVsTmFtZU9yTmFtZUFuZE9wdGlvbnMgPT09ICdzdHJpbmcnXG4gICAgICAgID8gYXNzZXJ0Q29uZmlndXJhdGlvbigpXG4gICAgICAgIDogKGNoYW5uZWxOYW1lT3JOYW1lQW5kT3B0aW9ucy5yZWFsdGltZSB8fCBhc3NlcnRDb25maWd1cmF0aW9uKCkpO1xuICAgIGNvbnN0IGNoYW5uZWxOYW1lID0gdHlwZW9mIGNoYW5uZWxOYW1lT3JOYW1lQW5kT3B0aW9ucyA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBjaGFubmVsTmFtZU9yTmFtZUFuZE9wdGlvbnNcbiAgICAgICAgOiBjaGFubmVsTmFtZU9yTmFtZUFuZE9wdGlvbnMuY2hhbm5lbE5hbWU7XG4gICAgY29uc3QgY2hhbm5lbCA9IHR5cGVvZiBjaGFubmVsTmFtZU9yTmFtZUFuZE9wdGlvbnMgPT09ICdzdHJpbmcnXG4gICAgICAgID8gYWJseS5jaGFubmVscy5nZXQoY2hhbm5lbE5hbWUpXG4gICAgICAgIDogYWJseS5jaGFubmVscy5nZXQoY2hhbm5lbE5hbWUsIGNoYW5uZWxOYW1lT3JOYW1lQW5kT3B0aW9ucy5vcHRpb25zKTtcbiAgICBjb25zdCBvbk1vdW50ID0gKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICB5aWVsZCBjaGFubmVsLnN1YnNjcmliZS5hcHBseShjaGFubmVsLCBjaGFubmVsU3Vic2NyaXB0aW9uQXJndW1lbnRzKTtcbiAgICB9KTtcbiAgICBjb25zdCBvblVubW91bnQgPSAoKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIHlpZWxkIGNoYW5uZWwudW5zdWJzY3JpYmUuYXBwbHkoY2hhbm5lbCwgY2hhbm5lbFN1YnNjcmlwdGlvbkFyZ3VtZW50cyk7XG4gICAgICAgIHNldFRpbWVvdXQoKCkgPT4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiogKCkge1xuICAgICAgICAgICAgLy8gUmVhY3QgaXMgdmVyeSBtb3VudC91bm1vdW50IGhhcHB5LCBzbyBpZiB3ZSBqdXN0IGRldGF0Y2ggdGhlIGNoYW5uZWxcbiAgICAgICAgICAgIC8vIGl0J3MgcXVpdGUgbGlrZWx5IGl0IHdpbGwgYmUgcmVhdHRhY2hlZCBhZ2FpbiBieSBhIHN1YnNlcXVlbnQgb25Nb3VudCBjYWxscy5cbiAgICAgICAgICAgIC8vIFRvIHNvbHZlIHRoaXMsIHdlIHNldCBhIHRpbWVyLCBhbmQgaWYgYWxsIHRoZSBsaXN0ZW5lcnMgaGF2ZSBiZWVuIHJlbW92ZWQsIHdlIGtub3cgdGhhdCB0aGUgY29tcG9uZW50XG4gICAgICAgICAgICAvLyBoYXMgYmVlbiByZW1vdmVkIGZvciBnb29kIGFuZCB3ZSBjYW4gZGV0YXRjaCB0aGUgY2hhbm5lbC5cbiAgICAgICAgICAgIGlmIChjaGFubmVsLmxpc3RlbmVycy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICB5aWVsZCBjaGFubmVsLmRldGFjaCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSwgMjUwMCk7XG4gICAgfSk7XG4gICAgY29uc3QgdXNlRWZmZWN0SG9vayA9ICgpID0+IHtcbiAgICAgICAgb25Nb3VudCgpO1xuICAgICAgICByZXR1cm4gKCkgPT4geyBvblVubW91bnQoKTsgfTtcbiAgICB9O1xuICAgIHVzZUVmZmVjdCh1c2VFZmZlY3RIb29rLCBbY2hhbm5lbE5hbWVdKTtcbiAgICByZXR1cm4gW2NoYW5uZWwsIGFibHldO1xufVxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9dXNlQ2hhbm5lbC5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/@ably-labs/react-hooks/dist/mjs/hooks/useChannel.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/@ably-labs/react-hooks/dist/mjs/hooks/usePresence.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@ably-labs/react-hooks/dist/mjs/hooks/usePresence.js ***!
  \***************************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"usePresence\": function() { return /* binding */ usePresence; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-client)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var _AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../AblyReactHooks.js */ \"(app-client)/./node_modules/@ably-labs/react-hooks/dist/mjs/AblyReactHooks.js\");\nvar __awaiter = (undefined && undefined.__awaiter) || function (thisArg, _arguments, P, generator) {\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\n    return new (P || (P = Promise))(function (resolve, reject) {\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\n    });\n};\n\n\nfunction usePresence(channelNameOrNameAndOptions, messageOrPresenceObject, onPresenceUpdated) {\n    const ably = typeof channelNameOrNameAndOptions === 'string'\n        ? (0,_AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_1__.assertConfiguration)()\n        : (channelNameOrNameAndOptions.realtime || (0,_AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_1__.assertConfiguration)());\n    const channelName = typeof channelNameOrNameAndOptions === 'string'\n        ? channelNameOrNameAndOptions\n        : channelNameOrNameAndOptions.channelName;\n    const channel = typeof channelNameOrNameAndOptions === 'string'\n        ? ably.channels.get(channelName)\n        : ably.channels.get(channelName, channelNameOrNameAndOptions.options);\n    const subscribeOnly = typeof channelNameOrNameAndOptions === 'string' ? false : channelNameOrNameAndOptions.subscribeOnly;\n    const [presenceData, updatePresenceData] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useState)([]);\n    const updatePresence = (message) => __awaiter(this, void 0, void 0, function* () {\n        const snapshot = yield channel.presence.get();\n        updatePresenceData(snapshot);\n        onPresenceUpdated === null || onPresenceUpdated === void 0 ? void 0 : onPresenceUpdated.call(this, message);\n    });\n    const onMount = () => __awaiter(this, void 0, void 0, function* () {\n        channel.presence.subscribe('enter', updatePresence);\n        channel.presence.subscribe('leave', updatePresence);\n        channel.presence.subscribe('update', updatePresence);\n        if (!subscribeOnly) {\n            yield channel.presence.enter(messageOrPresenceObject);\n        }\n        const snapshot = yield channel.presence.get();\n        updatePresenceData(snapshot);\n    });\n    const onUnmount = () => {\n        if (channel.state == 'attached') {\n            if (!subscribeOnly) {\n                channel.presence.leave();\n            }\n        }\n        channel.presence.unsubscribe('enter');\n        channel.presence.unsubscribe('leave');\n        channel.presence.unsubscribe('update');\n    };\n    const useEffectHook = () => {\n        onMount();\n        return () => { onUnmount(); };\n    };\n    (0,react__WEBPACK_IMPORTED_MODULE_0__.useEffect)(useEffectHook, []);\n    const updateStatus = (0,react__WEBPACK_IMPORTED_MODULE_0__.useCallback)((messageOrPresenceObject) => {\n        if (!subscribeOnly) {\n            channel.presence.update(messageOrPresenceObject);\n        }\n        else {\n            throw new Error(\"updateStatus can not be called while using the hook in subscribeOnly mode\");\n        }\n    }, [channel]);\n    return [presenceData, updateStatus];\n}\n//# sourceMappingURL=usePresence.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL0BhYmx5LWxhYnMvcmVhY3QtaG9va3MvZGlzdC9tanMvaG9va3MvdXNlUHJlc2VuY2UuanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQUEsaUJBQWlCLFNBQUksSUFBSSxTQUFJO0FBQzdCLDRCQUE0QiwrREFBK0QsaUJBQWlCO0FBQzVHO0FBQ0Esb0NBQW9DLE1BQU0sK0JBQStCLFlBQVk7QUFDckYsbUNBQW1DLE1BQU0sbUNBQW1DLFlBQVk7QUFDeEYsZ0NBQWdDO0FBQ2hDO0FBQ0EsS0FBSztBQUNMO0FBQ3lEO0FBQ0U7QUFDcEQ7QUFDUDtBQUNBLFVBQVUsdUVBQW1CO0FBQzdCLG1EQUFtRCx1RUFBbUI7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0MsK0NBQVE7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVCQUF1QjtBQUN2QjtBQUNBLElBQUksZ0RBQVM7QUFDYix5QkFBeUIsa0RBQVc7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFibHktbGFicy9yZWFjdC1ob29rcy9kaXN0L21qcy9ob29rcy91c2VQcmVzZW5jZS5qcz84MjBlIl0sInNvdXJjZXNDb250ZW50IjpbInZhciBfX2F3YWl0ZXIgPSAodGhpcyAmJiB0aGlzLl9fYXdhaXRlcikgfHwgZnVuY3Rpb24gKHRoaXNBcmcsIF9hcmd1bWVudHMsIFAsIGdlbmVyYXRvcikge1xuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICBmdW5jdGlvbiBmdWxmaWxsZWQodmFsdWUpIHsgdHJ5IHsgc3RlcChnZW5lcmF0b3IubmV4dCh2YWx1ZSkpOyB9IGNhdGNoIChlKSB7IHJlamVjdChlKTsgfSB9XG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxuICAgICAgICBzdGVwKChnZW5lcmF0b3IgPSBnZW5lcmF0b3IuYXBwbHkodGhpc0FyZywgX2FyZ3VtZW50cyB8fCBbXSkpLm5leHQoKSk7XG4gICAgfSk7XG59O1xuaW1wb3J0IHsgdXNlQ2FsbGJhY2ssIHVzZUVmZmVjdCwgdXNlU3RhdGUgfSBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyBhc3NlcnRDb25maWd1cmF0aW9uIH0gZnJvbSBcIi4uL0FibHlSZWFjdEhvb2tzLmpzXCI7XG5leHBvcnQgZnVuY3Rpb24gdXNlUHJlc2VuY2UoY2hhbm5lbE5hbWVPck5hbWVBbmRPcHRpb25zLCBtZXNzYWdlT3JQcmVzZW5jZU9iamVjdCwgb25QcmVzZW5jZVVwZGF0ZWQpIHtcbiAgICBjb25zdCBhYmx5ID0gdHlwZW9mIGNoYW5uZWxOYW1lT3JOYW1lQW5kT3B0aW9ucyA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBhc3NlcnRDb25maWd1cmF0aW9uKClcbiAgICAgICAgOiAoY2hhbm5lbE5hbWVPck5hbWVBbmRPcHRpb25zLnJlYWx0aW1lIHx8IGFzc2VydENvbmZpZ3VyYXRpb24oKSk7XG4gICAgY29uc3QgY2hhbm5lbE5hbWUgPSB0eXBlb2YgY2hhbm5lbE5hbWVPck5hbWVBbmRPcHRpb25zID09PSAnc3RyaW5nJ1xuICAgICAgICA/IGNoYW5uZWxOYW1lT3JOYW1lQW5kT3B0aW9uc1xuICAgICAgICA6IGNoYW5uZWxOYW1lT3JOYW1lQW5kT3B0aW9ucy5jaGFubmVsTmFtZTtcbiAgICBjb25zdCBjaGFubmVsID0gdHlwZW9mIGNoYW5uZWxOYW1lT3JOYW1lQW5kT3B0aW9ucyA9PT0gJ3N0cmluZydcbiAgICAgICAgPyBhYmx5LmNoYW5uZWxzLmdldChjaGFubmVsTmFtZSlcbiAgICAgICAgOiBhYmx5LmNoYW5uZWxzLmdldChjaGFubmVsTmFtZSwgY2hhbm5lbE5hbWVPck5hbWVBbmRPcHRpb25zLm9wdGlvbnMpO1xuICAgIGNvbnN0IHN1YnNjcmliZU9ubHkgPSB0eXBlb2YgY2hhbm5lbE5hbWVPck5hbWVBbmRPcHRpb25zID09PSAnc3RyaW5nJyA/IGZhbHNlIDogY2hhbm5lbE5hbWVPck5hbWVBbmRPcHRpb25zLnN1YnNjcmliZU9ubHk7XG4gICAgY29uc3QgW3ByZXNlbmNlRGF0YSwgdXBkYXRlUHJlc2VuY2VEYXRhXSA9IHVzZVN0YXRlKFtdKTtcbiAgICBjb25zdCB1cGRhdGVQcmVzZW5jZSA9IChtZXNzYWdlKSA9PiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uKiAoKSB7XG4gICAgICAgIGNvbnN0IHNuYXBzaG90ID0geWllbGQgY2hhbm5lbC5wcmVzZW5jZS5nZXQoKTtcbiAgICAgICAgdXBkYXRlUHJlc2VuY2VEYXRhKHNuYXBzaG90KTtcbiAgICAgICAgb25QcmVzZW5jZVVwZGF0ZWQgPT09IG51bGwgfHwgb25QcmVzZW5jZVVwZGF0ZWQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9uUHJlc2VuY2VVcGRhdGVkLmNhbGwodGhpcywgbWVzc2FnZSk7XG4gICAgfSk7XG4gICAgY29uc3Qgb25Nb3VudCA9ICgpID0+IF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24qICgpIHtcbiAgICAgICAgY2hhbm5lbC5wcmVzZW5jZS5zdWJzY3JpYmUoJ2VudGVyJywgdXBkYXRlUHJlc2VuY2UpO1xuICAgICAgICBjaGFubmVsLnByZXNlbmNlLnN1YnNjcmliZSgnbGVhdmUnLCB1cGRhdGVQcmVzZW5jZSk7XG4gICAgICAgIGNoYW5uZWwucHJlc2VuY2Uuc3Vic2NyaWJlKCd1cGRhdGUnLCB1cGRhdGVQcmVzZW5jZSk7XG4gICAgICAgIGlmICghc3Vic2NyaWJlT25seSkge1xuICAgICAgICAgICAgeWllbGQgY2hhbm5lbC5wcmVzZW5jZS5lbnRlcihtZXNzYWdlT3JQcmVzZW5jZU9iamVjdCk7XG4gICAgICAgIH1cbiAgICAgICAgY29uc3Qgc25hcHNob3QgPSB5aWVsZCBjaGFubmVsLnByZXNlbmNlLmdldCgpO1xuICAgICAgICB1cGRhdGVQcmVzZW5jZURhdGEoc25hcHNob3QpO1xuICAgIH0pO1xuICAgIGNvbnN0IG9uVW5tb3VudCA9ICgpID0+IHtcbiAgICAgICAgaWYgKGNoYW5uZWwuc3RhdGUgPT0gJ2F0dGFjaGVkJykge1xuICAgICAgICAgICAgaWYgKCFzdWJzY3JpYmVPbmx5KSB7XG4gICAgICAgICAgICAgICAgY2hhbm5lbC5wcmVzZW5jZS5sZWF2ZSgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNoYW5uZWwucHJlc2VuY2UudW5zdWJzY3JpYmUoJ2VudGVyJyk7XG4gICAgICAgIGNoYW5uZWwucHJlc2VuY2UudW5zdWJzY3JpYmUoJ2xlYXZlJyk7XG4gICAgICAgIGNoYW5uZWwucHJlc2VuY2UudW5zdWJzY3JpYmUoJ3VwZGF0ZScpO1xuICAgIH07XG4gICAgY29uc3QgdXNlRWZmZWN0SG9vayA9ICgpID0+IHtcbiAgICAgICAgb25Nb3VudCgpO1xuICAgICAgICByZXR1cm4gKCkgPT4geyBvblVubW91bnQoKTsgfTtcbiAgICB9O1xuICAgIHVzZUVmZmVjdCh1c2VFZmZlY3RIb29rLCBbXSk7XG4gICAgY29uc3QgdXBkYXRlU3RhdHVzID0gdXNlQ2FsbGJhY2soKG1lc3NhZ2VPclByZXNlbmNlT2JqZWN0KSA9PiB7XG4gICAgICAgIGlmICghc3Vic2NyaWJlT25seSkge1xuICAgICAgICAgICAgY2hhbm5lbC5wcmVzZW5jZS51cGRhdGUobWVzc2FnZU9yUHJlc2VuY2VPYmplY3QpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKFwidXBkYXRlU3RhdHVzIGNhbiBub3QgYmUgY2FsbGVkIHdoaWxlIHVzaW5nIHRoZSBob29rIGluIHN1YnNjcmliZU9ubHkgbW9kZVwiKTtcbiAgICAgICAgfVxuICAgIH0sIFtjaGFubmVsXSk7XG4gICAgcmV0dXJuIFtwcmVzZW5jZURhdGEsIHVwZGF0ZVN0YXR1c107XG59XG4vLyMgc291cmNlTWFwcGluZ1VSTD11c2VQcmVzZW5jZS5qcy5tYXAiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/@ably-labs/react-hooks/dist/mjs/hooks/usePresence.js\n"));

/***/ }),

/***/ "(app-client)/./node_modules/@ably-labs/react-hooks/dist/mjs/index.js":
/*!***************************************************************!*\
  !*** ./node_modules/@ably-labs/react-hooks/dist/mjs/index.js ***!
  \***************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"Realtime\": function() { return /* reexport safe */ _AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_0__.Realtime; },\n/* harmony export */   \"assertConfiguration\": function() { return /* reexport safe */ _AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_0__.assertConfiguration; },\n/* harmony export */   \"configureAbly\": function() { return /* reexport safe */ _AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_0__.configureAbly; },\n/* harmony export */   \"provideSdkInstance\": function() { return /* reexport safe */ _AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_0__.provideSdkInstance; },\n/* harmony export */   \"useChannel\": function() { return /* reexport safe */ _hooks_useChannel_js__WEBPACK_IMPORTED_MODULE_1__.useChannel; },\n/* harmony export */   \"usePresence\": function() { return /* reexport safe */ _hooks_usePresence_js__WEBPACK_IMPORTED_MODULE_2__.usePresence; }\n/* harmony export */ });\n/* harmony import */ var _AblyReactHooks_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./AblyReactHooks.js */ \"(app-client)/./node_modules/@ably-labs/react-hooks/dist/mjs/AblyReactHooks.js\");\n/* harmony import */ var _hooks_useChannel_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./hooks/useChannel.js */ \"(app-client)/./node_modules/@ably-labs/react-hooks/dist/mjs/hooks/useChannel.js\");\n/* harmony import */ var _hooks_usePresence_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./hooks/usePresence.js */ \"(app-client)/./node_modules/@ably-labs/react-hooks/dist/mjs/hooks/usePresence.js\");\n\n\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1jbGllbnQpLy4vbm9kZV9tb2R1bGVzL0BhYmx5LWxhYnMvcmVhY3QtaG9va3MvZGlzdC9tanMvaW5kZXguanMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQW9DO0FBQ0U7QUFDQztBQUN2QyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGFibHktbGFicy9yZWFjdC1ob29rcy9kaXN0L21qcy9pbmRleC5qcz81YWY2Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCAqIGZyb20gJy4vQWJseVJlYWN0SG9va3MuanMnO1xuZXhwb3J0ICogZnJvbSAnLi9ob29rcy91c2VDaGFubmVsLmpzJztcbmV4cG9ydCAqIGZyb20gJy4vaG9va3MvdXNlUHJlc2VuY2UuanMnO1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-client)/./node_modules/@ably-labs/react-hooks/dist/mjs/index.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-client)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=%2FUsers%2Frdzcn%2Fprojects%2Fpet%2Fonline-memory-game%2Fapp%2Fauthentication%2Fpage.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);